---
id: 587d825d367417b2b2512c96
title: 深度優先搜尋
challengeType: 1
forumTopicId: 301640
dashedName: depth-first-search
---

# --description--

類似於 <dfn>breadth-first search</dfn>，這裡我們將學習另一種圖形遍歷演算法，稱為 <dfn>depth-first search</dfn>。

當廣度優先搜尋從原始節點開始，逐步搜尋邊長時，<dfn>深度優先搜尋</dfn>會先沿著一條邊的路徑盡可能深入。

一旦到達路徑的一端，搜尋將回溯到最後一個具有未造訪邊路的節點並繼續搜尋。

下方的動畫顯示了演算法的運作方式。演算法從頂端節點開始，並依照編號順序拜訪節點。

<img alt="animation showing the depth first search algorithm" src='https://cdn.freecodecamp.org/curriculum/coding-interview-prep/depth-first-search.gif'>

注意，與廣度優先搜尋不同，每次拜訪節點時，它不會拜訪所有鄰居。相反地，它會先拜訪其中一個鄰居，並沿著該路徑繼續前進，直到該路徑上沒有更多節點可拜訪。

要實作這個演算法，你會想使用堆疊。堆疊是一個陣列，其中最後加入的元素是第一個被移除的。這也被稱為 <dfn>後進先出</dfn> 資料結構。堆疊在深度優先搜尋演算法中很有幫助，因為當我們將鄰居加入堆疊時，我們想先造訪最近加入的鄰居，並從堆疊中移除它們。

這個演算法的一個簡單輸出是從給定節點可達的節點列表。因此，你也會想要追蹤你造訪過的節點。

# --instructions--

撰寫一個函式（程式）`dfs()`，該函式接受一個無向的鄰接矩陣 `graph` 和一個節點標籤 `root` 作為參數。節點標籤將只是介於 `0` 和 `n - 1` 之間的節點數值，其中 `n` 是圖中節點的總數。

你的函式（程式）應該輸出從 `root` 可達的所有節點的陣列。

# --hints--

輸入圖形 `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` 且起始節點為 `1` 時，應該傳回包含 `0`、`1`、`2` 和 `3` 的陣列。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 1);
  })(),
  [0, 1, 2, 3]
);
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` 且起始節點為 `3` 時，應該傳回包含 `3`、`2`、`1` 和 `0` 的陣列。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 3);
  })(),
  [3, 2, 1, 0]
);
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` 且起始節點為 `1` 時，應該傳回一個有四個元素的陣列。

```js
assert(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 1);
  })().length === 4
);
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]` 且起始節點為 `3` 時，應該傳回一個包含 `3` 的陣列。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 0],
      [0, 0, 0, 0]
    ];
    return dfs(graph, 3);
  })(),
  [3]
);
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]` 且起始節點為 `3` 時，應該傳回一個包含一個元素的陣列。

```js
assert(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 0],
      [0, 0, 0, 0]
    ];
    return dfs(graph, 3);
  })().length === 1
);
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` 且起始節點為 `3` 時，應該傳回包含 `2` 和 `3` 的陣列。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 0, 0],
      [0, 0, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 3);
  })(),
  [2, 3]
);
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` 且起始節點為 `3` 時，應該傳回一個有兩個元素的陣列。

```js
assert(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 0, 0],
      [0, 0, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 3);
  })().length === 2
);
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` 且起始節點為 `0` 時，應該傳回包含 `0` 和 `1` 的陣列。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 0, 0],
      [0, 0, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 0);
  })(),
  [0, 1]
);
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` 且起始節點為 `0` 時，應該傳回一個有兩個元素的陣列。

```js
assert(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 0, 0],
      [0, 0, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 0);
  })().length === 2
);
```

# --seed--

## --seed-contents--

```js
function dfs(graph, root) {

}

var exDFSGraph = [
  [0, 1, 0, 0],
  [1, 0, 1, 0],
  [0, 1, 0, 1],
  [0, 0, 1, 0]
];
console.log(dfs(exDFSGraph, 3));
```

# --solutions--

```js
function dfs(graph, root) {
    var stack = [];
    var tempV;
    var visited = [];
    var tempVNeighbors = [];
    stack.push(root);
    while (stack.length > 0) {
        tempV = stack.pop();
        if (visited.indexOf(tempV) == -1) {
            visited.push(tempV);
            tempVNeighbors = graph[tempV];
            for (var i = 0; i < tempVNeighbors.length; i++) {
                if (tempVNeighbors[i] == 1) {
                    stack.push(i);
                }
            }
        }
    }
    return visited;
}
```
