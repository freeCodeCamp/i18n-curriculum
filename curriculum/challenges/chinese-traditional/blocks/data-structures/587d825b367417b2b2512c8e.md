---
id: 587d825b367417b2b2512c8e
title: 創建雜湊表
challengeType: 1
forumTopicId: 301627
dashedName: create-a-hash-table
---

# --description--

在這個挑戰中，我們將學習雜湊表。雜湊表用於實作關聯陣列，或鍵值配對的映射，就像我們剛剛學習的物件和 Maps。一個 JavaScript 物件例如可以實作為雜湊表（其實作體將取決於它執行的環境）。雜湊表的運作方式是，它接受一個鍵輸入，並以確定性的方式將此鍵雜湊成某個數值。這個數值接著被用作實際的鍵來存放相關的值。然後，如果你嘗試再次存取相同的鍵，雜湊函式會處理該鍵，傳回相同的數值結果，接著用此結果來查找相關的值。這平均提供非常高效的 O(1) 查找時間。

雜湊表可以實作為陣列，並使用雜湊函式產生指定範圍內的陣列索引。在此方法中，陣列大小的選擇與雜湊函式同樣重要。例如，若雜湊函式對兩個不同的鍵產生相同的值，這稱為碰撞。控制代碼碰撞的一種方法是將兩個鍵值配對都儲存在該索引位置。然後，在查詢任一鍵時，你必須迭代該桶中的項目以找到你要搜尋的鍵。一個好的雜湊函式會將碰撞降到最低，以維持高效的搜尋時間。

在這裡，我們不會關注雜湊或雜湊表實作的細節，我們只會嘗試大致了解它們的運作方式。

# --instructions--

讓我們創建雜湊表的基本功能。我們已經為你創建了一個簡單的雜湊函式供你使用。你可以將字串值傳遞給函式 `hash`，它會傳回一個雜湊值，你可以將此值用作儲存的鍵。根據此雜湊值將項目儲存在 `this.collection` 物件中。創建這三個方法：`add`、`remove` 和 `lookup`。第一個方法應接受一個鍵值配對並將其添加到雜湊表中。第二個方法應在傳入鍵時移除該鍵值配對。第三個方法應接受一個鍵並傳回相關的值，若該鍵不存在則傳回 `null`。

請務必撰寫你的程式碼以處理碰撞情況！

**注意：** 在正確實作 `add` 和 `lookup` 方法之前，`remove` 方法的測試不會通過。

# --hints--

`hash` 函式（程式）應該是有效的。 

```js
let calls = 0;
const ourHash = string => {
  calls++;
  let hashCode = 0;
  for (let i = 0; i < string.length; i++) {
    hashCode += string.charCodeAt(i);
  }
  return hashCode;
};

assert.strictEqual(hash('yek'),ourHash('yek'));

assert.strictEqual(hash('key'),ourHash('key'));
assert.strictEqual(hash('key1'),ourHash('key1'));
assert.strictEqual(hash('key2'),ourHash('key2'));
assert.strictEqual(hash('key3'),ourHash('key3'));

assert.strictEqual(hash('1key'),ourHash('1key'));
assert.strictEqual(hash('ke1y'),ourHash('ke1y'));
assert.strictEqual(hash('altKey'),ourHash('altKey'));

assert.strictEqual(called,calls); 
```

`HashTable` 資料結構應該存在。

```js
assert.isDefined(HashTable); 
let newHashTable = new HashTable(); 
assert.isObject(newHashTable); 
```

`HashTable` 應該有一個 `add` 方法。

```js
let newHashTable = new HashTable(); 
assert.isFunction(newHashTable.add); 
```

`HashTable` 應該有一個 `lookup` 方法。

```js
let newHashTable = new HashTable(); 
assert.isFunction(newHashTable.lookup); 
```

`HashTable` 應該有一個 `remove` 方法。

```js
let newHashTable = new HashTable(); 
assert.isFunction(newHashTable.remove); 
```

`add` 方法應該為鍵值對組添加資料，而 `lookup` 方法應該傳回與給定鍵相關的值。

```js
let newHashTable = new HashTable(); 
newHashTable.add('key','value');
assert.strictEqual(newHashTable.lookup('key'),'value'); 
```

`remove` 方法應該接受一個鍵作為輸入，並且應該移除相關的鍵值對組。

```js
let hashValue = hash('key');
let newHashTable = new HashTable(); 
newHashTable.add('key','value');
newHashTable.remove('key'); 
assert.notProperty(newHashTable.collection,hashValue); 
```

`remove` 方法應該只移除正確的鍵值配對。

```js
let newHashTable = new HashTable(); 
let hashValue = hash('key');
newHashTable.add('key','value');
newHashTable.add('yek','value');
newHashTable.add('altKey','value');
newHashTable.remove('yek');

assert.notExists(newHashTable.lookup('yek'));
assert.exists(newHashTable.lookup('altKey'));
assert.exists(newHashTable.lookup('key'));

newHashTable.remove('key');

assert.notProperty(newHashTable.collection,hashValue); 
assert.exists(newHashTable.lookup('altKey'));

```

應該使用雜湊函式為項目添加。

```js
let newHashTable = new HashTable(); 
called = 0;
newHashTable.add('key1', 'value1')
newHashTable.add('key2', 'value2');
newHashTable.add('key3', 'value3');
assert.strictEqual(called,3); 
```

雜湊表應該處理碰撞。

```js
let newHashTable = new HashTable(); 
called = 0;
newHashTable.add('key1','value1');
newHashTable.add('1key', 'value2'); 
newHashTable.add('ke1y', 'value3'); 
assert.strictEqual(newHashTable.lookup('key1'),'value1');
assert.strictEqual(newHashTable.lookup('1key'),'value2');
assert.strictEqual(newHashTable.lookup('ke1y'),'value3');
```

# --seed--

## --seed-contents--

```js
var called = 0;
var hash = string => {
  called++;
  var hashed = 0;
  for (var i = 0; i < string.length; i++) {
    hashed += string.charCodeAt(i);
  }
  return hashed;
};
var HashTable = function() {
  this.collection = {};
  // Only change code below this line
  
  // Only change code above this line
};
```

# --solutions--

```js
var called = 0;
var hash = (string) => {
  called++;
  var hash = 0;
  for (var i = 0; i < string.length; i++) { hash += string.charCodeAt(i); }
  return hash;
};
var HashTable = function() {
  this.collection = {};
  // Only change code below this line

  this.add = function(key, val) {
    var theHash = hash(key);
    if (!this.collection.hasOwnProperty(theHash)) {
      this.collection[theHash] = {};
    }
    this.collection[theHash][key] = val;
  }

  this.remove = function(key) {
    var theHash = hash(key);
    var hashedObj = this.collection[theHash];
    if (hashedObj.hasOwnProperty(key)) {
      delete hashedObj[key];
    }
    if (!Object.keys(hashedObj).length) {
      delete this.collection[theHash];
    }
  }

  this.lookup = function(key) {
    var theHash = hash(key);
    if (this.collection.hasOwnProperty(theHash)) {
      return this.collection[theHash][key];
    }
    return null
  }
  // Only change code above this line
};
```
