---
id: 587d7fb2367417b2b2512bf7
title: 使用 body-parser 來解析 POST 請求
challengeType: 2
forumTopicId: 301520
dashedName: use-body-parser-to-parse-post-requests
---

# --description--

除了 GET，還有另一個常見的 HTTP 動詞是 POST。POST 是用來透過 HTML 表單傳送客戶端資料的預設方法。在 REST 慣例中，POST 用於傳送資料以在資料庫中創建新項目（例如新使用者或新部落格文章）。你在這個專案中沒有資料庫，但你仍然會學習如何控制代碼來處理 POST 請求。

在這類請求中，資料不會出現在 URL 中，而是隱藏在請求主體中。主體是 HTTP 請求的一部分，也稱為有效載荷。即使資料在 URL 中不可見，這並不代表它是私密的。要了解原因，請查看 HTTP POST 請求的未經處理的內容：

```http
POST /path/subpath HTTP/1.0
From: john@example.com
User-Agent: someBrowser/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 20

name=John+Doe&age=25
```

如你所見，主體的編碼方式與查詢字串相同。這是 HTML 表單所使用的預設格式。使用 Ajax 時，你也可以使用 JSON 來控制具有較複雜結構的資料。還有另一種編碼類型：multipart/form-data。這種用於上傳二進位檔案。在這個練習中，你將使用 URL 編碼的主體。要解析來自 POST 請求的資料，你必須使用 `body-parser` 軟體包。這個軟體包允許你使用一系列中介層，能夠解析不同格式的資料。

# --instructions--

`body-parser` 已經安裝完成，並且存在你的專案的 `package.json` 檔案中。在 `myApp.js` 檔案的頂端使用 `require`，並將其存放在名為 `bodyParser` 的變數中。用來控制 URL 編碼資料的中介層是由 `bodyParser.urlencoded({extended: false})` 傳回的。將前一個方法呼叫所傳回的函式傳入 `app.use()`。如同往常，中介層必須在所有依賴它的路由之前掛載。

**注意：** `extended` 是一個設定選項，用來告訴 `body-parser` 需要使用哪種解析方式。當 `extended=false` 時，它使用經典編碼的 `querystring` 函式庫。當 `extended=true` 時，它使用 `qs` 函式庫進行解析。 

當使用 `extended=false` 時，值只能是字串或陣列。使用 `querystring` 時傳回的物件不會從預設的 JavaScript `Object` 原型繼承，這表示像 `hasOwnProperty`、`toString` 這類函式將無法使用。擴充版本允許更多資料彈性，但仍不及 JSON。

# --hints--

應該掛載 `body-parser` 中介層

```js
  const response = await fetch(code + '/_api/add-body-parser');
  if (!response.ok) {
    throw new Error(await response.text());
  }
  const data = await response.json();
  assert.isAbove(
    data.mountedAt,
    0,
    '"body-parser" is not mounted correctly'
  );
```

