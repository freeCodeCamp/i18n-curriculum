---
id: 587d825a367417b2b2512c8a
title: 將元素插入最大堆積
challengeType: 1
forumTopicId: 301703
dashedName: insert-an-element-into-a-max-heap
---

# --description--

現在我們將進入另一種樹狀資料結構，二元堆積。二元堆積是一種部分有序的二元樹，符合堆積屬性。堆積屬性指定父節點與子節點之間的關係。你可以有最大堆積，其中所有父節點都大於或等於其子節點，或者最小堆積，其關係則相反。二元堆積也是完全二元樹。這表示樹的所有層級都被完全填滿，若最後一層部分填滿，則是從左到右填充。

雖然二進位堆積可以實作為包含左、右引用節點的樹狀結構，但根據堆積屬性的部分排序允許我們用陣列來表述堆積。我們關注的是父節點與子節點的關係，並且透過簡單的算術運算可以計算出任何父節點的子節點以及任何子節點的父節點。

例如，考慮這個二進位最小堆積的陣列表述：

```js
[ 6, 22, 30, 37, 63, 48, 42, 76 ]
```

根節點是第一個元素，`6`。它的子節點是 `22` 和 `30`。如果我們查看這些值的陣列索引之間的關係，對於索引 `i`，子節點是 `2 * i + 1` 和 `2 * i + 2`。同樣地，索引 `0` 的元素是這兩個子節點（索引為 `1` 和 `2`）的父節點。更一般地說，我們可以用以下方式找到任何索引節點的父節點：`Math.floor((i - 1) / 2)`。隨著二元樹擴展到任何大小，這些樣式都會成立。最後，我們可以稍作調整，透過跳過陣列中的第一個元素，使這個運算更簡單。這樣做會為任何給定索引 `i` 的元素產生以下關係：

範例陣列表述：

```js
[ null, 6, 22, 30, 37, 63, 48, 42, 76 ]
```

元素的左子節點：`i * 2`

一個元素的右子節點：`i * 2 + 1`

元素的父節點：`Math.floor(i / 2)`

一旦你理解了數學原理，使用陣列表述非常有用，因為節點位置可以透過這種運算快速判定，且記憶體使用量減少，因為你不需要維護對子節點的引用。

# --instructions--

說明：這裡我們將創建一個最大堆積。首先只需創建一個 `insert` 方法，該方法會將元素添加到我們的堆積中。在插入過程中，始終維護堆積屬性非常重要。對於最大堆積，這表示根元素應該始終是樹中數值最大的元素，且所有父節點都應大於其子節點。對於堆積的陣列實作，這通常透過三個步驟完成：

<ol>
  <li>Add the new element to the end of the array.</li>
  <li>If the element is larger than its parent, switch them.</li>
  <li>Continue switching until the new element is either smaller than its parent or you reach the root of the tree.</li>
</ol>

最後，為你的 `heap` 添加一個 `print` 方法，該方法會傳回所有已添加到堆積中的項目陣列。

# --hints--

`MaxHeap` 資料結構應該存在。

```js
assert(
  (function () {
    var test = false;
    if (typeof MaxHeap !== 'undefined') {
      test = new MaxHeap();
    }
    return typeof test == 'object';
  })()
);
```

`MaxHeap` 應該有一個名為 `insert` 的方法。

```js
assert(
  (function () {
    var test = false;
    if (typeof MaxHeap !== 'undefined') {
      test = new MaxHeap();
    } else {
      return false;
    }
    return typeof test.insert == 'function';
  })()
);
```

`MaxHeap` 應該有一個名為 `print` 的方法。

```js
assert(
  (function () {
    var test = false;
    if (typeof MaxHeap !== 'undefined') {
      test = new MaxHeap();
    } else {
      return false;
    }
    return typeof test.print == 'function';
  })()
);
```

`insert` 方法應該根據最大堆積屬性添加元素。

```js
assert(
  (function () {
    var test = false;
    if (typeof MaxHeap !== 'undefined') {
      test = new MaxHeap();
    } else {
      return false;
    }
    test.insert(50);
    test.insert(100);
    test.insert(700);
    test.insert(32);
    test.insert(51);
    test.insert(800);
    const result = test.print();
    const solution = JSON.stringify([null,800,51,700,32,50,100]);
    const solutionWithoutNull = JSON.stringify([800,51,700,32,50,100]);

    return (result.length == 6) ? (JSON.stringify(result) == solutionWithoutNull) : (JSON.stringify(result) == solution);
  })()
);
```

# --seed--

## --seed-contents--

```js
var MaxHeap = function() {
  // Only change code below this line
    
  // Only change code above this line
};
```

# --solutions--

```js
var MaxHeap = function() {
    // Only change code below this line
    this.heap = [];
    this.parent = index => {
      return Math.floor((index - 1) / 2);
    }
    this.insert = element => {
      this.heap.push(element);
      this.heapifyUp(this.heap.length - 1);
    }
    this.heapifyUp = index => {
      let currentIndex = index,
      parentIndex = this.parent(currentIndex);
      while (currentIndex > 0 && this.heap[currentIndex] > this.heap[parentIndex]) {
        this.swap(currentIndex, parentIndex);
        currentIndex = parentIndex;
        parentIndex = this.parent(parentIndex);
      }
    }
    this.swap = (index1, index2) => {
      [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];
    }
    this.print = () => {
      return this.heap;
    }
    // Only change code above this line
};
```
