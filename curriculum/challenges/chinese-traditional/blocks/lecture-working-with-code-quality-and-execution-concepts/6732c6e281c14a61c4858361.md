---
id: 6732c6e281c14a61c4858361
title: 什麼是閉包，以及它們如何運作？
challengeType: 19
dashedName: what-are-closures-and-how-do-they-work
---

# --interactive--

Closure 是 JavaScript 中最強大且常被誤解的功能之一。從本質來看，closure 是一個函式（程式），即使在外層函式（程式）已傳回後，仍能存取其外層封閉詞彙範圍中的變數。這聽起來可能很複雜，但它是一個基本概念，使許多進階程式設計樣式成為可能。 

要理解閉包，讓我們從一個範例開始：

:::interactive_editor

```js
function outerFunction(x) {
    let y = 10;
    function innerFunction(){
        console.log(x + y);
    }
    return innerFunction;
}

let closure = outerFunction(5);
console.log(closure()); // 15
```

:::

在這個範例中，`outerFunction` 接受一個參數 `x` 並定義一個區域的變數 `y`。接著它定義一個 `innerFunction`，該函式使用了 `x` 和 `y`。最後它傳回 `innerFunction`。當我們呼叫 `outerFunction(5)` 時，它傳回 `innerFunction`，我們將其指定給變數 `closure`。當我們稍後呼叫 `closure()` 時，即使 `outerFunction` 已經執行完畢，它仍然可以存取來自 `outerFunction` 的 `x` 和 `y`。這就是 closure 的本質。

內部函式（程式）維護對其外部詞彙環境的引用，即使外部函式（程式）已完成，也能保留對該環境中變數的存取。

閉包特別適合用來建立私有變數和函式（程式）。請參考此範例：

:::interactive_editor

```js
function createCounter() {
    let count = 0;
    return function () {
        count++;
        return count;
    };
}

let counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

:::

在這種情況下，`createCounter` 傳回一個函式（程式），該函式會遞增並傳回一個 `count` 變數。`count` 變數無法從 `createCounter` 之外直接存取，但傳回的函式（我們的閉包）可以存取它。每次我們呼叫 `counter()`，它都會遞增並傳回 `count`。

閉包也可以從它們的外部作用域捕捉多個變數。例如：

:::interactive_editor

```js
function multiply(x) {
    return function (y) {
        return x * y;
    };
}

let double = multiply(2);
console.log(double(5)); // 10
```

:::

這裡內部函式捕捉了來自 `multiply` 的 `x` 參數。當我們透過呼叫 `multiply(2)` 創建 `double` 時，它會傳回一個函式，該函式總是將它的引數乘以 2。

關於閉包，有一件重要的事要注意，那就是它們捕捉的是變數的址參器，而非值。這表示如果被捕捉的變數值改變，閉包會看到新的值。 例如：

:::interactive_editor

```js
function createIncrementer() {
    let count = 0;
    return function () {
        count++;
        console.log(count);
    };
}

let increment = createIncrementer();
increment(); // 1
increment(); // 2
```

:::

每次我們呼叫 `increment` 時，它都是在操作相同的 `count` 變數，而不是它初始值的複本。閉包是 JavaScript 中一個強大的工具。隨著你繼續使用 JavaScript，你會發現有效理解和使用閉包能大幅提升你撰寫乾淨、高效且強大程式碼的能力。

# --questions--

## --text--

以下 `code` 的輸出結果會是什麼？

```js
function outer(x) {
    return function(y) {
        return x + y;
    };
}

let add5 = outer(5);
console.log(add5(3));
```

## --answers--

`5`

### --feedback--

考慮 outer 中的內部函式如何捕捉 `x` 參數。

---

`3`

### --feedback--

考慮 outer 中的內部函式如何捕捉 `x` 參數。

---

`8`

---

`undefined`

### --feedback--

考慮 outer 中的內部函式如何捕捉 `x` 參數。

## --video-solution--

3

## --text--

以下 `code` 展示了什麼概念？

```js
function createGreeter(greeting) {
    return function(name) {
        console.log(greeting + ", " + name);
    };
}

let sayHello = createGreeter("Hello");
sayHello("Alice");
```

## --answers--

提升。

### --feedback--

思考傳回的函式如何保留對 `greeting` 參數的存取。

---

閉包。

---

遞迴。

### --feedback--

思考傳回的函式如何保留對 `greeting` 參數的存取。

---

原型繼承。

### --feedback--

思考傳回的函式如何保留對 `greeting` 參數的存取。

## --video-solution--

2

## --text--

以下 `code` 的輸出結果會是什麼？

```js
function counter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}

let increment = counter();
console.log(increment());
console.log(increment());
console.log(increment());
```

## --answers--

```js
1
1
1
```

### --feedback--

請考慮在 `counter` 中的內部函式（程式）如何在多次呼叫中維護對 `count` 變數的存取。

---

```js
1
2
3
```

---

```js
0
1
2
```

### --feedback--

請考慮在 `counter` 中的內部函式（程式）如何在多次呼叫中維護對 `count` 變數的存取。

---

```js
undefined
undefined
undefined
```

### --feedback--

請考慮在 `counter` 中的內部函式（程式）如何在多次呼叫中維護對 `count` 變數的存取。

## --video-solution--

2
