---
id: 595608ff8bcd7a50bd490181
title: 冰雹數列
challengeType: 1
forumTopicId: 302279
dashedName: hailstone-sequence
---

# --description--

Hailstone 數列可以從一個起始正整數 `n` 產生，方法如下：

- 如果 `n` 是 `1`，序列即結束。
- 如果 `n` 是 `even`，則序列中接下來的 `n` 等於 `n/2`
- 如果 `n` 是 `odd`，則序列中接下來的 `n` 為 `= (3 * n) + 1`

（尚未證實的）Collatz 猜想是指任何起始數字的 hailstone 序列總是會終止。

冰雹數列也稱為冰雹數（因為數值通常會像雲中的冰雹一樣多次下降和上升），或稱為 Collatz 數列。

# --instructions--

1. 創建一個常式來產生數字的 hailstone 序列
2. 你的函式應該傳回一個陣列，該陣列包含小於 `limit` 的數字中擁有最長 hailstone 序列的數字及該序列的長度。（但不要顯示實際的序列！）

# --hints--

`hailstoneSequence` 應該是一個函式（程式）。

```js
assert(typeof hailstoneSequence === 'function');
```

`hailstoneSequence(30)` 應該傳回一個陣列。

```js
assert(Array.isArray(hailstoneSequence(30)));
```

`hailstoneSequence(30)` 應該傳回 `[27, 112]`。

```js
assert.deepEqual(hailstoneSequence(30), [27, 112]);
```

`hailstoneSequence(50000)` 應該傳回 `[35655, 324]`。

```js
assert.deepEqual(hailstoneSequence(50000), [35655, 324]);
```

`hailstoneSequence(100000)` 應該傳回 `[77031, 351]`。

```js
assert.deepEqual(hailstoneSequence(100000), [77031, 351]);
```

# --seed--

## --seed-contents--

```js
function hailstoneSequence(limit) {
  const res = [];


  return res;
}
```

# --solutions--

```js
function hailstoneSequence (limit) {
  function hailstone(n) {
    const seq = [n];
    while (n > 1) {
      n = n % 2 ? 3 * n + 1 : n / 2;
      seq.push(n);
    }
    return seq;
  }

  let n = 0;
  let max = 0;
  for (let i = limit; --i;) {
    const seq = hailstone(i);
    const sLen = seq.length;

    if (sLen > max) {
      n = i;
      max = sLen;
    }
  }

  return [n, max];
}
```
