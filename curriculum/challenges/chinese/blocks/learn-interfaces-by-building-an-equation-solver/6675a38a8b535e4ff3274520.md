---
id: 6675a38a8b535e4ff3274520
title: 步骤11
challengeType: 20
dashedName: step-11
---

# --description--

`hasattr` 内置函数接收对象作为其第一个参数，表示属性名称的字符串作为其第二个参数。 它返回一个布尔值，表示对象是否具有指定的属性。

现在，你将使用 `__init_subclass__` 方法来检查子类在实例化时是否具有 `degree` 属性。

创建一个 `if` 语句来检查 `cls` 是否没有 `degree` 属性。 如果是这样，则引发 `AttributeError` 并使用字符串 `f"Cannot create '{cls.__name__}' class: missing required attribute 'degree'"` 来提供自定义消息。

之后，通过在 `LinearEquation` 类内声明 `degree` 类属性来修复终端中出现的错误。 该属性应该表示方程的次数，即最高 \\( x \\) 项的指数。 因此，将整数 `1` 分配给 `degree` 属性。

# --hints--

你应该创建一个 `if` 语句来检查 `cls` 在 `__init_subclass__` 方法中是否没有属性 `degree`。

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("__init_subclass__").find_ifs()[0].find_conditions()[0].is_equivalent("not hasattr(cls, 'degree')")`)) })
```

你应该使用 `if` 语句中提供的字符串引发 `AttributeError`。

```js
({ test: () => runPython(`
raise_stmt = 'raise AttributeError(f"Cannot create \\'{cls.__name__}\\' class: missing required attribute \\'degree\\'")'
node = _Node(_code).find_class("Equation").find_function("__init_subclass__").find_ifs()[0].find_bodies()[0]
assert node.has_stmt(raise_stmt) 
`) })
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod


class Equation(ABC):
    degree: int
    
    def __init__(self):
        pass
--fcc-editable-region--
    def __init_subclass__(cls):
        pass

    @abstractmethod
    def solve(self):
        pass
        
    @abstractmethod
    def analyze(self):
        pass


class LinearEquation(Equation):
    
--fcc-editable-region--
    def solve(self):
        pass

    def analyze(self):
        pass


lin_eq = LinearEquation()
```
