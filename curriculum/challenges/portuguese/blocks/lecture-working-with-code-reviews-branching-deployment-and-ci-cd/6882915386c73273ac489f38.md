---
id: 6882915386c73273ac489f38
title: Quais São Algumas Melhores Práticas para Desenvolver uma Estratégia de Ramificação no Git?
challengeType: 19
dashedName: what-are-some-best-practices-for-developing-a-git-branching-strategy
---

# --description--

Falamos um pouco sobre branches nas lições anteriores. Você aprendeu como criar branches, por que não deve fazer commits diretamente no `main` e coisas semelhantes. Mas quando e por que você realmente deve criar branches?

Primeiro, vamos falar sobre por que você não deve simplesmente enviar vários commits para `main`. Seu branch padrão deve ser confiavelmente estável - ou seja, a qualquer momento eu devo ser capaz de baixar seu branch atual `main` e construir, executar e testar sua aplicação. Se você estiver enviando recursos parcialmente concluídos ou commits WIP, isso pode não ser sempre verdade.

Além disso, é muito comum trabalhar em múltiplos recursos em conjunto. Se você estiver enviando trabalho parcial para `main` para múltiplos recursos simultaneamente, fica muito mais difícil depurar um possível problema, já que você não tem mudanças isoladas. Além disso, a troca de contexto (ou mudar as tarefas em que você está trabalhando) não é nada tão limpa.

Então, quando você deve criar uma branch? Uma regra geral é criar uma branch para cada unidade isolada de trabalho. Ou seja, se você está trabalhando em uma nova funcionalidade OAuth, esse trabalho deve estar em uma branch dedicada. Se você precisar corrigir um bug na autenticação por senha, esse trabalho deve estar em sua própria branch dedicada. Precisa redesenhar a página de perfil do usuário? Essa é outra branch.

Observe que você deve sempre criar suas branches a partir de `main`. Então, se você estiver trabalhando em uma branch para sua funcionalidade OAuth, você deve fazer checkout de `main` antes de criar uma nova branch para a correção da autenticação por senha. Caso contrário, se você criar uma branch para a correção da senha diretamente da sua branch OAuth, você acabará com os commits do seu trabalho OAuth e o histórico ficará confuso.

Mas como você deve nomear suas branches? Bem, isso depende totalmente de você (ou do projeto para o qual você está contribuindo), mas aqui estão algumas convenções comuns:

`scope/description` - onde `scope` é algo como `feat` ou `fix` e `description` é uma explicação muito curta das mudanças do branch. Por exemplo: `feat/oauth-support`.

`scope/issue/description` - semelhante à convenção anterior, mas incluindo o número associado ao problema relacionado. Por exemplo: `fix/25/password-auth`.

`username/scope/description` - Para projetos onde todos vocês trabalham em branches no repositório original em vez de fazer um fork dele (isso é comum em repositórios internos privados), pode ser útil incluir seu nome de usuário no início da branch. Por exemplo: `naomi-lgbt/feat/profile-redesign`.

Vamos cobrir algumas outras observações sobre estratégias de branching.

Para trabalhos de recursos de longa duração, como um recurso beta que requer muitas horas de desenvolvedor, você pode querer usar uma feature flag para habilitar seletivamente a lógica em vez de um branch. Quanto mais tempo um branch permanecer sem ser mesclado, maior a probabilidade de você encontrar conflitos.

Você pode, no entanto, desejar manter branches dedicados para ambientes de implantação ou releases. Por exemplo, o repositório freeCodeCamp usa `prod-staging` e `prod-current` para acionar implantações nos servidores de staging e produção, respectivamente. Isso pode liberar a equipe para iterar mais rápido, mesclando conforme as coisas estão prontas e aprovadas sem precisar acionar uma implantação para cada merge. Em vez disso, as implantações são criadas mesclando o último `main` nessas branches de produção.

Você também pode querer manter "release branches", ou branches que representam uma versão principal do seu produto. Isso permite que você tenha um estado limpo para cada lançamento principal, para que, se precisar fazer backport de um patch de segurança crítico para uma versão anterior, possa fazê-lo sem precisar incluir quaisquer alterações da nova versão.

E finalmente, você deve evitar mesclar suas branches em `main` usando o CLI local. Em vez disso, crie um pull request com suas alterações e faça a mesclagem por esse fluxo. Isso lhe dá a chance de garantir que quaisquer testes passem no seu CI (sobre o qual você aprenderá em uma lição futura) e de verificar novamente a visualização do diff para ter certeza de que incluiu apenas as alterações que deseja mesclar.

Com essas dicas, você pode começar a criar ramificações rumo ao sucesso!

# --questions--

## --text--

Por que você deve evitar fazer commit diretamente na branch `main`?

## --answers--

Porque o Git não permite commits diretos para `main`.

### --feedback--

Pense nos requisitos de estabilidade e confiabilidade do branch padrão.

---

Porque a branch `main` deve permanecer confiavelmente estável o tempo todo.

---

Porque os commits em `main` são permanentemente bloqueados e não podem ser alterados.

### --feedback--

Pense nos requisitos de estabilidade e confiabilidade do branch padrão.

---

Porque os branches `main` têm desempenho mais lento do que os branches de feature.

### --feedback--

Pense nos requisitos de estabilidade e confiabilidade do branch padrão.

## --video-solution--

2

## --text--

Qual das seguintes é uma boa prática ao criar uma nova branch?

## --answers--

Crie novos branches a partir do seu branch de feature atual.

### --feedback--

Pense em manter os históricos de branch limpos e evitar a inclusão não intencional de código.

---

Sempre crie novos branches a partir de `main`.

---

Crie branches apenas para recursos principais.

### --feedback--

Pense em manter os históricos de branch limpos e evitar a inclusão não intencional de código.

---

Limite-se a um branch por semana.

### --feedback--

Pense em manter os históricos de branch limpos e evitar a inclusão não intencional de código.

## --video-solution--

2

## --text--

Qual é uma abordagem recomendada para lidar com trabalhos de recursos de longa duração?

## --answers--

Crie um único branch enorme que contenha todo o trabalho relacionado.

### --feedback--

Considere o potencial para conflitos de merge com branches que permanecem sem merge por longos períodos.

---

Use feature flags em vez de branches de longa duração.

---

Sempre faça merge diretamente para `main` usando o CLI local.

### --feedback--

Considere o potencial para conflitos de merge com branches que permanecem sem merge por longos períodos.

---

Crie um novo repositório para cada recurso principal.

### --feedback--

Considere o potencial para conflitos de merge com branches que permanecem sem merge por longos períodos.

## --video-solution--

2
