---
id: 68baa5e4f0e07f079245ca09
title: 矩阵和邻接列表如何工作？
challengeType: 19
dashedName: how-do-matrices-and-adjacency-lists-work
---

# --description--

图是非常强大的数据结构，由一组节点（也称为顶点）和连接它们的边组成。

在你的代码中实现图有两种常见方式：

* 邻接矩阵
    
* 邻接列表
    

让我们更深入地了解这些，并讨论它们的优点和局限性。

## 邻接矩阵

我们将从邻接矩阵开始。

邻接矩阵是一个二维列表，其中行和列表现图的顶点。

矩阵中的值表现节点之间的边或连接。

例如，如果你有一个保存在变量 `matrix` 中的矩阵，保存在 `matrix[i][j]` 的值，其中 `i` 是行，`j` 是列，表现节点 `i` 和节点 `j` 之间的边或连接。

这些值的含义可能因图是加权还是无权而不同：

* 如果图是无权的，值为 `1` 表示这些节点之间存在边，而值为 `0` 表示它们之间没有边。
    
* 如果 `Graph` 是加权的，该值将表现连接节点的边的权值。
    

使用邻接矩阵的一个巨大优势是，查看两个节点之间是否存在边的时间为常量时间 `O(1)`。这是因为程序只需在二维列表中查找该特定值。

然而，这种查找边的效率是有代价的。邻接矩阵需要大量的二次空间 `O(V²)`，其中 `V` 是图中的节点数。

这对于稀疏图来说是低效的，稀疏图是指只有少数边的图。为什么？因为如果图是稀疏的，你将会在矩阵中存储许多 0 来表现节点之间缺少边的情况，而这些 0 仍然会占用内存空间。

邻接矩阵在查找节点的邻居时也很低效，因为程序必须迭代整个行或列以查找表现边的 0 和 1。在最坏的情况下，这个进程可能需要 O(V) 时间，其中 V 是图中的节点数。

让我们来看这个特定图的邻接矩阵示例：

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png" alt="A graph with four nodes labeled A, B, C, and D. Node A connects to B, C, and D. Node B connects to A and D. Node C connects to A. Node D connects to A and B.">

在邻接矩阵中：

* 每一行表现一个节点。第一行表现节点 A，第二行表现节点 B，依此类推。
    
* 每个列也表现一个节点。
    
* 矩阵中的每个值表现每个节点点对之间是否存在边。值为 0 表示这些节点之间没有边连接，值为 1 表示存在边。
    

对角线上的值表现每个节点是否有自环，即连接节点自身的边。在我们的例子中，它们全是 0，因为图没有任何自环。

这是邻接矩阵的可视化表现，向你展示行和列如何表现对应的节点。

例如，第一行是 `[0, 1, 1, 1]`，因为节点 A 有边连接到节点 B、C 和 D：

```markdown
#      A  B  C  D
# A   [0, 1, 1, 1],
# B   [1, 0, 0, 1],
# C   [1, 0, 0, 0],
# D   [1, 1, 0, 0]
```

这就是相同的邻接矩阵，但用 Python 代码实现：

```python
adjacency_matrix = [
    [0, 1, 1, 1],  # The neighbors of A are B, C, and D
    [1, 0, 0, 1],  # The neighbors of B are A and D
    [1, 0, 0, 0],  # The only neighbor of C is A
    [1, 1, 0, 0]   # The neighbors of D are A and B
]
```

## 邻接列表

另一种表现图的常见方法是使用邻接列表。

邻接列表是一个数组或字典，用于保存每个节点的所有邻居。

实现邻接列表有两种方法：

* 作为一个数组，其中每个索引表现一个节点，存储在该索引处的列表包含它的邻居。
    
* 作为一个字典，其中每个 `key` 表现为一个节点，关联到该 `key` 的值（一个列表）包含它的邻居。
    

邻接列表在空间需求方面比邻接矩阵更高效。它们具有 `O(V + E)` 的空间复杂度，其中 `V` 是顶点（节点）数量，`E` 是边的数量。

它对于查找所有邻居节点也很高效，因为此操作只需访问关联到该节点的列表。

但是，也存在权衡。

对于判断两个节点之间是否存在边，邻接列表比邻接矩阵效率低。

查找进程在最坏情况下可能需要 `O(V)` 时间，因为如果节点与图中的所有其他节点相连，可能必须遍历非常长的邻居列表。

这是该图的邻接列表示例：

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png" alt="A graph with four nodes labeled A, B, C, and D. Node A connects to B, C, and D. Node B connects to A and D. Node C connects to A. Node D connects to A and B. It's the same image as before.">

这个邻接列表实现为一个字典。字典中的每个密钥表现一个节点，关联到该密钥的值是一个包含对应节点所有邻居的列表：

```python
adjacency_list = {
    'A': ['B', 'C', 'D'],
    'B': ['A', 'D'],
    'C': ['A'],
    'D': ['A', 'B']
}
```

备选方案是将其实现为一个二维列表，其中每个索引表现一个节点。例如，索引 0 表现节点 A，索引 1 表现节点 B，依此类推：

```python
adjacency_list = [
    ['B', 'C', 'D'],  # Neighbors of A (index 0)
    ['A', 'D'],       # Neighbors of B (index 1)
    ['A'],            # Neighbors of C (index 2)
    ['A', 'B']        # Neighbors of D (index 3)
]
```

请注意，即使这个二维列表看起来与邻接矩阵相似，它们实际上有很大不同。

* 邻接矩阵保存 0、1 或其他表现图中边或边权值的数值。
    
* 邻接列表保存每个节点所有邻居的实际列表。
    

这是一个你应该熟悉的非常重要的区别。

邻接矩阵和邻接列表对于实现图都非常重要。选择它们取决于图的大小以及你如何使用数据。邻接矩阵适用于边较多的稠密图，而邻接列表通常是现实场景中的首选，因为稀疏图更为常见。

# --questions--

## --text--

在以下哪种场景中，使用邻接矩阵表现一个图是最高效的选择？

## --answers--

一个拥有数十亿人的社交网络，每个人的连接非常少。

### --feedback--

考虑一个矩阵使用了多少内存以及这如何根据连接数量变化。

---

只有五个连接的计算机网络。

### --feedback--

考虑一个矩阵使用了多少内存以及这如何根据连接数量变化。

---

一个稠密图，其中每个节点都连接到大多数其他节点。

---

一个图，其主要操作是查找特定节点的所有邻居。

### --feedback--

考虑一个矩阵使用了多少内存以及这如何根据连接数量变化。

## --video-solution--

3

## --text--

什么时候使用邻接列表比使用邻接矩阵更高效？

## --answers--

当图稠密且有许多边时。

### --feedback--

考虑当一个图连接不多时，邻接列表如何节省内存。

---

当你需要非常快速地查看两个节点之间是否存在边时。

### --feedback--

考虑当一个图连接不多时，邻接列表如何节省内存。

---

当图有大量顶点和许多连接时。

### --feedback--

考虑当一个图连接不多时，邻接列表如何节省内存。

---

当图稀疏，顶点数量多且边数量少时。

## --video-solution--

4

## --text--

在邻接矩阵中，以下哪种操作比在邻接列表中更快？

## --answers--

查找单个节点的所有邻居。

### --feedback--

考虑如何在基于网格和基于列表的结构中执行每个这些操作。

---

查看两个特定节点之间是否存在直接边。

---

遍历图中的所有节点。

### --feedback--

考虑如何在基于网格和基于列表的结构中执行每个这些操作。

---

为你的 `Graph` 添加一个新建节点。

### --feedback--

考虑如何在基于网格和基于列表的结构中执行每个这些操作。

## --video-solution--

2
