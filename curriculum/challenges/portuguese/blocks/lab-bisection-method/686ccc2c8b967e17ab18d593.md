---
id: 686ccc2c8b967e17ab18d593
title: Implementar o Método da Bissecção
challengeType: 27
dashedName: implement-the-bisection-method
---

# --description--

O método da bissecção, também conhecido como método de busca binária, utiliza uma busca binária para encontrar as raízes de uma função de valor real. Funciona restringindo um intervalo onde a raiz quadrada se encontra até que converja para um valor dentro de uma tolerância especificada.

Por exemplo, se a tolerância for `0.01`, o método da bissecção continuará dividindo o intervalo pela metade até que a diferença entre os limites superior e inferior seja menor ou igual a `0.01`.

Neste laboratório, você implementará uma função que utiliza o método da bissecção para encontrar a raiz quadrada de um número.

**Objetivo:** Cumprir as user stories abaixo e fazer todos os testes passarem para completar o laboratório.

**Histórias de Usuário:**

1. Você deve definir uma função chamada `square_root_bisection` com três parâmetros:
    - O número para o qual você deseja encontrar a raiz quadrada.
    - A tolerância é a margem de erro aceitável para o resultado. Você deve definir um valor padrão para a tolerância.
    - O número máximo de iterações a serem realizadas. Você deve definir um número padrão de iterações.

1. A função `square_root_bisection` deve:
    - Levante um `ValueError` com a mensagem `Square root of negative number is not defined in real numbers` se o número passado para a função for negativo.
    - Para os números `0` e `1`, imprima a mensagem: `The square root of [number] is [number]` e retorne o próprio número como a raiz quadrada.
    - Para qualquer outro número positivo, imprima a raiz quadrada aproximada com a mensagem: `The square root of [square_target] is approximately [root]` e retorne o valor da raiz calculada.
    - Se nenhum valor atender à condição de tolerância, imprima uma mensagem de falha: `Failed to converge within [maximum] iterations` e retorne `None`.

**Nota**: Você não pode importar nenhum módulo para este laboratório.

# --hints--

Você não deve importar nenhum módulo.

```js
({ test: () => assert(runPython(`len(_Node(_code).find_imports()) == 0`)) })
```

Você deve ter uma função chamada `square_root_bisection`.

```js
({ test: () => assert(runPython(`_Node(_code).has_function("square_root_bisection")`)) })
```

Sua função `square_root_bisection` deve ter três parâmetros.

```js
({ test: () => runPython(`
    import inspect 
    sig = inspect.signature(square_root_bisection)
    assert len(sig.parameters) == 3
`) })
```

Você deve definir um valor padrão para a **tolerância** e o número máximo de iterações.

```js
({ test: () => runPython(`
try:
  import inspect 
  sig = inspect.signature(square_root_bisection)
  assert len(sig.parameters) == 3
  square_root_bisection(4)
except TypeError:
  assert False
`) })
```

Sua função `square_root_bisection` deve lançar um `ValueError` com a mensagem `Raiz quadrada de número negativo não está definida nos números reais` quando o número passado para a função for negativo.

```js
({ test: () => runPython(`
try:
  square_root_bisection(-6)
except ValueError as e:
  assert str(e) == "Square root of negative number is not defined in real numbers"
else:
  assert False
`) })
```

`square_root_bisection(0)` deve retornar `0`.

```js
({ test: () => runPython(`assert square_root_bisection(0) == 0`) })
```

`square_root_bisection(0)` deve imprimir `A raiz quadrada de 0 é 0`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print
square_root_bisection(0)
assert "The square root of 0 is 0" in _out
`) })
```

`square_root_bisection(0.001, 1e-7, 50)` deve retornar um número entre `0.03162267660168379` e `0.031622876601683794`.

```js
({ test: () => runPython(`assert 0.03162267660168379 <= square_root_bisection(0.001, 1e-7, 50) <= 0.031622876601683794`) })
```

`square_root_bisection(0.001, 1e-7, 50)` deve imprimir `A raiz quadrada de 0.001 é aproximadamente X`, onde `X` é um número entre `0.03162267660168379` e `0.031622876601683794`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(0.001, 1e-7, 50)

assert 0.03162267660168379 <= _root <= 0.031622876601683794
assert f"The square root of 0.001 is approximately {_root}" in _out
`) })
```

`square_root_bisection(0.25, 1e-7, 50)` deve retornar um número entre `0.4999999` e `0.5000001`.

```js
({ test: () => runPython(`assert 0.4999999 <= square_root_bisection(0.25, 1e-7, 50) <= 0.5000001`) })
```

`square_root_bisection(0.25, 1e-7, 50)` deve imprimir `A raiz quadrada de 0.25 é aproximadamente X`, onde `X` é um número entre `0.4999999` e `0.5000001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(0.25, 1e-7, 50)

assert 0.4999999 <= _root <= 0.5000001
assert f"The square root of 0.25 is approximately {_root}" in _out
`) })
```

`square_root_bisection(1)` deve retornar `1`.

```js
({ test: () => runPython(`assert square_root_bisection(1) == 1`) })
```

`square_root_bisection(1)` deve imprimir `A raiz quadrada de 1 é 1`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print
square_root_bisection(1)
assert "The square root of 1 is 1" in _out
`) })
```

`square_root_bisection(81, 1e-3, 50)` deve retornar um número entre `8.999` e `9.001`.

```js
({ test: () => runPython(`assert 8.999 <= square_root_bisection(81, 1e-3, 50) <= 9.001`) })
```

`square_root_bisection(81, 1e-3, 50)` deve imprimir `A raiz quadrada de 81 é aproximadamente X`, onde `X` é um número entre `8.999` e `9.001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(81, 1e-3, 50)

assert 8.999 <= _root <= 9.001
assert f"The square root of 81 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-3, 100)` deve retornar um número entre `14.999` e `15.001`.

```js
({ test: () => runPython(`assert 14.999 <= square_root_bisection(225, 1e-3, 100) <= 15.001`) })
```

`square_root_bisection(225, 1e-3, 100)` deve imprimir `A raiz quadrada de 225 é aproximadamente X`, onde `X` é um número entre `14.999` e `15.001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(225, 1e-3, 100)

assert 14.999 <= _root <= 15.001
assert f"The square root of 225 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-5, 100)` deve retornar um número entre `14.99999` e `15.00001`.

```js
({ test: () => runPython(`assert 14.99999 <= square_root_bisection(225, 1e-5, 100) <= 15.00001`) })
```

`square_root_bisection(225, 1e-5, 100)` deve imprimir `A raiz quadrada de 225 é aproximadamente X`, onde `X` é um número entre `14.99999` e `15.00001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(225, 1e-5, 100)

assert 14.99999 <= _root <= 15.00001
assert f"The square root of 225 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-7, 100)` deve retornar um número entre `14.9999999` e `15.0000001`.

```js
({ test: () => runPython(`assert 14.9999999 <= square_root_bisection(225, 1e-7, 100) <= 15.0000001`) })
```

`square_root_bisection(225, 1e-7, 100)` deve imprimir `A raiz quadrada de 225 é aproximadamente X`, onde `X` é um número entre `14.9999999` e `15.0000001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(225, 1e-7, 100)

assert 14.9999999 <= _root <= 15.0000001
assert f"The square root of 225 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-7, 10)` deve retornar `None`.

```js
({ test: () => runPython(`assert square_root_bisection(225, 1e-7, 10) is None`) })
```

`square_root_bisection(225, 1e-7, 10)` deve imprimir `Falha ao convergir dentro de 10 iterações`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print
square_root_bisection(225, 1e-7, 10)
assert "Failed to converge within 10 iterations" in _out
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):
    if square_target < 0:
        raise ValueError('Square root of negative number is not defined in real numbers')
    if square_target == 1:
        root = 1
        print(f'The square root of {square_target} is 1')
    elif square_target == 0:
        root = 0
        print(f'The square root of {square_target} is 0')

    else:
        low = square_target if square_target < 1 else 1
        high = 1 if square_target < 1 else square_target
        root = None

        for _ in range(max_iterations):
            mid = (low + high) / 2
            square_mid = mid**2

            if high - low <= tolerance:
                root = mid
                break

            elif square_mid < square_target:
                low = mid
            else:
                high = mid

        if root is None:
            print(f"Failed to converge within {max_iterations} iterations")

        else:   
            print(f'The square root of {square_target} is approximately {root}')

    return root
```
