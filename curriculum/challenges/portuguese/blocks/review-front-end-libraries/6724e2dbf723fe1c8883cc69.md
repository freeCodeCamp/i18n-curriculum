---
id: 6724e2dbf723fe1c8883cc69
title: Revisão de Bibliotecas Frontend
challengeType: 31
dashedName: review-front-end-libraries
---

# --description--

## Bibliotecas e Frameworks JavaScript

- Bibliotecas e frameworks JavaScript oferecem soluções rápidas para problemas comuns e aceleram o desenvolvimento ao fornecer código pré-construído.
- Bibliotecas geralmente são mais focadas em fornecer soluções para tarefas específicas, como manipular o DOM, lidar com eventos ou gerenciar requisições AJAX.
- Alguns exemplos de bibliotecas JavaScript são jQuery e React.
- Frameworks, por outro lado, fornecem uma estrutura mais definida para construir aplicações. Eles frequentemente vêm com um conjunto de regras e convenções que os desenvolvedores precisam seguir.
- Exemplos de frameworks incluem Angular e Next.js, um meta framework para React.
- **Aplicações de página única** (SPAs) são aplicações web que carregam uma única página HTML e atualizam dinamicamente essa página conforme o usuário interage com a aplicação sem recarregar a página inteira.
- SPAs usam JavaScript para gerenciar o estado da aplicação e renderizar o conteúdo. Isso é frequentemente feito usando frameworks que fornecem ótimas ferramentas para construir interfaces de usuário complexas.
- Algumas questões relacionadas a SPAs incluem:

  - Leitores de tela têm dificuldade com conteúdo atualizado dinamicamente.
  - A URL não muda quando o usuário navega dentro da aplicação, o que pode dificultar marcar, voltar ou compartilhar páginas específicas.
  - O tempo de carregamento inicial pode ser lento se a aplicação for grande, pois todos os assets precisam ser carregados antecipadamente.

## React

- React é uma biblioteca popular de JavaScript para construir interfaces de usuário e aplicações web.
- Um conceito central do React é a criação de componentes de UI reutilizáveis que podem atualizar e renderizar independentemente conforme os dados mudam.
- React permite que os desenvolvedores descrevam como a UI deve parecer com base no estado da aplicação. O React então atualiza e renderiza os componentes corretos quando os dados ou o estado mudam.

## Componentes React

- Componentes são os blocos de construção das aplicações React que permitem aos desenvolvedores dividir interfaces de usuário complexas em partes menores e gerenciáveis.
- A interface do usuário é descrita usando JSX, uma extensão da sintaxe JavaScript, que permite aos desenvolvedores escrever código semelhante a HTML dentro de JavaScript.
- Componentes são basicamente funções ou classes JS que retornam uma parte da interface do usuário.

Aqui está um exemplo de um componente React simples que renderiza uma mensagem de saudação:

```jsx
function Greeting() {
  const name = 'Anna';
  return <h1>Welcome, {name}!</h1>;
}
```

Para usar o componente, você pode simplesmente chamar:
    
```jsx
  <Greeting />
```

## Importando e Exportando componentes React

- Componentes React podem ser exportados de um arquivo e importados para outro arquivo.
- Vamos supor que você tenha um componente chamado `City` em um arquivo chamado `City.js`. Você pode exportar o componente usando a palavra-chave `export`:

```jsx
// City.js
function City() {
  return <p>New York</p>;
}

export default City;
```

- Para importar o componente `City` para outro arquivo, você pode usar a palavra-chave `import`:

```jsx
// App.js
import City from './City';

function App() {
  return (
    <div>
      <h1>My favorite city is:</h1>
      <City />
    </div>
  );
}
```

- A palavra-chave `default` é usada pois é a exportação padrão do arquivo `City.js`.

- Você também pode optar por exportar o componente na mesma linha da definição do componente assim:

```jsx
export default function City() {
  return <p>New York</p>;
}
```

## Configurando um projeto React usando Vite

- Ferramentas de configuração de projetos e CLIs oferecem uma maneira rápida e fácil de iniciar novos projetos, permitindo que os desenvolvedores se concentrem em escrever código em vez de lidar com configuração.
- Vite é uma ferramenta popular para configuração de projetos e pode ser usada com React.
- Para criar um novo projeto com Vite, você pode usar o seguinte comando no seu terminal:

```bash
npm create vite@latest my-react-app -- --template react
```

Este comando cria um novo projeto React chamado `my-react-app` usando o template React do Vite. No diretório do projeto, você verá um arquivo `package.json` com as dependências e comandos do projeto listados nele.

- Para executar o projeto, navegue até o diretório do projeto e execute os seguintes comandos:

```bash
cd my-react-app # path to the project directory
npm install # installs the dependencies listed in the package.json file
```

- Uma vez que as dependências estejam instaladas, você deve notar uma nova pasta no seu projeto chamada `node_modules`.

- A pasta `node_modules` é onde todos os pacotes e bibliotecas necessários para o seu projeto são armazenados.

- Para executar seu projeto, use o seguinte comando:

```bash
npm run dev
```

- Depois disso, abra seu navegador e navegue até `http://localhost:5173` para ver sua aplicação React em execução.

- Para realmente ver o código do template inicial, você pode entrar no seu projeto dentro da pasta `src` e deve ver o arquivo `App.jsx`.

## Passando props em componentes React

- No React, props (abreviação de properties) são uma forma de passar dados de um componente pai para um componente filho. Esse mecanismo é necessário para criar elementos de UI reutilizáveis e dinâmicos.
- Props podem ser qualquer valor JavaScript. Para passar props de um componente pai para um componente filho, você adiciona os props como atributos quando usa o componente filho no JSX do pai. Aqui está um exemplo simples:

```jsx
// Parent component
function Parent() {
  const name = 'Anna';
  return <Child name={name} />;
}

// Child component
function Child(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

Você pode passar múltiplas props usando o operador spread `(...)`, depois de convertê-las em um objeto. Aqui está um exemplo:
    
```jsx
// Parent component
function Parent() {
  const person = {
    name: 'Anna',
    age: 25,
    city: 'New York'
  };
  return <Child {...person} />;
}
```

Neste código, o operador spread `{...person}` converte o objeto person em props individuais que são passados para o componente Child.

## Renderização condicional em React

- A renderização condicional em React permite que você crie interfaces de usuário dinâmicas. É usado para mostrar conteúdo diferente com base em certas condições ou estados dentro da sua aplicação.
- Existem várias maneiras de renderizar conteúdo condicionalmente em React. Uma abordagem comum é usar o operador ternário. Aqui está um exemplo:

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please log in</h1>}
    </div>
  );
}
```

- Outra forma de renderizar conteúdo condicionalmente é usar o operador lógico AND (`&&`). Isso é útil quando você quer renderizar conteúdo somente se uma determinada condição for atendida. Aqui está um exemplo:

```jsx
function Greeting({ user }) {
  return (
    <div>
      {user && <h1>Welcome, {user.name}!</h1>}
    </div>
  );
}
```

No código acima, o elemento `h1` é renderizado apenas se o objeto user for truthy.

Você também pode usar uma declaração direta `if` desta forma:

```js
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  }
  return <h1>Please sign in</h1>;
}
```

## Renderizando listas em React

- Renderizar listas em React é uma tarefa comum ao construir interfaces de usuário.
- Listas podem ser renderizadas usando o método `map()` do array JS para iterar sobre um array de itens e retornar um novo array de elementos JSX.
- Por exemplo, se você tem um array de nomes que deseja renderizar como uma lista, você pode fazer o seguinte:

```jsx
function NameList({ names }) {
  return (
    <ul>
      {names.map((name, index) => (
        <li key={`${name}-${index}`}>{name}</li>
      ))}
    </ul>
  );
}
```

- Sempre lembre-se de fornecer uma chave única para cada item da lista para ajudar o React a gerenciar as funções de atualização e renderização. Com essas técnicas, você pode criar listas flexíveis, eficientes e dinâmicas em suas aplicações React.

## Estilos inline em React

- Estilos inline no React permitem que você aplique estilos CSS diretamente aos elementos JSX usando objetos JavaScript.
- Para aplicar estilos inline no React, você pode usar o atributo style em elementos JSX. O atributo style recebe um objeto onde as chaves são propriedades CSS em camelCase e os valores são os valores correspondentes. Aqui está um exemplo:

```js
function Greeting() {
  return (
    <h1
      style={{ color: 'blue', fontSize: '24px', backgroundColor: 'lightgray' }}
    >
      Hello, world!
    </h1>
  );
}

export default Greeting;
```

Você também pode extrair os estilos para um objeto separado e referenciá-lo no atributo `style` desta forma:

```jsx
function Greeting() {

  const styles = {
    color: 'blue',
    fontSize: '24px',
    backgroundColor: 'lightgray'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- Estilos inline suportam estilização dinâmica permitindo que você aplique estilos condicionalmente com base em props ou estado. Aqui está um exemplo de como você pode aplicar estilos condicionalmente com base em uma prop:

```jsx
function Greeting({ isImportant }) {

  const styles = {
    color: isImportant ? 'red' : 'black',
    fontSize: isImportant ? '24px' : '16px'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- No código acima, os estilos `color` e `fontSize` são definidos condicionalmente com base na prop `isImportant`.

## Trabalhando com Eventos em React

- **Sistema de Evento Sintético**: Esta é a forma do React de lidar com eventos. Ele funciona como um invólucro em torno dos eventos nativos como os eventos `click`, `keydown` e `submit`. Os manipuladores de eventos no React usam a convenção de nomenclatura em camel case. (Ex. `onClick`, `onSubmit`, etc)

Aqui está um exemplo de uso do atributo `onClick` para um elemento `button` no React:

```jsx
function handleClick() {
  console.log("Button clicked!");
}

<button onClick={handleClick}>Click Me</button>;
```

No React, funções manipuladoras de eventos geralmente começam com o prefixo `handle` para indicar que são responsáveis por lidar com eventos, como `handleClick` e `handleSubmit`.

Quando uma ação do usuário dispara um evento, o React passa um objeto Synthetic Event para o seu manipulador. Esse objeto se comporta de forma muito semelhante ao objeto Event nativo do JavaScript puro, fornecendo propriedades como `type`, `target` e `currentTarget`.

Para evitar comportamentos padrão como o refresh do navegador durante um evento `onSubmit`, por exemplo, você pode chamar o método `preventDefault()`:

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("Form submitted!");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>Submit</button>
</form>;
```

Você também pode envolver uma função handler em uma função arrow assim:

```jsx
function handleDelete(id) {
  console.log("Deleting item:", id);
}

<button onClick={() => handleDelete(1)}>Delete Item</button>;
```

## Trabalhando com State e o Hook `useState`

- **Definição para state**: Em React, state é um objeto que contém dados para um componente. Quando o state é atualizado, o componente será re-renderizado. React trata o state como imutável, o que significa que você não deve modificá-lo diretamente.
- **Hook `useState()`**: O hook `useState` é uma função que permite declarar variáveis de estado em componentes funcionais. Aqui está uma sintaxe básica:

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

Na variável de estado você tem o seguinte:

- `stateVariable` mantém o valor do estado atual
- `setStateFunction` (a função setter) atualiza a variável de estado
- `initialValue` define o estado inicial

Aqui está um exemplo completo para um componente `Counter`:

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

## Renderização e Componentes React

- **Definição**: No React, renderizar é o processo pelo qual os componentes aparecem na interface do usuário (UI), geralmente no navegador. O processo de renderização consiste em três etapas: trigger, render e commit.

A fase de gatilho ocorre quando o React detecta que algo mudou e a interface do usuário (UI) pode precisar ser atualizada. Essa mudança geralmente ocorre devido a uma atualização no state ou props.

Uma vez que o gatilho acontece, o React entra na fase de renderização. Aqui, o React reavalia seus componentes e determina o que exibir.  To do this, React uses a lightweight copy of the "real" DOM called the virtual DOM. Com o virtual DOM, o React pode verificar rapidamente o que precisa mudar no componente.

A etapa de commit é onde o React pega as mudanças preparadas do virtual DOM e as aplica no DOM real. Em outras palavras, esta é a etapa onde você vê o resultado final na tela.

## Atualizando Objetos e Arrays no State

- **Atualizando Objetos no State**: Se você precisar atualizar um objeto no state, então você deve criar um novo objeto ou copiar um objeto existente primeiro, depois definir o state para esse novo objeto. Qualquer objeto colocado no state deve ser considerado somente leitura. Aqui está um exemplo de como definir o nome, idade e cidade de um usuário. A função `handleChange` é usada para lidar com as atualizações das informações do usuário:

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **Atualizando Arrays no State**: Ao atualizar arrays no state, é importante não modificar diretamente o array usando métodos como `push()` ou `pop()`. Em vez disso, você deve criar um novo array ao atualizar o state:

```jsx
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

Se você quiser remover itens de um array, deve usar o método `filter()`, que retorna um novo array após filtrar o que você deseja remover:

```jsx
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## Referenciando Valores Usando Refs

- **Atributo `ref`**: Você pode acessar um nó DOM no React usando o atributo `ref`. Aqui está um exemplo para mostrar um `ref` para focar um elemento `input`. A propriedade `current` é usada para acessar o valor atual desse `ref`:

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Focus;
```

## Trabalhando com o Hook `useEffect`

- **`useEffect()` Hook**: In React, an effect is anything that happens outside the component rendering process. Ou seja, qualquer coisa que o React não gerencie diretamente como parte da renderização da UI. Exemplos comuns incluem buscar dados, atualizar o título da aba do navegador, ler ou gravar no armazenamento local do navegador, obter a localização do usuário e muito mais. Essas operações interagem com o mundo externo e são conhecidas como efeitos colaterais. React fornece o hook `useEffect` para permitir que você lide com esses efeitos colaterais. `useEffect` permite que você execute uma função após o componente renderizar ou atualizar.

```js
import { useEffect } from "react";

useEffect(() => {
 // Your side effect logic (usually a function) goes here
}, [dependencies]);
```

A função de efeito é executada após o componente renderizar, enquanto o argumento opcional `dependencies` controla quando o efeito é executado.

Observe que `dependencies` pode ser um array de "valores reativos" (state, props, functions, variables e assim por diante), um array vazio ou ser omitido completamente. Aqui está como todas essas opções controlam como `useEffect` funciona:

- Se `dependencies` for um array que inclui um ou mais valores reativos, o efeito será executado sempre que eles mudarem.

- Se `dependencies` for um array vazio, `useEffect` executa apenas uma vez quando o componente é renderizado pela primeira vez.

- Se você omitir `dependencies`, o efeito será executado toda vez que o componente renderizar ou atualizar.

## Como Criar Hooks Personalizados

- **Custom Hooks**: Um hook customizado permite que você extraia lógica reutilizável de componentes, como busca de dados, gerenciamento de estado, alternância e efeitos colaterais como monitoramento do status online. No React, todos os hooks internos começam com a palavra `use`, então seu hook customizado deve seguir a mesma convenção.

Aqui está um exemplo de como criar um hook `useDebounce`:

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

## Trabalhando com Formulários em React

- **Controlled Inputs**: Isso acontece quando você armazena o valor do campo de entrada no estado e o atualiza através de eventos `onChange`. Isso lhe dá controle completo sobre os dados do formulário e permite validação instantânea e renderização condicional.

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form>
    </>
  );
}

export default App;
```

- **Entradas Não Controladas**: Em vez de manipular as entradas através do hook `useState`, entradas não controladas em HTML mantêm seu próprio estado interno com a ajuda do DOM. Como o DOM controla os valores das entradas, você precisa obter os valores dos campos de entrada com um `ref`.

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">Your</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">Submit</button>
   </form>
 );
}

export default App;
```

## Trabalhando com o Hook `useActionState`

- **Server Actions**: Estas são funções que são executadas no servidor para permitir o manuseio de formulários diretamente no servidor sem a necessidade de endpoints de API. Aqui está um exemplo de uma aplicação Next.js:

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `Hello, ${name}!` };
}
```

A diretiva `"use server"` marca a função como uma ação do servidor.

- **Hook `useActionState`**: Este hook atualiza o estado com base no resultado de uma submissão de formulário. Aqui está a sintaxe básica do hook `useActionState`:

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` é o estado atual que a ação retorna.
- `action` é a função que dispara a ação do servidor.
- `isPending` é um booleano que indica se a ação está sendo executada no momento ou não.
- O parâmetro `actionFunction` é a própria ação do servidor.
- `initialState` é o parâmetro que representa o ponto de partida para o estado antes da execução da ação.
- `permalink` é uma string opcional que contém a URL única da página que o formulário modifica.

## Busca de Dados em React

- **Opções Para Buscar Dados**: Existem muitas maneiras diferentes de buscar dados no React. Você pode usar a Fetch API nativa ou ferramentas de terceiros como Axios ou SWR.
- **Variáveis de Estado Comumente Usadas ao Buscar Dados**: Independentemente da forma que você escolher para buscar seus dados em React, existem alguns pedaços de estado que você precisará acompanhar. O primeiro é o próprio dado. O segundo acompanhará se os dados ainda estão sendo buscados. O terceiro é uma variável de estado que capturará quaisquer erros que possam ocorrer durante o processo de busca dos dados.

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

Como a obtenção de dados é um efeito colateral, é melhor usar a `Fetch API` dentro de um hook `useEffect`.

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      
      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Então você pode exibir uma mensagem de carregamento se a busca dos dados não estiver completa, uma mensagem de erro se houve um erro ao buscar os dados, ou os resultados.

```jsx
if (loading) {
  return <p>Loading...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

Se você quiser usar Axios, você precisa instalá-lo e importá-lo:

```bash
npm i axios
```

```js
import axios from "axios";
```

Então você pode buscar os dados usando `axios.get`:

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Para buscar dados usando o hook `useSWR`, você precisa primeiro instalá-lo e importá-lo.

```bash
npm i swr
```

```js
import useSWR from "swr";
```

Aqui está como você pode usar o hook para buscar dados:

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>Loading...</h2>;
 }
 if (error) {
   return <h2>Error: {error.message}</h2>;
 }

 return (
   <>
     <h2>Todos</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## Trabalhando com o Hook `useOptimistic`

- **Hook `useOptimistic`**: Este hook é usado para manter as UIs responsivas enquanto aguarda a conclusão de uma ação assíncrona em segundo plano. Ele ajuda a gerenciar "atualizações otimistas" na UI, uma estratégia na qual você fornece atualizações imediatas para a UI com base no resultado esperado de uma ação, como aguardar uma resposta do servidor.

Aqui está a sintaxe básica:

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` é o estado temporário que é atualizado imediatamente para uma melhor experiência do usuário.
- `addOptimistic` é a função que aplica a atualização otimista antes das mudanças reais no estado.
- `actualState` é o valor real do estado que vem do resultado de uma ação, como buscar dados de um servidor.
- `updateFunction` é a função que determina como o estado otimista deve ser atualizado quando chamada.

Aqui está um exemplo de uso do hook `useOptimistic` em um componente `TaskList`:

```js
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**: Isso é usado para renderizar parte da UI e marcar uma atualização de estado como uma transição não urgente. Isso permite que a UI seja responsiva durante atualizações custosas. Aqui está a sintaxe básica:

```js
startTransition(action)
```

A `action` executa uma atualização de estado ou dispara alguma lógica relacionada à transição. Isso garante que atualizações urgentes da UI (como digitar ou clicar) não sejam bloqueadas.

## Trabalhando com o Hook `useMemo`

- **Memoization**: Esta é uma técnica de otimização na qual o resultado de chamadas de função custosas é armazenado em cache (lembrado) com base em argumentos específicos. Quando os mesmos argumentos são fornecidos novamente, o resultado em cache é retornado em vez de recalcular a função.
- **Hook `useMemo`**: Este hook é usado para memorizar valores computados. Aqui está um exemplo de como memorizar o resultado da ordenação de um array grande. A `expensiveSortFunction` será executada apenas quando `largeArray` mudar:

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## Trabalhando com o Hook `useCallback`

- **Hook `useCallback`**: Isso é usado para memorizar referências de função.

```js
const handleClick = useCallback(() => {
 // code goes here
}, [dependency]);
``` 

- **`React.memo`**: Isso é usado para memorizar um componente para evitar re-renderizações desnecessárias quando sua prop não mudou.

```js
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* Presentation */}
   </>
 )
});
``` 

## Ferramentas de Gerenciamento de Dependências

- **Definição de Dependência**: Em software, uma dependência é quando um componente ou módulo em uma aplicação depende de outro para funcionar corretamente. Dependências são comuns em aplicações de software porque permitem que desenvolvedores usem funções ou ferramentas pré-construídas criadas por outros. As duas dependências principais necessárias para um projeto React serão os pacotes `react` e `react-dom`:

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **Definição de Gerenciador de Pacotes**: Para gerenciar dependências de software em um projeto, você precisará usar um gerenciador de pacotes. Um gerenciador de pacotes é uma ferramenta usada para instalação, atualizações e remoção de dependências. Muitas linguagens de programação populares como JavaScript, Python, Ruby e Java usam gerenciadores de pacotes. Gerenciadores de pacotes populares para JavaScript incluem `npm`, `Yarn` e `pnpm`.
- **Arquivo `package.json`**: Este é um arquivo de configuração chave em projetos que contém metadados sobre seu projeto, incluindo seu nome, versão e dependências. Ele também define scripts, informações de licenciamento e outras configurações que ajudam a gerenciar o projeto e suas dependências.
- **Arquivo `package-lock.json`**: Este arquivo irá travar as versões exatas de todos os pacotes que seu projeto está usando. Quando você atualizar um pacote, as novas versões também serão atualizadas no arquivo de bloqueio.
- **Pasta `node_modules`**: Esta pasta contém o código real das dependências listadas no seu arquivo `package.json`, incluindo tanto as dependências diretas do seu projeto quanto quaisquer dependências dessas dependências.
- **Dependências de Desenvolvimento**: Estes são pacotes que são usados apenas para desenvolvimento e não em produção. Um exemplo disso seria uma biblioteca de testes como o Jest. Você instalaria o Jest como uma dependência de desenvolvimento porque ele é necessário para testar sua aplicação localmente mas não é necessário para que a aplicação funcione em produção.

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **Introdução**: React Router é uma biblioteca de terceiros que permite adicionar roteamento às suas aplicações React. Para começar, você precisará instalar o React Router em um projeto React existente assim:

```bash
npm i react-router
```

Então, dentro do arquivo `main.jsx` ou `index.jsx`, você precisará configurar a estrutura de rotas assim:

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

O `path` e o `element` são usados para acoplar a URL e os componentes da interface do usuário juntos. Neste caso, estamos configurando uma rota para a página inicial que aponta para o componente `App`. 

- **Múltiplas Views e Configuração de Rotas**: É comum em aplicações maiores ter múltiplas views e configurações de rotas assim:

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

A prop `index` nesses exemplos tem o propósito de representar a rota padrão para um determinado segmento de caminho. Então o componente `Home` será exibido na rota raiz `/` enquanto o componente `ProductsHome` será exibido na rota `/products`.

- **Rotas Aninhadas**: Você pode aninhar rotas dentro de outras rotas o que resulta no caminho da rota filha sendo anexado ao caminho da rota pai.

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

No exemplo acima, o caminho para os produtos em alta será products/trending.

- **Segmentos Dinâmicos**: Um segmento dinâmico é onde qualquer parte do caminho da URL é dinâmica.

```jsx
<Route path=":category" element={<Category />} />
```

Neste exemplo temos um segmento dinâmico chamado `category`. Quando um usuário navega para uma URL como products/brass-instruments, a visualização mudará para o componente `Category` e você pode buscar dinamicamente os dados apropriados com base no segmento.

- **Hook `useParams`**: Este hook é usado para acessar os parâmetros dinâmicos de um caminho de URL.

```js
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
   {/* Accessing the category param: params.category */}
   {/* rest of code goes here */}
}
```

## Frameworks React

- **Introdução**: Frameworks React fornecem recursos como roteamento, otimizações de imagem, busca de dados, autenticação e mais. Isso significa que você pode não precisar configurar aplicações frontend e backend separadas para certos casos de uso. Exemplos de Frameworks React incluem Next.js e Remix.
- **Next.js Routing**: Este sistema de roteamento inclui suporte para rotas dinâmicas, rotas paralelas, manipuladores de rotas, redirecionamentos, internalização e mais.

Aqui está um exemplo de como criar um manipulador de requisição personalizado:

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Otimização de Imagens no Next.js**: O componente `Image` estende o elemento nativo HTML `img` e permite carregamentos de página mais rápidos e otimizações de tamanho. Isso significa que as imagens serão carregadas apenas quando entrarem na área visível e o componente `Image` servirá automaticamente imagens com o tamanho correto para cada dispositivo.

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
``` 

## Prop Drilling

- **Definição**: Prop drilling é o processo de passar props de um componente pai para componentes filhos profundamente aninhados, mesmo quando alguns dos componentes filhos não precisam dos props.

## Gerenciamento de Estado

- **Context API**: Contexto refere-se a quando um componente pai disponibiliza informações para componentes filhos sem a necessidade de passá-las explicitamente através de props. `createContext` é usado para criar um objeto de contexto que representa o contexto que outros componentes irão ler. O `Provider` é usado para fornecer valores de contexto aos componentes filhos.

```js
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**: Redux handles state management by providing a central store and strict control over state updates. Ele usa um padrão previsível com actions, reducers e middleware. Ações são cargas úteis de informação que enviam dados da sua aplicação para o `Redux store`, frequentemente acionadas por interações do usuário. Reducers são funções que especificam como o estado deve mudar em resposta a essas ações, garantindo que o estado seja atualizado de forma imutável.  Middleware, on the other hand, acts as a bridge between the action dispatching and the reducer, allowing you to extend Redux's functionality (e.g., logging, handling async operations) without modifying the core flow.

- **Zustand**: Esta solução de gerenciamento de estado é ideal para aplicações de pequeno a médio porte. Ela funciona usando um hook `useStore` para acessar o estado diretamente em componentes e páginas. Isso permite modificar e acessar dados sem a necessidade de actions, reducers ou um provider.

## Depuração de Componentes React Usando o React DevTools

- **React Developer Tools**: Esta é uma extensão de navegador que você pode usar no Chrome, Firefox e Edge para inspecionar componentes React e identificar problemas de desempenho. Para Safari, você precisará instalar o pacote npm `react-devtools`. Após instalar o React DevTools e abrir um app React no navegador, abra as ferramentas de desenvolvedor do navegador para acessar as duas abas extras fornecidas para depuração do React – Components e Profiler.
- **Aba Components**: Esta aba exibe cada componente para você em um formato de visualização em árvore. Aqui estão algumas coisas que você pode fazer nesta aba:
  - visualize a hierarquia de componentes do app
  - verifique e modifique `props`, `states` e valores de `context` em tempo real
  - verifique o código-fonte de cada componente selecionado
  - registre os dados do componente no console
  - inspecione os elementos DOM para o componente
- **Aba Profiler**: Esta aba ajuda você a analisar o desempenho dos componentes. Você pode registrar o desempenho dos componentes para identificar re-renderizações desnecessárias, visualizar durações de commits e, subsequentemente, otimizar componentes lentos.

## Componentes de Servidor React

- **Definição**: React Server Components são componentes React que renderizam exclusivamente no servidor, enviando apenas o HTML final para o cliente. Isso significa que esses componentes podem acessar diretamente recursos do lado do servidor e reduzir drasticamente a quantidade de JavaScript enviada para o navegador.

## Diferenças Entre Desempenho Real e Percebido

- **Perceived Performance**: This is how users perceive the performance of a website. É assim que eles avaliam em termos de responsividade e confiabilidade. Esta é uma medida subjetiva, então é difícil quantificá-la, mas é muito importante, já que a experiência do usuário determina o sucesso ou fracasso de um site.
- **Real Performance**: This is the objective and measurable performance of the website. É medido usando métricas como tempo de carregamento da página, tempo de resposta do servidor e tempo de renderização. Essas medições são influenciadas por múltiplos fatores relacionados à rede e ao próprio código.

## Técnicas para Melhorar a Performance Percebida

- **Lazy Loading**: Esta técnica reduz o tempo de carregamento inicial ao máximo carregando recursos não essenciais em segundo plano.
- **Minimize os Atrasos de Fonte**: Se o seu site possui fontes personalizadas, você também deve tentar minimizar os atrasos no carregamento das fontes, pois isso pode resultar em piscadas ou na exibição da fonte fallback enquanto a fonte personalizada está sendo carregada. Uma sugestão para isso é usar uma fonte fallback que seja semelhante à fonte personalizada, assim caso isso aconteça, a mudança será mais sutil.
- **Uso de Indicadores de Carregamento**: Mostrar um indicador de carregamento para um processo de longa duração assim que o usuário clicar em um elemento pode ajudar o usuário a se sentir conectado e envolvido com o processo, fazendo o tempo de espera parecer mais curto.

## Conceitos Centrais de Performance

- **Ordem de origem**: Isso se refere à forma como os elementos HTML estão estruturados no documento. Isso determina o que carrega primeiro e pode impactar significativamente o desempenho e a acessibilidade.

Algumas melhores práticas para a ordem de origem incluem:

- Colocando conteúdo crítico como títulos, navegação ou texto principal mais alto na estrutura HTML.
- Adiar scripts não essenciais como os de analytics ou widgets de terceiros para que eles não bloqueiem a renderização.
- Usando aprimoramento progressivo, para garantir que a experiência principal funcione mesmo antes de os estilos e scripts serem carregados. Aprimoramento progressivo é uma forma de construir sites e aplicações baseada na ideia de que você deve fazer sua página funcionar com HTML primeiro.

Aqui está um exemplo de boa ordem de origem, usando as melhores práticas que acabamos de ver:

```html
<h1>Welcome to FastSite!</h1>
<p>Critical information loads first.</p>
<script src="slow-script.js" defer></script>
```

- **Critical Rendering Path**: Esta é a sequência de etapas que o navegador segue para converter o código em pixels na tela.
- **Latência**: Este é o tempo que uma requisição leva para viajar entre o navegador e o servidor. Ou seja, alta latência significa páginas lentas.

Algumas formas de reduzir a latência incluem:

- Usando CDNs, ou Redes de Distribuição de Conteúdo, para servir arquivos de locais mais próximos.
- Habilitando compressão usando coisas como Gzip para reduzir o tamanho dos arquivos.
- Otimização de imagens e uso de lazy loading.

```html
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
```

## Melhorando o INP

- **Definição**: INP (Interaction to Next Paint) avalia a responsividade geral de uma página medindo o tempo desde quando um usuário interage, como um clique ou pressionamento de tecla, até a próxima vez que o navegador atualiza a exibição. Um INP menor indica uma página mais responsiva.

Aqui estão algumas maneiras de melhorar o INP:

- Reduza o trabalho da thread principal dividindo tarefas longas em JavaScript.
- Use `requestIdleCallback()` para scripts não críticos. Isso colocará uma função na fila para ser chamada durante os períodos ociosos do navegador.
- Adie ou carregue preguiçosamente os recursos pesados que foram abordados anteriormente.
- Otimize os manipuladores de eventos. Se esses manipuladores forem executados com muita frequência ou realizarem operações pesadas, eles podem deixar a página lenta e aumentar o INP. A solução para isso é o debounce. O debounce garante que a função seja executada somente depois que o usuário parar de digitar por um curto período - por exemplo, 300ms. Isso evita cálculos desnecessários e melhora o desempenho.

## Como o Rendering Funciona no Navegador

- **How Rendering works**: First the browser parses the HTML and builds the DOM. Em seguida, o navegador processa o CSS, construindo o CSS Object Model, ou CSSOM. Esta é outra estrutura de árvore que determina como os elementos devem ser estilizados. Finalmente, o navegador pinta os pixels na tela, renderizando cada elemento com base nos estilos e layout calculados. Em páginas complexas, isso pode envolver múltiplas camadas que são compostas juntas para formar a saída visual final.

## Como o Desempenho Impacta a Sustentabilidade

- **Background Information**: The internet accounts for around 2% of global carbon emissions—that's the same as the airline industry! Cada byte transferido requer eletricidade, desde data centers até dispositivos do usuário. Arquivos maiores e scripts ineficientes significam maior consumo de energia. Um site de alto desempenho não é apenas mais rápido, ele também reduz o processamento desnecessário e o uso de energia.

## Maneiras de Reduzir os Tempos de Carregamento da Página

- **Otimize os Ativos de Mídia**: Imagens e vídeos grandes são culpados comuns por tempos de carregamento lentos. Ao otimizar esses ativos, você pode acelerar significativamente seu site. Isso inclui coisas como comprimir imagens, usar formatos modernos como `WebP` e usar carregamento preguiçoso para os ativos.
- **Aproveite o Cache do Navegador**: O cache permite que os navegadores armazenem partes do seu site localmente, reduzindo o tempo de carregamento para visitantes que retornam.
- **Minificar e Comprimir Arquivos**: Reduzir o tamanho dos seus arquivos pode levar a downloads mais rápidos. Isso inclui reduzir o tamanho dos arquivos transmitidos e minificar arquivos CSS e JavaScript.

## Melhorando o "time to usable"

- **Definição**: "time to usable" é o intervalo desde quando um usuário solicita uma página até quando ele pode interagir significativamente com ela. Para melhorar o "time to usable" você pode carregar seus assets de forma preguiçosa ou minimizar recursos que bloqueiam a renderização.

## Métricas-chave para Medir o Desempenho

- **First Contentful Paint ou FCP**: Mede a rapidez com que o primeiro conteúdo—texto ou imagem—aparece na tela. Um bom FCP é considerado um tempo abaixo de 1,8 segundos e um FCP ruim é acima de 3 segundos. Você pode verificar seu FCP usando o Chrome DevTools e conferindo a aba de performance.
- **Total Blocking Time**: Isso mostra por quanto tempo a thread principal fica bloqueada por tarefas pesadas de JavaScript. Se o Total Blocking Time (TBT) estiver alto, os usuários experimentam interações lentas. Para melhorar o TBT, divida tarefas longas e adie scripts não essenciais.
- **Taxa de Rejeição**: Esta é a porcentagem de visitantes que saem sem interagir. Se o seu site tem altas taxas de rejeição pode ser porque sua página está muito lenta.
- **Usuários Únicos**: Esta métrica acompanha quantos visitantes individuais acessam seu site. Para visualizar a Taxa de Rejeição e Usuários Únicos, você pode usar o Google Analytics. Ele permitirá que você monitore essas métricas e melhore o engajamento.

## Ferramentas Comuns de Medição de Desempenho

- **Chrome DevTools**: Chrome DevTools is a built-in tool inside Google Chrome that lets you analyze and debug performance in real-time. O DevTools mostrará tempos de carregamento, uso da CPU e atrasos na renderização.  It's especially useful for measuring First Contentful Paint, or FCP, is how fast a user sees the first visible content. Se o seu site parecer lento, o DevTools ajudará você a identificar os gargalos.
- **Lighthouse**: Esta é uma ferramenta automatizada que verifica desempenho, SEO e acessibilidade.
- **WebPageTest**: Esta ferramenta permite que você teste como seu site carrega a partir de diferentes locais e dispositivos. Esta ferramenta fornece uma análise detalhada do Speed Index, Total Blocking Time e outras métricas de desempenho chave do seu site. Se você quer saber como usuários reais experimentam seu site globalmente, WebPageTest é a ferramenta certa para isso.
- **PageSpeed Insights**: Esta ferramenta analisa seu site e sugere melhorias rápidas para dispositivos móveis e desktop. Ela informará o que está deixando seu site lento e dará recomendações específicas como otimizar imagens, remover scripts que bloqueiam a renderização e reduzir os tempos de resposta do servidor. PageSpeed Insights é uma maneira rápida e fácil de verificar como o Google vê o desempenho do seu site.
- **Real User Monitoring**: ferramentas de RUM acompanham o comportamento real dos usuários, mostrando como visitantes reais experimentam seu site. Ferramentas populares de RUM incluem Google Analytics, que monitora tempos de carregamento de página e taxas de rejeição, e New Relic ou Datadog, que monitoram problemas de desempenho em tempo real. Se você quer dados de usuários reais, ferramentas de RUM são essenciais.

## Trabalhando com Performance Web APIs

- **Definição**: As Performance Web APIs permitem que os desenvolvedores acompanhem quão eficientemente uma página web carrega e responde diretamente no código. Essas APIs permitem medir os tempos de carregamento da página, acompanhar atrasos na renderização e interação e analisar o tempo de execução do JavaScript.
- **`performance.now()`**: Esta API fornece timestamps de alta precisão (em milissegundos) para medir quanto tempo diferentes partes do seu site levam para carregar.

```js
const start = performance.now();  
// Run some code here  
const end = performance.now();  

console.log(`Execution time: ${end - start}ms`);
```

- **Performance Timing API**: Esta API fornece uma análise detalhada de cada etapa do carregamento da página, desde a consulta DNS até `DOMContentLoaded`.

```js
const timing = performance.timing;  

const pageLoadTime = timing.loadEventEnd - timing.navigationStart;  
console.log(`Page load time: ${pageLoadTime}ms`);
```

- **`PerformanceObserver`**: Esta API escuta eventos de desempenho como deslocamentos de layout, tarefas longas e interações do usuário.

```js
const observer = new PerformanceObserver((list) => {  
  list.getEntries().forEach((entry) => {  
    console.log(`Long task detected: ${entry.duration}ms`);  
  });  
});  

observer.observe({ type: "longtask", buffered: true });
```

## Técnicas para Melhorar o Desempenho do CSS

- **CSS Animations**: Animating certain CSS properties, such as dimensions, position, and layout, triggers a process called "reflow", during which the browser recalculates the position and geometry of certain elements on the page. Isso requer uma repintura, que é computacionalmente cara. Portanto, é recomendado reduzir o número de animações CSS ao máximo ou pelo menos dar ao usuário uma opção para ativá-las ou desativá-las.

## Técnicas para Melhorar a Performance do JavaScript

- **Code Splitting**: Dividir seu código JavaScript em módulos que executam tarefas críticas e não críticas também é útil. Dessa forma, você poderá pré-carregar os críticos o mais rápido possível e adiar os não críticos para renderizar a página o mais rápido possível.
- **Manipulação do DOM**: Lembre-se que Manipulação do DOM refere-se ao processo de alterar dinamicamente o conteúdo de uma página com JavaScript ao interagir com o Document Object Model (DOM). Manipular o DOM é computacionalmente custoso. Reduzir a quantidade de manipulação do DOM no seu código JavaScript melhorará o desempenho.

## Frameworks CSS

- **Frameworks CSS**: Frameworks CSS podem acelerar seu fluxo de trabalho, criar um estilo visual uniforme em todo o site, fazer seu design parecer consistente em vários navegadores e manter seu código CSS mais organizado.
- **Frameworks CSS populares**: Alguns dos frameworks CSS populares são Tailwind CSS, Bootstrap, Materialize e Foundation.
- **Desvantagens potenciais**:
  - O CSS fornecido pelo framework pode entrar em conflito com seu CSS personalizado.
  - Seu site pode parecer semelhante a outros sites que usam o mesmo framework.
  - Grandes frameworks podem causar problemas de desempenho.

## Dois Tipos de Frameworks CSS

- **Frameworks CSS utility-first**: Esses frameworks possuem classes pequenas com propósitos específicos, como definir a margem, o padding ou a cor de fundo. Você pode atribuir essas classes pequenas diretamente aos elementos HTML conforme necessário. Tailwind CSS é categorizado como um framework CSS utility-first.

Aqui está um exemplo de como usar Tailwind CSS para estilizar um botão.

```html
<button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700">
  Button
</button>
```

- **Frameworks CSS baseados em componentes**: Esses frameworks possuem componentes pré-construídos com estilos pré-definidos que você pode adicionar ao seu site. Os componentes estão disponíveis na documentação oficial do framework CSS e você pode copiá-los e colá-los no seu projeto. Bootstrap é categorizado como um framework CSS baseado em componentes.

Aqui está um exemplo de como usar o Bootstrap para criar um grupo de lista. Em vez de aplicar pequenas classes aos seus elementos HTML, você adicionará o componente inteiro, incluindo a estrutura HTML.

```html
<div class="card" style="width: 25rem;">
  <ul class="list-group list-group-flush">
    <li class="list-group-item">HTML</li>
    <li class="list-group-item">CSS</li>
    <li class="list-group-item">JavaScript</li>
  </ul>
</div>
```

## Tailwind CSS

Tailwind é um framework CSS utility-first. Em vez de escrever regras CSS personalizadas, você cria seus designs combinando pequenas classes utilitárias diretamente no seu HTML.

### Utilitários de Design Responsivo

Tailwind usa prefixos como `sm:`, `md:` e `lg:` para aplicar estilos em diferentes tamanhos de tela.

```html
<div class="w-full md:w-1/2 lg:flex-row">
  Responsive layout
</div>
```

### Utilitários Flexbox

Classes como `flex`, `flex-col`, `justify-around` e `items-center` facilitam a criação de layouts flexíveis.

```html
<div class="flex flex-col md:flex-row justify-around items-center">
  <p>Column on small screens</p>
  <p>Row on medium and larger screens</p>
</div>
```

### Utilitários de Grid

Tailwind inclui utilitários para CSS Grid, como `grid`, `grid-cols-1` e `md:grid-cols-3`.

```html
<div class="grid grid-cols-1 md:grid-cols-3 gap-8">
  <div class="bg-gray-100 p-4">Column 1</div>
  <div class="bg-gray-100 p-4">Column 2</div>
  <div class="bg-gray-100 p-4">Column 3</div>
</div>
```

### Utilitários de Espaçamento

Utilitários como `mt-8`, `mx-auto`, `p-4` e `gap-4` ajudam a criar espaçamento consistente sem escrever CSS.

```html
<div class="mt-8 p-4 bg-indigo-600 text-white">
  Spaced content
</div>
```

### Utilitários de Tipografia

Utilitários como `uppercase`, `font-bold`, `font-semibold` e `text-4xl` controlam a aparência do texto.

Você pode definir tamanhos de fonte que se ajustam em pontos de interrupção, como `text-3xl` e `md:text-5xl`.

```html
<h1 class="text-3xl md:text-5xl font-semibold text-center">
  Responsive Heading
</h1>
```

### Cores e Estados de Hover

Tailwind fornece uma ampla paleta de cores, como `text-red-700`, `bg-indigo-600` e `bg-gray-100`.

Classes como `hover:bg-pink-600` tornam efeitos interativos simples.

```html
<a href="#" class="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-md">
  Hover Me
</a>
```

### Bordas, Anéis e Efeitos

- **Bordas**: `border-2 border-red-300` adiciona bordas com espessura e cores especificadas.
- **Rings**: `ring-1 ring-gray-300` cria efeitos semelhantes a contornos frequentemente usados para foco ou cartões.
- **Cantoneiras arredondadas e escalonamento**: Classes como `rounded-md`, `rounded-xl` e `scale-105` adicionam acabamento.

```html
<div class="p-6 rounded-xl ring-2 ring-fuchsia-500 scale-105">
  Highlighted card
</div>
```

### Gradientes

Tailwind suporta utilitários de gradiente como `bg-gradient-to-r from-fuchsia-500 to-indigo-600`.

```html
<div class="p-4 text-white bg-gradient-to-r from-fuchsia-500 to-indigo-600">
  Gradient background
</div>
```

## Pré-processadores CSS

- **Pré-processador CSS**: Um pré-processador CSS é uma ferramenta que estende o CSS padrão. Ele compila o código com sintaxe estendida em um arquivo CSS nativo. Pode ser útil para escrever CSS mais limpo, reutilizável, menos repetitivo e escalável para projetos complexos.
- **Recursos**: Alguns dos recursos que podem ser fornecidos por preprocessadores CSS são variáveis, mixins, aninhamento e herança de seletores.
- **Pré-processadores CSS populares**: Alguns dos pré-processadores CSS populares são Sass, Less e Stylus.
- **Desvantagens potenciais**:
  - Compilar as regras CSS em CSS padrão pode causar overhead.
  - O código compilado pode ser difícil de depurar.

## Sass

- **Sass**: É um dos preprocessadores CSS mais populares. Sass significa "Syntactically Awesome Style Sheets."
- **Recursos suportados pelo Sass**: Sass suporta recursos como variáveis, regras CSS aninhadas, módulos, mixins, herança e operadores para operações matemáticas básicas

## Duas Sintaxes Suportadas pelo Sass

- **Sintaxe SCSS**: O SCSS (Sassy CSS) expande a sintaxe básica do CSS. É a sintaxe mais usada para Sass. Arquivos SCSS têm a extensão `.scss`.

Aqui está um exemplo de como definir e usar uma variável em SCSS.

```scss
$primary-color: #3498eb;

header {
  background-color: $primary-color;
}
```

- **Sintaxe indentada**: A sintaxe indentada foi a sintaxe original do Sass e também é conhecida como a "Sass syntax."

Aqui está um exemplo de como definir e usar uma variável na sintaxe indentada.

```sass
$primary-color: #3498eb

header
  background-color: $primary-color
```

### Mixins

- **Mixins**: Mixins permitem agrupar múltiplas propriedades CSS e seus valores sob um nome e reutilizar esse bloco de código CSS em toda a sua folha de estilo.

Aqui está um exemplo de definição de um mixin na sintaxe SCSS. Neste caso, o mixin é chamado `center-flex`. Ele tem três propriedades CSS para centralizar elementos usando flexbox.

```scss
@mixin center-flex {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

Aqui está um exemplo de uso do mixin que você definiu.

```scss
section {
  @include center-flex;
  height: 500px;
  background-color: #3289a8;
}
```

## Testes Manuais e Automatizados

- **Teste Manual**: No teste manual, um testador irá manualmente passar por cada parte da aplicação e testar diferentes funcionalidades para garantir que funcionem corretamente. Se algum bug for descoberto durante o processo de teste, o testador irá reportar esses bugs para a equipe de software para que possam ser corrigidos.
- **Testes Automatizados**: Em testes automatizados, você pode automatizar seus testes escrevendo um programa separado que verifica se sua aplicação se comporta conforme o esperado.

## Teste Unitário

- **Testes Unitários**: Nos testes unitários, você testa cada função para garantir que tudo está funcionando conforme o esperado. Os testes unitários também podem servir como uma forma de documentação para sua aplicação porque eles são destinados a representar o comportamento esperado do seu código.
- **Princípio da Responsabilidade Única**: O princípio da responsabilidade única recomenda manter cada função pequena e responsável por uma única coisa.
- **Frameworks Comuns de Testes em JavaScript**: Alguns frameworks comuns de teste incluem Jest, Mocha e Vitest. Jest é um framework popular de teste para testes unitários.

Aqui está um exemplo de testes unitários usando Jest.

Primeiro, você pode criar uma função que seja responsável por retornar uma string recém formatada:

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

Em um arquivo separado `getFormattedWord.test.js`, você pode escrever alguns testes para verificar se a função está funcionando conforme o esperado. O arquivo `getFormattedWord.test.js` ficará assim:

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **Função `expect`**: A função `expect` é usada para testar um valor.
- **Matcher**: Matcher é uma função que verifica se o valor se comporta conforme o esperado. No exemplo acima, o matcher é `toBe()`. O Jest possui uma variedade de matchers.

Para usar Jest, você primeiro precisa instalar o pacote `jest` usando `npm i jest`. Você também precisará adicionar um script ao seu arquivo `package.json` assim:

```js
"scripts": {
  "test": "jest"
},
```

Então, você pode executar o comando `npm run test` para rodar seus testes.

## Ciclo de Vida do Desenvolvimento de Software

- **Diferentes Estágios do Ciclo de Vida do Desenvolvimento de Software**:
  - **Fase de Planejamento**: A equipe de desenvolvimento coleta os requisitos para o trabalho proposto dos stakeholders.
  - **Fase de Design**: A equipe de software divide os requisitos e decide as melhores abordagens para as soluções.
  - **Fase de Implementação**: A equipe de software divide os requisitos em tarefas gerenciáveis e as implementa.
  - **Fase de Testes**: Isso envolve testes manuais e automatizados para o novo trabalho. Às vezes, a equipe testa a aplicação durante toda a fase de desenvolvimento para identificar e corrigir quaisquer problemas que surgirem.
  - **Fase de Implantação**: A equipe implanta as novas alterações em um ambiente de build ou de teste.
  - **Estágio de Manutenção**: Isso envolve corrigir quaisquer problemas que surgirem dos clientes na aplicação em produção.

- **Diferentes Modelos do Ciclo de Vida do Desenvolvimento de Software**:
  - **Modelo Waterfall**: O modelo Waterfall é onde cada fase do ciclo de vida precisa ser concluída antes que a próxima fase possa começar.
  - **Modelo Ágil**: O modelo Ágil foca no desenvolvimento iterativo dividindo o trabalho em sprints.

## BDD e TDD

- **TDD**: Desenvolvimento orientado a testes é uma metodologia que enfatiza escrever testes primeiro. Escrever testes antes de desenvolver funcionalidades fornece feedback em tempo real para os desenvolvedores durante o processo de desenvolvimento.
- **BDD**: Desenvolvimento orientado por comportamento é a abordagem de alinhar uma série de testes com os objetivos de negócio. Os cenários de teste em BDD devem ser escritos em uma linguagem que possa ser entendida tanto por pessoas técnicas quanto não técnicas. Um exemplo dessa sintaxe é Gherkin.
- **Frameworks de Teste BDD**: Exemplos de frameworks de teste BDD incluem Cucumber, JBehave e SpecFlow.

## Asserções em Testes Unitários

- **Assertion**: As assertions são usadas para testar se o código está se comportando conforme o esperado.
- **Bibliotecas de Asserção**: Chai é uma biblioteca de asserção comumente usada. Outras bibliotecas comuns de asserção em JavaScript são `should.js` e `expect.js`.

Aqui está um exemplo de uma asserção usando Chai que verifica se o valor retornado da função `addThreeAndFour` é igual ao número 7:

```js
assert.equal(addThreeAndFour(), 7);
```

- **Melhores Práticas**: Independentemente da biblioteca de asserção que você usar, você deve escrever mensagens claras de assert e falha que o ajudarão a entender quais testes estão falhando e por quê.

## Mocking, Faking e Stubbing

- **Mocking**: Mocking é o processo de substituir dados reais por dados falsos que simulam o comportamento de componentes reais. Por exemplo, você pode mockar a resposta da API em testes em vez de fazer chamadas contínuas à API para obter os dados.
- **Stubbing**: Stubs são objetos que retornam respostas pré-definidas ou dados fictícios para um comportamento esperado em uma aplicação. Por exemplo, você pode stubar o comportamento de uma conexão de banco de dados em seus testes sem precisar depender de uma conexão real com o banco de dados.
- **Faking**: Fakes are simplified versions of real components without the complexity or side effects. Por exemplo, você pode simular um banco de dados armazenando os dados na memória em vez de interagir com o banco de dados real. Isso permitirá que você simule operações de banco de dados na memória, o que será muito mais rápido do que lidar com o banco de dados real.

## Teste Funcional

- **Teste Funcional**: O teste funcional verifica se os recursos e funções da aplicação funcionam conforme o esperado. O objetivo do teste funcional é testar o sistema como um todo contra múltiplos cenários.
- **Teste Não Funcional**: O teste não funcional foca em aspectos como desempenho e confiabilidade.
- **Teste de fumaça**: Teste de fumaça é uma verificação preliminar no sistema para problemas básicos ou críticos antes de iniciar testes mais extensos.

## Teste de ponta a ponta

- **Testes de Ponta a Ponta**: Testes de ponta a ponta, ou E2E, testam cenários do mundo real sob a perspectiva do usuário. Testes de ponta a ponta ajudam a garantir que sua aplicação se comporte corretamente e seja previsível para os usuários. No entanto, é demorado configurar, projetar e manter.
- **Frameworks de Teste de Ponta a Ponta**: Playwright é um framework popular de teste de ponta a ponta desenvolvido pela Microsoft. Outros exemplos de ferramentas de teste de ponta a ponta incluem Cypress, Selenium e Puppeteer.

Aqui está um exemplo de testes E2E da base de código do freeCodeCamp usando Playwright. O hook `beforeEach` será executado antes de cada um dos testes. Os testes verificam se o doador possui um link de apoiador na barra de menu, assim como uma borda estilizada especial ao redor do avatar:

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## Teste de Usabilidade

- **Teste de Usabilidade**: Teste de usabilidade é quando você tem usuários reais interagindo com a aplicação para descobrir se há algum problema de design, experiência do usuário ou funcionalidade no app. O teste de usabilidade foca na intuitividade da aplicação pelos usuários.
- **Quatro Tipos Comuns de Testes de Usabilidade**:
  - **Explorative**: Testes de usabilidade exploratórios envolvem os usuários interagindo com os diferentes recursos da aplicação para entender melhor como eles funcionam.
  - **Comparativo**: Teste comparativo é quando você compara a experiência do usuário da sua aplicação com aplicações similares no mercado.
  - **Avaliação**: Testes de avaliação são onde você estuda o quão intuitivo é usar a aplicação.
  - **Validação**: Testes de validação são onde você identifica quaisquer problemas graves que impedirão o usuário de usar a aplicação de forma eficaz.
- **Ferramentas de Teste de Usabilidade**: Exemplos de ferramentas para teste de usabilidade incluem Loop11, Maze, Userbrain, UserTesting e UXTweak.

## Teste de Compatibilidade

- **Teste de Compatibilidade**: O objetivo do teste de compatibilidade é garantir que sua aplicação funcione em diferentes ambientes computacionais.
- **Diferentes Tipos de Testes de Compatibilidade**:
  - **Compatibilidade Retroativa**: Compatibilidade retroativa refere-se a quando o software é compatível com versões anteriores.
  - **Compatibilidade com versões futuras**: Compatibilidade com versões futuras refere-se a quando o software e os sistemas funcionarão com versões futuras.
  - **Compatibilidade de Hardware**: Compatibilidade de hardware é a capacidade do software de funcionar corretamente em diferentes configurações de hardware.
  - **Compatibilidade de Sistemas Operacionais**: A compatibilidade de sistemas operacionais é a capacidade do software de funcionar em diferentes sistemas operacionais, como macOS, Windows e distribuições Linux como Ubuntu e Fedora.
  - **Compatibilidade de Rede**: Compatibilidade de rede significa que o software pode funcionar em diferentes condições de rede, como diferentes velocidades de rede, protocolos, configurações de segurança, etc.
  - **Compatibilidade entre Navegadores**: Compatibilidade entre navegadores significa que a aplicação web pode funcionar de forma consistente em diferentes navegadores, como Google Chrome, Safari, Firefox etc.
  - **Compatibilidade Móvel**: É importante garantir que suas aplicações de software funcionem em uma variedade de dispositivos Android e iOS, incluindo telefones e tablets.

## Teste de Desempenho

- **Teste de Desempenho**: No teste de desempenho, você testa a velocidade, a capacidade de resposta, a escalabilidade e a estabilidade de uma aplicação sob diferentes cargas de trabalho. O objetivo é resolver qualquer tipo de gargalo de desempenho.
- **Diferentes Tipos de Testes de Desempenho**:
  - **Teste de Carga**: O teste de carga determina como um sistema se comporta durante períodos de carga normal e máxima.
  - **Teste de Estresse**: Teste de estresse é quando você testa sua aplicação em cargas extremas e verifica quão bem seu sistema responde à carga maior.
  - **Soak Testing (Endurance Testing)**: Soak testing ou endurance testing é um tipo de teste de carga onde você testa o sistema com uma carga maior por um período prolongado.
  - **Teste de Pico**: Teste de pico é quando você aumenta e diminui dramaticamente as cargas e analisa as reações do sistema às mudanças.
  - **Teste de Ponto de Interrupção (Teste de Capacidade)**: O teste de ponto de interrupção ou teste de capacidade é quando você aumenta lentamente a carga ao longo do tempo até o ponto em que o sistema começa a falhar ou degradar.

## Teste de Segurança

- **Testes de Segurança**: Testes de segurança ajudam a identificar vulnerabilidades e pontos fracos.
- **Princípios de Segurança**:
  - **Confidencialidade**: Isso protege contra o vazamento de informações sensíveis para outros destinatários que não sejam o destinatário pretendido.
  - **Integridade**: Isso envolve impedir que usuários mal-intencionados modifiquem informações do usuário.
  - **Autenticação**: Isso envolve verificar a identidade do usuário para garantir que ele tenha permissão para usar aquele sistema.
  - **Autorização**: Este é o processo de determinar quais ações os usuários autenticados têm permissão para executar ou quais partes do sistema eles podem acessar.
  - **Disponibilidade**: Isso garante que informações e serviços estejam disponíveis para usuários autorizados quando eles precisarem.
  - **Não Repúdio**: Isso garante que tanto o remetente quanto o destinatário tenham prova da entrega e verificação da identidade do remetente. Protege contra o remetente negar ter enviado a informação.
- **Ameaças Comuns à Segurança**:
  - **Cross-Site Scripting (XSS)**: Ataques de XSS acontecem quando um invasor injeta scripts maliciosos em uma página web e então os executa no contexto do navegador da vítima.
  - **SQL Injection**: SQL injection permite que usuários mal-intencionados injetem código malicioso em um banco de dados.
  - **Ataque de Negação de Serviço (DoS)**: Ataque DoS ocorre quando usuários maliciosos inundam um site com um alto número de requisições ou tráfego, fazendo com que o servidor fique lento e possivelmente trave, tornando o site indisponível para os usuários.
- **Categorias de Ferramentas de Teste de Segurança**:
  - **Teste Estático de Segurança de Aplicações**: Essas ferramentas avaliam o código-fonte de uma aplicação para identificar vulnerabilidades de segurança.
  - **Teste Dinâmico de Segurança de Aplicações**: Essas ferramentas interagem com o frontend da aplicação para descobrir possíveis vulnerabilidades de segurança. As ferramentas DAST não têm acesso ao código-fonte.
- **Penetration Testing (pentest)**: Penetration testing é um tipo de teste de segurança que envolve a criação de ataques cibernéticos simulados na aplicação para identificar quaisquer vulnerabilidades no sistema.

## Teste A/B

- **Teste A/B**: O teste A/B envolve comparar duas versões de uma página ou aplicação e estudar qual versão tem melhor desempenho. Também é conhecido como teste bucket ou split. O teste A/B permite que você tome decisões mais baseadas em dados e melhore continuamente a experiência do usuário.
- **Ferramentas para Testes A/B**: Exemplos de ferramentas para usar em testes A/B incluem GrowthBook e LaunchDarkly.

## Teste Alpha e Beta

Uma vez que o desenvolvimento inicial e os testes de software estejam completos, é importante que a aplicação seja testada por testadores e usuários reais. É aqui que entram os testes alpha e beta.

- **Teste Alfa**: O teste alfa é realizado por um grupo seleto de testadores que percorrem a aplicação para garantir que não haja bugs antes de ser lançada no mercado. O teste alfa faz parte do teste de aceitação e utiliza técnicas de teste de caixa branca e preta.
- **Teste Beta**: O teste beta é quando a aplicação é disponibilizada para usuários reais. Os usuários podem interagir com a aplicação e fornecer feedback. O teste beta também é uma forma de teste de aceitação do usuário.
- **Teste de Aceitação**: O teste de aceitação garante que a aplicação de software atenda aos requisitos de negócio e às necessidades dos usuários antes de seu lançamento.
- **Teste de Caixa Preta**: O teste de caixa preta foca apenas no comportamento esperado da aplicação.
- **Teste de Caixa Branca**: O teste de caixa branca envolve o testador conhecer os componentes internos e realizar testes neles.

## Teste de Regressão

- **Regressão**: Regressão refere-se a situações em que novas alterações quebram involuntariamente funcionalidades existentes.
- **Teste de Regressão**: O teste de regressão ajuda a identificar problemas de regressão. No teste de regressão, você executa novamente os testes funcionais em partes da sua aplicação para garantir que tudo ainda funcione conforme o esperado.
- **Ferramentas para Testes de Regressão**: Ferramentas que você pode usar para realizar testes de regressão incluem Puppeteer, Playwright, Selenium e Cypress.
- **Técnicas para Testes de Regressão**:
  - **Teste de Regressão Unitário**: É quando você tem uma lista de itens que precisam ser testados toda vez que mudanças ou correções importantes são implementadas no app.
  - **Teste de Regressão Parcial**: Isso envolve abordagens direcionadas para garantir que novas alterações não tenham quebrado aspectos específicos da aplicação.
  - **Teste de Regressão Completo**: Isso executa testes contra todas as funcionalidades na base de código. Esta é a opção mais demorada e detalhada.
- **Retesting**: Retesting é usado para verificar problemas conhecidos e garantir que eles foram resolvidos. Em contraste, regression testing busca por problemas desconhecidos que possam ter ocorrido por meio de mudanças recentes na codebase.

## O que é TypeScript

- **JavaScript**: JavaScript é uma linguagem de tipagem dinâmica. Isso significa que variáveis podem receber quaisquer valores em tempo de execução. O desafio de uma linguagem de tipagem dinâmica é que a falta de segurança de tipo pode introduzir erros.

Por exemplo, mesmo que sua função JavaScript espere um array, você ainda pode chamá-la com um número:

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

A saída do `console` para o exemplo acima será `undefined`.

- **TypeScript**: TypeScript estende a linguagem JavaScript para incluir tipagem estática, o que ajuda a detectar erros causados por incompatibilidades de tipo antes de você executar seu código.

Por exemplo, você pode definir um tipo para o parâmetro `array` da seguinte forma:

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Esta definição de tipo informa ao TypeScript que o parâmetro `array` deve ser um array de strings. Então, quando você chama `getRandomValue` e passa um número, você recebe um erro chamado erro de compilador.

- **Compilador**: Você primeiro precisa compilar o código TypeScript em JavaScript comum. Quando você executar o compilador, o TypeScript avaliará seu código e gerará um erro para quaisquer problemas onde os tipos não correspondem.

## Tipos de Dados em TypeScript

- **Tipos de Dados Primitivos em TypeScript**: Para os tipos de dados primitivos `string`, `null`, `undefined`, `number`, `boolean` e `bigint`, o TypeScript oferece palavras-chave de tipo correspondentes.

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **Array**: Você pode definir um array de tipo específico com duas sintaxes diferentes.

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **Objetos**: Você pode definir a estrutura exata de um objeto.

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

Se você quer um objeto com quaisquer chaves, mas onde todos os valores devem ser strings, existem duas maneiras de defini-lo:

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **Outros Tipos Úteis no TypeScript**:
  - **`any`**: `any` indica que um valor pode ter qualquer tipo. Isso informa ao compilador para parar de se preocupar com o tipo dessa variável.
  - **`unknown`**: `unknown` diz ao TypeScript que você *se importa* com o tipo do valor, mas na verdade não sabe qual é. `unknown` é geralmente preferido em vez de `any`.
  - **`void`**: Este é um tipo especial que você normalmente usará apenas ao definir funções. Funções que não têm um valor de retorno usam um tipo de retorno `void`.
  - **`never`**: Representa um tipo que nunca existirá.

- **Palavra-chave `type`**: Esta palavra-chave é como `const`, mas em vez de declarar uma variável, você pode declarar um tipo.

É útil para declarar tipos personalizados como tipos união ou tipos que incluem apenas valores específicos:

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interface`**: Interfaces são como classes para tipos. Elas podem implementar ou estender outras interfaces, são especificamente tipos de objeto e geralmente são preferidas a menos que você precise de um recurso específico oferecido por uma declaração `type`.

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **Definindo o Tipo de Retorno**: Você também pode definir o *return type* da função.

O exemplo abaixo define o valor de retorno como uma string. Se você tentar retornar qualquer outra coisa, o TypeScript gerará um erro de compilação.

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## Genéricos

- **Definindo Tipo Genérico**: Você pode definir um tipo genérico e referenciá-lo na sua função. Ele pode ser pensado como um parâmetro especial que você fornece para uma função para controlar o comportamento da definição de tipo da função.

Aqui está um exemplo de definição de um tipo genérico para uma função:

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

A sintaxe `<T>` informa ao TypeScript que você está definindo um tipo genérico `T` para a função. `T` é um nome comum para tipos genéricos mas você pode usar qualquer nome.

Então, você informa ao TypeScript que o parâmetro `array` é um array de valores que correspondem ao tipo genérico, e que o valor retornado é um único elemento desse mesmo tipo.

- **Especificando Argumento de Tipo na Chamada de Função**: Você pode passar um argumento de tipo para uma chamada de função usando colchetes angulares entre o nome da função e seus parâmetros.

Aqui está um exemplo de passagem de um argumento de tipo para uma chamada de função:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Isso informa ao TypeScript que o elemento que você espera encontrar será um elemento input.

## Refinamento de Tipo

- **Refinamento por Veracidade**: No exemplo abaixo, você recebe um erro do compilador ao tentar acessar a propriedade `value` de `email` porque `email` *pode* ser `null`.

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Você pode usar uma declaração condicional para confirmar que `email` é *truthy* antes de acessar a propriedade:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

Verificações de veracidade também podem funcionar na direção oposta:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

Lançar um erro termina a execução lógica deste código, o que significa que quando você chega à chamada `console.log()`, o TypeScript sabe que `email` *não pode* ser `null`.

- **Encadeamento Opcional**: O encadeamento opcional `?.` também é uma forma de restrição de tipo, sob a mesma premissa de que o acesso à propriedade não pode acontecer se o valor de `email` for `null`.

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **Operador `typeof`**: Você pode usar uma condicional para verificar o tipo da variável usando o operador `typeof`.

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **Palavra-chave `instanceof`**: Se o objeto vem de uma classe, você pode usar a palavra-chave `instanceof` para restringir o tipo.

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **Casting**: Quando o TypeScript não consegue determinar automaticamente o tipo de um valor, como o resultado do método `request.json()` no exemplo abaixo, você receberá um erro do compilador. Uma forma de resolver isso é fazendo o casting do tipo, mas isso enfraquece a capacidade do TypeScript de detectar erros potenciais.

```typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **Type Guard**: Em vez de fazer o cast do tipo, você pode escrever um type guard:

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

A sintaxe `user is User` indica que sua função retorna um valor booleano, que quando verdadeiro significa que o valor `user` satisfaz a interface `User`.

## Arquivo `tsconfig`

- **`tsconfig.json`**: As configurações do compilador do TypeScript ficam em um arquivo `tsconfig.json` no diretório raiz do seu projeto.

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

Aqui estão as descrições das opções do compilador usadas no exemplo acima:

- **`compilerOptions`**: A propriedade `compilerOptions` é onde você controla como o compilador TypeScript se comporta.
- **`rootDir` e `outDir`**: O `rootDir` e o `outDir` informam ao TypeScript qual diretório contém seus arquivos fonte e qual diretório deve conter o código JavaScript transpilado.
- **`lib`**: A propriedade `lib` determina quais definições de tipo o compilador usa e permite que você inclua suporte para versões específicas do ES, o DOM e mais.
- **`module` e `moduleResolution`**: O `module` e o `moduleResolution` trabalham em conjunto para gerenciar como seu pacote usa módulos - seja CommonJS ou ECMAScript.
- **`esModuleInterop`**: O `esModuleInterop` permite uma interoperabilidade mais suave entre CommonJS e módulos ES ao criar automaticamente objetos de namespace para importações.
- **`skipLibCheck`**: A opção `skipLibCheck` pula a validação dos arquivos `.d.ts` que não são referenciados por imports no seu código.
- **`strict`**: A flag `strict` habilita várias verificações, como garantir o tratamento adequado de tipos anuláveis e avisar quando o TypeScript recorre a `any`.
- **`exclude`**: A propriedade de nível superior `exclude` indica ao compilador para ignorar esses arquivos TypeScript durante a compilação.


# --assignment--

Revise os tópicos e conceitos de Frontend Libraries.
