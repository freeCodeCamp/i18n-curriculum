---
id: 67f413a2abe9894c52e15c6e
title: 动态编程测验
challengeType: 8
dashedName: quiz-dynamic-programming
---

# --description--

要通过测验，你必须正确回答以下 10 道题中的至少 9 题。

# --quizzes--

## --quiz--

### --question--

#### --text--

动态编程作为一种有效的方案方法，问题必须具备哪两个基本属性？

#### --distractors--

快速执行时间和最小内存使用量

---

递归能力和迭代的循环

---

循序的进程和并行计算

#### --answer--

重叠子问题和最优子结构

### --question--

#### --text--

动态编程中备忘录法和表格法的主要区别是什么？

#### --distractors--

记忆化使用哈希表，而填表法使用数组，使其更高效。

---

记忆化比表格法更快，但使用更多的内存和 CPU 周期。

---

记忆化只能解决比表格法更简单的问题。

#### --answer--

记忆化是使用递归的自顶向下方法，而制表法是使用迭代的自底向上方法。

### --question--

#### --text--

为什么天真的递归的动态规划问题方案通常具有指数时间复杂度？

#### --distractors--

因为它们使用指数级的内存来保存变量。

---

因为它们需要在指数时间内对数据进行排序。

---

因为他们必须查看输入的所有可能排列。

#### --answer--

因为每个递归的 `call` 会多次分支，导致相同的子问题被重复计算。

### --question--

#### --text--

在动态编程的上下文中，最优子结构是什么意思？

#### --distractors--

该 `algorithm` 必须使用最 `efficient` 的 `data structure` 。

---

该方案必须同时最小化时间和空间复杂度。

---

该问题必须有唯一的、单一的最优 `solution`。

#### --answer--

最优方案可以由其子问题的最优方案构造而成。

### --question--

#### --text--

当实现记忆化时，当一个函数使用已经计算过的参数被调用，会发生什么？

#### --distractors--

该函数重新计算结果以确保准确性。

---

该函数对旧结果和新结果取平均以获得更好的查准率。

---

因为不允许副本计算，故抛出误差。

#### --answer--

缓存的结果会立即返回，无需重新计算。

### --question--

#### --text--

使用标签（页）而不是记忆化的一个主要优势是什么？

#### --distractors--

标签（页）总是比记忆化使用更少的内存。

---

制表法可以解决更广泛的类问题。

---

制表总是更容易实现和理解。

#### --answer--

标签（页）避免了递归额外开销并提供了可预测的循序执行。

### --question--

#### --text--

在自底向上的动态规划方案中，为什么要先初始化基本情形？

#### --distractors--

为数据结构高效地分配内存。

---

为了防止算法中的无限循环。

---

为了提高算法的时间复杂度。

#### --answer--

提供所有更大子问题构建的基础值。

### --question--

#### --text--

动态编程如何改变表现出重叠子问题的问题的时间复杂度？

#### --distractors--

通过高效地划分问题，从多项式的转为对数的。

---

通过优化循环结构将二次复杂度降为线性复杂度。

---

通过使用哈希表将线性转换为常量。

#### --answer--

通过存储和重用子问题 `solution`，将指数级转为多项式的。

### --question--

#### --text--

动态规划通常通过什么权衡来实现更好的时间复杂度？

#### --distractors--

它牺牲了代码可读性以换取更快的执行速度。

---

它需要更复杂且更难维护的算法。

---

它限制了可解决问题的规模。

#### --answer--

它使用额外空间来保存中间结果。

### --question--

#### --text--

在哪种情况下动态编程不会是合适的算法方法？

#### --distractors--

当问题需要查找最优方案时。

---

当问题可以拆分成更小的子问题时。

---

当必须最小化空间复杂度时。

#### --answer--

当子问题相互独立且不重叠时。
