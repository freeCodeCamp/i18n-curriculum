---
id: 67fe859a00971c34a23abd43
title: '¿Cuáles son los tipos de datos comunes en Python y cómo obtienes el tipo de una variable?'
challengeType: 19
dashedName: what-are-common-data-types-in-python-and-how-do-you-get-the-type-of-a-variable
---

# --description--

Python es un lenguaje de tipado dinámico como JavaScript, lo que significa que no es necesario declarar explícitamente tipos para las variables. El lenguaje sabe qué tipo de dato es una variable basado en lo que le asignes.

Aquí hay algunos ejemplos:

```python
name = 'John Doe' # Python knows this is a string
age = 25 # Python knows this is an integer
```

Esto contrasta con algunos lenguajes de tipado estático como C#, Java y C++, donde tienes que declarar tipos con variables, como esto:

```csharp
string name = 'John Doe'
int age = 25
```

La naturaleza de tipado dinámico de Python hace que la codificación sea realmente rápida y más flexible, pero puede llevar a errores inesperados porque los errores de tipo solo se detectan cuando se ejecuta un programa, no cuando se compila.

Estos son los tipos de datos más comunes que usarás en Python:

- Entero: Un número entero sin decimales, por ejemplo, `10` o `-5`.

```python
my_integer_var = 10
print('Integer:', my_integer_var) # Integer: 10
```

- Flotante: Un número con un punto decimal, como `4.41` o `-0.4`.

```python
my_float_var = 4.50
print('Float:', my_float_var) # Float 4.50
```

- Complejo: Un número con parte real e imaginaria, como `6 + 7j`.

```python
my_complex_var = 3 + 4j
print('Complex:', my_complex_var) # Complex: (3+4j)
```

- Cadena: Una secuencia de caracteres encerrados en comillas simples o dobles como `'¡Hola mundo!'`.

```python
my_string_var = 'hello'
print('String:', my_string_var) # String: hello
```

- Booleano: Un tipo verdadero o falso, escrito como `True` o `False`.

```python
my_boolean_var = True
print('Boolean:', my_boolean_var) # Boolean: True
```

- Conjunto: Una colección no ordenada de elementos únicos, como `{4, 2, 0}`.

```python
my_set_var = {7, 5, 8}
print('Set:', my_set_var) # Set: {7, 5, 8}
```

- Diccionario: Una colección de pares clave-valor encerrados en llaves, como `{'nombre': 'John Doe', 'edad': 28}`.

```python
my_dictionary_var = {'name': 'Alice', 'age': 25}
print('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}
```

- Tupla: Una colección ordenada e inmutable, encerrada en paréntesis, como `(7, 8, 4)`.

```python
my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)
```

- Rango: Una secuencia de números, a menudo usada en bucles, por ejemplo, `range(5)`.

```python
my_range_var = range(5)
print(my_range_var) # range(0, 5)
```

- Lista: Una colección ordenada de elementos que admite diferentes tipos de datos.

```python
my_list = [22, 'Hello world', 3.14, True]
print(my_list) # [22, 'Hello world', 3.14, True]
```

- Ninguno: Un valor especial que representa la ausencia de un valor.

```python
my_none_var = None
print('None:', my_none_var) # None: None
```

Muchos otros lenguajes de programación agrupan los tipos de datos en tipos primitivos o de referencia. Los tipos primitivos son simples e inmutables, es decir, no se pueden cambiar una vez declarados. Los tipos de referencia pueden contener múltiples valores, y pueden ser mutables o inmutables. Pero Python no traza una línea dura entre esos dos grupos. En su lugar, todos los datos se tratan como objetos, y algunos objetos son inmutables mientras que otros son mutables.

Los tipos de datos inmutables no se pueden modificar o alterar una vez que se declaran. Puedes apuntar sus variables a algo nuevo, lo que se llama reasignación, pero no puedes cambiar el objeto original en sí mismo agregando, eliminando o reemplazando cualquiera de sus elementos. Ejemplos de tipos de datos inmutables en Python son cadena, entero, flotante, booleano, tupla y rango.

Aquí tienes un ejemplo que muestra que, aunque puedes reasignar una cadena diferente a una variable, la modificación directa de una cadena no está permitida porque las cadenas son inmutables:

```python
greeting = 'hi'
greeting = 'hello'
print(greeting) # hello

greeting[0] = 'H' # TypeError: 'str' object does not support item assignment
```

Por otro lado, puedes cambiar tipos mutables sin darles un nuevo nombre. Puedes agregar, eliminar o actualizar elementos donde están. Ejemplos son una lista y un diccionario.

Aquí tienes un ejemplo de actualización de un elemento en una lista:

```python
nums = [1, 2, 3]
nums[0] = 4

print(nums) # [4, 2, 3]
```

Para obtener el tipo de dato de una variable, puedes usar la función `type()`:

```python
my_var_1 = 'Hello world'
my_var_2 = 21

print(type(my_var_1)) # <class 'str'>
print(type (my_var_2)) # <class 'int'>
```

Y aquí están todos los tipos de datos cubiertos en esta conferencia, junto con sus tipos en el terminal:

```python
my_integer_var = 10
print('Integer:', my_integer_var, '| Type:', type(my_integer_var))  # Integer: 10 | Type: <class 'int'>

my_float_var = 4.50
print('Float:', my_float_var, '| Type:', type(my_float_var))  # Float: 4.50 | Type: <class 'float'>

my_complex_var = 3 + 4j
print('Complex:', my_complex_var, '| Type:', type(my_complex_var))  # Complex: (3+4j) | Type: <class 'complex'>

my_string_var = 'hello'
print('String:', my_string_var, '| Type:', type(my_string_var))  # String: hello | Type: <class 'str'>

my_boolean_var = True
print('Boolean:', my_boolean_var, '| Type:', type(my_boolean_var))  # Boolean: True | Type: <class 'bool'>

my_set_var = {7, 5, 8}
print('Set:', my_set_var, '| Type:', type(my_set_var))  # Set: {7, 5, 8} | Type: <class 'set'>

my_dictionary_var = {'name': 'Alice', 'age': 25}
print('Dictionary:', my_dictionary_var, '| Type:', type(my_dictionary_var))  # Dictionary: {'name': 'Alice', 'age': 25} | Type: <class 'dict'>

my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var, '| Type:', type(my_tuple_var))  # Tuple: (7, 5, 8) | Type: <class 'tuple'>

my_range_var = range(5)
print('Range:', list(my_range_var), '| Type:', type(my_range_var))  # Range: [0, 1, 2, 3, 4] | Type: <class 'range'>

my_list = [22, 'Hello world', 3.14, True]
print('List:', list(my_list), '| Type:', type(my_list)) # List: [22, 'Hello world', 3.14, True] | Type: <class 'list'>

my_none_var = None
print('None:', my_none_var, '| Type:', type(my_none_var))  # None: None | Type: <class 'NoneType'>
```

Otra forma de comprobar el tipo de una variable es usar la función incorporada `isinstance()`, que verifica si una variable coincide con un tipo de dato específico.

`isinstance()` toma un objeto y el tipo contra el que quieres verificarlo, luego devuelve un booleano. Aquí tienes algunos ejemplos:

```python
isinstance('Hello world', str) # True
isinstance(True, bool) # True
isinstance(42, int) # True
isinstance('John Doe', int) # False
```

Aunque Python es de tipado dinámico, aún puedes agregar sugerencias de tipo. Estas son señales opcionales que le dicen a otros desarrolladores de qué tipo de dato se espera que sea una variable o función. Aquí tienes un ejemplo rápido para los tipos de variables:

```python
user_name: str = 'John Doe'
user_age: int = 24
```

Aquí tienes otro ejemplo que muestra sugerencias para parámetros de función y un tipo de retorno:

```python
def greet(name: str, age: int) -> str:
    return f'Hello, {name}, age {age}.'
```

Y aquí tienes una combinación de los dos:

```python
def greet(name: str, age: int) -> str:
    return f'Hello, {name}, age {age}.'

user_name: str = 'John Doe'
user_age: int = 24

print(greet(user_name, user_age)) # Hello, John Doe, age 24.
```

Notar que, a diferencia de TypeScript que impone tipos en el tiempo de compilación, Python solo usa estas pistas para análisis estáticos, documentación y soporte al editor, **no** para imponer tipos durante la ejecución. Esto puede ayudar a los desarrolladores a detectar errores temprano y mejorar la legibilidad del código, especialmente en proyectos grandes.

# --questions--

## --text--

¿Qué significa que Python sea de tipado dinámico?

## --answers--

Debe especificar manualmente el tipo de dato de cada variable.

### --feedback--

Piensa en cómo Python determina el tipo de dato por ti.

---

Python no admite diferentes tipos de datos.

### --feedback--

Think about how Python figures out the data type for you.

---

Python determina automáticamente el tipo de dato según el valor asignado.

---

Las variables en Python no pueden cambiar su tipo de dato después de la asignación.

### --feedback--

Piensa en cómo Python determina el tipo de dato por ti.

## --video-solution--

3

## --text--

¿Cuál es la diferencia entre los tipos de datos enteros y flotantes?

## --answers--

Los enteros pueden almacenar números positivos y negativos, mientras que los flotantes solo pueden almacenar números positivos.

### --feedback--

Uno tiene decimales, el otro no los tiene.

---

Los enteros son números enteros sin decimales, mientras que los flotantes son números con puntos decimales.

---

Los flotantes ocupan menos memoria que los enteros en Python.

### --feedback--

Uno tiene decimales, el otro no los tiene.

---

Los enteros solo pueden almacenar números hasta 1000, mientras que los flotantes no tienen límite.


### --feedback--

One has decimals, the other doesn't.

## --video-solution--

2

## --text--

¿Cómo se puede comprobar el tipo de dato de una variable en Python?

## --answers--

Usando la función `type()`, como `type(my_var)`.

---

Comprobando manualmente el valor de la variable.

### --feedback--

Hay una función incorporada para esto.

---

Usando la función `typeof`, como `typeof(my_var)`.

---

Convirtiendo la variable a una cadena y analizando sus caracteres.

### --feedback--

Hay una función incorporada para esto.

## --video-solution--

1
