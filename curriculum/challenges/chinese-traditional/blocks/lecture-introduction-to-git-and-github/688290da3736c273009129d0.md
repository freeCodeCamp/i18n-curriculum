---
id: 688290da3736c273009129d0
title: 什麼是 Pull Request，如何創建一個？
challengeType: 19
dashedName: what-is-a-pull-request-and-how-do-you-create-one
---

# --description--

在上一課中，我們創建了一個功能分支，將一個新的檔案提交到該分支，並將它推送到我們的遠端儲存庫。但接下來我們該怎麼做？我們需要在 GitHub 上創建一個拉取請求。

拉取請求實際上是從你的分支拉取變更到標的分支的請求。當你想為開放原始碼專案貢獻程式碼變更時，拉取請求是你使用的流程。這種方式讓專案的維護者能夠審查你的變更。他們可以留下評論、提出問題、建議調整，並且（希望）批准你的變更並將其合併！

讓我們再次前往 GitHub 上的儲存庫。

現在，在你推送你的新分支之後，你應該會看到一個華麗的橫幅，顯示你已經推送到一個分支，還有一個按鈕你可以點擊來創建一個 pull request。這個按鈕會跳過幾個步驟並簡化處理程序，所以我們現在會忽略它。這樣你就能為橫幅未出現的情況做好準備。

點擊儲存庫頁面頂部的 pull requests 分頁，然後再次忽略橫幅並點擊「New Pull Request」。你將被帶到一個用於準備請求的使用者介面。

現在，我們需要在這裡說明一些術語。首先，我們有「base」和「compare」下拉選單。「base」是你合併的標的。由於我們想要合併到 `main`，所以可以保持不變。

「compare」是你想要合併的對象。我們想要合併我們的 `feature` 分支，所以我們應該將此更改為 `feature`。這也稱為 head 分支，是你會想要記住的術語。

一旦你這麼做，UI 就會重新整理。它現在應該會顯示在 `feature` 上但不在 `main` 上的提交，表明你正在請求合併的內容。你也會看到所謂的「diff」，這是你所做實際變更的視覺表現。

因為我們所做的只是添加一個檔案，所以差異相當乾淨。對於更複雜的變更，GitHub 會凸顯標示像是行修改、新增、刪除等內容。理解如何閱讀差異可能具有挑戰性，但經過一些練習你將會變得相當熟練。

現在，讓我們回到我們的 pull request。頂部有一個小的聯結，顯示「compare across forks」。如果我們是從 freeCodeCamp 倉庫的分支工作，這將讓我們能夠將 PR 的標的改為原始的 freeCodeCamp 倉庫，而不僅限於我們分支中的 `main` 分支。

由於我們不是在處理分支，因此可以忽略這點。然而，非常重要的是要了解，我們在這裡所做的主要是為了學習和探索。你不應該為某人的專案開啟只包含練習更動的 PR－這會為維護者製造額外的干擾。

現在，既然我們對變更感到滿意且一切都已組態完成，我們可以點擊「Create Pull Request」按鈕。這會帶我們到一個新的使用者介面。

在底部且視野外的是我們先前看到的相同提交列表和差異檢視。在建立你的 PR 前最後再確認一次絕對沒壞處，但就這次探索而言，你可以繼續前進。

你也會看到幾個新的輸入欄位。第一個輸入欄位是你 pull request 的標題。GitHub 會根據你正在合併的 commit 自動產生這個標題，如果 PR 中只有一個 commit，或者如果有多個 commit，則會根據分支名稱產生。

第二個輸入是用於你的描述。在大多數情況下，這不會是空的。相反，專案的維護者可以定義一個會預先填入的模板。如果他們提供了模板，你應該尊重他們的工作流程並完成該模板。

在這兩種情況下，你都會想閱讀該專案的貢獻文件，以確保你了解並遵循他們關於如何命名和填寫你的 PR 的指引。

由於你擁有此儲存庫，你會在右側看到可以設定審查者、被指定者、標籤、專案和里程碑。當你對他人的專案做出貢獻時，除了請求審查之外，你將無法編輯這些設定。但如果你想探索這些功能，現在因為這是你的儲存庫，你可以隨意設定它們。

當所有內容都填寫並組態完成後，點擊「Create pull request」。最後，你將看到實際結果！

當你對別人的專案提出 pull request 時，必須經過「程式碼審查」。這是一個讓維護者可以評估你的 pull request、要求修改、提出問題等等的處理程序。維護者核准後，就可以將它合併。

由於這是你自己的專案，你不需要等待審查。相反地，你可以在 Commits 標籤下雙重檢查提交歷史，在 Files changed 下檢查變更，如果你滿意就可以合併。

合併後，你會想將這些變更拉取到你的區域的儲存庫。

回到你的終端機，並確定你仍在該 repo 的資料夾中。然後使用 `git checkout main` 切換到 `main` 分支。

接著，使用 `git pull` 拉取最新的變更。

現在，如果你使用 `git log` 查看提交歷史，你會看到你的提交。但你也會看到一則 `Merge pull request #1` 訊息。那是什麼？

好吧，當你在 GitHub 上合併 pull request 時，有三種策略可以使用：

預設值是「Merge」，它會將所有來自 head 分支的提交帶入，然後創建另一個提交來處理程序並記錄合併。

另一個選項，可選方案是「Squash and Merge」，它會將來自 head 分支的所有提交壓縮成一個提交，然後將該新提交直接合併到 base 分支，而不會建立合併提交。

最後，有「Rebase and Merge」，它會將所有的提交取出，重設為「接在」基底分支的最新提交之後，然後將分支合併進來而不產生合併提交。Rebasing 是一個複雜的主題，你稍後會深入學習，所以今天如果你還不太理解也沒關係。

每個開源專案都會選擇最適合的合併策略。但因為這些行為上的差異，你應該永遠為你的貢獻創建一個新的分支來提交。切勿直接提交到預設的 `main` 分支，否則當你需要從原始碼庫拉取變更時，情況會變得混亂。

有了這些，你已成功創建並合併你的第一個 pull request！

# --questions--

## --text--

什麼是 GitHub 中的 pull request？

## --answers--

一種強制推送程式碼到 `main` 分支的方法。

### --feedback--

思考你要求專案維護者對你的程式碼變更做什麼。

---

從一個分支拉取變更到另一個分支的請求。

---

一種直接編輯主儲存庫中檔案的方法。

### --feedback--

思考你要求專案維護者對你的程式碼變更做什麼。

---

一個用於將儲存庫下載到你的區域的機器的工具。

### --feedback--

思考你要求專案維護者對你的程式碼變更做什麼。

## --video-solution--

2

## --text--

在拉取請求中，術語「base」和「compare」（或「head」）指的是什麼？

## --answers--

「Base」是原始碼分支；「compare」是標的分支。

### --feedback--

考慮哪個分支將接收變更以及哪個分支包含變更。

---

「Base」是標的分支；「compare」是原始碼分支。

---

「Base」是分支；「compare」是原始儲存庫。

### --feedback--

考慮哪個分支將接收變更以及哪個分支包含變更。

---

「Base」是原始的儲存庫；「compare」是分支。

### --feedback--

考慮哪個分支將接收變更以及哪個分支包含變更。

## --video-solution--

2

## --text--

以下哪一項不是在 GitHub 合併拉取請求時提到的合併策略？

## --answers--

合併

### --feedback--

課程提到在合併期間處理提交的三種具體策略。

---

壓縮並合併

### --feedback--

課程提到在合併期間處理提交的三種具體策略。

---

重新基底並合併

### --feedback--

課程提到在合併期間處理提交的三種具體策略。

---

分支與合併

## --video-solution--

4
