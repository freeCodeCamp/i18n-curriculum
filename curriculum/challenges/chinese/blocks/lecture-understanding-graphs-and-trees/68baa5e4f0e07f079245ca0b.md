---
id: 68baa5e4f0e07f079245ca0b
title: 优先级队列和堆如何工作？
challengeType: 19
dashedName: how-do-priority-queues-and-heaps-work
---

# --description--

**优先级队列** 是一种抽象的数据类型（ADT），其工作方式类似于队列或栈，但有一个关键区别。

正如你可能已经知道的，标准队列遵循 FIFO（先进先出）方法，其中第一个添加到队列的元素是第一个从队列中移除的元素。

栈遵循 LIFO（后进先出）方法，其中最后添加到栈的元素是第一个从栈中移除的元素。

队列和栈只考虑元素的插入顺序。

但是，优先级队列会考虑元素的“priority”。优先级用于确定下一个应该被移除的元素。

通常，优先级最高的元素会被首先移除，但某些实现也可能选择首先移除优先级最低的元素。这将取决于你的程序的需求。

优先级队列对于实际应用非常有帮助，例如查找两个位置之间的最短路径、在操作系统中调度任务、模拟交通、压缩数据和管理网络。

在实际中，优先级队列通常使用堆数据结构来实现。

**堆** 是一种具有非常特定属性的树数据结构，该属性称为 **堆属性**。该属性根据堆的类型确定每个节点与其子节点之间的关系。

堆有两种主要类型：

* 最大堆
    
* 最小堆
    

在**最大堆**中，每个节点的值大于或`equal`于其子节点的值。

在此示例中，你可以看到一个包含节点 8、7、5、2 和 1 的树结构。请注意，节点 7 大于节点 2 和节点 1，符合堆属性。其他所有节点也都满足此条件。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-1.png" alt="A max-heap tree structure showing nodes with values 8 at the root, 7 and 5 as children of 8, and 2 and 1 as children of 7, demonstrating that each parent node is greater than its children.">

相比之下，在**最小堆**中，每个节点的值小于或`equal`于其子节点的值。

在此示例中，我们有值为 4、7、9、12 和 15 的节点。例如，节点 7 小于节点 12 和节点 15，符合堆属性。所有其他节点也同样如此。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-2.png" alt="A min-heap tree structure showing nodes with values 4 at the root, 7 and 9 as children of 4, and 12 and 15 as children of 7, demonstrating that each parent node is less than its children.">

堆属性是关键，因为它确保最大（或最小）元素（取决于堆的类型）始终保持在顶部，这使得移除操作非常简单。

在实际中，堆通常被实现为数组，以高效访问父节点和子节点。

使用数组简化了访问这些值或“节点”的逻辑，因为在后台，如果堆维护了完全二叉树的结构，数组实现只需要基于它们的索引进行简单的数学运算，就能查找元素在内存中的位置。

Python 有一个 `heapq` 内置模块，你可以用它来操作一个最小堆的实现。

它通过直接操作 Python 列表来工作，遵循特定步骤，将元素视为堆来处理列表，保持堆属性。

要使用这个模块，你只需导入它：

```python
import heapq
```

然后，你需要定义一个空的列表。这将是堆的底层数据结构：

```python
my_heap = []
```

要为堆添加元素，你需要调用 `heappush()`，传入堆的名称和你想要添加的元素作为参数。这将自动将元素添加到列表中正确的位置，以保持堆的属性：

```python
heapq.heappush(my_heap, 9)
```

要获取优先级最低的元素（在此情况下为最小值），你需要调用 `heappop()`：

```python
heapq.heappop(my_heap)
```

`heappushpop()` 将两个操作合并为一次调用。

这比单独按序列调用它们更高效，尤其是在堆很大时，因为它只执行一次 `"heapify"` 操作来将列表重新排序为堆：

```python
heapq.heappushpop(my_heap, 15)
```

如果你已经有一个列表并且想将其转换为堆，你可以调用 `heapify()`，将堆作为参数传入：

```python
heapq.heapify(my_heap)
```

但目前，我们是按它们的值对元素进行排序，对吗？

如果我们想按它们的 `priority` 排序呢？

你可以通过存储具有此结构的元组来实现：`(priority, element)`。

由于元组是从左到右逐个元素进行比较，优先级将首先被比较，并且决策将基于它们做出。

请注意，在这种分支中，较低的值将表现出较高的优先级。这意味着优先级为 1 的元组的优先级**高于**优先级为 3 的元组：

```python
my_heap = []

heapq.heappush(my_heap, (3, "A"))
heapq.heappush(my_heap, (2, "B"))
heapq.heappush(my_heap, (1, "C"))
```

如果你需要以插入顺序移除具有相同优先级的元素，可以考虑将唯一计数器作为元组的第二个元素来打破平局，像这样 `(priority, counter, element)`。

现在让我们谈谈堆的效率。

插入和提取堆中最小值或最大值（取决于堆的类型）的平均和最坏分支时间复杂度是对数级的，`O(log n)`，因为所需的交换次数通常与堆的高度成正比，而堆的高度是 log(n)。

`"peek"` 操作的平均和最坏分支时间复杂度是常量时间，O(1)。`peek` 涉及获取最小值或最大值（取决于 `heap` 的类型），但不移除它。

`heapify` 操作，即从无序 `list` 构建 `heap`，在平均和最坏 `case` 下具有线性时间复杂度 O(n)。

同样，查找和删除任意 `Element` 的平均和最坏分支时间复杂度均为 O(n)，因为它们可能需要遍历整个堆。

它们需要多少空间？

堆的空间复杂度是线性的，O(n)，其中 `n` 是它包含的元素数量。它只需要保存元素和列表对象本身的一点额外开销。

优先级队列和堆在计算机科学中非常重要。它们让你能够快速查找并使用列表中最重要的元素。这种效率对于许多执行关键现实任务的计算机程序至关重要，例如查找地图上最快的路线。

# --questions--

## --text--

优先级队列与标准队列或栈的主要区别特征是什么？

## --answers--

它允许通过索引访问元素。

### --feedback--

考虑决定下一个被移除的元素的主要因素。

---

它总是按照插入的顺序处理元素。

### --feedback--

考虑决定下一个被移除的元素的主要因素。

---

它根据赋值的优先级检索元素。

---

它只保存相同数据类型的元素。

### --feedback--

考虑决定下一个被移除的元素的主要因素。

## --video-solution--

3

## --text--

以下哪项是优先级队列有用的常见现实应用？

## --answers--

在操作系统中调度一些更紧急的任务。

---

管理一个歌曲按固定顺序播放的播放列表。

### --feedback--

考虑某些项更重要且需要优先处理的场景。

---

存储一份杂货项的列表。

### --feedback--

考虑某些项更重要且需要优先处理的场景。

---

按字母顺序跟踪客户名称。

### --feedback--

考虑某些项更重要且需要优先处理的场景。

## --video-solution--

1

## --text--

尽管堆被概念化为树，但在实际中通常将堆实现为数组的主要原因是什么？

## --answers--

数组总是比任何其他数据结构更快。

### --feedback--

考虑如何将堆的树状结构高效映射到线性数据结构。

---

数组通过使用数学公式简化了访问父节点和子节点的逻辑。

---

数组允许对任何元素进行直接随机访问，这是核心堆操作。

### --feedback--

考虑如何将堆的树状结构高效映射到线性数据结构。

---

数组是唯一能够保证堆属性的数据结构。

### --feedback--

考虑如何将堆的树状结构高效映射到线性数据结构。

## --video-solution--

2
