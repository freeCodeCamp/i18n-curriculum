---
id: 688290da3736c273009129d0
title: O que é um Pull Request e como criar um?
challengeType: 19
dashedName: what-is-a-pull-request-and-how-do-you-create-one
---

# --description--

Na lição anterior, criamos uma branch de feature, fizemos commit de um novo arquivo nessa branch e o enviamos para o nosso repositório remoto. Mas quais são os próximos passos? Precisamos criar um pull request no GitHub.

Um pull request é, efetivamente, uma solicitação para puxar mudanças do seu branch para o branch de destino. Pull requests são o fluxo que você usa quando quer contribuir com alterações de código para um projeto open source. Essa abordagem permite que os mantenedores do projeto revisem suas mudanças. Eles podem deixar comentários, fazer perguntas, sugerir ajustes e (esperançosamente) aprovar suas mudanças e mesclá-las!

Vamos para o nosso repositório no GitHub novamente.

Agora, depois que você enviou sua nova branch, você deve ver um banner elegante que diz que você enviou para uma branch e um botão que você pode clicar para criar um pull request. Esse botão pula algumas etapas e simplifica o processo, então vamos ignorá-lo por enquanto. Assim você estará preparado para os casos em que o banner não aparecer.

Clique na aba de pull requests no topo da página do repositório, depois ignore o banner novamente e clique em "New Pull Request". Você será levado para uma interface para preparar sua solicitação.

Agora, há alguns termos que precisamos revisar aqui. Primeiro, temos os menus suspensos "base" e "compare". A "base" é seu alvo para a mesclagem. Como queremos mesclar em `main`, podemos deixar isso como está.

O "compare" é o que você quer mesclar. Queremos mesclar nossa branch `feature`, então devemos mudar isso para `feature`. Isso também é conhecido como a head branch, que é um termo que você vai querer lembrar.

Depois que você fizer isso, a UI será atualizada. Agora ela deve mostrar os commits em `feature` que não estão em `main`, indicando o que você está solicitando para mesclar. Você também verá o que é chamado de "diff", que é uma representação visual das mudanças reais que você fez.

Como tudo o que fizemos foi adicionar um arquivo, o diff está bem limpo. Para mudanças mais complexas, o GitHub destacará coisas como modificações de linha, adições, exclusões e mais. Entender como ler um diff pode ser desafiador, mas com um pouco de prática você se tornará bastante proficiente nisso.

Por enquanto, vamos voltar ao nosso pull request. Há um pequeno link no topo que diz "compare across forks". Se estivéssemos trabalhando a partir do nosso fork do repositório freeCodeCamp, isso nos daria a capacidade de mudar nosso PR para direcionar ao repositório original freeCodeCamp, em vez de apenas o branch `main` dentro do nosso fork.

Como não estamos trabalhando com um fork, podemos ignorar isso. No entanto, é muito importante entender que o que estamos fazendo aqui é principalmente para aprendizado e exploração. Você não deve abrir um PR para o projeto de alguém que contenha apenas mudanças de prática - isso cria ruído extra para os mantenedores.

Agora, como estamos satisfeitos com nossas alterações e tudo está configurado, podemos clicar no botão "Create Pull Request". Isso nos leva a uma nova interface.

Na parte inferior e fora de vista estão a mesma lista de commits e a visualização de diff que vimos anteriormente. Nunca é demais conferir uma última vez antes de criar seu PR, mas para esta exploração você está pronto para seguir em frente.

Você também verá alguns novos inputs. O primeiro input é o título do seu pull request. O GitHub irá gerar isso automaticamente com base no commit que você está mesclando, se houver apenas um no PR, ou no nome da branch, se você tiver múltiplos commits.

A segunda entrada é para sua descrição. Na maioria dos casos, isso não estará vazio. Em vez disso, os mantenedores de um projeto podem definir um template que é pré-preenchido. Se eles fornecerem um, você deve respeitar o fluxo de trabalho deles e completar o template.

Em ambos os casos, você vai querer ler a documentação de contribuição do projeto para garantir que você entenda e siga as diretrizes deles sobre como titular e preencher seu `PR`.

Como você é o proprietário deste repositório, verá à direita que pode definir reviewers, assignees, labels, projects e milestones. Você não poderá editar esses itens, exceto para solicitar uma revisão, quando contribuir para o projeto de outra pessoa. Mas se quiser explorar esses recursos, pode configurá-los como desejar agora, já que este é o seu repositório.

Depois que tudo estiver preenchido e configurado, clique em "Create pull request". Finalmente, você verá o resultado real!

Quando você faz um pull request para o projeto de outra pessoa, ele precisa passar por uma "code review". Este é um processo onde os mantenedores podem avaliar seu pull request, solicitar alterações, fazer perguntas e assim por diante. Uma vez que os mantenedores o tenham aprovado, eles podem fazer o merge.

Como este é seu próprio projeto, você não precisa esperar por uma revisão. Em vez disso, você pode verificar novamente o histórico de commits na aba Commits, as alterações na aba Files changed e, se estiver satisfeito, pode fazer o merge.

Depois que for mesclado, você vai querer puxar essas alterações para o seu repositório local.

Volte para o seu terminal e certifique-se de que você ainda está na pasta do repositório. Então, mude para a branch `main` com `git checkout main`.

Em seguida, faça o download das últimas alterações com `git pull`.

Agora, se você olhar o histórico de commits com `git log`, verá seu commit. Mas também verá uma mensagem `Merge pull request #1`. O que é isso?

Bem, quando você faz merge de um pull request no GitHub existem três estratégias que você pode usar:

O padrão é "Merge", que traz todos os commits do branch head, depois cria outro commit para processar e registrar o merge.

Outra opção é "Squash and Merge", que pega TODOS os commits do branch head, os junta em um único commit e mescla esse novo commit diretamente no branch base sem criar um commit de merge.

Finalmente, há o "Rebase and Merge", que pega todos os commits, os reseta para "virem depois" do commit mais recente na branch base, e então faz o merge do head sem um commit de merge. Rebase é um tópico complicado que você aprenderá em profundidade mais adiante, então tudo bem se você não entender completamente hoje.

Cada projeto open source escolherá a estratégia de merge que funcionar melhor. Mas por causa dessas diferenças de comportamento, você deve SEMPRE criar uma nova branch para commitar suas contribuições. Nunca commite diretamente na branch padrão `main`, ou as coisas ficarão confusas quando você precisar trazer as mudanças do repositório original.

Com tudo isso, você criou e mesclou com sucesso seu primeiro pull request!

# --questions--

## --text--

O que é um pull request no GitHub?

## --answers--

Uma forma de forçar o push do código para a branch `main`.

### --feedback--

Pense no que você está pedindo para os mantenedores do projeto fazerem com suas alterações de código.

---

Uma solicitação para puxar mudanças de uma branch para outra branch.

---

Uma forma de editar arquivos diretamente no repositório principal.

### --feedback--

Pense no que você está pedindo para os mantenedores do projeto fazerem com suas alterações de código.

---

Uma ferramenta para baixar repositórios para sua máquina local.

### --feedback--

Pense no que você está pedindo para os mantenedores do projeto fazerem com suas alterações de código.

## --video-solution--

2

## --text--

Em um pull request, a que se referem os termos "base" e "compare" (ou "head")?

## --answers--

"Base" é o branch de origem; "compare" é o branch de destino.

### --feedback--

Considere qual branch receberá as alterações e qual branch contém as alterações.

---

"Base" é a branch de destino; "compare" é a branch de origem.

---

"Base" é o fork; "compare" é o repositório original.

### --feedback--

Considere qual branch receberá as alterações e qual branch contém as alterações.

---

"Base" é o repositório original; "compare" é o fork.

### --feedback--

Considere qual branch receberá as alterações e qual branch contém as alterações.

## --video-solution--

2

## --text--

Qual das seguintes opções NÃO é uma estratégia de merge mencionada ao fazer merge de um pull request no GitHub?

## --answers--

Mesclar

### --feedback--

A lição mencionou três estratégias específicas para lidar com commits durante um merge.

---

Squash e Merge

### --feedback--

A lição mencionou três estratégias específicas para lidar com commits durante um merge.

---

Rebase e Merge

### --feedback--

A lição mencionou três estratégias específicas para lidar com commits durante um merge.

---

Fork e Merge

## --video-solution--

4
