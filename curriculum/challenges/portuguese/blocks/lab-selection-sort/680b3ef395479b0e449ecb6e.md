---
id: 680b3ef395479b0e449ecb6e
title: Implementar o Algoritmo de Ordenação por Seleção
challengeType: 27
dashedName: implement-selection-sort-algorithm
---

# --description--

Selection sort é outro algoritmo de ordenação popular ensinado na maioria dos cursos de ciência da computação.

Este algoritmo funciona encontrando repetidamente o menor elemento da porção não ordenada da lista e trocando-o com o primeiro elemento não ordenado. Ele começa selecionando o valor mínimo em toda a lista e trocando-o com o primeiro elemento. Então ele se move para a segunda posição, encontra o menor valor nos elementos restantes não ordenados e o troca com o segundo elemento. Este processo continua, avançando pela lista um elemento de cada vez, até que toda a lista esteja ordenada.

A ordenação por seleção resulta em uma complexidade de tempo quadrática nos cenários de melhor, médio e pior caso. A complexidade de espaço será constante `O(1)` porque a ordenação é feita in loco e uma quantidade constante de memória está sendo usada independentemente do tamanho da lista.

**Objetivo:** Cumprir as user stories abaixo e fazer todos os testes passarem para completar o laboratório.

**Histórias de Usuário:**

1. Você deve definir uma função chamada `selection_sort`.
1. Sua função `selection_sort` deve ter um parâmetro que representa a lista de itens.
1. Sua função `selection_sort` deve receber uma lista e ordenar os itens no local do menor para o maior.
1. Sua função `selection_sort` deve modificar a lista de entrada in-place e retorná-la assim que estiver ordenada.
1. Sua função `selection_sort` deve seguir o algoritmo de ordenação por seleção, trocando o menor elemento da parte não ordenada da lista com o primeiro elemento não ordenado.
1. Sua função `selection_sort` não deve usar nem o método embutido `sort()` nem a função `sorted()`.

# --hints--

Você deve ter uma função chamada `selection_sort`.

```js
({test: () => {
    runPython(`
assert _Node(_code).has_function('selection_sort')
    `)
}})
```

Sua função `selection_sort` deve ter um parâmetro.

```js
(
    {test: () => {
        runPython(`
            import inspect
            sig = inspect.signature(selection_sort)
            assert len(sig.parameters) == 1
        `)
    }}
)
```

Você não deve importar nenhum módulo ou usar métodos de ordenação embutidos no seu código.

```js
(
    {
        test: () => runPython(`
            assert len(_Node(_code).find_imports()) == 0
            assert not _Node(_code).block_has_call("sort")
            assert not _Node(_code).block_has_call("sorted")
        `)
    }
)
```

Seu `selection_sort` deve retornar a mesma lista que a lista de entrada.

```js
(
    {
        test: () => runPython(`
            input_list = [32, 0, 88, 1, 203]
            assert selection_sort(input_list) is input_list
        `)
    }
)
```

Seu `selection_sort` deve modificar a lista de entrada in-place. Você não deve usar nenhum método que adicione ou remova itens da lista.

```js
(
    {
        test: () => runPython(`
            from collections import UserList

            class CustomList(UserList):
                def __init__(self, *args, **kwargs):
                    self._record = []
                    super().__init__(*args, **kwargs)

                def __setitem__(self, key, value):
                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')
                    super().__setitem__(key, value)

                def append(self, *args, **kwargs):
                    self._record.append(f'Appending to list: {args}, {kwargs}')
                    super().append(*args, **kwargs)

                def insert(self, *args, **kwargs):
                    self._record.append(f'Inserting to list: {args}, {kwargs}')
                    super().insert(*args, **kwargs)

                def pop(self, *args, **kwargs):
                    self._record.append(f'Popping from list: {args}, {kwargs}')
                    super().pop(*args, **kwargs)

                def remove(self, *args, **kwargs):
                    self._record.append(f'Removing from list: {args}, {kwargs}')
                    super().remove(*args, **kwargs)


            list_to_sort = CustomList([32, 0, 88, 1, 203])

            selection_sort(list_to_sort)
            assert all(
                'Setting item' in record
                for record in list_to_sort._record
            )
        `)
    }
)
```

Seu `selection_sort` deve seguir o algoritmo de ordenação por seleção, trocando o valor mínimo na parte não ordenada da lista com o primeiro elemento não ordenado.

```js
(
    {
        test: () => runPython(`
            from collections import UserList

            class CustomList(UserList):
                def __init__(self, *args, **kwargs):
                    self._record = []
                    super().__init__(*args, **kwargs)

                def __setitem__(self, key, value):
                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')
                    super().__setitem__(key, value)


            list_to_sort = CustomList([33, 1, 89, 2, 67, 245])

            swap_pairs = [
                ((0, 1, 33), (1, 33, 1)),
                ((1, 2, 33), (3, 33, 2)),
                ((2, 33, 89), (3, 89, 33)),
                ((3, 67, 89), (4, 89, 67)),
            ]

            selection_sort(list_to_sort)
            record = list_to_sort._record

            actual_pairs = [
                (record[offset * 2], record[offset * 2 + 1])
                for offset, _ in enumerate(record[::2])
            ]
            assert len(swap_pairs) == len(actual_pairs)

            for expected_pair, actual_pair in zip(swap_pairs, actual_pairs):
                assert (
                    set(f'Setting item {key} to {value}. Previous value: {old}' for key, value, old in expected_pair)
                    == set(actual_pair)
                )
        `)
    }
)
```

`selection_sort([33, 1, 89, 2, 67, 245])` deve retornar `[1, 2, 33, 67, 89, 245]`.

```js
(
    {
        test: () => runPython(`
            assert selection_sort([33, 1, 89, 2, 67, 245]) == [1, 2, 33, 67, 89, 245]
            
        `)
    }
)
```

`selection_sort([5, 16, 99, 12, 567, 23, 15, 72, 3])` deve retornar `[3, 5, 12, 15, 16, 23, 72, 99, 567]`.

```js
(
    {
        test: () => runPython(`
            assert selection_sort([5, 16, 99, 12, 567, 23, 15, 72, 3]) == [3, 5, 12, 15, 16, 23, 72, 99, 567]
            
        `)
    }
)
```

`selection_sort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92])` deve retornar `[1, 1, 2, 2, 4, 8, 32, 43, 43, 55, 63, 92, 123, 123, 234, 345, 5643]`.

```js
(
    {
        test: () => runPython(`
            assert selection_sort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]) == [1, 1, 2, 2, 4, 8, 32, 43, 43, 55, 63, 92, 123, 123, 234, 345, 5643]
            
        `)
    }
)
```

Sua função `selection_sort` deve ordenar corretamente qualquer lista de números.

```js
(
    {
        test: () => runPython(`
            assert selection_sort([42, 17, 93, 8, 61, 29]) == [8, 17, 29, 42, 61, 93]
            assert selection_sort([11, 4, 78, 23, 55, 198, 65, 90, 2]) == [2, 4, 11, 23, 55, 65, 78, 90, 198]
            assert selection_sort([9, 27, 3, 7, 101, 66, 34, 52, 87, 42, 12, 29]) == [3, 7, 9, 12, 27, 29, 34, 42, 52, 66, 87, 101]
            assert selection_sort([5, 14, 33, 77, 2, 18, 92, 1, 100, 45, 73, 64, 28, 56]) == [1, 2, 5, 14, 18, 28, 33, 45, 56, 64, 73, 77, 92, 100]
            
        `)
    }
)     
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def selection_sort(nums):
    for i, _ in enumerate(nums):
        min_index = i

        for j in range(i + 1, len(nums)):
            if nums[j] < nums[min_index]:
                min_index = j

        if min_index != i:
            nums[i], nums[min_index] = nums[min_index], nums[i]

    return nums

```
