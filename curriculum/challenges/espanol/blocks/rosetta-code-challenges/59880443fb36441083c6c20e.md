---
id: 59880443fb36441083c6c20e
title: Método de Euler
challengeType: 1
forumTopicId: 302258
dashedName: euler-method
---

# --description--

El método de Euler aproxima numéricamente soluciones de ecuaciones diferenciales ordinarias (ODEs) de primer orden con un valor inicial dado. Es un método explícito para resolver problemas de valor inicial (IVPs), como se describe en <a href="https://www.freecodecamp.org/news/eulers-method-explained-with-examples/" title="Euler's Method Explained with Examples" target="_blank" rel="noopener noreferrer nofollow">este artículo</a>.

La EDO debe proporcionarse en la siguiente forma:

<ul style='list-style: none;'>
  <li><big>$\frac{dy(t)}{dt} = f(t,y(t))$</big></li>
</ul>

con un valor inicial

<ul style='list-style: none;'>
  <li><big>$y(t_0) = y_0$</big></li>
</ul>

Para obtener una solución numérica, reemplazamos la derivada en el LHS con una aproximación de diferencia finita:

<ul style='list-style: none;'>
  <li><big>$\frac{dy(t)}{dt}  \approx \frac{y(t+h)-y(t)}{h}$</big></li>
</ul>

luego resuelve para $y(t+h)$:

<ul style='list-style: none;'>
  <li><big>$y(t+h) \approx y(t) + h \, \frac{dy(t)}{dt}$</big></li>
</ul>

que es lo mismo que

<ul style='list-style: none;'>
  <li><big>$y(t+h) \approx y(t) + h \, f(t,y(t))$</big></li>
</ul>

La regla de la solución iterativa es entonces:

<ul style='list-style: none;'>
  <li><big>$y_{n+1} = y_n + h \, f(t_n, y_n)$</big></li>
</ul>

donde $h$ es el tamaño del paso, el parámetro más relevante para la precisión de la solución. Un tamaño de paso más pequeño aumenta la precisión pero también el costo computacional, por lo que siempre debe ser seleccionado manualmente según el problema en cuestión.

**Ejemplo: Ley de Enfriamiento de Newton**

La ley de enfriamiento de Newton describe cómo un objeto con temperatura inicial $T(t_0) = T_0$ se enfría en un ambiente con temperatura $T_R$:

<ul style='list-style: none;'>
  <li><big>$\frac{dT(t)}{dt} = -k \, \Delta T$</big></li>
</ul>

o

<ul style='list-style: none;'>
  <li><big>$\frac{dT(t)}{dt} = -k \, (T(t) - T_R)$</big></li>
</ul>

Dice que la tasa de enfriamiento $\frac{dT(t)}{dt}$ del objeto es proporcional a la diferencia de temperatura actual $\Delta T = (T(t) - T_R)$ con el entorno.

La solución analítica, que compararemos con la aproximación numérica, es

<ul style='list-style: none;'>
  <li><big>$T(t) = T_R + (T_0 - T_R) \; e^{-k t}$</big></li>
</ul>

# --instructions--

Implementa una rutina del método de Euler y luego úsala para resolver el ejemplo dado de la ley de enfriamiento de Newton para tres diferentes tamaños de paso de:

<ul>
  <li><code>2 s</code></li>
  <li><code>5 s</code> and</li>
  <li><code>10 s</code></li>
</ul>

y compara con la solución analítica.

**Valores iniciales:**

<ul>
  <li>initial temperature <big>$T_0$</big> shall be <code>100 °C</code></li>
  <li>room temperature <big>$T_R$</big> shall be <code>20 °C</code></li>
  <li>cooling constant <big>$k$</big> shall be <code>0.07</code></li>
  <li>time interval to calculate shall be from <code>0 s</code> to <code>100 s</code></li>
</ul>  

El primer parámetro de la función es el tiempo inicial, el segundo parámetro es la temperatura inicial, el tercer parámetro es el tiempo transcurrido y el cuarto parámetro es el tamaño del paso.

# --hints--

`eulersMethod` debe ser una función.

```js
assert(typeof eulersMethod === 'function');
```

`eulersMethod(0, 100, 100, 2)` debería devolver un número.

```js
assert(typeof eulersMethod(0, 100, 100, 2) === 'number');
```

`eulersMethod(0, 100, 100, 2)` debería devolver 20.0424631833732.

```js
assert.equal(eulersMethod(0, 100, 100, 2), 20.0424631833732);
```

`eulersMethod(0, 100, 100, 5)` debería devolver 20.01449963666907.

```js
assert.equal(eulersMethod(0, 100, 100, 5), 20.01449963666907);
```

`eulersMethod(0, 100, 100, 10)` debería devolver 20.000472392.

```js
assert.equal(eulersMethod(0, 100, 100, 10), 20.000472392);
```

# --seed--

## --seed-contents--

```js
function eulersMethod(x1, y1, x2, h) {

}
```

# --solutions--

```js
function eulersMethod(x1, y1, x2, h) {
  let x = x1;
  let y = y1;

  while ((x < x2 && x1 < x2) || (x > x2 && x1 > x2)) {
    y += h * (-0.07 * (y - 20));
    x += h;
  }

  return y;
}
```
