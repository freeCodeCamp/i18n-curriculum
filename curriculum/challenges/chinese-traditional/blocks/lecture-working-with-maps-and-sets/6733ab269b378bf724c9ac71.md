---
id: 6733ab269b378bf724c9ac71
title: JavaScript 中的集合是什麼，以及它與 WeakSets 有何不同？
challengeType: 19
dashedName: what-are-sets-in-javascript-and-how-does-it-differ-from-weaksets
---

# --description--

在 JavaScript 中，`Set` 是一個用於管理資料群集的內建物件。它讓你儲存任何型別的唯一值，無論是原始值還是物件引用。`Set` 確保其中的每個值只出現一次，使其在從陣列中消除重複項目或處理不同值的群集時非常有用。

至於 `WeakSet`，它是一種具有較少特性的特殊 `Set` 型別，允許你儲存弱參考的物件引用和符號。與 `Set` 不同，`WeakSet` 不支援像數字或字串這類的原始值。

與一般的 `Set` 不同，`WeakSet` 只儲存物件，且對這些物件的引用是「弱引用」，這表示如果沒有其他引用指向這些物件，`WeakSet` 不會阻止它們被垃圾回收。簡單來說，如果物件在你的程式碼中沒有被其他地方使用，它會自動被移除以釋放記憶體。

要創建 `Set`，你使用 `Set` 建構式並將它指定給一個變數：

```js
const myFirstSet = new Set();
```

你也可以用值來初始化 `Set`：

```js
const treeSet = new Set(['Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit']);
```

如果你將 `Set` 記錄到主控台，輸出結果如下：

```js
/*
Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
  [[Entries]]
  0: "Baobab"
    value: "Baobab"
  1: "Jackalberry"
    value: "Jackalberry"
  2: "Mopane Tree"
    value: "Mopane Tree"
  3: "Breadfruit"
    value: "Breadfruit"
  size: 4
  [[Prototype]]: Set
*/
```

如果你沒有用值初始化 `Set`，你可以使用 `add()` 方法將一個項目添加到 `Set`：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
```

結果和結果在主控台中的外觀保持不變。

別忘了重複的項目會在 `Set` 中被忽略：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
treeSet.add('Baobab'); //duplicate item will be ignored

console.log(treeSet);
// Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
```

你可以用來操作 `Set` 的其他方法有：

- `delete()`  
- `clear()`
- `has()`
- `entries()`
- `forEach()`
- `keys()`
- `values()`

讓我們逐一看看這些方法如何運作。`delete()` 從 `Set` 中移除指定的項目、條款：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet); // Set(3) {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`has()` 檢查指定的值是否存在於 `Set` 中：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.has('Breadfruit')); // false
```

`entries()` 傳回一個 `Set` 迭代器，該迭代器包含以 `[value, value]` 格式表示的值陣列：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.entries());
// SetIterator {'Baobab' => 'Baobab', 'Jackalberry' => 'Jackalberry', 'Mopane Tree' => 'Mopane Tree'}
```

`keys()` 和 `values()` 顯示 `Set` 中的值。`keys()` 只是 `values()` 方法的別名：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log('Keys: ', treeSet.keys());
console.log('Values: ', treeSet.values());
// Keys: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
// Values: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`forEach()` 讓你迭代 `Set`：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.forEach((tree) => console.log(tree));
/*
Baobab
Jackalberry
Mopane Tree
*/
```

`clear()` 會移除陣列中的所有條款：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.clear();

console.log(treeSet); // Set(0) {size: 0}
```

同時值得一提的是，有一個 `size` 屬性會傳回 `Set` 中的項目數量：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.size); // 3
```

就像 `Set` 一樣，也有一個 `WeakSet` 建構式，你可以用來創建 `WeakSet`：

```javascript
const treeWeakSet = new WeakSet();
```

`WeakSet` 也有 `add()`、`delete()` 和 `has()` 方法：

```javascript
const treeWeakSet = new WeakSet();

treeWeakSet.add({ name: 'Baobab' });
treeWeakSet.add({ name: 'Jackalberry' });
treeWeakSet.add({ name: 'Mopane Tree' });
treeWeakSet.add({ name: 'Breadfruit' });

treeWeakSet.delete('Jackalberry');
console.log(treeWeakSet.has('Jackalberry')); // false

console.log(treeWeakSet);
```

在輸出中，`WeakSet` 的內容看起來像這樣：

```javascript
/*
WeakSet {{…}, {…}, {…}, {…}}
  [[Entries]]
    No properties
  [[Prototype]]: WeakSet
    .
    .
    .
*/
```

內容看起來是空的，因為 WeakSets 不可迭代且不會直接暴露其內容。

別忘了只有具有明確鍵和值的符號和物件才被支援。添加原始類型，例如數字或字串，將導致錯誤：

```js
treeWeakSet.add('Alan Smith');

console.log(treeWeakSet); // Invalid value used in weak set
//    at WeakSet.add (<anonymous>)
```

`Set` 和 `WeakSet` 之間的主要差異在於 `Set` 可以儲存任何值，而 `WeakSet` 只能儲存物件。

以下是 `Set` 和 `WeakSet` 之間的一些其他明顯差異：

| Feature | Set | WeakSet |
| --- | --- | --- |
| Type of Values Stored | Stores any data type | Stores only objects |
| Referencing | Strong referencing | Weak referencing |
| Iteration | Supports iteration with `forEach` and loops | Does not support iteration |
| Methods and Properties | `add()`, `delete()`, `has()`, `keys()`, `values()`, `size`, and more | `add()`, `delete()`, and `has()` only |
| Use case | General-purpose collection of unique values and removing duplicates from arrays | Efficient memory tracking of object references |

你可以看到這兩種集合能儲存的值的型別差異、它們對於遍歷已儲存物件的支援，以及它們的理想使用情境。請花點時間閱讀此表格的內容。

# --questions--

## --text--

`Set` 和 `WeakSet` 在它們所支援的資料方面有何不同？

## --answers--

`Set` 允許弱持有物件引用，而 `WeakSet` 支援物件和原始值。

### --feedback--

請記住，`Set` 可以容納各種資料型別。

---

`Set` 可以儲存任何型別，包括原始值，而 `WeakSet` 僅允許弱取用的物件引用。

---

`Set` 的特性比 `WeakSet` 少。

### --feedback--

請記住，`Set` 可以容納各種資料型別。

---

`Set` 專門用於物件，而 `WeakSet` 用於數字。

### --feedback--

請記住，`Set` 可以容納各種資料型別。

## --video-solution--

2

## --text--

你如何在 JavaScript 中創建 `Set` 或 `WeakSet`？

## --answers--

透過不帶 `new` 關鍵字呼叫 `Set()` 或 `WeakSet()`

### --feedback--

思考需要包含哪些關鍵字才能創建 `Set` 或 `WeakSet`。

---

透過使用物件字面值 `{}`

### --feedback--

思考需要包含哪些關鍵字才能創建 `Set` 或 `WeakSet`。

---

透過使用陣列字面值 `[]`

### --feedback--

思考需要包含哪些關鍵字才能創建 `Set` 或 `WeakSet`。

---

透過使用 `new` 關鍵字搭配 `Set` 或 `WeakSet` 建構式

## --video-solution--

4

## --text--

哪些方法同時適用於 JavaScript 中的 `Set` 和 `WeakSet`？

## --answers--

`keys()`、`values()` 和 `size()`

### --feedback--

回顧課程結尾處討論過的內容。 

---

`add()`、`delete()` 和 `has()`

---

`clear()`、`entries()` 和 `forEach()`

### --feedback--

回顧課程結尾處討論過的內容。 

---

`set()`、`get()` 和 `remove()`

### --feedback--

回顧課程結尾處討論過的內容。 

## --video-solution--

2
