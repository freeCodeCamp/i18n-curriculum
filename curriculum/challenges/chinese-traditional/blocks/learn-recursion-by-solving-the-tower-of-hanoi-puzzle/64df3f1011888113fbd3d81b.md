---
id: 64df3f1011888113fbd3d81b
title: 步驟 44
challengeType: 20
dashedName: step-44
---

# --description--

要用遞迴解決這個謎題，首先要將原始問題拆解成較小的子問題。

最終的設定是將 `n` 個碟以遞減順序堆疊到第三根桿子上，可以透過移動來達成：

- 將 `n - 1` 個碟從原始碼移到輔助桿。
- 將原始碼中最大的硬碟複製到標的。
- 然後將 `n - 1` 個碟從輔助桿移到標的。

所以，`move` 函式（程式）應該做的第一件事是以 `n - 1` 作為第一個引數呼叫自己。但如果你嘗試在未定義基底情況下這麼做，你將會得到 `RecursionError`。這是因為函式（程式）持續無限地呼叫自己所導致的。

在你的註解和你的 `print()` 呼叫之前，為你的遞迴函式（程式）呼叫添加第一個引數為 `n - 1`，並確保函式（程式）本體僅在 `n` 大於零時執行。暫時保持其他引數的順序不變。

# --hints--

`move` 函式（程式）本體應該以一個 `if` 述語開始，當 `n` 大於零時觸發。

```js
({ test: () => assert.match(code, /def\s+move\(\s*n\s*,\s*source\s*,\s*auxiliary\s*,\s*target\s*\)\s*:\s+if\s+n\s*>\s*0\s*:/) })
```

你應該在 `if` 述語內呼叫 `move(n - 1, source, auxiliary, target)`。記得縮排你的 `print()` 呼叫。

```js
const transformedCode = "\n" + code.replace(/\r/g, '');
const move = __helpers.python.getDef(transformedCode, "move");
const { function_parameters, function_body } = move;

assert.match(function_parameters, /n\s*,\s*source\s*,\s*auxiliary\s*,\s*target/);
const functionBodyIndent = function_body.match(/ +/)[0];
const re = new RegExp(`${functionBodyIndent}if\\s+n\\s*>\\s*0\\s*:\\s+^${functionBodyIndent}( +)move\\(\\s*n\\s*-\\s*1\\s*,\\s*source\\s*,\\s*auxiliary\\s*,\\s*target\\s*\\).+?^${functionBodyIndent}\\1print\\s*\\(\\s*rods\\s*,\\s*("|')\\\\n\\2\\s*\\)`, "ms");
assert.match(function_body, re);
```

# --seed--

## --seed-contents--

```py
NUMBER_OF_DISKS = 4
rods = {
    'A': list(range(NUMBER_OF_DISKS, 0, -1)),
    'B': [],
    'C': []
}

--fcc-editable-region--
def move(n, source, auxiliary, target):
    # display starting configuration
    print(rods, '\n')
    
--fcc-editable-region--
# initiate call from source A to target C with auxiliary B
move(NUMBER_OF_DISKS, 'A', 'B', 'C')
```
