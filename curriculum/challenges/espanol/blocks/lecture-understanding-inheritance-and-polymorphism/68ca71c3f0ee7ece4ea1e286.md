---
id: 68ca71c3f0ee7ece4ea1e286
title: ¿Qué es Name Mangling y cómo funciona?
challengeType: 19
dashedName: what-is-name-mangling-and-how-does-it-work
---

# --description--

En una lección anterior, aprendiste sobre el prefijo de atributos con un solo guion bajo y un doble guion bajo.

Para recordarte la diferencia entre ellos, un solo guion bajo es una convención que significa que el atributo está destinado para uso interno en la clase y no debe ser accedido directamente desde fuera de la clase. El doble guion bajo, por otro lado, evita que ese atributo sea accedido directamente desde fuera de la clase.

Aquí tienes un ejemplo que demuestra cómo funcionan ambos:

```py
class Example:
    def __init__(self):
        self._internal = 'I can be accessed from outside the class, but should not'
        self.__private = 'You cannot access me directly from outside the class'

obj = Example()

print(obj._internal) # I can be accessed from outside the class, but should not
print(obj.__private)  # AttributeError: 'Example' object has no attribute '__private'
```

Anteponer un atributo con un doble guion bajo activa el proceso de ofuscación de nombres de Python, en el cual Python renombra internamente el atributo añadiendo un guion bajo y el nombre de la clase como prefijo, convirtiendo `__attribute` en `_ClassName__attribute`.

Para ver esto en acción, crea una instancia de la clase y usa el atributo especial `__dict__` de esa instancia, que es un diccionario que contiene los atributos del objeto:

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    'I can be accessed from outside the class, but should not',
    'I cannot be accessed directly from outside the class'
)

print(example1.__dict__)
```

El resultado sería:

```py
{
  '_internal': 'I can be accessed from outside the class, but should not',
  '_Example__private': 'I cannot be accessed directly from outside the class'
}
```

Como puedes ver, el atributo `__private` se almacena como `_Example__private`. Esto significa que aún puedes acceder a ese atributo fuera de la clase de esta manera:

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    'I can be accessed from outside the class, but should not',
    'I cannot be accessed directly from outside the class'
)
example2 = Example(
    'I should not be accessed from outside the class',
    'But I can be accessed from outside the class with name mangling'
)

print(example1._Example__private) # I cannot be accessed directly from outside the class
print(example2._Example__private) # But I can be accessed from outside the class with name mangling
```

Entonces, ¿por qué Python realiza name mangling?

El propósito principal de la mangling de nombres es evitar la sobreescritura accidental de atributos y métodos cuando usas herencia. Aquí tienes un ejemplo que lo aclara:

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

Puedes ver que tanto la clase `Parent` como la `Child` que hereda de ella tienen sus propios atributos `_class__data` separados. Esto es posible gracias al name mangling. De lo contrario, la `Child` habría sobrescrito accidentalmente los datos de `Parent`.

Esto es lo que habría pasado sin permitir que Python realice el name mangling, es decir, si no prefijas los atributos en ambas clases con doble guion bajo:

```py
class Parent:
   def __init__(self):
       self.data = 'Parent data'

class Child(Parent):
   def __init__(self):
       super().__init__()
       self.data = 'Child data'

c = Child()
print(c.__dict__)  # {'data': 'Child data'}
```

Entonces, ¿cuál deberías usar para prefijar atributos, entre guion bajo simple (`_`) y guion bajo doble (`__`)? Depende. Si un atributo está destinado solo para uso interno dentro de la clase, usa un guion bajo simple. 

Pero si estás trabajando con una clase que será heredada, debes usar un doble guion bajo para que el atributo del padre no sea sobrescrito. 

# --questions--

## --text--

¿Cuál es la diferencia entre un guion bajo simple y un guion bajo doble?

## --answers--

Un guion bajo simple y un guion bajo doble son tratados de la misma manera por Python.

### --feedback--

Concéntrate en cómo Python maneja los atributos que comienzan con `_` frente a `__`.

---

Un solo guion bajo hace que los atributos sean completamente privados, mientras que un doble guion bajo los hace protegidos.

### --feedback--

Concéntrate en cómo Python maneja los atributos que comienzan con `_` frente a `__`.

---

Un solo guion bajo evita el acceso directo, mientras que un doble guion bajo permite el acceso directo.

### --feedback--

Concéntrate en cómo Python maneja los atributos que comienzan con `_` frente a `__`.

---

Un solo guion bajo es solo una convención, mientras que un doble guion bajo activa el name mangling.

## --video-solution--

4

## --text--

¿Qué es name mangling?

## --answers--

Un proceso en el que Python convierte todos los atributos en métodos para un acceso más fácil.

### --feedback--

Piensa en cómo Python renombra internamente los atributos con doble guion bajo.

---

Un proceso en el que Python elimina atributos con un solo guion bajo para mantenerlos ocultos.

### --feedback--

Piensa en cómo Python renombra internamente los atributos con doble guion bajo.

---

Un proceso en el que Python cambia `__attribute` a `_ClassName__attribute` para evitar la sobrescritura accidental en las subclases.

---

Un proceso en el que Python encripta datos privados para hacerlos inaccesibles desde fuera de la clase.

### --feedback--

Piensa en cómo Python renombra internamente los atributos con doble guion bajo.

## --video-solution--

3

## --text--

¿Qué pasa cuando no prefijas los atributos en clases padre e hijo con un doble guion bajo?

## --answers--

Ambas clases mantienen sus propias copias separadas del atributo sin interferir entre ellas.

### --feedback--

Piensa en lo que muestra `print(c.__dict__)` cuando ambas clases usan el mismo nombre de atributo sin `__`.

---

La clase hija anula completamente el atributo de la clase padre, y se pierde la información del padre.

---

Los atributos de la clase padre se vuelven de solo lectura y no pueden ser modificados por la clase hija.

### --feedback--

Piensa en lo que muestra `print(c.__dict__)` cuando ambas clases usan el mismo nombre de atributo sin `__`.

---

Python genera un error porque los atributos siempre deben estar precedidos por un doble guion bajo.

### --feedback--

Piensa en lo que muestra `print(c.__dict__)` cuando ambas clases usan el mismo nombre de atributo sin `__`.

## --video-solution--

2
