---
id: 68c128cbd77e4ba9ed671937
title: ¿Qué son los Getters y Setters?
challengeType: 19
dashedName: what-are-getters-and-setters
---

# --description--

Los getters y setters son métodos que te permiten controlar cómo se accede y modifica los atributos de una clase. Con los getters recuperas un valor, y con los setters estableces un valor.

Estas acciones se realizan a través de lo que se conoce como propiedades. Son lo que conecta a los getters y setters, y permiten el acceso a los datos.

Las propiedades actúan como atributos pero se comportan como métodos internamente. Piénsalas como datos que defines como métodos, pero que funcionan como atributos. Esto significa que puedes acceder a las propiedades con notación de punto en lugar de paréntesis.

Lo principal que hacen las propiedades es que ejecutan lógica adicional detrás de escena cuando obtienes, estableces o eliminas valores con ellas. Esto las convierte en la opción perfecta cuando quieres acceder o manipular datos dentro de objetos.

Entonces, ¿por qué usar propiedades para eso en lugar de métodos? Es principalmente por legibilidad y convención. Hacen que tu código sea más limpio y fácil de leer.

Cuando usas un método, siempre tienes que llamarlo con paréntesis. Pero con una propiedad, puedes acceder a ella como un atributo normal usando la notación de punto. Eso hace que tu código se vea simple incluso cuando está haciendo trabajo extra detrás de escena.

Por ejemplo, podrías querer calcular un valor o verificar que un nuevo valor sea válido antes de guardarlo. En lugar de llamar a un método para eso, puedes usar una forma similar a un atributo para hacerlo.

Para crear una propiedad, defines un método y colocas el decorador `@property` encima. Esto le indica a Python que trate el método como una propiedad.

Eso nos lleva a los getters. Aquí te mostramos cómo crear uno con el decorador `@property`:

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

Este ejemplo obtiene un radio y el área de un círculo.

Observa cómo usamos `_radius` en lugar de radius dentro de la clase. El guion bajo es una convención común en Python para indicar que un atributo está destinado a ser privado. En otras palabras, significa que es para uso interno y no debe ser accedido directamente desde fuera de la clase.

Para crear un setter para definir el radio, por ejemplo, tienes que definir otro método con el mismo nombre y usar `@<property_name>.setter` encima:

Usar `self.radius` dentro de `__init__` asegura que el setter se ejecute durante la creación del objeto, por lo que los valores inválidos de radius se detectan inmediatamente.

```py
class Circle:
    def __init__(self, radius):
        self.radius = radius # Calling the setter

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

En este ejemplo, el setter de radius no solo está estableciendo el radius para el círculo, también está ejecutando una validación que asegura que el radius no sea un número negativo.

Una vez que defines getters y setters, Python los llama automáticamente en segundo plano cada vez que usas la sintaxis normal de atributos:

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

Ten en cuenta que dentro del setter no puedes usar el mismo nombre de la propiedad al asignar un nuevo valor. Eso es porque `self.radius = value` llamará al setter dentro del mismo método setter, lo que provoca una recursión infinita y un `RecursionError`. Por eso siempre debes usar la forma con guion bajo al inicio `self._radius = value`.

Así como puedes controlar cómo se accede a un atributo mediante un getter y cómo se modifica con un setter, también puedes controlar cómo se elimina usando un deleter.

Un eliminador ejecuta lógica personalizada cuando usas la instrucción del en una propiedad. Para crear uno, usas el decorador `@<property_name>.deleter`:

```py
class Circle:
    def __init__(self, radius):
        self.radius = radius

    # Getter
    @property
    def radius(self):
        return self._radius

    # Setter
    @radius.setter
    def radius(self, value):
        if value <= 0:
            raise ValueError("Radius must be positive")
        self._radius = value

    # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

Aquí tienes cómo se puede usar el deleter:

```py
# Create circle object with a radius
my_circle = Circle(33)
print("Initial radius:", my_circle.radius)  # 33

# Delete the radius
# This calls the deleter
del my_circle.radius # Deleting radius...
print("Radius deleted!") # Radius deleted!

# Try to access radius after deletion
try:
    print(my_circle.radius)
except AttributeError as e:
    print("Error:", e) # Error: 'Circle' object has no attribute '_radius'
```

La conclusión de esto es que:

- Los getters te permiten obtener un valor o incluso calcular un valor al instante.
- Los setters te permiten modificar los valores de forma segura ejecutando verificaciones antes de la asignación.
- Las propiedades son lo que une estos getters y setters para que puedas escribir lógica mientras sigues usando la notación de punto.
- Los deleters te permiten definir qué sucede cuando se elimina un atributo.

# --questions--

## --text--

¿Qué te permite ejecutar lógica en segundo plano mientras obtienes o estableces el valor de un atributo?

## --answers--

Importando módulos externos.

### --feedback--

Piensa en métodos que permitan la validación o el cálculo al leer y escribir datos.

---

Herencia de clases.

### --feedback--

Piensa en métodos que permitan la validación o el cálculo al leer y escribir datos.

---

Propiedades

---

Acceso directo a atributos.

### --feedback--

Piensa en métodos que permitan la validación o el cálculo al leer y escribir datos.

## --video-solution--

3

## --text--

¿Qué une a los getters y setters para que puedas ejecutar lógica mientras mantienes el acceso con notación de punto?

## --answers--

Propiedades

---

Decoradores

### --feedback--

Piensa en una característica que te permita usar métodos como atributos con una sintaxis simple de punto.

---

Herencia de clases

### --feedback--

Piensa en una característica que te permita usar métodos como atributos con una sintaxis simple de punto.

---

Llamadas directas a métodos

### --feedback--

Piensa en una característica que te permita usar métodos como atributos con una sintaxis simple de punto.

## --video-solution--

1

## --text--

¿Qué dos decoradores se usan para crear getters y setters para una propiedad?

## --answers--

`@getter` y `@setter`

### --feedback--

Piensa en decoradores que permiten que las llamadas a métodos usen una notación de punto simple sin paréntesis.

---

`@attr.get` y `@attr.set`

### --feedback--

Piensa en decoradores que permiten que las llamadas a métodos usen una notación de punto simple sin paréntesis.

---

`@compute` y `@assign`

### --feedback--

Piensa en decoradores que permiten que las llamadas a métodos usen una notación de punto simple sin paréntesis.

---

`@property` y `@<property_name>.setter`

## --video-solution--

4
