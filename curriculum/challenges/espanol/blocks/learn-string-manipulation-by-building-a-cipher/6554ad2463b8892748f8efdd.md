---
id: 6554ad2463b8892748f8efdd
title: Paso 67
challengeType: 20
dashedName: step-67
---

# --description--

Por el momento, tu función imprime algunas cadenas, pero estos valores no pueden ser usados por otras partes del código para realizar ninguna acción.

Para ese propósito, necesitas usar una sentencia `return`:

```python
def foo():
    return 'spam'
```

Necesitas escribir `return` seguido de un espacio y el valor que la función debe devolver. Una vez que se encuentra la sentencia `return`, ese valor se devuelve y la ejecución de la función se detiene, procediendo a la siguiente línea de código después de la llamada a la función. En el ejemplo anterior, la función `foo` devuelve la cadena `'spam'`.

Elimina las dos llamadas a `print()` de tu función y devuelve `encrypted_text`.

# --hints--

Debes eliminar las dos llamadas a `print()` de tu función.

```js
({ 
  test: () => {
    const commentless_code = __helpers.python.removeComments(code);
    assert.isFalse(/print\s*\(\s*("|')plain\stext:\1\s*,\s*message\s*\)/.test(commentless_code))
    assert.isFalse(/print\s*\(\s*("|')encrypted\stext:\1\s*,\s*encrypted_text\s*\)/.test(commentless_code))
  }
})
```

Tu función debería devolver `encrypted_text`.

```js
({ test: () => {
    const commentless_code = __helpers.python.removeComments(code);
    const {function_body} = __helpers.python.getDef(commentless_code, "vigenere");
    const {block_body} = __helpers.python.getBlock(commentless_code, /for\s+char\s+in\s+message\.lower\s*\(\s*\)\s*/);
    const regex = /return\s+encrypted_text/
    assert(function_body.match(regex));
    assert.notMatch(block_body, regex);
  }
})
```

# --seed--

## --seed-contents--

```py
text = 'Hello Zaira'
custom_key = 'python'

def vigenere(message, key):
    key_index = 0
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    encrypted_text = ''

    for char in message.lower():
    
        # Append space to the message
        if char == ' ':
            encrypted_text += char
        else:        
            # Find the right key character to encode
            key_char = key[key_index % len(key)]
            key_index += 1
--fcc-editable-region--
            # Define the offset and the encrypted letter
            offset = alphabet.index(key_char)
            index = alphabet.find(char)
            new_index = (index + offset) % len(alphabet)
            encrypted_text += alphabet[new_index]
    print('plain text:', message)
    print('encrypted text:', encrypted_text)
--fcc-editable-region--
```
