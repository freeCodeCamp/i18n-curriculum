---
id: 697dc755c709772fad37dea0
title: 优先级队列和堆如何工作？
challengeType: 19
dashedName: how-do-priority-queues-and-heaps-work
---

# --description--

**优先级队列** 是一种抽象的数据类型（ADT），其工作方式类似于队列或栈，但有一个关键区别。

正如你可能已经知道的，标准队列遵循 FIFO（先进先出）方法，其中第一个添加到队列的元素是第一个从队列中移除的元素。

栈遵循 LIFO（后进先出）方法，其中最后添加到栈的元素是第一个从栈中移除的元素。

队列和栈只考虑元素的插入顺序。

但是，优先级队列会考虑元素的“priority”。优先级用于确定下一个应该被移除的元素。

通常，优先级最高的元素会被首先移除，但某些实现也可能选择首先移除优先级最低的元素。这将取决于你的程序的需求。

优先级队列对于实际应用非常有帮助，例如查找两个位置之间的最短路径、在操作系统中调度任务、模拟交通、压缩数据和管理网络。

在实际中，优先级队列通常使用堆数据结构来实现。

**堆** 是一种具有非常特定属性的树数据结构，该属性称为 **堆属性**。该属性根据堆的类型确定每个节点与其子节点之间的关系。

堆有两种主要类型：

* 最大堆
    
* 最小堆
    

在**最大堆**中，每个节点的值大于或`equal`于其子节点的值。

在此示例中，你可以看到一个包含节点 8、7、5、2 和 1 的树结构。请注意，节点 7 大于节点 2 和节点 1，符合堆属性。其他所有节点也都满足此条件。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-1.png" alt="A max-heap tree structure showing nodes with values 8 at the root, 7 and 5 as children of 8, and 2 and 1 as children of 7, demonstrating that each parent node is greater than its children.">

相比之下，在**最小堆**中，每个节点的值小于或`equal`于其子节点的值。

在此示例中，我们有值为 4、7、9、12 和 15 的节点。例如，节点 7 小于节点 12 和节点 15，符合堆属性。所有其他节点也同样如此。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-2.png" alt="A min-heap tree structure showing nodes with values 4 at the root, 7 and 9 as children of 4, and 12 and 15 as children of 7, demonstrating that each parent node is less than its children.">

堆属性是关键，因为它确保最大（或最小）元素（取决于堆的类型）始终保持在顶部，这使得移除操作非常简单。

在实际中，堆通常被实现为数组，以高效访问父节点和子节点。

使用数组简化了访问这些值或“节点”的逻辑，因为在后台，如果堆维护了完全二叉树的结构，数组实现只需要基于它们的索引进行简单的数学运算，就能查找元素在内存中的位置。

JavaScript 没有内置的堆模块，但你可以使用数组实现一个最小堆。

这是一个用 JavaScript 实现的基本最小堆：

```js
class MinHeap {
  constructor(compare = (a, b) => a - b) {
    this.data = [];
    this.compare = compare;
  }

  peek() {
    return this.data[0];
  }

  push(value) {
    this.data.push(value);
    this.#bubbleUp(this.data.length - 1);
  }

  pop() {
    if (this.data.length === 0) return undefined;

    const top = this.data[0];
    const last = this.data.pop();

    if (this.data.length > 0) {
      this.data[0] = last;
      this.#bubbleDown(0);
    }

    return top;
  }

  pushPop(value) {
    if (this.data.length === 0) return value;

    if (this.compare(this.data[0], value) < 0) {
      const top = this.data[0];
      this.data[0] = value;
      this.#bubbleDown(0);
      return top;
    }

    return value;
  }

  heapify(arr) {
    this.data = arr.slice();
    for (let i = Math.floor(this.data.length / 2) - 1; i >= 0; i--) {
      this.#bubbleDown(i);
    }
  }

  #bubbleUp(i) {
    while (i > 0) {
      const p = Math.floor((i - 1) / 2);
      if (this.compare(this.data[i], this.data[p]) >= 0) break;
      [this.data[i], this.data[p]] = [this.data[p], this.data[i]];
      i = p;
    }
  }

  #bubbleDown(i) {
    const n = this.data.length;

    while (true) {
      let smallest = i;
      const l = 2 * i + 1;
      const r = 2 * i + 2;

      if (l < n && this.compare(this.data[l], this.data[smallest]) < 0) smallest = l;
      if (r < n && this.compare(this.data[r], this.data[smallest]) < 0) smallest = r;

      if (smallest === i) break;

      [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];
      i = smallest;
    }
  }
}
````

要使用此堆，你可以创建一个空堆。这将是堆的底层数据结构：

```js
const myHeap = new MinHeap();
```

要为堆添加元素，你需要调用 `push()`。这将自动将元素添加到应在的位置，以保持堆属性：

```js
myHeap.push(9);
```

要获取优先级最低的元素（在此情况下，即最小的值），你可以调用 `pop()`：

```js
myHeap.pop();
```

`pushPop()` 将两个操作合并为一次调用。

这比单独按序列调用它们更高效，尤其是在堆很大时，因为它只执行一次重新排序操作：

```js
myHeap.pushPop(15);
```

如果你已经有一个数组并且想将它转换成堆，你可以调用 `heapify()`：

```js
myHeap.heapify([9, 2, 7, 1]);
```

但目前，我们是按它们的值对元素进行排序，对吗？

如果我们想按它们的 `priority` 排序呢？

你可以通过存储具有此结构的数组来实现：`[priority, element]`。

在 JavaScript 中，数组不会自动逐元素进行排序比较，因此你需要向堆传递一个先比较优先级的比较函数。

请注意，在这种分支中，较低的值将表现出较高的优先级。这意味着优先级为 1 的项比优先级为 3 的项具有**更高**的优先级：

```js
const myHeap = new MinHeap((a, b) => a[0] - b[0]);

myHeap.push([3, "A"]);
myHeap.push([2, "B"]);
myHeap.push([1, "C"]);
```

如果你需要以插入顺序移除具有相同优先级的元素，可以考虑将唯一计数器作为你的项的第二个元素以打破平局，格式如 `[priority, counter, element]`。

例如，你可以先按优先级比较，然后按计数器比较：

```js
let counter = 0;
const myHeap = new MinHeap((a, b) => (a[0] - b[0]) || (a[1] - b[1]));

myHeap.push([3, counter++, "A"]);
myHeap.push([2, counter++, "B"]);
myHeap.push([2, counter++, "C"]);
```

现在让我们谈谈堆的效率。

插入和提取堆中最小值或最大值（取决于堆的类型）的平均和最坏分支时间复杂度是对数级的，`O(log n)`，因为所需的交换次数通常与堆的高度成正比，而堆的高度是 log(n)。

`"peek"` 操作的平均和最坏分支时间复杂度是常量时间，O(1)。`peek` 涉及获取最小值或最大值（取决于 `heap` 的类型），但不移除它。

`heapify` 操作，即从无序 `list` 构建 `heap`，在平均和最坏 `case` 下具有线性时间复杂度 O(n)。

同样，查找和删除任意 `Element` 的平均和最坏分支时间复杂度均为 O(n)，因为它们可能需要遍历整个堆。

它们需要多少空间？

堆的空间复杂度是线性的，O(n)，其中 `n` 是它包含的元素数量。它只需要保存元素和数组对象本身的一小部分额外开销。

优先级队列和堆在计算机科学中非常重要。它们让你能够快速查找并使用列表中最重要的元素。这种效率对于许多执行关键现实任务的计算机程序至关重要，例如查找地图上最快的路线。

# --questions--

## --text--

优先级队列与标准队列或栈的主要区别特征是什么？

## --answers--

它允许通过索引访问元素。

### --feedback--

考虑决定下一个被移除的元素的主要因素。

---

它总是按照插入的顺序处理元素。

### --feedback--

考虑决定下一个被移除的元素的主要因素。

---

它根据赋值的优先级检索元素。

---

它只保存相同数据类型的元素。

### --feedback--

考虑决定下一个被移除的元素的主要因素。

## --video-solution--

3

## --text--

以下哪项是优先级队列有用的常见现实应用？

## --answers--

在操作系统中调度一些更紧急的任务。

---

管理一个歌曲按固定顺序播放的播放列表。

### --feedback--

考虑某些项更重要且需要优先处理的场景。

---

存储一份杂货项的列表。

### --feedback--

考虑某些项更重要且需要优先处理的场景。

---

按字母顺序跟踪客户名称。

### --feedback--

考虑某些项更重要且需要优先处理的场景。

## --video-solution--

1

## --text--

尽管堆被概念化为树，但在实际中通常将堆实现为数组的主要原因是什么？

## --answers--

数组总是比任何其他数据结构更快。

### --feedback--

考虑如何将堆的树状结构高效映射到线性数据结构。

---

数组通过使用数学公式简化了访问父节点和子节点的逻辑。

---

数组允许对任何元素进行直接随机访问，这是核心堆操作。

### --feedback--

考虑如何将堆的树状结构高效映射到线性数据结构。

---

数组是唯一能够保证堆属性的数据结构。

### --feedback--

考虑如何将堆的树状结构高效映射到线性数据结构。

## --video-solution--

2
