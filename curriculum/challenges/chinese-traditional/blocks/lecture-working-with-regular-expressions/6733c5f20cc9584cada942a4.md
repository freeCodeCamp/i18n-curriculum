---
id: 6733c5f20cc9584cada942a4
title: 什麼是捕獲群組和反向引用，它們如何運作？
challengeType: 19
dashedName: what-are-capturing-groups-and-backreferences-and-how-do-they-work
---

# --interactive--

捕獲群組允許你「捕獲」匹配字串的一部分，以便你根據需要使用。捕獲群組是由包含要捕獲樣式的小括弧所定義，且前面沒有像先行斷言這類的字元。

讓我們從 `freeCodeCamp` 的正規表達式中擷取 `code`。為此，我們將用小括弧括住 `code`，並將其定義為一個擷取群組：

```js
const regex = /free(code)camp/i;
```

為了確認行為，我們可以針對 `freecodecamp` 字串進行測試：

:::interactive_editor

```js
const regex = /free(code)camp/i;
console.log(regex.test("freecodecamp")); // true
```

:::

但這並沒有實際使用我們捕捉到的群組。相反地，讓我們來看看使用 `match` 的結果：

```js
const regex = /free(code)camp/i;
console.log("freecodecamp".match(regex));
// [
//   'freecodecamp',
//   'code', <--
//   index: 0,
//   input: 'freecodecamp',
//   groups: undefined
// ]
```

這裡我們可以看到我們的 `match` 陣列有第二個元素，該元素是由我們的捕獲群組擷取的字串部分。

注意捕獲群組如何精確匹配樣式 `code`，而字元類別則會匹配列表 `c`、`o`、`d` 和 `e` 中的單一字元。

但是我們實際上要如何使用這個呢？捕捉群組通常用於取代字串的內容。讓我們設定一些程式碼來做到這一點。我們將把 `freecodecamp` 變成 `paidcodeworld`：

:::interactive_editor

```js
const regex = /free(code)camp/i;
console.log("freecodecamp".replace(regex, "paidcodeworld"));
```

:::

這個方法本身可以運作，但如果我們不知道 `code` 中有多少個 `o` 呢？如果我們需要一個量詞來表示一個或多個 `o`：

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paidcodeworld"));
```

:::

我們得到的結果是 `paidcodeworld`。我們想保留 `o` 的數量，所以需要重複使用正規表達式所捕捉到的內容。

這就是反向引用發揮作用的地方。我們可以直接取用捕獲的群組，而不是將取代字串中的 `code` 部分硬編碼。

在 `replace` 呼叫中，你可以透過使用美元符號（`$`）後接要使用的捕獲群組編號來達成反向引用。在我們的例子中，那就是 `$1`，因為 `code` 是在第一個捕獲群組中捕獲的：

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world")); // paidcoooooooodeworld
```

:::

我們現在已成功在將 `freecodecamp` 轉換成 `paidcodeworld` 時保留了不明數量的 `o` 字元。但回址參考不僅限於 `replace` 呼叫。你實際上可以直接在正規表達式中使用它們。

這將允許你在正規表達式中稍後比對先前擷取的樣式。

假設我們想要在字串中任意位置匹配兩次 `freecodecamp`，且 `o` 的數量相同。

首先，我們需要用萬用字元將它們分開，並允許任意數量的字元與該萬用字元相符：

```js
const regex = /free(co+de)camp.*free(co+de)camp/i;
```

不過，這個目前的表達式不會確保 `o` 字元的數量相同。為了達成這點，我們需要將第二個捕獲群組取代為對第一個的引用。

在正規表達式中，反向引用以反斜線後接捕獲群組的編號表示：

:::interactive_editor

```js
const regex = /free(co+de)camp.*free\1camp/i;
console.log(regex.test("freecooooodecamp is great i love freecooooodecamp")); // true
console.log(regex.test("freecooooodecamp is great i love freecodecamp")); // false
```

:::

由此可見，具有正確數量 `o` 的字串符合條件，而具有兩個不同數量 `o` 的字串則不符合。

這個語法很棒，但當你取用多個捕獲群組時，很快就會變得混亂。幸運的是，你可以為你的群組命名，而不是使用數字。

要定義一個命名捕獲群組，你需要在群組開頭添加一個問號（`?`），後面接著用小於號和大於號括起來的名稱。讓我們將捕獲群組命名為 `code`：

```js
const regex = /free(?<code>co+de)camp.*free\1camp/i;
```

現在我們可以更新正規表達式中的反向引用，以指向這個群組。在 JavaScript 中，命名反向引用以反斜線開頭，接著是字母 `k`。然後你再加上名稱，並用小於（`<`）和大於（`>`）符號括起來。讓我們來看看：

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
```

現在如果我們檢查我們的 `test()` 呼叫，我們可以看到我們仍然傳遞：

:::interactive_editor

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
console.log(regex.test("freecooooodecamp is freecooooodecamp")); // true
```

:::

要在 `replace()` 呼叫中使用我們的命名捕獲群組，我們會在字串中插入一個美元符號，接著是用小於和大於符號括起來的名稱：

:::interactive_editor

```js
const regex = /free(?<code>co+de)camp/i;
console.log("freecooooodecamp".replace(regex, "paid$<code>camp")); // paidcooooodecamp
```

:::

最後，有時你想要創建一個字元群組，但不需要擷取的結果。

假設我們想要匹配 `freecodecamp` 或 `freecandycamp`。你可以創建兩個由 OR 斷言分隔的樣式：

```js
const regex = /freecodecamp|freecandycamp/i;
```

但對於較大規模的正規表達式，這可能會變得相當冗長。相反地，你可以在你需要 OR 的字元周圍創建一個非捕獲群組：

```js
const regex = /free(?:code|candy)camp/i;
```

非捕獲群組不會將 `code|candy` 的比對結果單獨儲存在記憶體中。但它可以幫助建立替代樣式，而不犧牲可讀性或效率。

# --questions--

## --text--

如何在正規表達式中創建命名捕獲群組？

## --answers--

`(name:pattern)`

### --feedback--

本課程描述用於命名捕獲群組的特定語法，涉及尖括號。

---

`(?<name>pattern)`

---

`(?name:pattern)`

### --feedback--

本課程描述用於命名捕獲群組的特定語法，涉及尖括號。

---

`(name=>pattern)`

### --feedback--

本課程描述用於命名捕獲群組的特定語法，涉及尖括號。

## --video-solution--

2

## --text--

在 `replace()` 方法中，你要如何在替換字串中取用第一個捕獲群組？

## --answers--

`\1`

### --feedback--

課程提到使用特定符號後接數字來取用替換呼叫中的擷取群組。

---

`$1`

---

`{1}`

### --feedback--

課程提到使用特定符號後接數字來取用替換呼叫中的擷取群組。

---

`[1]`

### --feedback--

課程提到使用特定符號後接數字來取用替換呼叫中的擷取群組。

## --video-solution--

2

## --text--

在正規表達式中，非捕獲群組的目的是什麼？

## --answers--

擷取群組而不將其儲存在記憶體中

### --feedback--

本課程描述了與建立替代樣式相關的非捕獲群組的特定使用案例。

---

在不犧牲可讀性或效率的情況下創建替代樣式

---

為捕獲群組命名

### --feedback--

本課程描述了與建立替代樣式相關的非捕獲群組的特定使用案例。

---

取用先前擷取的群組

### --feedback--

本課程描述了與建立替代樣式相關的非捕獲群組的特定使用案例。

## --video-solution--

2
