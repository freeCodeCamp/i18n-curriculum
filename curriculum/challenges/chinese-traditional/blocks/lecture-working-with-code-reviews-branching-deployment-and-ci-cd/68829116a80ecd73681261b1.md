---
id: 68829116a80ecd73681261b1
title: 與你的遠端對應者保持同步的良好做法是什麼？
challengeType: 19
dashedName: what-are-good-practices-for-remaining-in-sync-with-your-remote-counterparts
---

# --description--

我們已經稍微談過使用分支來處理獨立變更，以避免弄髒你的 `main` 分支。但這是什麼意思，為什麼這很重要？

如果你直接將變更提交到你的 `main` 分支，且上游儲存庫接受了其他非你所做的變更，你最終會遇到所謂的「分歧歷史」。這表示你 `main` 分支上的提交不再與上游 `main` 分支上的提交對齊。這會讓同步上游變更變得非常困難。

所以，假設你一直遵循良好的分支實務，這就不會是問題。如果你有跟著我們之前的課程，你應該會有一個你已經在區域複製的儲存庫分支，並且你應該有一個指向原始儲存庫的上游遠端。

如果你沒有這麼做，這裡有一個快速提醒。你會想要分支一個儲存庫，將你的分支複製到區域的，並執行這個指令：

```sh
git remote add upstream <url>
```

將 `<url>` 取代為原始儲存庫的 SSH URL，而非你的分支。

在正確組態的上游後，你可以執行以下一系列指令以拉取最新的上游變更：

```sh
git checkout main
git fetch upstream
git merge upstream/main
```

這些有什麼作用？你已經學過 `git checkout`，所以第一個指令確保你在你的區域的 `main` 分支上。

第二個指令 `git fetch upstream` 告訴 Git 去取得你上游遠端（即原始倉庫）上的最新變更。然而，與 pull 不同的是，Git 不會自動更新你的分支。這點很重要，因為你本地的 `main` 分支是連接到你 fork 的 `main` 分支，而不是原始倉庫的 `main` 分支！執行 git pull 可能會導致意外的行為。

最後的指令 `git merge upstream/main` 告訴 Git 將 upstream 遠端中 `main` 分支的最新變更合併到你目前的分支－也就是你的區域的 `main` 分支，因為那是我們所檢出的分支。

但是如果合併失敗怎麼辦？如果你不小心提交到了 `main`，而 Git 無法合併分歧的歷史紀錄怎麼辦？嗯……假設你沒有從你的 `main` 分支建立任何拉取請求，你可以執行硬重設來強制 Git 更新你的分支。

```sh
git reset --hard upstream/main
```

`git reset` 指令允許你重設分支的當前狀態。傳入 `--hard` 旗標會告訴 Git 強制讓區域的檔案與分支狀態相符。這確保你有一個乾淨的起點來進行作業。而傳入 `upstream/main` 則告訴 Git 你想讓當前分支（即 `main`）與上游遠端的 `main` 分支相符。使用此指令時請小心－每當你強制更新 Git 歷史時，可能會發生奇怪且不幸的狀況。

一旦你已正確更新你的區域的 `main` 分支，將該狀態推送到你的遠端分支（如果你有遵循我們的課程，應該是 `origin`）是很重要的。為此，你可以執行：

```sh
git push
```

這將會將目前的狀態推送到你的遠端分支。但如果你必須進行硬重設來清理歷史紀錄，遠端分支可能也有分歧的歷史紀錄，推送將會失敗。

你可以透過強制推送來修正這個問題：

```sh
git push --force
```

**請小心使用此指令**。執行強制推送會有效地重寫你的遠端歷史紀錄，如果你操作錯誤，強制推送將會變成難以解開的惡夢。

將同步的變更推送到你的遠端分支非常重要，因為這有助於你確保如果遺失了現有的區域的儲存庫，仍能安全地複製該分支並取得最新的變更。

一旦你已將你的 `main` 分支同步，你就可以從該狀態創建一個新的分支，開始在另一個貢獻上工作－使用原始程式碼庫的最新版本！

# --questions--

## --text--

當你使用分叉的儲存庫時，為什麼你應該避免直接提交變更到你的 `main` 分支的主要原因是什麼？

## --answers--

它會產生重複的提交。

### --feedback--

想想當你的分支和原始儲存庫分別演進時會發生什麼情況。

---

它會導致「分歧歷史」，使得與上游同步變得困難。

---

Git 不允許對 main 分支進行提交。

### --feedback--

想想當你的分支和原始儲存庫分別演進時會發生什麼情況。

---

它會自動刪除你的區域的變更。

### --feedback--

想想當你的分支和原始儲存庫分別演進時會發生什麼情況。

## --video-solution--

2

## --text--

哪一系列指令會正確地使用原始儲存庫的變更來更新你區域的 `main` 分支？

## --answers--

`git checkout main`；`git pull upstream`

### --feedback--

考慮取得上游變更而不干擾你的分支所需的逐步處理程序。

---

`git pull upstream main`

### --feedback--

考慮取得上游變更而不干擾你的分支所需的逐步處理程序。

---

`git checkout main`；`git fetch upstream`；`git merge upstream/main`

---

`git fetch upstream/main`；`git merge`

### --feedback--

考慮取得上游變更而不干擾你的分支所需的逐步處理程序。

## --video-solution--

3

## --text--

如果你不小心提交到你的 `main` 分支且無法合併上游變更，假設你還沒有建立任何拉取請求，你可以使用什麼指令強制重設你的 `main` 分支以符合上游？

## --answers--

`git checkout upstream/main`

### --feedback--

哪個指令會完全重設你的分支，使其與另一個分支的狀態相符？

---

`git reset --hard upstream/main`

---

`git rebase upstream/main`

### --feedback--

哪個指令會完全重設你的分支，使其與另一個分支的狀態相符？

---

`git clean upstream/main`

### --feedback--

哪個指令會完全重設你的分支，使其與另一個分支的狀態相符？

## --video-solution--

2
