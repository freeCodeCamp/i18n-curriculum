---
id: 587d7fb2367417b2b2512bf8
title: 從 POST 請求取得資料
challengeType: 2
forumTopicId: 301511
dashedName: get-data-from-post-requests
---

# --description--

在路徑 `/name` 上掛載一個 POST 處理常式。這與之前的路徑相同。我們已經在 html 首頁準備了一個表單。它將提交練習 10（查詢字串）中的相同資料。如果 body-parser 組態正確，你應該會在物件 `req.body` 中找到參數。請參考常用的函式庫範例：

<blockquote>route: POST '/library'<br>urlencoded_body: userId=546&#x26;bookId=6754 <br>req.body: {userId: '546', bookId: '6754'}</blockquote>

回應與之前相同的 JSON 物件：`{name: 'firstname lastname'}`。使用我們在應用程式首頁提供的 html 表單測試你的端點是否運作。

提示：除了 GET 和 POST 之外，還有其他幾種 http 方法。根據慣例，http 動詞與你將在伺端執行的操作行為之間存在對應關係。慣例對應如下：

POST（有時是 PUT）－ 使用隨請求發送的資訊創建一個新的資源，

GET - 讀取現有資源而不修改它，

PUT 或 PATCH（有時是 POST）－ 使用傳送的資料更新資源，

DELETE - 刪除資源。

還有其他幾種用來與伺服端協商連接的行為。除了 GET，以上列出的所有其他行為都可以有有效負載（即請求主體中的資料）。`body-parser` 中介層也適用於這些行為。

# --hints--

測試 1 ：你的 API 端點應該回應正確的名稱

```js
  const response = await fetch(code + '/name', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({ first: 'Mick', last: 'Jagger' })
  });
  if (!response.ok) {
    throw new Error(await response.text());
  }
  const data = await response.json();
  assert.equal(
    data.name,
    'Mick Jagger',
    'Test 1: "POST /name" route does not behave as expected'
  );
```

測試 2 ：你的 API 端點應該回應正確的名稱

```js
  const response = await fetch(code + '/name', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      first: 'Keith',
      last: 'Richards'
    })
  });
  if (!response.ok) {
    throw new Error(await response.text());
  }
  const data = await response.json();
  assert.equal(
    data.name,
    'Keith Richards',
    'Test 2: "POST /name" route does not behave as expected'
  );
```

