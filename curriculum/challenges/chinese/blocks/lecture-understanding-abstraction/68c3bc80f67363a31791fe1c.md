---
id: 68c3bc80f67363a31791fe1c
title: 什么是抽象以及它如何帮助保持复杂系统的有序？
challengeType: 19
dashedName: what-is-abstraction-and-how-does-it-help-keep-complex-systems-organized
---

# --description--

既然我们已经了解了封装、继承和多态，接下来让我们讨论面向对象编程的下一个关键概念——抽象。

抽象是隐藏复杂实现细节并仅显示对象或系统的基本特色的进程。可以将其视为关注某物的功能而非其实现方式。

抽象不仅限于 Python。它是一种可以在许多支持面向对象编程的语言中实现的编程概念。

为了说明抽象，想象你正在开车。当你坐在驾驶座时，你与方向盘、换挡杆以及油门和刹车踏板等关键部件进行交互。你不需要了解发动机如何工作、变速器如何换挡或制动系统背后的物理原理，因为这些都是复杂的实现细节。

这就是抽象的作用！它为你提供了一个简化的接口，以便与你的复杂系统交互。

以汽车为例，简化的接口是方向盘、刹车和油门，而复杂的系统是汽车本身。

至于 Python 如何实现抽象，它是通过 `abc` 模块实现的。

该模块提供了 `ABC` 类（代表“抽象基类”）和 `@abstractmethod` 装饰器。

`ABC` 是用于继承的类，但你不能直接创建它的对象。它定义了其子类必须实现的公共方法和属性接口。

另一方面，抽象方法是在抽象基类（ABC）中使用 `@abstractmethod` 装饰器声明的方法。它可能没有实现或只有一个基本的默认实现。然而，任何子类必须覆写它，才能被视为具体且可实例化，即使提供了默认实现。

以下是 Python 中抽象类的基本语法：

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

这是一个基本示例：

```py
from abc import ABC, abstractmethod

class Animal(ABC): # Inherits from abstract base class
   @abstractmethod # Abstract method decorator
   def make_sound(self):  # The method subclasses must override
       pass

# Concrete class that will override the abstract method
class Dog(Animal):
   def make_sound(self):
       print('Woof!')

# Another concrete class that will override the abstract method
class Cat(Animal):
   def make_sound(self):
       print('Meow!')

# Another concrete class that will override the abstract method
class Monkey(Animal):
   def make_sound(self):
       print('Ooh ooh aah aah!')

# Create instances of each concrete class
animals = [Dog(), Cat(), Monkey()]

# Loop through the instances to call the make_sound method
for animal in animals:
   animal.make_sound()

# Output:
# Woof!
# Meow!
# Ooh ooh aah aah!
```

下面为例：

- 我们正在从 `abc` 模块导入 `ABC` 类和 `abstractmethod`。
- 然后我们创建一个继承自 `ABC` 的 `Animal` 类，并在其中创建一个抽象的 `make_sound` 方法，`Animal` 的每个子类都必须覆写该方法。
- 我们创建具体的类 `Dog`、`Cat` 和 `Monkey`，它们必须覆写抽象的 `make_sound` 方法。
- 我们实例化具体类并调用它们的 `make_sound` 方法，以展示它们各自如何以自己的方式实现 `make_sound` 抽象方法。

请记住，你不能创建 `Animal` 类的实例。如果你尝试这样做，会发生以下情况：

```py
dog = Animal() 
# TypeError: Can't instantiate abstract class Animal 
# without an implementation for abstract method 'make_sound'
```

同样的规则适用于没有为抽象方法提供实现的子类。即使你定义了 Animal 的子类，只有在覆写了 `make_sound` 之后才能实例化它。下面是一个示例：

```py
class Bird(Animal):
    pass

bird = Bird()
# TypeError: Can't instantiate abstract class Bird 
# without an implementation for abstract method 'make_sound'
```

这是另一个示例，这次是一个你可以传递给具体方法实例的实例属性：

```py
from abc import ABC, abstractmethod

# The blueprint for any toy that can speak
class TalkingToy(ABC):
   def __init__(self, name):
       self.name = name
   @abstractmethod
   def speak(self):
       pass

class RobotToy(TalkingToy):
   def speak(self):
       print(f'{self.name} says beep boop! I am a robot!')

class TeddyBearToy(TalkingToy):
   def speak(self):
       print(f"{self.name} says hug me! I'm cuddly!")

class DinosaurToy(TalkingToy):
   def speak(self):
       print(f'{self.name} says ROOOOAR!')

# Create toys
rusty = RobotToy('Rusty')
fluffy = TeddyBearToy('Fluffy')
rex = DinosaurToy('Rex')

toys = [rusty, fluffy, rex]
for toy in toys:
   toy.speak()

# Output:
# Rusty says beep boop! I am a robot!
# Fluffy says hug me! I'm cuddly!
# Rex says ROOOOAR!
```

在此示例中： 

- 我们有一个抽象的基类 `TalkingToy`，它定义了任何能说话的玩具的蓝图。
- 子类 `RobotToy`、`TeddyBearToy` 和 `DinosaurToy` 以各自的方式实现了 `speak` 方法。
- 当我们创建这些子类的实例并调用 `speak` 方法时，每个玩具都会以其独特的方式发声。

总之，Python 中的抽象通过提高可重用性简化了复杂系统。

你已经看到如何在多个子类中重用抽象的类中的单个方法，同时强制每个子类提供其特定行为。

这种方法使你的代码保持有序、灵活，并且更易于维护，尤其是在你的应用增长时。

# --questions--

## --text--

面向对象编程中抽象的主要目标是什么？

## --answers--

向用户公开所有内部实现细节。

### --feedback--

思考抽象如何简化与复杂系统的交互。

---

将多个类合并为一个。

### --feedback--

思考抽象如何简化与复杂系统的交互。

---

防止方法在子类中被重写。

### --feedback--

思考抽象如何简化与复杂系统的交互。

---

隐藏复杂逻辑，仅显示必要的特色

## --video-solution--

4

## --text--

Python 如何通过其 `ABC` 模块实现抽象？

## --answers--

通过允许直接实例化抽象的 `class`。

### --feedback--

`ABC` 模块迫使子类实现方法。

---

通过使用装饰器和继承来定义子类必须实现的抽象的方法。

---

通过自动隐藏所有带有双下划线的 `method`。

### --feedback--

`ABC` 模块迫使子类实现方法。

---

通过将类转换为函数。

### --feedback--

`ABC` 模块迫使子类实现方法。

## --video-solution--

2

## --text--

在抽象的汽车类比中，什么表现为简化的接口和复杂的系统？

## --answers--

接口是发动机活塞，复杂系统是方向盘。

### --feedback--

考虑接口是你直接交互的部分，而复杂系统是其工作原理。

---

接口是方向盘、刹车和油门，复杂系统是发动机、变速器和制动物理。

---

接口是汽车手册，复杂系统是仪表盘控件。

### --feedback--

考虑接口是你直接交互的部分，而复杂系统是其工作原理。

---

接口是燃料 `type`，复杂系统是轮胎。

### --feedback--

考虑接口是你直接交互的部分，而复杂系统是其工作原理。

## --video-solution--

2
