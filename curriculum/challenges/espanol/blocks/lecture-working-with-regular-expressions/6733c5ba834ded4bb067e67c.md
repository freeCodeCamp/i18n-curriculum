---
id: 6733c5ba834ded4bb067e67c
title: ¬øCu√°les son algunos modificadores comunes de expresiones regulares utilizados para buscar?
challengeType: 19
dashedName: what-are-some-common-regular-expression-modifiers-used-for-searching
---

# --interactive--

Los modificadores, a menudo llamados "flags", modifican el comportamiento de una expresi√≥n regular. Recordemos nuestro ejemplo de una lecci√≥n anterior:

:::interactive_editor

```js
const regex = /freeCodeCamp/;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // true
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // false
console.log(regex.test("FREECODECAMP")); // false
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

:::

Si recuerdas, las cadenas de `freeCodeCamp` en min√∫sculas y may√∫sculas no coincidieron con el patr√≥n. Esto se debe a que, por defecto, las expresiones regulares distinguen entre may√∫sculas y min√∫sculas.

Pero, ¬øqu√© pasar√≠a si pudi√©ramos decirle a la expresi√≥n regular que no distinga entre may√∫sculas y min√∫sculas? Bueno, hay un modificador para eso. La bandera `i` hace que una regex ignore las may√∫sculas. ¬øC√≥mo podemos usarla? Las banderas van despu√©s de la barra inclinada de cierre en una expresi√≥n regular:

```js
const regex = /freeCodeCamp/i;
```

Observa el cambio en la expresi√≥n regular en la primera l√≠nea. Ahora podemos verificar c√≥mo esto cambia las cosas:

:::interactive_editor

```js
const regex = /freeCodeCamp/i;

console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // true
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

:::

Debido a que ahora nuestra expresi√≥n regular no distingue entre may√∫sculas y min√∫sculas, las cadenas en min√∫sculas y may√∫sculas han "pasado" la prueba. Esto tambi√©n puede funcionar para una cadena con una mezcla aleatoria de letras may√∫sculas y min√∫sculas:

:::interactive_editor

```js
const regex = /freeCodeCamp/i;

console.log(regex.test("dO yOu LoVe fReEcOdEcAmP?")); // true
```

:::

Hay bastantes otras banderas que puedes usar. La bandera `g`, o el modificador global, permite que tu expresi√≥n regular coincida con un patr√≥n m√°s de una vez. 

Veamos c√≥mo eso afecta nuestro c√≥digo. Notar√°s que mantenemos la bandera `i`: una expresi√≥n regular puede usar m√∫ltiples banderas (tantas como sean necesarias) para lograr tu comportamiento deseado.

```js
const regex = /freeCodeCamp/gi;
```

Espera un segundo... ¬øqu√© es esto? Parecer√≠a que el modificador global est√° haciendo que algunas de nuestras cadenas que deber√≠an estar pasando fallan en su lugar:

:::interactive_editor

```js
const regex = /freeCodeCamp/gi;

console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // false
console.log(regex.test("FREECODECAMP")); // true
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

:::

¬øPor qu√©? Bueno, el modificador global hace que tu expresi√≥n regular sea stateful. Esto significa que realiza un seguimiento de d√≥nde ha coincidido previamente un patr√≥n. Por lo tanto, cuando coincide la primera cadena de `freeCodeCamp`, recuerda que encontr√≥ una coincidencia que comienza en el √≠ndice `0`.

Luego lo probamos contra `freeCodeCamp es genial`, pero no comienza en el √≠ndice `0`. La expresi√≥n regular "sabe" que encontr√≥ una coincidencia en el √≠ndice `0` ya, por lo que aunque esta es una cadena diferente, comienza desde el √≠ndice final de la coincidencia. 

`freeCodeCamp` tiene `12` caracteres de largo, por lo que una coincidencia en `0` termina en el √≠ndice `11`. La coincidencia se reanudar√° en el √≠ndice `12`. Y dado que `es genial` no coincide con `freeCodeCamp`, devuelve `false`.

Luego, porque no encuentra una coincidencia, "pierde" su estado y comienza la coincidencia siguiente desde `0`.

Si intercambiamos nuestros registros para que una cadena con la coincidencia en `0` sea seguida inmediatamente por una cadena que tiene una coincidencia m√°s all√° del √≠ndice `11`:

:::interactive_editor

```js
const regex = /freeCodeCamp/gi;

console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("I loooooooove freeCodeCamp")); // true
```

:::

Cuando una expresi√≥n regular es global, obtiene una nueva propiedad llamada `lastIndex`. Tomando nuestro c√≥digo anterior, veamos c√≥mo funciona esta propiedad:

:::interactive_editor

```js
const regex = /freeCodeCamp/gi;

console.log(regex.lastIndex); // 0
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.lastIndex); // 12
console.log(regex.test("freeCodeCamp is great")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.lastIndex); // 19
console.log(regex.test("freecodecamp")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("FREECODECAMP")); // true
console.log(regex.lastIndex); // 12
console.log(regex.test("free")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("code")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("camp")); // false
```

:::

Al mirar este ejemplo, puedes ver c√≥mo cambia el estado de la expresi√≥n regular con cada llamada de prueba, usando el `lastIndex` para rastrear sus coincidencias previas.

El flag global es excelente cuando necesitas obtener m√∫ltiples coincidencias de una sola cadena. Pero si est√°s probando m√∫ltiples cadenas con la misma expresi√≥n regular, es mejor dejar la bandera `g` desactivada.

Antes de aprender sobre la siguiente bandera, necesitas aprender sobre los anclajes. El ancla de zanahoria (`^`), al principio de la expresi√≥n regular, dice "coincide el inicio de la cadena":

```js
const start = /^freecodecamp/i;
```

El ancla del signo de d√≥lar (`$`), al final de la expresi√≥n regular, dice "coincide el fin de la cadena":

```js
const end = /freecodecamp$/i;
```

T√≥mate un momento para comparar los resultados en la derecha:

:::interactive_editor

```js
const start = /^freecodecamp/i;
const end = /freecodecamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
console.log(start.test("freecodecamp is great")); // true
console.log(end.test("freecodecamp is great")); // false
console.log(start.test("i love freecodecamp")); // false
console.log(end.test("i love freecodecamp")); // true
console.log(start.test("have met freecodecamp's founder")); // false
console.log(end.test("have met freecodecamp's founder")); // false
```

:::

¬øVes c√≥mo el ancla de inicio solo coincide al comienzo de la cadena y el ancla final solo coincide al final de la cadena? ¬øPero qu√© hay de la coincidencia a trav√©s de m√∫ltiples l√≠neas? Echemos un vistazo a eso:

:::interactive_editor

```js
const start = /^freecodecamp/i;
const end = /freecodecamp$/i;
const string = `I really love
freecodecamp
it's my favorite`;
console.log(start.test(string)); // false
console.log(end.test(string)); // false
```

:::

Aunque `freecodecamp` est√° all√≠ por su propia l√≠nea, falla ambas pruebas. Esto se debe a que, por defecto, los anclajes buscan el inicio y el final de toda la cadena.

Pero puedes hacer que una regex maneje m√∫ltiples l√≠neas con la bandera `m`, o el modificador de l√≠neas m√∫ltiples. Agreguemos eso a nuestras expresiones regulares para ver qu√© obtenemos:

:::interactive_editor

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const string = `I really love
freecodecamp
it's my favorite`;
console.log(start.test(string)); // true
console.log(end.test(string)); // true
```

:::

¬°Ahora coinciden ambas! Dado que `freecodecamp` est√° completamente en su propia l√≠nea, el ancla de inicio coincide con el inicio de esa l√≠nea y el ancla final coincide con el final de esa l√≠nea.

Finalmente, tienes la bandera `d`, o el modificador de √≠ndices. Recuerda que la bandera `i` es para insensibilidad a may√∫sculas, por lo que el modificador de √≠ndices necesita una bandei diferente.

La bandera `d` expande la informaci√≥n que obtienes en un objeto de coincidencia. Agregu√©moslo a nuestra expresi√≥n regular:

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

Y el resultado es:

```js
// [
//   'freecodecamp',
//   index: 8,
//   input: "we love freecodecamp isn't freecodecamp great?",
//   groups: undefined,
//   indices: [
//     0: [8, 20],
//     groups: undefined
//   ]
// ]
```

¬°Nuestro objeto de coincidencia obtiene una nueva propiedad `indices`! Esta propiedad es un array de dos n√∫meros, el primero es el √≠ndice en la cadena original donde comienza la coincidencia, y el segundo es el √≠ndice despu√©s de que termin√≥ la coincidencia. Este array tambi√©n tiene una propiedad `groups` extra, que tambi√©n es para grupos de captura por nombre.

Hay algunas otras banderas que deber√≠as saber que est√°n disponibles para ti, pero son menos comunes en el c√≥digo t√≠pico.

La primera es el modificador unicode, o la bandei `u`. Esto expande la funcionalidad de una expresi√≥n regular para permitir que coincida con caracteres especiales unicode.

Aprender√°s m√°s sobre las clases de caracteres en una lecci√≥n futura, pero la bandera `u` te da acceso a clases especiales como `Extended_Pictographic` para coincidir con la mayor√≠a de los emojis:

:::interactive_editor

```js
const regex = /üçé/u;

const str = "I have an apple üçé";
console.log(regex.test(str)); // true
```

:::

Tambi√©n hay un indicador `v`, que ampl√≠a a√∫n m√°s la funcionalidad de la coincidencia unicode.

La segunda es el modificador sticky, o la bandei `y`. El modificador sticky se comporta de manera muy similar al modificador global, pero con algunas excepciones.

La mayor es que una expresi√≥n regular global comenzar√° desde `lastIndex` y buscar√° a trav√©s de toda la cadena restante otra coincidencia, pero una expresi√≥n regular sticky retornar√° `null` y restablecer√° el `lastIndex` a `0` si no hay inmediatamente una coincidencia en el `lastIndex` anterior.

Y, por √∫ltimo, est√° el modificador de l√≠nea √∫nica, o la bandei `s`. Recuerda que el modificador multil√≠nea permite que los anclajes de inicio y final coincidan con el inicio y el final de una l√≠nea, en lugar de toda la cadena. 

El modificador de l√≠nea √∫nica permite que un car√°cter comod√≠n, representado por un punto (`.`) en regex, coincida con saltos de l√≠nea, tratando efectivamente la cadena como una sola l√≠nea de texto.

Hay bastantes de estos modificadores, pero las banderas `i` y `g` son las que usar√°s m√°s frecuentemente, y son las m√°s importantes de recordar.

# --questions--

## --text--

¬øQu√© devolver√≠a el siguiente c√≥digo?

```js
const regex = /freecodecamp/i;
console.log(regex.test("I love FREECODECAMP!"));
console.log(regex.test("freeCodoCamp"));
console.log(regex.test("We went freeCodeCamping."));
```

## --answers--

```js
true
true
true
```

### --feedback--

El `i` flag hace que la regex sea insensible a may√∫sculas, por lo que `freeCodeCamp` coincide sin importar las may√∫sculas, siempre que las letras sean las mismas.

---

```js
true
false
true
```

---

```js
true
true
false
```

### --feedback--

El `i` flag hace que la regex sea insensible a may√∫sculas, por lo que `freeCodeCamp` coincide sin importar las may√∫sculas, siempre que las letras sean las mismas.

---

```js
false
false
false
```

### --feedback--

El `i` flag hace que la regex sea insensible a may√∫sculas, por lo que `freeCodeCamp` coincide sin importar las may√∫sculas, siempre que las letras sean las mismas.

## --video-solution--

2

## --text--

¬øCu√°ndo NO querr√≠as usar el global (`g`) flag en una expresi√≥n regular?

## --answers--

Cuando quieres coincidir un patr√≥n varias veces dentro de una sola cadena.

### --feedback--

El `g` flag es stateful, lo que significa que rastrea la √∫ltima coincidencia, lo que puede causar problemas al probar m√∫ltiples cadenas.

---

Cu√°ndo quieres que la coincidencia comience de nuevo con cada prueba nueva.

### --feedback--

El `g` flag es stateful, lo que significa que rastrea la √∫ltima coincidencia, lo que puede causar problemas al probar m√∫ltiples cadenas.

---

Cuando quieres hacer que la regex no distinga entre may√∫sculas y min√∫sculas.

### --feedback--

El `g` flag es stateful, lo que significa que rastrea la √∫ltima coincidencia, lo que puede causar problemas al probar m√∫ltiples cadenas.

---

Cuando est√°s probando m√∫ltiples cadenas y no necesitas rastrear el estado de la coincidencia.

## --video-solution--

4

## --text--

¬øQu√© hace el modificador de l√≠neas m√∫ltiples (`m`) en una expresi√≥n regular?

## --answers--

Permite que los anclajes (`^` y `$`) coincidan con el inicio y fin de cada l√≠nea, no solo con toda la cadena.

---

Hace que la expresi√≥n regular sea insensible a may√∫sculas y min√∫sculas.

### --feedback--

El modificador `m` permite la coincidencia al inicio y final de las l√≠neas en cadenas multil√≠nea.

---

Permite que la expresi√≥n regular coincida con los saltos de l√≠nea.

### --feedback--

El modificador `m` permite la coincidencia al inicio y final de las l√≠neas en cadenas multil√≠nea.

---

Hace que la expresi√≥n regular coincida globalmente.

### --feedback--

El modificador `m` permite la coincidencia al inicio y final de las l√≠neas en cadenas multil√≠nea.

## --video-solution--

1
