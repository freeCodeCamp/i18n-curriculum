---
id: 67c2bbd476f6e540b4c0b0d4
title: React 状态和 Hooks 回顾
challengeType: 31
dashedName: review-react-state-and-hooks
---

# --description--

## 在 React 中使用事件

- **合成事件系统**：这是 React 处理事件的方式。它作为本地事件（如 `click`、`keydown` 和 `submit` 事件）的包装器。React 中的事件处理器使用驼峰命名法。（例如 `onClick`、`onSubmit` 等）

下面是一个在 React 中为 `button` 元素使用 `onClick` 属性的示例：

```jsx
function handleClick() {
  console.log("Button clicked!");
}

<button onClick={handleClick}>Click Me</button>;
```

在 React 中，事件处理器函数通常以前缀 `handle` 开头，以表示它们负责处理事件，例如 `handleClick` 或 `handleSubmit`。

当用户操作触发一个事件时，React 会将一个合成事件对象传递给你的处理器。该对象的行为类似于原生 JavaScript 中的本地事件对象，提供诸如 `type`、`target` 和 `currentTarget` 等属性。

为了防止诸如浏览器刷新之类的默认行为（例如在 `onSubmit` 事件期间），你可以调用 `preventDefault()` 方法：

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("Form submitted!");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>Submit</button>
</form>;
```

你也可以像这样用箭头函数包裹一个处理器函数：

```jsx
function handleDelete(id) {
  console.log("Deleting item:", id);
}

<button onClick={() => handleDelete(1)}>Delete Item</button>;
```

## 使用状态和 `useState` Hook

- **状态的定义**：在 React 中，状态是包含组件数据的对象。当状态更新时，组件将重新渲染。React 将状态视为不可变的，这意味着你不应直接修改它。
- **`useState()` Hook**：`useState` hook 是一个函数，允许你在函数组件中声明状态变量。基本语法如下：

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

在状态变量中你有以下内容：

- `stateVariable` 保存当前状态值
- `setStateFunction`（设置函数）更新状态变量
- `initialValue` 设置初始状态

这是一个完整的 `Counter` 组件示例：

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

## 渲染和 React 组件

- **定义**：在 React 中，渲染是组件出现在用户界面（UI）中的进程，通常是浏览器。渲染进程包括三个阶段：触发器、渲染和提交。

触发器阶段发生在 React 检测到某些内容已更改且用户界面（UI）可能需要更新时。此更改通常是由于状态或 props 的更新引起的。

一旦触发器发生，React 就进入渲染阶段。在这里，React 会重新评估你的组件并确定要显示的内容。为此，React 使用了一个称为虚拟 DOM 的“真实” DOM 的轻量级拷贝。通过虚拟 DOM，React 可以快速查看组件中需要更改的内容。

提交阶段是 React 从虚拟 DOM 获取准备好的更改并将其应用到真实 DOM 的阶段。换句话说，这个阶段是你在屏幕上看到最终结果的阶段。

## 更新状态中的对象和数组

- **更新状态中的对象**：如果你需要更新状态中的对象，那么你应该先构造一个新对象或拷贝一个已有对象，然后为该新对象设置状态。任何放入状态中的对象都应被视为只读。下面是设置用户的姓名、年龄和城市的示例。`handleChange` 函数用于处理用户信息的更新：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **更新状态中的数组**：在更新状态中的数组时，重要的是不要使用 `push()` 或 `pop()` 等方法直接修改数组。相反，更新状态时应创建一个新数组：

```js
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

如果你想从数组中移除项，你应该使用 `filter()` 方法，该方法会在过滤掉你想移除的内容后返回一个新数组：

```js
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## 使用 Refs 参考值

- **`ref` 属性**：你可以通过使用 `ref` 属性来访问 React 中的 DOM 节点。下面是一个示例，展示如何使用 `ref` 来聚焦一个 `input` 元素。`current` 属性用于访问该 `ref` 的当前值：

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Focus;
```

## 使用 `useEffect` Hook

- **`useEffect()` Hook**：在 React 中，效果是指发生在组件渲染过程之外的任何事情。也就是说，任何 React 不直接作为渲染 UI 一部分处理的内容。常见的例子包括获取数据、更新浏览器标签（页）的标题、从浏览器的局部存储读取或写入数据、获取用户的位置等等。这些操作与外部世界交互，被称为副作用。React 提供了 `useEffect` hook 来让你处理这些副作用。`useEffect` 允许你在组件渲染或更新后运行一个函数。

```js
import { useEffect } from "react";

useEffect(() => {
 // Your side effect logic (usually a function) goes here
}, [dependencies]);
```

效果函数在组件渲染后运行，而可选的 `dependencies` 参数控制效果的运行时机。

请注意，`dependencies` 可以是一个包含“响应式值”（状态、属性、函数、变量等）的数组、一个空数组，或者完全省略。以下是所有这些选项如何控制 `useEffect` 的工作方式：

- 如果 `dependencies` 是包含一个或多个响应式值的数组，则每当它们变化时，效果将运行。

- 如果 `dependencies` 是一个空数组，`useEffect` 只会在组件首次渲染时运行一次。

- 如果你省略 `dependencies`，该效果将在组件每次渲染或更新时运行。

## 如何创建自定义 Hooks

- **自定义 Hooks**：自定义 hook 允许你从组件中提取可重用的逻辑，例如数据获取、状态管理、切换以及跟踪在线状态等副作用。在 React 中，所有内置 hook 都以 `use` 开头，因此你的自定义 hook 也应遵循相同的命名规范。

下面是创建 `useDebounce` 钩子的示例：

```js
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

# --assignment--

复习 React 状态和钩子主题及概念。
