---
id: 587d7fb8367417b2b2512c0e
title: '透過執行查找、編輯，然後存檔來進行經典更新'
challengeType: 2
forumTopicId: 301541
dashedName: perform-classic-updates-by-running-find-edit-then-save
---

# --description--

在過去，如果你想編輯一個文件，並且能以某種方式使用它（例如，在伺服端回應中回傳它），這就是你需要做的事情。Mongoose 有一個專用的更新方法：`Model.update()`。它綁定於低層次的 mongo 驅動程式。它可以批次編輯符合特定條件的多個文件，但它不會回傳更新後的文件，只會回傳一個「狀態」訊息。此外，它使模型驗證變得困難，因為它只是直接呼叫 mongo 驅動程式。

# --instructions--

修改 `findEditThenSave` 函式（程式），使用參數 `personId` 作為搜尋鍵，透過 `_id` 找到一個人（可使用上述任一方法）。為該人的 `favoriteFoods` 列表添加 `"hamburger"`（你可以使用 `Array.push()`）。然後，在搜尋回呼中，`save()` 更新後的 `Person`。

**注意：** 如果你在 Schema 中將 `favoriteFoods` 宣告為陣列，但未指定型別（例如 `[String]`），這可能會比較棘手。在這種情況下，`favoriteFoods` 預設為 Mixed 型別，你必須手動使用 `document.markModified('edited-field')` 標記為已編輯。請參考我們的 <a href="https://www.freecodecamp.org/news/introduction-to-mongoose-for-mongodb-d2a7aa593c57/" target="_blank" rel="noopener noreferrer nofollow">Mongoose 文章</a>。

# --hints--

尋找-編輯-更新一個項目應該成功

```js
  const response = await fetch(code + '/_api/find-edit-save', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      name: 'Poldo',
      age: 40,
      favoriteFoods: ['spaghetti']
    })
  });
  if (!response.ok) {
    throw new Error(await response.text());
  }
  const data = await response.json();
  assert.equal(data.name, 'Poldo', 'item.name is not what is expected');
  assert.equal(data.age, 40, 'item.age is not what expected');
  assert.deepEqual(
    data.favoriteFoods,
    ['spaghetti', 'hamburger'],
    'item.favoriteFoods is not what expected'
  );
  assert.equal(data.__v, 1, 'The item should be previously edited');
```

