---
id: 67172b43f84bcd2dec238a3d
title: 建置一本書籍整理器
challengeType: 26
dashedName: build-a-book-organizer
---

# --description--

**目標：** 完成以下使用者故事並通過所有測試以完成實驗。 

**使用者故事：**

1. 你應該有一個名為 `books` 的物件陣列，其中陣列中的每個物件都應該有一個字串 `title`、另一個字串 `authorName`，以及一個數字 `releaseYear`。

2. 你的 `books` 陣列應該至少有三個物件。

3. 你應該有一個名為 `sortByYear` 的回呼函式（程式），該函式接受兩本書作為參數，用於排序陣列。

4. 如果第一本書的 `releaseYear` 小於第二本書，則 `sortByYear` 函式（程式）應該傳回 `-1`。

5. 如果第一本書的 `releaseYear` 大於第二本書，`sortByYear` 函式（程式）應該傳回 `1`。

6. 如果兩個 `releaseYear` 值相等，`sortByYear` 函式（程式）應該傳回 `0`。

7. 你應該從 `books` 陣列中篩選出某年（例如 1950 年）之後寫的書籍，並將篩選後的陣列存檔到名為 `filteredBooks` 的新陣列中。

8. 你應該根據 `releaseYear` 以遞增順序排序 `filteredBooks` 陣列中的書籍。你在之前的課程中學到，`sort()` 方法會就地排序陣列。這表示 `filteredBooks` 陣列將會被變更。

# --hints--

你應該在你的程式碼中有一個函式 `sortByYear`。

```js
assert.isFunction(sortByYear);
```

你的 `sortByYear` 函式應該接受兩個參數。

```js
assert.lengthOf(sortByYear, 2);
```

你的 `sortByYear` 函式（程式）應該在 `book1` 物件的 `releaseYear` 小於 `book2` 物件的 `releaseYear` 時傳回 `-1`，在 `book1` 物件的 `releaseYear` 大於 `book2` 物件的 `releaseYear` 時傳回 `1`，在其他所有情況下傳回 `0`。

```js
assert.equal(sortByYear({releaseYear: 1913}, {releaseYear: 1925}), -1);
assert.equal(sortByYear({releaseYear: 1925}, {releaseYear: 1913}), 1);
assert.equal(sortByYear({releaseYear: 1925}, {releaseYear: 1925}), 0);
```

你應該在你的程式碼中有一個陣列 `books`。

```js
assert.isArray(books)
```

你的 `books` 陣列應該至少有三個書籍物件。

```js
assert.isAtLeast(books.length, 3)
```

你的 `books` 陣列應該包含物件，每個物件都有一個字串 `title`、另一個字串 `authorName` 和一個數字 `releaseYear`。

```js

books.forEach((book) => {
  assert.isObject(book);
  assert.sameMembers(Object.keys(book), ["title", "authorName", "releaseYear"]);
  assert.isString(book.title);
  assert.isNotEmpty(book.title);
  assert.isString(book.authorName);
  assert.isNotEmpty(book.authorName);
  assert.isNumber(book.releaseYear);
})
```

你應該在你的程式碼中有一個陣列 `filteredBooks`。

```js
assert.isArray(filteredBooks)
```

`filteredBooks` 陣列應該從 `books` 陣列中篩選出部分書籍，且不應該是空的。

```js
assert.isBelow(filteredBooks.length, books.length)
assert.isNotEmpty(filteredBooks)
```

`filteredBooks` 陣列應該只包含來自原始 `books` 陣列的書籍。

```js
filteredBooks.forEach(book => {
  assert.isTrue(
    books.some(original => 
      original.title === book.title &&
      original.authorName === book.authorName &&
      original.releaseYear === book.releaseYear
    )
  );
});
```

`filteredBooks` 陣列應該只包含在指定年份或之前發行的書籍。

```js
const maxYear = Math.max(...filteredBooks.map(book => book.releaseYear));
const removedYears = books.filter(book => !filteredBooks.includes(book)).map(book => book.releaseYear);
assert.isTrue(removedYears.every(year => year > maxYear));
```

你應該在 `filteredBooks` 陣列上，透過傳入 `sortByYear` 回呼函式來呼叫 `sort` 高階函式（函式）。

```js
assert.match(__helpers.removeJSComments(code), /\s*filteredBooks\s*\.\s*sort\s*\(\s*sortByYear\s*\)/);
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
function sortByYear(book1, book2) {
  if (book1.releaseYear < book2.releaseYear) {
    return -1;
  }

  if (book1.releaseYear > book2.releaseYear) {
    return 1;
  }

  return 0;
}

const books = [
  {
    title: "The Great Gatsby",
    authorName: "F. Scott Fitzgerald",
    releaseYear: 1925,
  },
  {
    title: "In Search of Lost Time",
    authorName: "Marcel Proust",
    releaseYear: 1913,
  },
  {
    title: "Ulysses",
    authorName: "James Joyce",
    releaseYear: 1922,
  },
  {
    title: "One Hundred Years of Solitude",
    authorName: "Gabriel García Márquez",
    releaseYear: 1967,
  },
  {
    title: "The Catcher in the Rye",
    authorName: "J. D. Salinger",
    releaseYear: 1951,
  },
];

let filteredBooks = books.filter((book) => book.releaseYear < 1950);

filteredBooks.sort(sortByYear);

console.log("Books Written Before 1950 (sorted according to release year)");
filteredBooks.forEach((book) => {
  console.log(`${book.title} by ${book.authorName} (${book.releaseYear})`);
});
```
