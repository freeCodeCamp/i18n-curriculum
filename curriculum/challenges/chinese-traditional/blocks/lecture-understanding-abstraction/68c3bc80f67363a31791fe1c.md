---
id: 68c3bc80f67363a31791fe1c
title: 什麼是抽象性以及它如何幫助保持複雜系統的組織性？
challengeType: 19
dashedName: what-is-abstraction-and-how-does-it-help-keep-complex-systems-organized
---

# --description--

既然我們已經探討了封裝、繼承和多型，現在讓我們討論物件導向程式設計的下一個關鍵概念－抽象性。

抽象性是隱藏複雜實作細節並僅顯示物件或系統的必要特性的處理程序。將它視為專注於某物的功能，而非其運作方式。

抽象性不限於 Python。它是一個可以在許多支援物件導向程式設計的語言中實作的程式設計概念。

為了說明抽象性，想像你正在開車。當你坐在駕駛座時，你會與方向盤、排檔桿以及油門和煞車踏板等重要零件互動。你不需要知道引擎如何運作、變速箱如何換檔，或煞車系統背後的物理原理，因為這些都是複雜的實作細節。

這就是抽象性的運作！它為你提供一個簡化的介面來與複雜系統互動。

以汽車為例，簡化的介面是方向盤、煞車和油門，而複雜的系統則是整輛汽車本身。

至於 Python 如何實作抽象性，它是透過 `abc` 模組來完成的。

此模組提供 `ABC` 類別（代表「抽象的基礎類別」）和 `@abstractmethod` 裝飾器。

`ABC` 是用來被繼承的類別，但你無法直接從它創建物件。它定義了其子類別必須實作的共通方法和屬性介面。

另一方面，抽象方法是在抽象基礎類別（ABC）中使用 `@abstractmethod` 裝飾器宣告的方法。它可能沒有實作或只有基本的預設實作。然而，任何子類別必須改寫它，才能被視為具體的且可實例化，即使提供了預設實作。

以下是 Python 中抽象類別的基本語法：

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

這裡有一個基本範例：

```py
from abc import ABC, abstractmethod

class Animal(ABC): # Inherits from abstract base class
   @abstractmethod # Abstract method decorator
   def make_sound(self):  # The method subclasses must override
       pass

# Concrete class that will override the abstract method
class Dog(Animal):
   def make_sound(self):
       print('Woof!')

# Another concrete class that will override the abstract method
class Cat(Animal):
   def make_sound(self):
       print('Meow!')

# Another concrete class that will override the abstract method
class Monkey(Animal):
   def make_sound(self):
       print('Ooh ooh aah aah!')

# Create instances of each concrete class
animals = [Dog(), Cat(), Monkey()]

# Loop through the instances to call the make_sound method
for animal in animals:
   animal.make_sound()

# Output:
# Woof!
# Meow!
# Ooh ooh aah aah!
```

在此範例中：

- 我們正在從 `abc` 模組匯入 `ABC` 類別和 `abstractmethod`。
- 接著，我們創建一個繼承自 `ABC` 的 `Animal` 類別，並在其中創建一個抽象的 `make_sound` 方法，`Animal` 的每個子類別都必須改寫該方法。
- 我們創建具體的類別 `Dog`、`Cat` 和 `Monkey`，它們必須改寫 `make_sound` 抽象的行為。
- 我們實例化具體的類別並呼叫它們的 `make_sound` 方法，以展示它們各自如何以自己的方式實作 `make_sound` 抽象的行為。

請記住你無法創建 `Animal` 類別的實體。如果你嘗試這麼做，會發生以下情況：

```py
dog = Animal() 
# TypeError: Can't instantiate abstract class Animal 
# without an implementation for abstract method 'make_sound'
```

相同的規則也適用於沒有提供抽象方法實作的子類別。即使你定義了 Animal 的子類別，只有在它改寫了 `make_sound` 之後，你才能實例化它。以下是一個說明這點的範例：

```py
class Bird(Animal):
    pass

bird = Bird()
# TypeError: Can't instantiate abstract class Bird 
# without an implementation for abstract method 'make_sound'
```

這裡有另一個範例，這次是你可以傳遞給具體方法實體的實體屬性：

```py
from abc import ABC, abstractmethod

# The blueprint for any toy that can speak
class TalkingToy(ABC):
   def __init__(self, name):
       self.name = name
   @abstractmethod
   def speak(self):
       pass

class RobotToy(TalkingToy):
   def speak(self):
       print(f'{self.name} says beep boop! I am a robot!')

class TeddyBearToy(TalkingToy):
   def speak(self):
       print(f"{self.name} says hug me! I'm cuddly!")

class DinosaurToy(TalkingToy):
   def speak(self):
       print(f'{self.name} says ROOOOAR!')

# Create toys
rusty = RobotToy('Rusty')
fluffy = TeddyBearToy('Fluffy')
rex = DinosaurToy('Rex')

toys = [rusty, fluffy, rex]
for toy in toys:
   toy.speak()

# Output:
# Rusty says beep boop! I am a robot!
# Fluffy says hug me! I'm cuddly!
# Rex says ROOOOAR!
```

在此範例中： 

- 我們有一個抽象的基礎類別 `TalkingToy`，它定義了任何會說話玩具的藍圖。
- 子類別 `RobotToy`、`TeddyBearToy` 和 `DinosaurToy` 各自以自己的方式實作 `speak` 方法。
- 當我們創建這些子類別的實體並呼叫 `speak` 方法時，每個玩具都會以其獨特的方式發聲。

總結來說，Python 中的抽象性透過提高可重複使用性來簡化複雜系統。

你已經看到如何從抽象的類別重複使用單一方法於多個子類別，同時強制每個子類別提供其特定行為。

這種方法讓你的程式碼保持有條理、彈性，且更容易維護，特別是當你的應用程式規模擴大時。

# --questions--

## --text--

物件導向程式設計中抽象性的主要目標是什麼？

## --answers--

將所有內部實作細節公開給使用者。

### --feedback--

思考抽象性如何簡化與複雜系統的互動。

---

將多個類別合併為一個。

### --feedback--

思考抽象性如何簡化與複雜系統的互動。

---

為了防止方法在子類別中被覆寫。

### --feedback--

思考抽象性如何簡化與複雜系統的互動。

---

隱藏複雜邏輯，只顯示必要的特性

## --video-solution--

4

## --text--

Python 如何透過其 `ABC` 模組實作抽象性？

## --answers--

允許直接具現抽象的類別。

### --feedback--

ABC 模組強制子類別實作方法。

---

透過使用裝飾器和繼承來定義子類別必須實作的抽象的行為。

---

透過自動隱藏所有帶有雙底線的行為。

### --feedback--

ABC 模組強制子類別實作方法。

---

透過將類別轉換為函式（程式）。

### --feedback--

ABC 模組強制子類別實作方法。

## --video-solution--

2

## --text--

在抽象性的汽車類比中，什麼表述了簡化的介面和複雜的系統？

## --answers--

介面是引擎活塞，而複雜系統是方向盤。

### --feedback--

思考介面是你直接互動的部分，而複雜系統則是其運作方式。

---

介面是方向盤、煞車和油門，而複雜系統是引擎、變速箱和煞車物理。

---

介面是汽車手冊，而複雜系統是儀表板控制元件。

### --feedback--

思考介面是你直接互動的部分，而複雜系統則是其運作方式。

---

介面是燃料型別，複雜系統是輪胎。

### --feedback--

思考介面是你直接互動的部分，而複雜系統則是其運作方式。

## --video-solution--

2
