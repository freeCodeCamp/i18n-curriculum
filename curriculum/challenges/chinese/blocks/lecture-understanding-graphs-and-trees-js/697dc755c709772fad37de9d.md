---
id: 697dc755c709772fad37de9d
title: 深度优先和广度优先查找是如何工作的？
challengeType: 19
dashedName: how-do-depth-first-and-breadth-first-search-work
---

# --description--

当你开始使用数据结构和算法时，你很快会意识到你需要执行的常见操作之一是访问每个节点。

这个进程被称为“遍历”数据结构。

遍历用于对数据结构中的每个节点执行某些操作，比如打印它们的值、查找特定值或对节点执行某些操作。

通过系统地访问每个节点，你确保进程不会跳过任何节点。

但是你如何确定应该以什么顺序遍历数据结构？进程应该从哪里开始，下一节点又应该如何选择？

如果没有明确的方法来遍历数据结构，遍历它就像在迷宫中行走却没有特定的路径可循。

这就是像广度优先搜索（BFS）和深度优先搜索（DFS）这样的算法变得非常重要的地方。它们通常用于遍历图和查找两个节点之间的路径。

当它们用于遍历一个数据结构时，它们定义了节点应被访问的顺序，以确保没有任何节点被跳过。

让我们从广度优先查找（BFS）开始。

## 广度优先查找（BFS）

**广度优先查找（BFS）** 是一种算法，它在移动到图中的下一层之前访问所有相邻节点。

它可以用于查找无权图中两个节点之间的最短路径，因为它会分析每个层级的所有节点，因此它首先找到边数最少的路径。

该算法通常使用队列数据结构来实现，以跟踪已访问的节点。队列遵循 FIFO（先进先出）方法，其中第一个添加到队列的节点是第一个被移除的节点。

算法的工作原理如下：

* 你从一个特定的节点开始。
    
* 该节点被标记为已访问并添加到队列。
    
* 当队列不为空时，当前节点从队列中移除（出队）。然后，对于它的每一个邻居，如果邻居尚未被访问，则将其标记为已访问并添加到队列中。
    

一个重要的考虑是，由于广度优先查找（BFS）需要在内存中存储一个队列，而该队列可能包含大量节点，因此该算法的空间需求可能相当大。对于同一层级上节点数量众多的图，这一点尤其如此。

让我们来看一个将 BFS 应用于一种称为树的特定类型图的例子。

你将在即将到来的课程中学习更多关于树的内容，但它们本质上是没有周期的图，其中节点以层次结构组织。周期是从同一节点开始并结束的路径。

让我们将广度优先查找（BFS）算法应用到这棵树上：

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-1.png" alt="A tree diagram showing nodes A through G arranged in a hierarchy. Node A is at the root, with children B and C. Node B has children D and E, and node C has children F and G.">

**步骤 1：**

我们从树的根节点 A 开始。我们将 A 添加到队列中并立即将其标记为已访问。

* **队列：** `[A]`
    
* **已访问：** `{A}`
    

**步骤 2：**

我们出队节点 A。我们将它未访问的子节点（节点 B 然后节点 C）添加到队列中并标记为已访问。

* **队列：** `[B, C]`
    
* **已访问：** `{A, B, C}`
    

同一级别的节点添加到队列的顺序由数据结构的实现以及图表现中边（连接）的保存顺序定义。

如果实现是一致的，同一级别节点的具体遍历顺序不会影响算法的正确性。它仍然会逐层访问每个节点。

**步骤 3：**

我们出队节点 B。我们将它未访问的子节点（节点 D 然后节点 E）添加到队列中并标记为已访问。

* **队列：** `[C, D, E]`
    
* **已访问：** `{A, B, C, D, E}`
    

**第 4 步：**

我们出队节点 C。我们将它未访问的子节点（节点 F 然后节点 G）添加到队列中，并将它们标记为已访问。

* **队列：** `[D, E, F, G]`
    
* **已访问：** `{A, B, C, D, E, F, G}`
    

**第 5 步：**

我们出队节点 D。该节点没有任何未访问的子节点，因此访问集合没有任何变化。

* **队列：** `[E, F, G]`
    
* **已访问：** `{A, B, C, D, E, F, G}`
    

**第 6 步：**

我们出队节点 E。该节点没有任何未访问的子节点，因此访问集合没有变化。

* **队列：** `[F, G]`
    
* **已访问：** `{A, B, C, D, E, F, G}`
    

**第 7 步：**

我们出队 `F`。该节点没有任何未访问的子节点，因此访问集没有变化。

* **队列：** `[G]`
    
* **已访问：** `{A, B, C, D, E, F, G}`
    

**第 8 步：**

我们出队 `G`。该节点没有任何未访问的子节点，因此访问集没有变化。

* **队列：** `[]`
    
* **已访问：** `{A, B, C, D, E, F, G}`
    

当队列为空时，遍历完成。

节点按此顺序被遍历：

**A → B → C → D → E → F → G**

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-2.png" alt="The same tree diagram with arrows showing the BFS traversal order: A to B to C to D to E to F to G, demonstrating level-by-level visitation.">

注意算法如何按层访问节点。

我们从节点 A 开始，然后移动到下一层访问节点 B 和 C，再到下一层访问节点 D、E、F 和 G。这就是广度优先查找（BFS）的核心原理。

## 深度优先搜索（DFS）

当广度优先搜索（BFS）首先访问同一层的所有相邻节点时，**深度优先搜索（DFS）** 会沿着每个分支尽可能深入，然后再回溯。

你可以将这个算法想象成通过选择一条特定的路径并沿着它前进，直到你到达死胡同或退出。如果你到达死胡同，你就返回并选择另一条路径。

深度优先搜索（DFS）通常用于解决具有单一方案的谜题、检测图中的周期以及查找连通图组件。

该算法可以使用递归或栈数据结构来实现，以跟踪已访问的节点。

栈遵循 LIFO（后进先出）方法，其中最后添加到栈的节点是第一个从栈中移除的节点。

算法的工作原理如下：

* 从特定节点开始。
    
* 该节点被标记为已访问并添加到栈中。
    
* 当栈不为空时，当前节点被弹出（移除）。这时我们“访问”或处理它（例如，通过打印它的值）。然后，将所有未访问的邻居标记为已访问并添加到栈中。
    

这个算法的一个限制是，它并不总能保证在无权图中查找两个节点之间的最短路径。

让我们来看一个将深度优先搜索（DFS）应用于我们的树示例的例子。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-3.png" alt="The same tree diagram as before, showing nodes A through G in their hierarchical structure, ready for DFS demonstration.">

**步骤 1：**

我们从根节点 A 开始。我们将其标记为已访问并将其添加到栈中。

* **栈：** `[A]`
    
* **已访问：** `{A}`
    

**步骤 2：**

我们从栈中弹出节点 A。

然后，我们将它未访问的子节点，节点 B 和节点 C，添加到栈中。我们将它们按相反顺序添加，先 `C` 再 `B`，这样 `B` 会在栈顶（后进先出），并且会被下一个处理。我们还将它们标记为已访问。

* **栈：** `[C, B]`
    
* **已访问：** `{A, B, C}`
    

**步骤 3：**

我们从栈中弹出节点 B。

然后，我们将其未访问的子节点，节点 `D` 和节点 `E`，以相反的顺序（先 `E` 再 `D`）添加到栈中。我们还将它们标记为已访问。

* **栈：** `[C, E, D]`
    
* **已访问：** `{A, B, C, D, E}`
    

**第 4 步：**

我们从栈中弹出节点 D。该节点没有子节点可添加到栈中。

* **栈：** `[C, E]`
    
* **已访问：** `{A, B, C, D, E}`
    

**第 5 步：**

我们从栈中弹出节点 E。该节点没有子节点可添加到栈中。

* **栈：** `[C]`
    
* **已访问：** `{A, B, C, D, E}`
    

**第 6 步：**

我们弹出节点 C。

然后，我们将它的子节点 node F 和 node G 以相反顺序（先 node G 再 node F）添加到栈中，并将它们标记为已访问。

* **栈：** `[G, F]`
    
* **已访问：** `{A, B, C, D, E, F, G}`
    

**第 7 步：**

我们从栈中弹出节点 F。该节点没有子节点可添加到栈中。

* **栈：** `[G]`
    
* **已访问：** `{A, B, C, D, E, F, G}`
    

**第 8 步：**

我们弹出节点 G。该节点没有子节点可添加到栈中。

* **栈：** `[]`
    
* **已访问：** `{A, B, C, D, E, F, G}`
    

当栈为空时，遍历完成且所有节点均已被访问。

算法按以下顺序访问了节点：

**A → B → D → E → C → F → G**

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-4.png" alt="The tree diagram with numbers showing the DFS traversal order: A(1), B(2), D(3), E(4), C(5), F(6), G(7), demonstrating depth-first exploration of branches.">

注意我们如何从节点 A 开始，然后一直向下遍历树到节点 B，以及节点 D 和 E，之后再向上移动到节点 C，然后是节点 F 和 G。这就是深度优先搜索（DFS）的核心原理，先遍历完整路径再回溯查找其他路径。

在这种分支中，我们使用栈解决了这个示例。备选方案是使用递归实现深度优先搜索（DFS），其中函数处理当前节点，然后为每个未访问的邻居调用自身。函数调用栈隐式地管理后进先出（LIFO）顺序。

广度优先搜索（BFS）和深度优先搜索（DFS）都是遍历图和树的基本算法。广度优先搜索（BFS）按层级逐层探索节点，非常适合查找无权图中的最短路径。另一方面，深度优先搜索（DFS）沿着一个分支尽可能深入，然后回溯，非常适合解决迷宫和检测周期。理解它们的优缺点有助于为特定问题选择合适的算法。

# --questions--

## --text--

以下哪种数据结构通常用于实现标准的广度优先搜索（BFS）算法？

## --answers--

栈

### --feedback--

思考队列如何处理数据以及这如何与按层访问节点相关。

---

队列

---

链表

### --feedback--

思考队列如何处理数据以及这如何与按层访问节点相关。

---

树

### --feedback--

思考队列如何处理数据以及这如何与按层访问节点相关。

## --video-solution--

2

## --text--

以下关于深度优先搜索（DFS）的语句中，哪一条是正确的？

## --answers--

深度优先搜索保证在无权图中查找两个节点之间的最短路径。

### --feedback--

思考深度优先搜索（DFS）用来遍历数据结构的策略。

---

深度优先搜索会在移动到下一层之前访问当前层的所有邻居。

### --feedback--

思考深度优先搜索（DFS）用来遍历数据结构的策略。

---

深度优先搜索总是比 BFS 更节省空间。

### --feedback--

思考深度优先搜索（DFS）用来遍历数据结构的策略。

---

深度优先搜索通常使用递归或栈来实现。

## --video-solution--

4

## --text--

如果你想在无权图中查找从起始节点到目标节点的最短路径，哪种算法是最合适的选择？

## --answers--

广度优先查找（BFS）

---

深度优先搜索（DFS）

### --feedback--

思考广度优先搜索和深度优先搜索的核心遍历策略，以及哪一种能保证找到两个节点之间的最短路径。

---

二分查找

### --feedback--

思考广度优先搜索和深度优先搜索的核心遍历策略，以及哪一种能保证找到两个节点之间的最短路径。

---

归并排序

### --feedback--

思考广度优先搜索和深度优先搜索的核心遍历策略，以及哪一种能保证找到两个节点之间的最短路径。

## --video-solution--

1
