---
id: 68dbc6b7e8f794a2ae69bc74
title: 實作 N-Queens 演算法
challengeType: 27
dashedName: implement-the-n-queens-algorithm
---

# --description--

N 皇后問題要求你將 N 個皇后放置在一個 N×N 的棋盤上，使得沒有兩個皇后互相攻擊（沒有兩個皇后共用同一列、行或對角線）。 

例如，如果有一個 4x4 棋盤，其中一個有效的排列是：

```md
[1, 3, 0, 2]
```

這表示在第 0 列，皇后放置在第 1 行；在第 1 列，皇后放置在第 3 行；在第 2 列，皇后放置在第 0 行；在第 3 列，皇后放置在第 2 行。

從視覺上來看，這種排列方式如下：

```md
. Q . .
. . . Q
Q . . .
. . Q .
```

其中 `Q` 表示一個皇后，`．` 表示一個空格。

在本實驗中，你將使用深度優先搜尋方法實作 N-Queens 問題解決器。


**目標**：完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 你應該有一個名為 `dfs_n_queens` 的函式（程式）。
2. 該函式（程式）應該只接受一個引數：整數 `n`。
3. 如果 `n` 小於 `1`，該函式應該傳回一個空列表（`[]`）。
4. 該函式應傳回一個解決方案列表；每個解決方案本身是一個長度為 `n` 的列表，其中索引為 `i` 的元素是第 `i` 列中皇后的行索引（從 0 開始）。

# --hints--

你應該有一個名為 `dfs_n_queens` 的函式（程式），它接受一個引數。

```js
({ test: () => runPython(`
  import inspect
  assert inspect.isfunction(dfs_n_queens)
  sig = inspect.signature(dfs_n_queens)
  assert len(sig.parameters) == 1
`) })
```

如果 `n` 小於 `1`，該函式應該傳回一個空列表。

```js
({ test: () => runPython(`
  assert dfs_n_queens(0) == []
  assert dfs_n_queens(-1) == []
  assert dfs_n_queens(-5) == []
`) })
```

該函式應該傳回一個解決方案的列表，其中每個解決方案都是長度為 `n` 的列表。

```js
({ test: () => runPython(`
  result = dfs_n_queens(4)
  assert isinstance(result, list)
  for solution in result:
    assert isinstance(solution, list)
    assert len(solution) == 4
`) })
```

`dfs_n_queens(1)` 應該傳回 `[[0]]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(1) == [[0]]
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(2)` 應該傳回 `[]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(2) == []
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(3)` 應該傳回 `[]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(3) == []
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(4)` 應該傳回 `[[1, 3, 0, 2], [2, 0, 3, 1]]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(4) == [[1, 3, 0, 2], [2, 0, 3, 1]]
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(5)` 應該傳回 `[[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
  assert dfs_n_queens(3) == []
`) })
```

`len(dfs_n_queens(5))` 應該是 `10`。

```js
({ test: () => runPython(`
  assert len(dfs_n_queens(5)) == 10
  assert len(dfs_n_queens(6)) == 4
`) })
```

`len(dfs_n_queens(8))` 應該是 `92`。

```js
({ test: () => runPython(`
  assert len(dfs_n_queens(8)) == 92
  assert len(dfs_n_queens(5)) == 10

`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def dfs_n_queens(n):
    if n < 1:
        return []

    results = []

    def is_safe(queens, row, col):
        for r, c in enumerate(queens):
            if c == col or abs(row - r) == abs(col - c):
                return False
        return True

    def dfs(queens):
        row = len(queens)
        if row == n:
            results.append(queens[:])
            return
        for col in range(n):
            if is_safe(queens, row, col):
                queens.append(col)
                dfs(queens)
                queens.pop()

    dfs([])
    return results
```
