---
id: 587d7db5367417b2b2512b95
title: 匹配多種可能的單一字元
challengeType: 1
forumTopicId: 301357
dashedName: match-single-character-with-multiple-possibilities
---

# --description--

你學會了如何匹配字面樣式（`/literal/`）和萬用字元（`/./`）。這些是正規表達式的兩個極端，一個尋找精確匹配，另一個匹配所有內容。有些選項是在這兩個極端之間的平衡。

你可以使用 <dfn>字元類別</dfn> 以一定的彈性搜尋字面樣式。字元類別允許你將想要比對的字元群組放在方括號（`[` 和 `]`）內定義。

例如，你想要匹配 `bag`、`big` 和 `bug`，但不匹配 `bog`。你可以創建正則表達式 `/b[aiu]g/` 來達成此目的。`[aiu]` 是字元類別，只會匹配字元 `a`、`i` 或 `u`。

```js
let bigStr = "big";
let bagStr = "bag";
let bugStr = "bug";
let bogStr = "bog";
let bgRegex = /b[aiu]g/;
bigStr.match(bgRegex);
bagStr.match(bgRegex);
bugStr.match(bgRegex);
bogStr.match(bgRegex);
```

依序，這四個 `match` 呼叫會傳回值 `["big"]`、`["bag"]`、`["bug"]` 和 `null`。

# --instructions--

在你的正規表示式 `vowelRegex` 中使用包含母音（`a`、`e`、`i`、`o`、`u`）的字元類別，以尋找字串 `quoteSample` 中的所有母音。

**注意：** 請確保匹配大寫和小寫的母音。

# --hints--

你應該找到所有 25 個母音。

```js
assert(result.length == 25);
```

你的正規表達式 `vowelRegex` 應該使用字元類別。

```js
assert(/\[.*\]/.test(vowelRegex.source));
```

你的正規表達式 `vowelRegex` 應該使用全域的旗標。

```js
assert(vowelRegex.flags.match(/g/).length == 1);
```

你的正規表達式 `vowelRegex` 應該使用不區分大小寫的旗標。

```js
assert(vowelRegex.flags.match(/i/).length == 1);
```

你的正則表達式不應該匹配任何子音。

```js
assert(!/[b-df-hj-np-tv-z]/gi.test(result.join()));
```

# --seed--

## --seed-contents--

```js
let quoteSample = "Beware of bugs in the above code; I have only proved it correct, not tried it.";
let vowelRegex = /change/; // Change this line
let result = vowelRegex; // Change this line
```

# --solutions--

```js
let quoteSample = "Beware of bugs in the above code; I have only proved it correct, not tried it.";
let vowelRegex = /[aeiou]/gi; // Change this line
let result = quoteSample.match(vowelRegex); // Change this line
```
