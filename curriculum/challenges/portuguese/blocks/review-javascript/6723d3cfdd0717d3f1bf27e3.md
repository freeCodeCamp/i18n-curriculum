---
id: 6723d3cfdd0717d3f1bf27e3
title: Revisão de JavaScript
challengeType: 31
dashedName: review-javascript
---

# --description--

Revise os conceitos abaixo para se preparar para o próximo exame preparatório.


## Trabalhando com HTML, CSS e JavaScript

Enquanto HTML e CSS fornecem a estrutura do site, JavaScript traz interatividade para os sites ao permitir funcionalidades complexas, como manipular a entrada do usuário, animar elementos e até construir aplicações web completas.

## Tipos de Dados em JavaScript

Tipos de dados ajudam o programa a entender o tipo de dado com o qual está trabalhando, seja um número, texto ou outra coisa.

- **Number**: Um número representa tanto valores inteiros quanto de ponto flutuante. Exemplos de inteiros incluem 7, 19 e 90. 
- **Ponto flutuante**: Um número de ponto flutuante é um número com um ponto decimal. Exemplos incluem 3.14, 0.5 e 0.0001.
- **String**: Uma string é uma sequência de caracteres, ou texto, entre aspas. `"I like coding"` e `'JavaScript is fun'` são exemplos de strings.
- **Booleano**: Um booleano representa um dos dois valores possíveis: `true` ou `false`. Você pode usar um booleano para representar uma condição, como `isLoggedIn = true`.
- **Undefined e Null**: Um valor undefined é uma variável que foi declarada mas não recebeu um valor. Um valor null é um valor vazio ou uma variável que intencionalmente recebeu um valor `null`.
- **Objeto**: Um objeto é uma coleção de pares chave-valor. A chave é o nome da propriedade e o valor é o valor da propriedade.

Aqui, o objeto `pet` tem três propriedades ou chaves: `name`, `age` e `type`. Os valores são `Fluffy`, `3` e `dog`, respectivamente.

```js
let pet = {
  name: 'Fluffy',
  age: 3,
  type: 'dog'
};
```

- **Symbol**: O tipo de dado Symbol é um valor único e imutável que pode ser usado como identificador para propriedades de objetos.

No exemplo abaixo, dois símbolos são criados com a mesma descrição, mas eles não são iguais.

```js
const crypticKey1= Symbol('saltNpepper');
const crypticKey2= Symbol('saltNpepper');
console.log(crypticKey1 === crypticKey2); // false
```

- **BigInt**: Quando o número é muito grande para o tipo de dado `Number`, você pode usar o tipo de dado BigInt para representar inteiros de comprimento arbitrário.

Ao adicionar um `n` ao final do número, você pode criar um BigInt.

```js
const veryBigNumber = 1234567890123456789012345678901234567890n;
```

## Variáveis em JavaScript

- Variáveis podem ser declaradas usando a palavra-chave `let`. 

```js
let cityName;
```

- Para atribuir um valor a uma variável, você pode usar o operador de atribuição `=`.

```js
cityName = 'New York';
```

- Variáveis declaradas usando `let` podem ser reatribuídas com um novo valor.

```js
cityName = 'Los Angeles';
console.log(cityName); // Los Angeles
```

- Além de `let`, você também pode usar `const` para declarar uma variável. No entanto, uma variável `const` não pode ser reatribuída a um novo valor.

```js
const cityName = 'New York';
cityName = 'Los Angeles'; // TypeError: Assignment to constant variable.
```

- Variáveis declaradas usando `const` são usadas para declarar constantes, que não podem ser alteradas ao longo do código, como `PI` ou `MAX_SIZE`.

## Convenções de Nomenclatura de Variáveis

- Nomes de variáveis devem ser descritivos e significativos.
- Nomes de variáveis devem ser camelCase como `cityName`, `isLoggedIn` e `veryBigNumber`.
- Nomes de variáveis não devem começar com um número. Eles devem começar com uma letra, `_` ou `$`.
- Nomes de variáveis não devem conter espaços ou caracteres especiais, exceto `_` e `$`.
- Nomes de variáveis não devem ser palavras-chave reservadas.
- Nomes de variáveis são sensíveis a maiúsculas e minúsculas. `age` e `Age` são variáveis diferentes.

## Strings e imutabilidade de String em JavaScript

- Strings são sequências de caracteres entre aspas. Elas podem ser criadas usando aspas simples e aspas duplas.

```js
let correctWay = 'This is a string';
let alsoCorrect = "This is also a string";
```

- Strings são imutáveis em JavaScript. Isso significa que, uma vez que uma string é criada, você não pode alterar os caracteres na string. No entanto, você ainda pode reatribuir strings a um novo valor.

```js
let firstName = 'John';
firstName = 'Jane'; // Reassigning the string to a new value
```

## Concatenação de Strings em JavaScript

- Concatenação é o processo de juntar múltiplas strings ou combinar strings com variáveis que contêm texto. O operador `+` é um dos métodos mais simples e frequentemente usados para concatenar strings. 

```js
let studentName = 'Asad';
let studentAge = 25;
let studentInfo = studentName + ' is ' + studentAge + ' years old.';
console.log(studentInfo); // Asad is 25 years old.
```

- Se você precisar adicionar ou anexar a uma string existente, então você pode usar o operador `+=`. Isso é útil quando você quer construir uma string adicionando mais texto a ela ao longo do tempo.

```js
let message = 'Welcome to programming, ';
message += 'Asad!';
console.log(message); // Welcome to programming, Asad!
```

- Outra forma de concatenar strings é usar o método `concat()`. Este método junta duas ou mais strings.

```js
let firstName = 'John';
let lastName = 'Doe';
let fullName = firstName.concat(' ', lastName);
console.log(fullName); // John Doe
```

## Registrando Mensagens com `console.log()`

- O método `console.log()` é usado para registrar mensagens no console. É uma ferramenta útil para depuração e teste do seu código.

```js
console.log('Hello, World!');
// Output: Hello, World!
```

## Ponto e vírgula em JavaScript

- Ponto e vírgula são usados principalmente para marcar o fim de uma instrução. Isso ajuda o motor JavaScript a entender a separação das instruções individuais, o que é crucial para a execução correta.

```js
let message = 'Hello, World!'; // first statement ends here
let number = 42; // second statement starts here
```

- Os pontos e vírgulas ajudam a prevenir ambiguidades na execução do código e garantem que as instruções sejam corretamente finalizadas.

## Comentários em JavaScript

- Qualquer linha de código que esteja comentada é ignorada pelo motor JavaScript. Comentários são usados para explicar o código, fazer anotações ou desabilitar temporariamente o código.
- Comentários de linha única são criados usando `//`.

```js
// This is a single-line comment and will be ignored by the JavaScript engine
```

- Comentários multilinha são criados usando `/*` para iniciar o comentário e `*/` para finalizar o comentário.

```js
/*
This is a multi-line comment.
It can span multiple lines.
*/
```

## JavaScript como uma Linguagem de Tipagem Dinâmica

- JavaScript é uma linguagem de tipagem dinâmica, o que significa que você não precisa especificar o tipo de dado de uma variável quando a declara. O motor do JavaScript determina automaticamente o tipo de dado com base no valor atribuído à variável.

```js
let error = 404; // JavaScript treats error as a number
error = "Not Found"; // JavaScript now treats error as a string
```

- Outras linguagens, como Java, que não são tipadas dinamicamente resultariam em um erro:

```java
int error = 404; // value must always be an integer
error = "Not Found"; // This would cause an error in Java
```

## Usando o operador `typeof`

- O operador `typeof` é usado para verificar o tipo de dado de uma variável. Ele retorna uma string indicando o tipo da variável.

```js
let age = 25;
console.log(typeof age); // number

let isLoggedIn = true;
console.log(typeof isLoggedIn); // boolean
```

- No entanto, há uma peculiaridade bem conhecida em JavaScript quando se trata de null. O operador `typeof` retorna `object` para valores null.

```js
let user = null;
console.log(typeof user); // object
```

## Noções básicas sobre Strings

- **Definição**: Uma string é uma sequência de caracteres envolvida por aspas simples, aspas duplas ou backticks. Strings são tipos de dados primitivos e são imutáveis. Imutabilidade significa que, uma vez que uma string é criada, ela não pode ser alterada. 
- **Acessando Caracteres de uma String**: Para acessar um caractere de uma string você pode usar a notação de colchetes e passar o número do índice. Um índice é a posição de um caractere dentro de uma string e é baseado em zero.

```js
const developer = "Jessica";
developer[0] // J
```

- **`\n` (Caractere de Nova Linha)**: Você pode criar uma nova linha em uma string usando o caractere de nova linha `\n`.

```js
const poem = "Roses are red,\nViolets are blue,\nJavaScript is fun,\nAnd so are you.";
console.log(poem);
```

- **Escapando Strings**: Você pode escapar caracteres em uma string colocando barras invertidas (`\`) na frente das aspas.

```js
const statement = "She said, \"Hello!\"";
console.log(statement); // She said, "Hello!"
```
  
## Literais de Template (Strings de Template) e Interpolação de Strings

- **Definição**: Template literals são definidos com backticks (`). Eles permitem uma manipulação de strings mais fácil, incluindo a incorporação de variáveis diretamente dentro de uma string, um recurso conhecido como interpolação de strings.

```js
const name = "Jessica";
const greeting = `Hello, ${name}!`; // "Hello, Jessica!"
```

## ASCII, o método `charCodeAt()` e o método `fromCharCode()`

- **ASCII**: ASCII, abreviação de American Standard Code for Information Interchange, é um padrão de codificação de caracteres usado em computadores para representar texto. Ele atribui um valor numérico a cada caractere, que é universalmente reconhecido pelas máquinas. 
- **O Método `charCodeAt()`**: Este método é chamado em uma string e retorna o código ASCII do caractere em um índice especificado.

```js
const letter = "A";
console.log(letter.charCodeAt(0));  // 65
```

- **O Método `fromCharCode()`**: Este método converte um código ASCII em seu caractere correspondente.

```js
const char = String.fromCharCode(65);
console.log(char);  // A
```

## Outros Métodos Comuns de String

- **O Método `indexOf`**: Este método é usado para buscar uma substring dentro de uma string. Se a substring for encontrada, `indexOf` retorna o índice (ou posição) da primeira ocorrência dessa substring. Se a substring não for encontrada, `indexOf` retorna -1, o que indica que a busca não teve sucesso.

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.indexOf("fox")); // 16
console.log(text.indexOf("cat")); // -1
```
  
- **O Método `includes()`**: Este método é usado para verificar se uma string contém uma substring específica. Se a substring for encontrada dentro da string, o método retorna true. Caso contrário, retorna false.

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.includes("fox")); // true
console.log(text.includes("cat")); // false
```

- O **Método `slice()`**: Este método retorna um novo array contendo uma cópia superficial de uma parte do array original, especificada pelos índices de início e fim. O novo array contém referências aos mesmos elementos do array original (não duplicatas). Isso significa que, se os elementos forem primitivos (como números ou strings), os valores são copiados; mas se os elementos forem objetos ou arrays, as referências são copiadas, não os próprios objetos.

```js
const text = "freeCodeCamp";
console.log(text.slice(0, 4));  // "free"
console.log(text.slice(4, 8));  // "Code"
console.log(text.slice(8, 12)); // "Camp"
```

- **O Método `toUpperCase()`**: Este método converte todos os caracteres para letras maiúsculas e retorna uma nova string com todos os caracteres em maiúsculas.

```js
const text = "Hello, world!";
console.log(text.toUpperCase()); // "HELLO, WORLD!"
```

- **O Método `toLowerCase()`**: Este método converte todos os caracteres em uma string para letras minúsculas.

```js
const text = "HELLO, WORLD!"
console.log(text.toLowerCase()); // "hello, world!"
```

- **O Método `replace()`**: Este método permite que você encontre um valor especificado (como uma palavra ou caractere) em uma string e o substitua por outro valor. O método retorna uma nova string com a substituição e deixa a original inalterada porque as strings em JavaScript são imutáveis.

```js
const text = "I like cats";
console.log(text.replace("cats", "dogs")); // "I like dogs"
```
 
- **O Método `repeat()`**: Este método é usado para repetir uma string um número especificado de vezes.

```js
const text = "Hello";
console.log(text.repeat(3)); // "HelloHelloHello"
```

- **O Método `trim()`**: Este método é usado para remover espaços em branco tanto do início quanto do fim de uma string.

```js
const text = "  Hello, world!  ";
console.log(text.trim()); // "Hello, world!"
```

- **O Método `trimStart()`**: Este método remove espaços em branco do início (ou "start") da string.

```js
const text = "  Hello, world!  ";
console.log(text.trimStart()); // "Hello, world!  "
```

- **O Método `trimEnd()`**: Este método remove espaços em branco do final da string.

```js
const text = " Hello, world! ";
console.log(text.trimEnd()); // "  Hello, world!"
```

- **O Método `prompt()`**: Este método do `window` é usado para obter informações de um usuário por meio de uma caixa de diálogo. Este método recebe dois argumentos. O primeiro argumento é a mensagem que aparecerá dentro da caixa de diálogo, normalmente solicitando que o usuário insira informações. O segundo é um valor padrão que é opcional e preencherá o campo de entrada inicialmente.

```js
const answer = window.prompt("What's your favorite animal?"); // This will change depending on what the user answers
```

## Trabalhando com o Tipo de Dados Number

- **Definição**: O tipo `Number` do JavaScript inclui inteiros, números de ponto flutuante, `Infinity` e `NaN`. Números de ponto flutuante são números com ponto decimal. `Infinity` positivo é um número maior que qualquer outro número enquanto `-Infinity` é um número menor que qualquer outro número. `NaN` (`Not a Number`) representa um valor numérico inválido como a string `"Jessica"`.

## Operações Aritméticas Comuns

- **Operador de Adição**: Este operador (`+`) é usado para calcular a soma de dois ou mais números. 
- **Operador de Subtração**: Este operador (`-`) é usado para calcular a diferença entre dois números.
- **Operador de Multiplicação**: Este operador (`*`) é usado para calcular o produto de dois ou mais números. 
- **Operador de Divisão**: Este operador (`/`) é usado para calcular o quociente entre dois números
- **Divisão Por Zero**: Se você tentar dividir por zero, o JavaScript retornará `Infinity`.
- **Operador de Resto**: Este operador(`%`) retorna o resto de uma divisão. 
- **Operador de Exponenciação**: Este operador (`**`) eleva um número à potência de outro.

## Cálculos com Números e Strings

- **Explicação**: Quando você usa o operador `+` com um número e uma string, o JavaScript irá converter o número em uma string e concatenar os dois valores. Quando você usa os operadores `-`, `*` ou `/` com uma string e um número, o JavaScript irá converter a string em um número e o resultado será um número. Para `null` e `undefined`, o JavaScript trata `null` como 0 e `undefined` como `NaN` em operações matemáticas.

```js
const result = 5 + '10';

console.log(result); // 510
console.log(typeof result); // string

const subtractionResult = '10' - 5;
console.log(subtractionResult); // 5
console.log(typeof subtractionResult); // number

const multiplicationResult = '10' * 2;
console.log(multiplicationResult); // 20
console.log(typeof multiplicationResult); // number

const divisionResult = '20' / 2;
console.log(divisionResult); // 10
console.log(typeof divisionResult); // number

const result1 = null + 5;
console.log(result1); // 5
console.log(typeof result1); // number

const result2 = undefined + 5;
console.log(result2); // NaN
console.log(typeof result2); // number
```

## Precedência de Operadores

- **Definição**: A precedência de operadores determina a ordem na qual as operações são avaliadas em uma expressão. Operadores com maior precedência são avaliados antes daqueles com menor precedência. Valores dentro dos parênteses serão avaliados primeiro e multiplicação/divisão terão precedência maior que adição/subtração. Se os operadores tiverem a mesma precedência, então o JavaScript usará associatividade. Associatividade é o que indica ao JavaScript se deve avaliar os operadores da esquerda para a direita ou da direita para a esquerda. Por exemplo, o operador de expoente também é associativo da direita para a esquerda:

```js
const result = (2 + 3) * 4;

console.log(result); // 20

const result2 = 10 - 2 + 3;

console.log(result2); // 11

const result3 = 2 ** 3 ** 2;

console.log(result3); // 512
```

## Operadores de Incremento e Decremento

- **Operador de Incremento**: Este operador é usado para aumentar o valor em um. A notação prefixa `++num` aumenta o valor da variável primeiro, depois retorna um novo valor. A notação pós-fixa `num++` retorna o valor atual da variável primeiro, depois o aumenta.

```js
let x = 5;

console.log(++x); // 6
console.log(x); // 6


let y = 5;

console.log(y++); // 5
console.log(y); // 6
```

- **Operador de Decremento**: Este operador é usado para diminuir o valor em um. A notação prefixa e posfixa funciona da mesma forma que anteriormente com o operador de incremento.

```js
let num = 5;

console.log(--num); // 4
console.log(num--); // 4
console.log(num); // 3
```

## Operadores de Atribuição Composta

- **Operador de Atribuição de Adição (`+=`)**: Este operador realiza a adição dos valores e atribui o resultado à variável.
- **Operador de Atribuição de Subtração (`-=`)**: Este operador realiza a subtração dos valores e atribui o resultado à variável.
- **Operador de Atribuição de Multiplicação (`*=`)**: Este operador realiza a multiplicação dos valores e atribui o resultado à variável.
- **Operador de Atribuição de Divisão (`/=`)**: Este operador realiza a divisão dos valores e atribui o resultado à variável.
- **Operador de Atribuição de Resto (`%=`)**: Este operador divide uma variável pelo número especificado e atribui o resto à variável.
- **Operador de Atribuição de Exponenciação (`**=`)**: Este operador eleva uma variável à potência do número especificado e reatribui o resultado à variável.

## Booleanos e Igualdade

- **Definição de Booleano**: Um booleano é um tipo de dado que pode ter apenas dois valores: `true` ou `false`. 
- **Operador de Igualdade (`==`)**: Este operador usa coerção de tipo antes de verificar se os valores são iguais.

```js
console.log(5 == '5'); // true
```

- **Operador de Igualdade Estrita (`===`)**: Este operador não realiza coerção de tipo e verifica se tanto os tipos quanto os valores são iguais.

```js
console.log(5 === '5'); // false
```

- **Operador de Desigualdade (`!=`)**: Este operador usa coerção de tipo antes de verificar se os valores não são iguais.
- **Operador de Desigualdade Estrita (`!==`)**: Este operador não realiza coerção de tipo e verifica se tanto os tipos quanto os valores não são iguais.

## Operadores de Comparação

- **Operador Maior Que (`>`)**: Este operador verifica se o valor à esquerda é maior que o da direita.
- **Operador Maior Ou Igual (`>=`)**: Este operador verifica se o valor à esquerda é maior ou igual ao da direita.
- **Operador Menor Que (`<`)**: Este operador verifica se o valor à esquerda é menor que o da direita.
- **Operador Menor Que (`<=`) ou Igual**: Este operador verifica se o valor à esquerda é menor ou igual ao da direita.

## Operadores Unários

- **Operador Unário Plus**: Este operador converte seu operando em um número. Se o operando já for um número, ele permanece inalterado.

```js
const str = '42';
const num = +str;

console.log(num); // 42
console.log(typeof num); // number
```

- **Operador de Negação Unária (`-`)**: Este operador nega o operando.

```js
const num = 4;
console.log(-num); // -4
```

- **Operador lógico NOT (`!`)**: Este operador inverte o valor booleano do seu operando. Então, se o operando for `true`, ele se torna `false` e, se for `false`, ele se torna `true`. 

## Operadores Bit a Bit

- **Operador Bitwise AND (`&`)**: Este operador retorna 1 em cada posição de bit para a qual os bits correspondentes de ambos os operandos são 1. 
- **Operador de Atribuição Bit a Bit E (`&=`)**: Este operador realiza uma operação de `bitwise AND` com o número especificado e reatribui o resultado à variável.
- **Operador OR bit a bit (`|`)**: Este operador retorna 1 em cada posição de bit para a qual os bits correspondentes de um ou ambos os operandos são 1. 
- **Operador de Atribuição OR Bit a Bit (`|=`)**: Este operador realiza uma operação de `bitwise OR` com o número especificado e reatribui o resultado à variável.
- **Operador XOR bit a bit (`^`)**: Este operador retorna 1 em cada posição de bit para a qual os bits correspondentes de um dos operandos, mas não de ambos, são 1. 
- **Operador Bitwise NOT (`~`)**: Este operador inverte a representação binária de um número.
- **Operador de Deslocamento à Esquerda (`<<`)**: Este operador desloca todos os bits para a esquerda por um número especificado de posições. 
- **Operador de Deslocamento para Direita (`>>`)**: Este operador desloca todos os bits para a direita. 

## Instruções Condicionais, Valores Truthy, Valores Falsy e o Operador Ternário

- **`if/else if/else`**: Uma declaração `if` recebe uma condição e executa um bloco de código se essa condição for `truthy`. Se a condição for `false`, então ela passa para o bloco `else if`. Se nenhuma dessas condições for `true`, então ela executará a cláusula `else`. Valores `truthy` são quaisquer valores que resultam em `true` quando avaliados em um contexto Booleano como uma declaração `if`. Valores `falsy` são valores que avaliam para `false` em um contexto Booleano. 

```js
const score = 87;

if (score >= 90) {
 console.log('You got an A'); 
} else if (score >= 80) {
 console.log('You got a B'); // You got an B
} else if (score >= 70) {
 console.log('You got a C');
} else {
 console.log('You failed! You need to study more!');
}
```

- **Operador Ternário**: Este operador é frequentemente usado como uma forma mais curta de escrever declarações `if else`. 

```js
const temperature = 30;
const weather = temperature > 25 ? 'sunny' : 'cool';

console.log(`It's a ${weather} day!`); // It's a sunny day!
```

## Operadores Lógicos Binários

- **Operador AND lógico (`&&`)**: Este operador verifica se ambos os operandos são truthy. Se o primeiro valor for truthy, então ele retornará o segundo valor. Se o primeiro valor for falsy, então ele retornará o primeiro valor. 

```js
const result = true && 'hello';

console.log(result); // hello
```

- **Operador OR lógico (`||`)**: Este operador verifica se pelo menos um dos operandos é truthy. Se o primeiro valor for truthy, então ele é retornado. Se o primeiro valor for falsy, então o segundo valor é retornado.
- **Operador de Coalescência Nula (`??`)**: Este operador retornará um valor somente se o primeiro for `null` ou `undefined`.

```js
const userSettings = {
 theme: null,
 volume: 0,
 notifications: false,
};

let theme = userSettings.theme ?? 'light';
console.log(theme); // light
```

## O Objeto `Math`

- **O Método `Math.random()`**: Este método gera um número de ponto flutuante aleatório entre 0 (inclusivo) e 1 (exclusivo). Isso significa que a saída possível pode ser 0, mas nunca alcançará 1. 
- **O Método `Math.max()`**: Este método recebe um conjunto de números e retorna o valor máximo.
- **O Método `Math.min()`**: Este método recebe um conjunto de números e retorna o valor mínimo.
- **O Método `Math.ceil()`**: Este método arredonda um valor para cima até o inteiro mais próximo. 
- **O Método `Math.floor()`**: Este método arredonda um valor para baixo até o inteiro mais próximo. 
- **O Método `Math.round()`**: Este método arredonda um valor para o inteiro mais próximo. 

```js
console.log(Math.round(2.3)); // 2
console.log(Math.round(4.5)); // 5
console.log(Math.round(4.8)); // 5
```

- **O Método `Math.trunc()`**: Este método remove a parte decimal de um número, retornando apenas a porção inteira, sem arredondamento.
- **O Método `Math.sqrt()`**: Este método retornará a raiz quadrada de um número.
- **O Método `Math.cbrt()`**: Este método retornará a raiz cúbica de um número.
- **O Método `Math.abs()`**: Este método retornará o valor absoluto de um número.
- **O Método `Math.pow()`**: Este método recebe dois números e eleva o primeiro à potência do segundo.

## Métodos Numéricos Comuns

- **`isNaN()`**: `NaN` significa "Not-a-Number". É um valor especial que representa um resultado numérico não representável ou indefinido. A propriedade da função `isNaN()` é usada para determinar se um valor é `NaN` ou não. `Number.isNaN()` fornece uma maneira mais confiável de verificar valores `NaN`, especialmente em casos onde a coerção de tipo pode levar a resultados inesperados com a função global `isNaN()`.

```js
console.log(isNaN(NaN));       // true
console.log(isNaN(undefined)); // true
console.log(isNaN({}));        // true

console.log(isNaN(true));      // false
console.log(isNaN(null));      // false
console.log(isNaN(37));        // false


console.log(Number.isNaN(NaN));        // true
console.log(Number.isNaN(Number.NaN)); // true
console.log(Number.isNaN(0 / 0));      // true

console.log(Number.isNaN("NaN"));      // false
console.log(Number.isNaN(undefined));  // false
```

- **O Método `parseFloat()`**: Este método analisa um argumento do tipo string e retorna um número de ponto flutuante. Ele foi projetado para extrair um número do início de uma string, mesmo que a string contenha caracteres não numéricos posteriormente.
- **The `parseInt()` Method**: This method parses a string argument and returns an integer. `parseInt()` stops parsing at the first non-digit it encounters. Para números de ponto flutuante, ele retorna apenas a parte inteira. Se não encontrar um inteiro válido no início da string, retorna `NaN`.
- **O Método `toFixed()`**: Este método é chamado em um número e recebe um argumento opcional, que é o número de dígitos a aparecer após o ponto decimal. Ele retorna uma representação em string do número com o número especificado de casas decimais.

## Comparações e os tipos de dados `null` e `undefined`

- **Comparações e `undefined`**: Uma variável é `undefined` quando foi declarada mas não recebeu um valor. É o valor padrão de variáveis não inicializadas e parâmetros de função que não receberam um argumento. `undefined` se converte em `NaN` em contextos numéricos, o que faz com que todas as comparações numéricas com `undefined` retornem `false`.

```js
console.log(undefined > 0);  // false
console.log(undefined < 0);  // false
console.log(undefined == 0); // false
```

- **Comparações e `null`**: O tipo `null` representa a ausência intencional de um valor. Ao usar o operador de igualdade, `null` e `undefined` são considerados iguais. No entanto, ao usar o operador de igualdade estrita (`===`), que verifica tanto o valor quanto o tipo sem realizar coerção de tipo, `null` e `undefined` não são iguais:

```js
console.log(null == undefined); // true
console.log(null === undefined); // false
```

## Instruções `switch`

- **Definição**: Uma instrução `switch` avalia uma expressão e compara seu valor com uma série de cláusulas `case`. Quando uma correspondência é encontrada, o bloco de código associado a esse case é executado. 

```js
const dayOfWeek = 3; 

switch (dayOfWeek) {
  case 1:
    console.log("It's Monday! Time to start the week strong.");
    break;
  case 2:
    console.log("It's Tuesday! Keep the momentum going.");
    break;
  case 3:
    console.log("It's Wednesday! We're halfway there.");
    break;
  case 4:
    console.log("It's Thursday! Almost the weekend.");
    break;
  case 5:
    console.log("It's Friday! The weekend is near.");
    break;
  case 6:
    console.log("It's Saturday! Enjoy your weekend.");
    break;
  case 7:
    console.log("It's Sunday! Rest and recharge.");
    break;
  default:
    console.log("Invalid day! Please enter a number between 1 and 7.");
}
```

## Funções JavaScript

- Funções são blocos reutilizáveis de código que executam uma tarefa específica.
- Funções podem ser definidas usando a palavra-chave `function` seguida de um nome, uma lista de parâmetros e um bloco de código que executa a tarefa.
- Argumentos são valores passados para uma função quando ela é chamada.
- Quando uma função termina sua execução, ela sempre retornará um valor.
- Por padrão, o valor retornado de uma função é `undefined`.
- A palavra-chave `return` é usada para especificar o valor a ser retornado da função e termina a execução da função.

## Funções Arrow

- Funções arrow são uma forma mais concisa de escrever funções em JavaScript.
- Funções arrow são definidas usando a sintaxe `=>` entre os parâmetros e o corpo da função.
- Ao definir uma arrow function, você não precisa da palavra-chave `function`.
- Se você estiver usando um único parâmetro, pode omitir os parênteses ao redor da lista de parâmetros.
- Se o corpo da função consiste em uma única expressão, você pode omitir as chaves e a palavra-chave `return`.

## Escopo em Programação

- **Escopo global**: Este é o escopo mais externo no JavaScript. Variáveis declaradas no escopo global são acessíveis de qualquer lugar no código e são chamadas de variáveis globais.
- **Escopo local**: Isso se refere a variáveis declaradas dentro de uma função. Essas variáveis são acessíveis apenas dentro da função onde são declaradas e são chamadas de variáveis locais.
- **Escopo de bloco**: Um bloco é um conjunto de instruções delimitadas por chaves `{}` como em declarações `if` ou loops.
- O escopo de bloco com `let` e `const` oferece um controle ainda mais preciso sobre a acessibilidade de variáveis, ajudando a prevenir erros e tornar seu código mais previsível.

## Noções básicas sobre Array em JavaScript

- **Definição**: Um array JavaScript é uma coleção ordenada de valores, cada um identificado por um índice numérico. Os valores em um array JavaScript podem ser de diferentes tipos de dados, incluindo números, strings, booleanos, objetos e até outros arrays. Arrays são contíguos na memória, o que significa que todos os elementos são armazenados em um único bloco contínuo de locais de memória, permitindo indexação eficiente e acesso rápido aos elementos pelo seu índice.

```js
const developers = ["Jessica", "Naomi", "Tom"];
```

- **Acessando Elementos de Arrays**: Para acessar elementos de um array, você precisará referenciar o array seguido pelo número do índice dentro de colchetes. Arrays em JavaScript são indexados a partir do zero, o que significa que o primeiro elemento está no índice 0, o segundo elemento está no índice 1, etc. Se você tentar acessar um índice que não existe no array, o JavaScript retornará `undefined`.

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers[0] // "Jessica"
developers[1] // "Naomi"

developers[10] // undefined
```

- **Propriedade `length`**: Esta propriedade é usada para retornar o número de itens em um array.

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers.length // 3
```

- **Atualizando Elementos em um Array**: Para atualizar um elemento em um array, você usa o operador de atribuição (`=`) para atribuir um novo valor ao elemento em um índice específico.

```js
const fruits = ['apple', 'banana', 'cherry'];
fruits[1] = 'blueberry';

console.log(fruits); // ['apple', 'blueberry', 'cherry']
```

## Arrays Bidimensionais

- **Definition**: A two-dimensional array is essentially an array of arrays. É usado para representar dados que possuem uma estrutura natural em grade, como um tabuleiro de xadrez, uma planilha ou pixels em uma imagem. Para acessar um elemento em um array bidimensional, você precisa de dois índices: um para a linha e um para a coluna. 

```js
const chessboard = [
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']
];

console.log(chessboard[0][3]); // "Q"
```

## Desestruturação de Array

- **Definição**: Desestruturação de array é um recurso do JavaScript que permite extrair valores de arrays e atribuí-los a variáveis de uma forma mais concisa e legível. Ele oferece uma sintaxe conveniente para desempacotar elementos de array em variáveis distintas. 

```js
const fruits = ["apple", "banana", "orange"];

const [first, second, third] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(third); // "orange"
```

- **Sintaxe Rest**: Isso permite capturar os elementos restantes de um array que não foram desestruturados em um novo array. 

```js
const fruits = ["apple", "banana", "orange", "mango", "kiwi"];
const [first, second, ...rest] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(rest); // ["orange", "mango", "kiwi"]
```

## Métodos Comuns de Array

- **Método `push()`**: Este método é usado para adicionar elementos ao final do array e retornará o novo comprimento.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.push("ice cream");

console.log(desserts); // ["cake", "cookies", "pie", "ice cream"];
```

- **Método `pop()`**: Este método é usado para remover o último elemento de um array e retornará esse elemento removido. Se o array estiver vazio, o valor retornado será `undefined`.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.pop();

console.log(desserts); // ["cake", "cookies"];
```

- **Método `shift()`**: Este método é usado para remover o primeiro elemento de um array e retornar esse elemento removido. Se o array estiver vazio, o valor retornado será `undefined`.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.shift();

console.log(desserts); // ["cookies", "pie"];
```

- **Método `unshift()`**: Este método é usado para adicionar elementos ao início do array e retornará o novo comprimento.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.unshift("ice cream");

console.log(desserts); // ["ice cream", "cake", "cookies", "pie"];
```

- **Método `indexOf()`**: Este método é útil para encontrar o primeiro índice de um elemento específico dentro de um array. Se o elemento não puder ser encontrado, ele retornará `-1`.

```js
const fruits = ["apple", "banana", "orange", "banana"];
const index = fruits.indexOf("banana");

console.log(index); // 1
console.log(fruits.indexOf("not found")); // -1
```

- **Método `splice()`**: Este método é usado para adicionar ou remover elementos de qualquer posição em um array. O valor retornado pelo método `splice()` será um array dos itens removidos do array. Se nada foi removido, então um array vazio será retornado. Este método irá modificar o array original, alterando-o no local em vez de criar um novo array. O primeiro argumento especifica o índice no qual começar a modificar o array. O segundo argumento é o número de elementos que você deseja remover. Os argumentos seguintes são os elementos que você deseja adicionar.

```js
const colors = ["red", "green", "blue"];
colors.splice(1, 0, "yellow", "purple");

console.log(colors); // ["red", "yellow", "purple", "green", "blue"]
```

- **Método `includes()`**: Este método é usado para verificar se um array contém um valor específico. Este método retorna `true` se o array contém o elemento especificado e `false` caso contrário. 

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];

console.log(programmingLanguages.includes("Python")); // true
console.log(programmingLanguages.includes("Perl")); // false
```

- **Método `concat()`**: Este método cria um novo array ao mesclar dois ou mais arrays.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.concat("Perl");

console.log(newList); // ["JavaScript", "Python", "C++", "Perl"]
```

- **Método `slice()`**: Este método retorna uma cópia superficial de uma parte do array, começando a partir de um índice especificado ou do array inteiro. Uma cópia superficial copiará a referência para o array em vez de duplicá-lo.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.slice(1);

console.log(newList); // ["Python", "C++"]
```

- **Spread Syntax**: A spread syntax é usada para criar cópias superficiais de um array.

```js
const originalArray = [1, 2, 3];
const shallowCopiedArray = [...originalArray];

shallowCopiedArray.push(4);

console.log(originalArray); // [1, 2, 3]
console.log(shallowCopiedArray); // [1, 2, 3, 4]
```

- **Método `split()`**: Este método divide uma string em um array de substrings e especifica onde cada divisão deve acontecer com base em um separador fornecido. Se nenhum separador for fornecido, o método retorna um array contendo a string original como um único elemento.

```js
const str = "hello";
const charArray = str.split("");

console.log(charArray); // ["h", "e", "l", "l", "o"]
```

- **Método `reverse()`**: Este método inverte um array no local.

```js
const desserts = ["cake", "cookies", "pie"];
console.log(desserts.reverse()); // ["pie", "cookies", "cake"]
```

- **Método `join()`**: Este método concatena todos os elementos de um array em uma única string, com cada elemento separado por um separador especificado. Se nenhum separador for fornecido ou uma string vazia (`""`) for usada, os elementos serão unidos sem nenhum separador.

```js
const reversedArray = ["o", "l", "l", "e", "h"];
const reversedString = reversedArray.join("");

console.log(reversedString); // "olleh"
```

## Noções Básicas de Objetos

- **Definição**: Um objeto é uma estrutura de dados composta por propriedades. Uma propriedade consiste em uma chave e um valor. Para acessar dados de um objeto você pode usar a notação de ponto ou a notação de colchetes.

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};

console.log(person.name);  // Alice
console.log(person["name"]); // Alice
```

Para definir uma propriedade de um objeto existente você pode usar tanto a notação de ponto quanto a notação de colchetes junto com o operador de atribuição.

```js
const person = {
  name: "Alice",
  age: 30
};

person.job = "Engineer"
person["hobby"] = "Knitting"
console.log(person);  // {name: 'Alice', age: 30, job: 'Engineer', hobby: 'Knitting'}
```

## Removendo Propriedades de um Objeto

- **Operador `delete`**: Este operador é usado para remover uma propriedade de um objeto.

```js
const person = {
  name: "Alice",
  age: 30,
  job: "Engineer"
};

delete person.job;

console.log(person.job); // undefined
```

## Verificando se um Objeto possui uma Propriedade

- **Método `hasOwnProperty()`**: Este método retorna um booleano indicando se o objeto possui a propriedade especificada como sua própria propriedade. 

```js
const person = {
  name: "Alice",
  age: 30
};

console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("job")); // false
```

- **Operador `in`**: Este operador retornará `true` se a propriedade existir no objeto. 

```js
const person = {
  name: "Bob",
  age: 25
};

console.log("name" in person);  // true
```

## Acessando Propriedades de Objetos Aninhados

- **Acessando Dados**: Acessar propriedades de objetos aninhados envolve usar a notação de ponto ou a notação de colchetes, assim como acessar propriedades de objetos simples. No entanto, você precisará encadear esses acessadores para aprofundar na estrutura aninhada. 

```js
const person = {
  name: "Alice",
  age: 30,
  contact: {
    email: "alice@example.com",
    phone: {
      home: "123-456-7890",
      work: "098-765-4321"
    }
  }
};

console.log(person.contact.phone.work); // "098-765-4321"
```

## Tipos de Dados Primitivos e Não Primitivos

- **Primitive Data Types**: These data types include numbers, strings, booleans, `null`, `undefined`, and symbols. Esses tipos são chamados de "primitivos" porque representam valores únicos e não são objetos. Valores primitivos são imutáveis, o que significa que, uma vez criados, seu valor não pode ser alterado. 
- **Tipos de Dados Não Primitivos**: Em JavaScript, estes são objetos, que incluem objetos regulares, arrays e funções. Diferentemente dos primitivos, os tipos não primitivos podem conter múltiplos valores como propriedades ou elementos. 

## Métodos de Objeto

- **Definição**: Métodos de objeto são funções que estão associadas a um objeto. Eles são definidos como propriedades de um objeto e podem acessar e manipular os dados do objeto. A palavra-chave `this` dentro do método refere-se ao próprio objeto, permitindo o acesso às suas propriedades.

```js
const person = {
  name: "Bob",
  age: 30,
  sayHello: function() {
    return "Hello, my name is " + this.name;
  }
};

console.log(person.sayHello()); // "Hello, my name is Bob"
```

## Construtor de Objeto

- **Definition**: In JavaScript, a constructor is a special type of function used to create and initialize objects. Ele é invocado com a palavra-chave `new` e pode inicializar propriedades e métodos no objeto recém-criado. O construtor `Object()` cria um novo objeto vazio.

```js
new Object()
```

## Trabalhando com o Operador de Encadeamento Opcional (`?.`)

- **Definição**: Este operador permite acessar propriedades de objetos ou chamar métodos com segurança sem se preocupar se eles existem. 

```js
const user = {
  name: "John",
  profile: {
    email: "john@example.com",
    address: {
      street: "123 Main St",
      city: "Somewhere"
    }
  }
};

console.log(user.profile?.address?.street); // "123 Main St"
console.log(user.profile?.phone?.number);   // undefined
```

## Desestruturação de Objetos

- **Definição**: A desestruturação de objetos permite extrair valores de objetos e atribuí-los a variáveis de uma forma mais concisa e legível. 

```js
const person = { name: "Alice", age: 30, city: "New York" };

const { name, age } = person;

console.log(name); // Alice
console.log(age);  // 30
```

## Trabalhando com JSON

- **Definição**: JSON significa JavaScript Object Notation. É um formato de dados leve, baseado em texto, que é comumente usado para trocar dados entre um servidor e uma aplicação web. 

```js
{
  "name": "Alice",
  "age": 30,
  "isStudent": false,
  "list of courses": ["Mathematics", "Physics", "Computer Science"]
}
```

- **`JSON.stringify()`**: Este método é usado para converter um objeto JavaScript em uma string JSON. Isso é útil quando você quer armazenar ou transmitir dados em um formato que pode ser facilmente compartilhado ou transferido entre sistemas. 

```js
const user = {
  name: "John",
  age: 30,
  isAdmin: true
};

const jsonString = JSON.stringify(user);
console.log(jsonString); // '{"name":"John","age":30,"isAdmin":true}'
```

- **`JSON.parse()`**: Este método converte uma string JSON de volta em um objeto JavaScript. Isso é útil quando você recupera dados JSON de um servidor web ou do localStorage e precisa manipular os dados na sua aplicação. 

```js
const jsonString = '{"name":"John","age":30,"isAdmin":true}';
const userObject = JSON.parse(jsonString);

// result: { name: 'John', age: 30, isAdmin: true }
console.log(userObject);
```


## Trabalhando com Loops

- **`for` Loop**: Este tipo de loop é usado para repetir um bloco de código um certo número de vezes. Este loop é dividido em três partes: a declaração de inicialização, a condição e a declaração de incremento/decremento. A declaração de inicialização é executada antes do loop começar. Ela é tipicamente usada para inicializar uma variável contador. A condição é avaliada antes de cada iteração do loop. Uma iteração é uma única passagem pelo loop. Se a condição for `true`, o bloco de código dentro do loop é executado. Se a condição for `false`, o loop para e você passa para o próximo bloco de código. A declaração de incremento/decremento é executada após cada iteração do loop. Ela é tipicamente usada para incrementar ou decrementar a variável contador.

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

- **Loop `for...of`**: Este tipo de loop é usado quando você precisa iterar sobre valores de um iterável. Exemplos de iteráveis são arrays e strings.

```js
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num);
}
```

- **Loop `for...in`**: Este tipo de loop é melhor usado quando você precisa iterar sobre as propriedades de um objeto. Este loop irá percorrer todas as propriedades enumeráveis de um objeto, incluindo propriedades herdadas e propriedades não numéricas.

```js
const fruit = {
  name: 'apple',
  color: 'red',
  price: 0.99
};

for (const prop in fruit) {
  console.log(fruit[prop]);
}
```

- **Loop `while`**: Este tipo de loop executará um bloco de código enquanto a condição for `true`.

```js
let i = 5;

while (i > 0) {
  console.log(i);
  i--;
}
```

- **Loop `do...while`**: Este tipo de loop executará o bloco de código pelo menos uma vez antes de verificar a condição.

```js
let userInput;

do {
  userInput = prompt("Please enter a number between 1 and 10");
} while (Number(userInput) < 1 || Number(userInput) > 10);

alert("You entered a valid number!");
```

## Declarações `break` e `continue`

- **Definição**: Uma declaração `break` é usada para sair de um loop antecipadamente, enquanto uma declaração `continue` é usada para pular a iteração atual de um loop e passar para a próxima.

```js
// Example of break statement
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, and 4

// Example of continue statement 
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    continue;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, 4, 6, 7, 8, and 9
```

## Construtor de String e Método `toString()`

- **Definição**: Um objeto string é usado para representar uma sequência de caracteres. Objetos string são criados usando a função construtora `String`, que envolve o valor primitivo em um objeto. 

```js
const greetingObject = new String("Hello, world!");

console.log(typeof greetingObject); // "object"
```

- **Método `toString()`**: Este método converte um valor para sua representação em string. É um método que você pode usar para números, booleanos, arrays e objetos.

```js
const num = 10;
console.log(num.toString()); // "10"

const arr = [1, 2, 3];
console.log(arr.toString()); // "1,2,3"
```

Este método aceita um radix opcional que é um número de 2 a 36. Esse radix representa a base, como base 2 para binário ou base 8 para octal. Se o radix não for especificado, o padrão é base 10, que é decimal.


```js
const num = 10;
console.log(num.toString(2)); // "1010"(binary)
```

## Construtor Number

- **Definição**: O construtor `Number` é usado para criar um objeto número. O objeto número contém algumas propriedades e métodos úteis como os métodos `isNaN` e `toFixed`. Na maioria das vezes, você usará o construtor `Number` para converter outros tipos de dados para o tipo de dado número.

```js
const myNum = new Number("34");
console.log(typeof myNum); // "object"

const num = Number('100');
console.log(num); // 100

console.log(typeof num); // number
```

## Melhores Práticas para Nomear Variáveis e Funções

- **camelCasing**: Por convenção, desenvolvedores JavaScript usam camel casing para nomear variáveis e funções. Camel casing é quando a primeira palavra está toda em minúsculas e as palavras seguintes começam com letra maiúscula. Ex. `isLoading`.

- **Nomeando Booleanos**: Para variáveis booleanas, é uma prática comum usar prefixos como "is", "has" ou "can". 

```js
let isLoading = true;
let hasPermission = false;
let canEdit = true;
```

- **Nomeando Funções**: Para funções, o nome deve indicar claramente o que a função faz. Para funções que retornam um booleano (frequentemente chamadas de predicados), você pode usar os mesmos prefixos "is", "has" ou "can". Quando você tem funções que recuperam dados, é comum começar com a palavra "get". Quando você tem funções que definem dados, é comum começar com a palavra "set". Para funções manipuladoras de eventos, você pode usar o prefixo "handle" ou o sufixo "Handler". 

```js
function getUserData() { /* ... */ }

function isValidEmail(email) { /* ... */ }

function getProductDetails(productId) { /* ... */ }

function setUserPreferences(preferences) { /* ... */ }

function handleClick() { /* ... */ }
```

- **Nomeando Variáveis Dentro de Loops**: Ao nomear variáveis iteradoras em loops, é comum usar letras simples como `i`, `j` ou `k`.

```js
for (let i = 0; i < array.length; i++) { /* ... */ }
```

## Trabalhando com Arrays Esparsos

- **Definition**: It is possible to have arrays with empty slots. Slots vazios são definidos como slots que não contêm nada.  This is different than array slots with the value of `undefined`. Esses tipos de arrays são conhecidos como sparse arrays. 

```js
const sparseArray = [1, , , 4];
console.log(sparseArray.length); // 4
```
  
## Linters e Formatters

- **Linters**: Um linter é uma ferramenta de análise estática de código que sinaliza erros de programação, bugs, erros de estilo e construções suspeitas. Um exemplo de linter comum seria o ESLint. 
- **Formatadores**: Formatadores são ferramentas que formatam automaticamente seu código para aderir a um guia de estilo específico. Um exemplo de formatador comum é o Prettier.

## Gerenciamento de Memória

- **Definição**: Gerenciamento de memória é o processo de controlar a memória, alocando-a quando necessário e liberando-a quando não é mais necessária. JavaScript usa gerenciamento automático de memória. Isso significa que JavaScript (mais especificamente, o motor JavaScript no seu navegador) cuida da alocação e desalocação de memória para você. Você não precisa liberar explicitamente a memória no seu código. Esse processo automático é frequentemente chamado de "garbage collection."

## Closures

- **Definição**: Um closure é uma função que tem acesso a variáveis em seu escopo léxico externo (envolvente), mesmo depois que a função externa retornou. 

```js
function outerFunction(x) {
  let y = 10;
  function innerFunction() {
    console.log(x + y);
  }
  return innerFunction;
}

let closure = outerFunction(5);
closure(); // 15
```

## Palavra-chave `var` e Hoisting

- **Definição**: `var` foi a forma original de declarar variáveis antes de 2015. Mas havia alguns problemas que vinham com `var` em termos de escopo, redeclaração e mais. Por isso é que a programação moderna em JavaScript usa `let` e `const` em vez disso.
- **Redefinindo Variáveis com `var`**: Se você tentar redefinir uma variável usando `let`, você receberá um `SyntaxError`. Mas com `var`, é permitido redefinir uma variável. 

```js
// Uncaught SyntaxError: Identifier 'num' has already been declared 
let num = 19;
let num = 18;

var myNum = 5;
var myNum = 10; // This is allowed and doesn't throw an error

console.log(myNum) // 10
```

- **`var` e Escopo**: Variáveis declaradas com `var` dentro de um bloco (como uma declaração `if` ou um loop `for`) ainda são acessíveis fora desse bloco. 

```js
if (true) {
  var num = 5;
}
console.log(num); // 5
```

- **Hoisting**: Este é o comportamento padrão do JavaScript de mover declarações para o topo de seus respectivos escopos durante a fase de compilação antes que o código seja executado. Quando você declara uma variável usando a palavra-chave `var`, o JavaScript eleva a declaração para o topo do seu escopo. 

```js
console.log(num); // undefined
var num = 5;
console.log(num); // 5
```

Quando você declara uma função usando a sintaxe de declaração de função, tanto o nome da função quanto o corpo da função são içados. Isso significa que você pode chamar uma função antes de declará-la no seu código.

```js
sayHello(); // "Hello, World!"

function sayHello() {
  console.log("Hello, World!");
}
```

Declarações de variáveis feitas com `let` ou `const` são içadas, mas não são inicializadas e você não pode acessá-las antes da declaração real no seu código. Esse comportamento é frequentemente referido como a "zona morta temporal".

```js
console.log(num); // Throws a ReferenceError
let num = 10;
```

## Trabalhando com Imports, Exports e Modules

- **Módulo**: Esta é uma unidade autônoma de código que encapsula funções, classes ou variáveis relacionadas. Para criar um módulo, você escreve seu código JavaScript em um arquivo separado.
- **Exports**: Quaisquer variáveis, funções ou classes que você deseja tornar disponíveis para outras partes da sua aplicação precisam ser explicitamente exportadas usando a palavra-chave `export`. Existem dois tipos de exportação: named export e default export.
- **Imports**: Para usar os itens exportados em outra parte da sua aplicação, você precisa importá-los usando a palavra-chave `import`. Os tipos podem ser importação nomeada, importação padrão e importação de namespace.

```js
// Within a file called math.js, we export the following functions:

// Named export
export function add(num1, num2) {
  return num1 + num2;
}

// Default export
export default function subtract(num1, num2) {
  return num1 - num2;
}

// Within another file, we can import the functions from math.js.

// Named import - This line imports the add function.
// The name of the function must exactly match the one exported from math.js.
import { add } from './math.js';

// Default import - This line imports the subtract function.
// The name of the function can be anything.
import subtractFunc from './math.js';

// Namespace import - This line imports everything from the file.
import * as Math from './math.js';

console.log(add(5, 3)); // 8
console.log(subtractFunc(5, 3)); // 2
console.log(Math.add(5, 3)); // 8
console.log(Math.subtract(5, 3)); // 2
```

## Funções de Callback e o Método `forEach`

- **Definição**: Em JavaScript, uma função callback é uma função que é passada como argumento para outra função e é executada após a função principal ter terminado sua execução. 
- **Método `forEach()`**: Este método é usado para iterar sobre cada elemento em um array e executar uma operação em cada elemento. A função de callback em `forEach` pode receber até três argumentos: o elemento atual, o índice do elemento atual e o array no qual `forEach` foi chamado. 

```js
const numbers = [1, 2, 3, 4, 5];

// Result: 2 4 6 8 10
numbers.forEach((number) => {
  console.log(number * 2);
});
```

## Funções de Ordem Superior

- **Definição**: Uma função de ordem superior recebe uma ou mais funções como argumentos e retorna uma função ou valor como resultado.

```js
function operateOnArray(arr, operation) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(operation(arr[i]));
  }
  return result;
}

function double(x) {
  return x * 2;
}

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = operateOnArray(numbers, double);
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
```

- **Método `map()`**: Este método é usado para criar um novo array aplicando uma função dada a cada elemento do array original. A função de callback pode aceitar até três argumentos: o elemento atual, o índice do elemento atual e o array no qual `map` foi chamado. 

```js
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);

console.log(numbers); // [1, 2, 3, 4, 5]
console.log(doubled); // [2, 4, 6, 8, 10]
```

- **Método `filter()`**: Este método é usado para criar um novo array com elementos que passam em um teste especificado, tornando-o útil para extrair itens seletivamente com base em critérios. Assim como o método `map`, a função callback para o método `filter` aceita os mesmos três argumentos: o elemento atual sendo processado, o índice e o array.

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter((num) => num % 2 === 0);

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

- **`reduce()` Method**: This method is used to process an array and condense it into a single value. Este valor único pode ser um número, uma string, um objeto ou até mesmo outro array.  The `reduce()` method works by applying a function to each element in the array, in order, passing the result of each calculation on to the next. Esta função é frequentemente chamada de função reducer. A função reducer recebe dois parâmetros principais: um acumulador e o valor atual. O acumulador é onde você armazena o resultado acumulado das suas operações e o valor atual é o elemento do array que está sendo processado.

```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0
);

console.log(sum); // 15
```

## Encadeamento de Métodos

- **Definição**: Encadeamento de métodos é uma técnica de programação que permite chamar múltiplos métodos no mesmo objeto em uma única linha de código. Essa técnica pode tornar seu código mais legível e conciso, especialmente ao realizar uma série de operações no mesmo objeto. 

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

## Trabalhando com o método `sort`

- **Definição**: O método `sort` é usado para ordenar os elementos de um array e retornar uma referência ao array ordenado. Nenhuma cópia é feita neste caso porque os elementos são ordenados no local.

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();

console.log(fruits); // ["Apple", "Banana", "Mango", "Orange"]
```

Se você precisar ordenar números, então será necessário passar uma função de comparação. O método `sort` converte os elementos em strings e depois compara suas sequências de valores de unidades de código UTF-16. Unidades de código UTF-16 são os valores numéricos que representam os caracteres na string. Exemplos de unidades de código UTF-16 são os números 65, 66 e 67 que representam os caracteres "A", "B" e "C" respectivamente. Então o número 200 aparece antes do número 3 em um array, porque a string "200" vem antes da string "3" ao comparar suas unidades de código UTF-16.

```js
const numbers = [414, 200, 5, 10, 3];

numbers.sort((a, b) => a - b);

console.log(numbers); // [3, 5, 10, 200, 414]
```

Os parâmetros `a` e `b` são os dois elementos que estão sendo comparados. A função de comparação deve retornar um valor negativo se `a` deve vir antes de `b`, um valor positivo se `a` deve vir depois de `b` e zero se `a` e `b` forem iguais.

## Trabalhando com os métodos `every` e `some`

- **`every()` Method**: This method tests whether all elements in an array pass a test implemented by a provided function. O método `every()` retorna `true` se a função fornecida retornar `true` para todos os elementos do array. Se algum elemento falhar no teste, o método retorna imediatamente `false` e para de verificar os elementos restantes.

```js
const numbers = [2, 4, 6, 8, 10];
const hasAllEvenNumbers = numbers.every((num) => num % 2 === 0);

console.log(hasAllEvenNumbers); // true
```

- **`some()` Method**: This method checks if at least one element passes the test. O método `some()` retorna `true` assim que encontra um elemento que passa no teste. Se nenhum elemento passar no teste, ele retorna `false`.

```js
const numbers = [1, 3, 5, 7, 8, 9];
const hasSomeEvenNumbers = numbers.some((num) => num % 2 === 0);

console.log(hasSomeEvenNumbers); // true
```

## Trabalhando com o DOM e as Web APIs

- **API**: Uma API (Application Programming Interface) é um conjunto de regras e protocolos que permitem que aplicações de software se comuniquem entre si e troquem dados de forma eficiente. 
- **Web API**: Web APIs são projetadas especificamente para aplicações web. Esses tipos de APIs são frequentemente divididos em duas categorias principais: browser APIs e third-party APIs.
- **Browser APIs**: Essas APIs expõem dados do navegador. Como desenvolvedor web, você pode acessar e manipular esses dados usando JavaScript.
- **APIs de Terceiros**: Elas não são incorporadas ao navegador por padrão. Você precisa obter o código delas de alguma forma. Normalmente, elas terão documentação detalhada explicando como usar seus serviços. Um exemplo é a `Google Maps API`, que você pode usar para exibir mapas interativos no seu site.
- **DOM**: O DOM significa Document Object Model. É uma interface de programação que permite interagir com documentos HTML. Com o DOM, você pode adicionar, modificar ou excluir elementos em uma página web. A raiz da árvore DOM é o elemento `html`. É o contêiner de nível superior para todo o conteúdo de um documento HTML. Todos os outros nós são descendentes desse nó raiz. Em seguida, abaixo do nó raiz, encontramos outros nós na hierarquia. Um nó pai é um elemento que contém outros elementos. Um nó filho é um elemento que está contido dentro de outro elemento.
- **Interface `navigator`**: Isso fornece informações sobre o ambiente do navegador, como a string do agente do usuário, a plataforma e a versão do navegador. Uma string do agente do usuário é uma string de texto que identifica o navegador e o sistema operacional em uso.
- **Interface `window`**: Isso representa a janela do navegador que contém o documento DOM. Ela fornece métodos e propriedades para interagir com a janela do navegador, como redimensionar a janela, abrir novas janelas e navegar para diferentes URLs.

## Trabalhando com os métodos `querySelector()`, `querySelectorAll()` e `getElementById()`

- **Método `getElementById()`**: Este método é usado para obter um objeto que representa o elemento HTML com o `id` especificado. Lembre-se que os IDs devem ser únicos em cada documento HTML, então este método retornará apenas um objeto Element.

```html
<div id="container"></div>
```

```js
const container = document.getElementById("container");
```

- **Método `querySelector()`**: Este método é usado para obter o primeiro elemento no documento HTML que corresponde ao seletor CSS passado como argumento.

```html
<section class="section"></section>
```

```js
const section = document.querySelector(".section");
```

- **Método `querySelectorAll()`**: Você pode usar este método para obter uma lista de todos os elementos DOM que correspondem a um seletor CSS específico.

```html
<ul class="ingredients">
  <li>Sugar</li>
  <li>Milk</li>
  <li>Eggs</li>
</ul>
```

```js
const ingredients = document.querySelectorAll('ul.ingredients li');
```

## Trabalhando com os métodos `innerText()`, `innerHTML()`, `createElement()` e `textContent()`

- **Propriedade `innerHTML`**: Esta é uma propriedade do `Element` que é usada para definir ou atualizar partes da marcação HTML.

```html
<div id="container">
  <!-- Add new elements here -->
</div>
```

```js
const container = document.getElementById("container");
container.innerHTML = '<ul><li>Cheese</li><li>Tomato</li></ul>';
```

- **Método `createElement`**: Isso é usado para criar um elemento HTML. 

```js
const img = document.createElement("img");
```

- **`innerText`**: Isso representa o conteúdo de texto visível do elemento HTML e seus descendentes. 

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.innerText);
```

- **`textContent`**: Isso retorna o conteúdo de texto simples de um elemento, incluindo todo o texto dentro de seus descendentes.

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.textContent);
```

## Trabalhando com os Métodos `appendChild()` e `removeChild()`

- **Método `appendChild()`**: Este método é usado para adicionar um nó ao final da lista de filhos de um nó pai especificado.

```html
<ul id="desserts">
  <li>Cake</li>
  <li>Pie</li>
</ul>
```

```js
const dessertsList = document.getElementById("desserts");
const listItem = document.createElement("li");

listItem.textContent = "Cookies";
dessertsList.appendChild(listItem);
```

- **Método `removeChild()`**: Este método é usado para remover um nó do DOM.

```html
<section id="example-section">
  <h2>Example sub heading</h2>
  <p>first paragraph</p>
  <p>second paragraph</p>
</section>
```

```js
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");

sectionEl.removeChild(lastParagraph);
```

## Trabalhe com o Método `setAttribute`

- **Definição**: Este método é usado para definir o atributo para um determinado elemento. Se o atributo já existir, o valor é atualizado. Caso contrário, um novo atributo é adicionado com um valor.

```html
<p id="para">I am a paragraph</p>
```

```js
const para = document.getElementById("para");
para.setAttribute("class", "my-class");
```

## Objeto de Evento

- **Definição**: O objeto `Event` é uma carga útil que é acionada quando um usuário interage com sua página web de alguma forma. Essas interações podem ser qualquer coisa, desde clicar em um botão ou focar em um input até sacudir o dispositivo móvel deles. Todos os objetos `Event` terão a propriedade `type`. Esta propriedade revela o tipo de evento que acionou o payload, como keydown ou click. Esses valores corresponderão aos mesmos valores que você pode passar para `addEventListener()`, onde você pode capturar e utilizar o objeto `Event`.

## Métodos `addEventListener()` e `removeEventListener()`

- **Método `addEventListener`**: Este método é usado para escutar eventos. Ele recebe dois argumentos: o evento que você quer escutar e uma função que será chamada quando o evento ocorrer. Alguns exemplos comuns de eventos seriam eventos de clique, eventos de entrada e eventos de alteração.

```js
const btn = document.getElementById("btn");

btn.addEventListener("click", () => alert("You clicked the button"));
```

- **Método `removeEventListener`**: Este método é usado para remover um event listener que foi previamente adicionado a um elemento usando o método `addEventListener`. Isso é útil quando você quer parar de escutar um evento específico em um elemento.

```js
const bodyEl = document.querySelector("body");
const para = document.getElementById("para");
const btn = document.getElementById("btn");

let isBgColorGrey = true;

function toggleBgColor() {
  bodyEl.style.backgroundColor = isBgColorGrey ? "blue" : "grey";
  isBgColorGrey = !isBgColorGrey;
}

btn.addEventListener("click", toggleBgColor);

para.addEventListener("mouseover", () => {
  btn.removeEventListener("click", toggleBgColor);
});
```

- **Manipuladores de Eventos Inline**: Manipuladores de eventos inline são atributos especiais em um elemento HTML usados para executar código JavaScript quando um evento ocorre. No JavaScript moderno, manipuladores de eventos inline não são considerados uma boa prática. É preferível usar o método `addEventListener`.

```html
<button onclick="alert('Hello World!')">Show alert</button>
```

## DOMContentLoaded

- **Definição**: O evento `DOMContentLoaded` é disparado quando tudo no documento HTML foi carregado e analisado. Se você tiver folhas de estilo externas ou imagens, o evento `DOMContentLoaded` não aguardará que elas sejam carregadas. Ele aguardará apenas o carregamento do HTML.

## Trabalhando com `style` e `classList`

- **Propriedade `Element.style`**: Esta propriedade é uma propriedade somente leitura que representa o estilo inline de um elemento. Você pode usar esta propriedade para obter ou definir o estilo de um elemento.

```js
const paraEl = document.getElementById("para");
paraEl.style.color = "red";
```

- **Propriedade `Element.classList`**: Esta propriedade é somente leitura e pode ser usada para adicionar, remover ou alternar classes em um elemento.

```js
// Example adding a class
const paraEl = document.getElementById("para");
paraEl.classList.add("highlight");

// Example removing a class
paraEl.classList.remove("blue-background");

// Example toggling a class
const menu = document.getElementById("menu");
const toggleBtn = document.getElementById("toggle-btn");

toggleBtn.addEventListener("click", () => menu.classList.toggle("show"));
```


## Trabalhando com os métodos `setTimeout` e `setInterval`

- **Método `setTimeout()`**: Este método permite atrasar uma ação por um tempo especificado. 

```js
setTimeout(() => {
 console.log('This runs after 3 seconds'); 
}, 3000);
```

- **Método `setInterval()`**: Este método continua executando um trecho de código repetidamente em um intervalo definido. Como `setInterval()` continua executando a função fornecida no intervalo especificado, você pode querer pará-lo. Para isso, você deve usar o método `clearInterval()`.

```js
setInterval(() => {
 console.log('This runs every 2 seconds');
}, 2000);

// Example using clearInterval
const intervalID = setInterval(() => {
 console.log('This will stop after 5 seconds');
}, 1000);

setTimeout(() => {
 clearInterval(intervalID);
}, 5000);
```

## O Método `requestAnimationFrame()`

- **Definição**: Este método permite que você agende a próxima etapa da sua animação antes da próxima repintura da tela, resultando em uma experiência fluida e visualmente atraente. A próxima repintura da tela refere-se ao momento em que o navegador atualiza a exibição visual da página web. Isso acontece várias vezes por segundo, tipicamente cerca de 60 vezes (ou 60 quadros por segundo) na maioria dos monitores.

```js
function animate() {
 // Update the animation...
 // for example, move an element, change a style, and more.
 update();
 // Request the next frame
 requestAnimationFrame(animate);
}
```

## API de Animações Web

- **Definição**: A Web Animations API permite que você crie e controle animações diretamente dentro do JavaScript. 

```js
const square = document.querySelector('#square');

const animation = square.animate(
 [{ transform: 'translateX(0px)' }, { transform: 'translateX(100px)' }],
 {
   duration: 2000, // makes animation lasts 2 seconds
   iterations: Infinity, // loops indefinitely
   direction: 'alternate', // moves back and forth
   easing: 'ease-in-out', // smooth easing
 }
);
```

## A API Canvas

- **Definição**: A Canvas API é uma ferramenta poderosa que permite manipular gráficos diretamente dentro do seu arquivo JavaScript. Para trabalhar com a Canvas API, você primeiro precisa fornecer um elemento `canvas` no HTML. Esse elemento atua como uma superfície de desenho que você pode manipular com os métodos de instância e propriedades das interfaces da Canvas API. Essa API possui interfaces como `HTMLCanvasElement`, `CanvasRenderingContext2D`, `CanvasGradient`, `CanvasPattern` e `TextMetrics` que contêm métodos e propriedades que você pode usar para criar gráficos no seu arquivo JavaScript.

```html
<canvas id="my-canvas" width="400" height="400"></canvas>
```

```js
const canvas = document.getElementById('my-canvas');

// Access the drawing context of the canvas. 
// "2d" allows you to draw in two dimensions 
const ctx = canvas.getContext('2d');

// Set the background color
ctx.fillStyle = 'crimson';

// Draw a rectangle
ctx.fillRect(1, 1, 150, 100);
```

## Abrindo e Fechando Diálogos e Modais com JavaScript

- **Definições de Modal e Diálogo**: Diálogos permitem que você exiba informações importantes ou ações para os usuários. Com o elemento de diálogo embutido no HTML, você pode facilmente criar esses diálogos (tanto modais quanto não modais) em suas aplicações web. Um diálogo modal é um tipo de diálogo que obriga o usuário a interagir com ele antes de poder acessar o restante da aplicação ou página web. Em contraste, um diálogo não modal permite que o usuário continue interagindo com outras partes da página ou aplicação mesmo quando o diálogo está aberto. Ele não impede o acesso ao restante do conteúdo.
- **Método `showModal()`**: Este método é usado para abrir um modal.

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');

openButton.addEventListener('click', () => {
  dialog.showModal();
});
```

- **Método `close()`**: Este método é usado para fechar o modal.

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
   <button id="close-modal">Close Modal</button>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');
const closeButton = document.getElementById('close-modal');

openButton.addEventListener('click', () => {
  dialog.show();
});

closeButton.addEventListener('click', () => {
  dialog.close();
});
```

## O Evento de Mudança

- **Definição**: O evento change é um evento especial que é disparado quando o usuário modifica o valor de certos elementos de entrada. Exemplos incluem quando uma caixa de seleção ou um botão de opção é marcado. Ou quando o usuário faz uma seleção em algo como um seletor de data ou menu suspenso.

```html
<label>
  Choose a programming language:
  <select class="language" name="language">
    <option value="">---Select One---</option>
    <option value="JavaScript">JavaScript</option>
    <option value="Python">Python</option>
    <option value="C++">C++</option>
  </select>
</label>

<p class="result"></p>
```

```js 
const selectEl = document.querySelector(".language");
const result = document.querySelector(".result");

selectEl.addEventListener("change", (e) => {
  result.textContent = `You enjoy programming in ${e.target.value}.`;
});
```

## Propagação de Eventos

- **Definição**: Event bubbling, ou propagação, refere-se a como um evento "bubbles up" para objetos pai quando acionado.

## Delegação de Eventos

- **Definição**: Delegação de eventos é o processo de escutar eventos que subiram para um elemento pai, em vez de tratá-los diretamente no elemento que os disparou. 

## JavaScript e Acessibilidade

### Atributos Comuns de Acessibilidade ARIA

- **Atributo `aria-expanded`**: Usado para transmitir o estado de um recurso de alternância (ou divulgação) para usuários de leitores de tela.
- **Atributo `aria-haspopup`**: Este estado é usado para indicar que um elemento interativo acionará um elemento pop-up quando ativado. Você só pode usar o atributo `aria-haspopup` quando o pop-up tiver um dos seguintes papéis: `menu`, `listbox`, `tree`, `grid` ou `dialog`. O valor de `aria-haspopup` deve ser um desses papéis ou `true`, que é o mesmo que `menu`.
- **Atributo `aria-checked`**: Este atributo é usado para indicar se um elemento está no estado marcado. Ele é mais comumente usado ao criar caixas de seleção personalizadas, botões de rádio, interruptores e caixas de lista.
- **Atributo `aria-disabled`**: Este estado é usado para indicar que um elemento está desabilitado apenas para pessoas que utilizam tecnologias assistivas, como leitores de tela.
- **Atributo `aria-selected`**: Este estado é usado para indicar que um elemento está selecionado. Você pode usar este estado em controles personalizados como uma interface com abas, uma listbox ou uma grade.
- **Atributo `aria-controls`**: Usado para associar um elemento a outro elemento que ele controla. Isso ajuda pessoas que usam tecnologias assistivas a entender a relação entre os elementos.
- **Atributo `hidden`**: Oculta painéis inativos tanto para usuários visuais quanto para usuários de tecnologias assistivas.

### Trabalhando com Live Regions e Conteúdo Dinâmico

- **Atributo `aria-live`**: Torna parte de uma página da web uma região dinâmica, o que significa que quaisquer atualizações dentro dessa área serão anunciadas por um leitor de tela para que os usuários não percam mudanças importantes.
- **Valor `polite`**: A maioria das regiões dinâmicas usa este valor. Este valor significa que a atualização não é urgente, então o leitor de tela pode esperar até terminar qualquer anúncio atual ou o usuário completar sua ação atual antes de anunciar a atualização.

Aqui está um exemplo de uma região ao vivo que é atualizada dinamicamente por JavaScript:

```html
<div aria-live="polite" id="status"></div>
```

```js
const statusEl = document.getElementById("status");
statusEl.textContent = "Your file has been successfully uploaded.";
```

- **Atributo `contenteditable`**: Transforma o elemento em um editor ao vivo, permitindo que os usuários atualizem seu conteúdo como se fosse um campo de texto. Quando não houver um rótulo ou título visível para uma região contenteditable, adicione um nome acessível usando o atributo `aria-label` para ajudar os usuários de leitores de tela a entender o propósito da área editável.

```html
<div contenteditable="true" aria-label="Note editor">
  Editable content goes here
</div>
```

## Eventos `focus` e `blur`

- **Evento `blur`**: Disparado quando um elemento perde o foco.

```js
element.addEventListener("blur", () => {
  // Handle when user leaves the element
});
```

- **Evento `focus`**: Disparado quando um elemento recebe foco.

```js
element.addEventListener("focus", () => {
  // Handle when user enters the element
});
```

## Tipos Comuns de Mensagens de Erro

- **SyntaxError**: Esses erros acontecem quando você escreve algo incorretamente no seu código, como esquecer um parêntese ou um colchete. Pense nisso como um erro gramatical em uma frase.

```js
const arr = ["Beau", "Quincy" "Tom"]
```

- **ReferenceError**: Existem vários tipos de Reference Errors, acionados de maneiras diferentes. O primeiro tipo de reference error seria variáveis não definidas. Outro exemplo de ReferenceError é tentar acessar uma variável, declarada com `let` ou `const`, antes de ela ter sido definida.

```js
console.log(num);
const num = 50;
```

- **TypeError**: Esses erros ocorrem quando você tenta realizar uma operação em um tipo errado.

```js
const developerObj = {
  name: "Jessica",
  country: "USA",
  isEmployed: true
};

developerObj.map()
```

- **RangeError**: Esses erros acontecem quando seu código tenta usar um valor que está fora do intervalo que o JavaScript pode manipular. 

```js
const arr = [];
arr.length = -1; 
```

## A Declaração `throw`

- **Definição**: A declaração `throw` em JavaScript é usada para lançar uma exceção definida pelo usuário. Uma exceção em programação é quando um evento inesperado acontece e interrompe o fluxo normal do programa.

```js
function validateNumber(input) {
  if (typeof input !== "number") {
    throw new TypeError("Expected a number, but received " + typeof input);
  }
  return input * 2;
}
```

## `try...catch...finally`

- **Definição**: O bloco `try` é usado para envolver código que pode gerar um erro. Ele atua como um espaço seguro para tentar algo que pode falhar. O bloco `catch` captura e trata erros que ocorrem no bloco try. Você pode usar o objeto de erro dentro do catch para inspecionar o que deu errado. O bloco `finally` é executado após os blocos try e catch, independentemente de um erro ter ocorrido. Ele é comumente usado para tarefas de limpeza, como fechar arquivos ou liberar recursos.

```js
function processInput(input) {
  if (typeof input !== "string") {
    throw new TypeError("Input must be a string.");
  }

  return input.toUpperCase();
}

try {
  console.log("Starting to process input...");
  const result = processInput(9);
  console.log("Processed result:", result);
} catch (error) {
  console.error("Error occurred:", error.message);
} 
```

## Técnicas de Depuração

- **Declaração `debugger`**: Esta declaração permite que você pause seu código em uma linha específica para investigar o que está acontecendo no programa.

```js
let firstNumber = 5;
let secondNumber = 10;

debugger; // Code execution pauses here
let sum = firstNumber + secondNumber;

console.log(sum);
```

- **Breakpoints**: Breakpoints permitem que você pause a execução do seu código em uma linha específica de sua escolha. Após a pausa, você pode inspecionar variáveis, avaliar expressões e examinar a pilha de chamadas.
- **Watchers**: Expressões de observação permitem que você monitore os valores de variáveis ou expressões enquanto o código é executado mesmo que estejam fora do escopo atual.
- **Profiling**: O profiling ajuda você a identificar gargalos de desempenho permitindo capturar screenshots e registrar o uso da CPU, chamadas de função e tempo de execução.
- **`console.dir()`**: Este método é usado para exibir uma lista interativa das propriedades de um objeto JavaScript especificado. Ele gera uma listagem hierárquica que pode ser expandida para ver todas as propriedades aninhadas.

```js
console.dir(document);
```

- **`console.table()`**: Este método exibe dados tabulares como uma tabela no console. Ele recebe um argumento obrigatório, que deve ser um array ou um objeto, e um argumento opcional para especificar quais propriedades (colunas) exibir.

## Expressões Regulares e Métodos Comuns

- **Definição**: Expressões Regulares, ou Regex, são usadas para criar um "padrão", que você pode então usar para verificar uma string, extrair texto e mais.

```js
const regex = /freeCodeCamp/;
```

- **Método `test()`**: Este método aceita uma string, que é a string a ser testada para correspondências contra a expressão regular. Este método retornará um booleano se a string corresponder ao regex.

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test); // false
```

- **Método `match()`**: Este método aceita uma expressão regular, embora você também possa passar uma string que será convertida em uma expressão regular. O método `match` retorna o array de correspondência para a string. 

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match); // ["freeCodeCamp"]
```

- **Método `replace()`**: Este método aceita dois argumentos: a expressão regular para corresponder (ou uma string) e a string para substituir a correspondência (ou uma função para executar em cada correspondência). 

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced); // "freeCodeCamp is rly kewl"
```

- **Método `replaceAll`**: Este método é usado para substituir todas as ocorrências de um padrão especificado por uma nova string. Este método lançará um erro se você fornecer uma expressão regular sem o modificador global.

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

- **Método `matchAll`**: Este método é usado para recuperar todas as correspondências de uma expressão regular dada em uma string, incluindo grupos de captura, e as retorna como um iterador. Um iterador é um objeto que permite percorrer (ou "iterar sobre") uma coleção de itens.

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

## Modificadores de Expressão Regular

- **Definição**: Modificadores, frequentemente chamados de "flags", modificam o comportamento de uma expressão regular. 
- **Bandeira `i`**: Esta bandeira faz com que uma regex ignore maiúsculas e minúsculas.

```js
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
```

- **Flag `g`**: Esta flag, ou modificador global, permite que sua expressão regular corresponda a um padrão mais de uma vez. 

```js
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
```

- **Definição de Anchor**: O `^` anchor, no início da expressão regular, indica "corresponder ao início da string". O `$` anchor, no final da expressão regular, indica "corresponder ao final da string". 

```js
const start = /^freeCodeCamp/i;
const end = /freeCodeCamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
```

- **Flag `m`**: Os âncoras procuram o início e o fim de toda a string. Mas você pode fazer uma regex lidar com múltiplas linhas com a flag `m`, ou o modificador multi-linha.

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const str = `I love 
freecodecamp
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true

```

- **Flag `d`**: Esta flag expande as informações que você obtém em um objeto de correspondência. 

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

- **Bandeira `u`**: Isso expande a funcionalidade de uma expressão regular para permitir que ela corresponda a caracteres unicode especiais. A bandeira `u` dá acesso a classes especiais como a `Extended_Pictographic` para corresponder à maioria dos emojis. Também existe uma bandeira `v`, que expande ainda mais a funcionalidade da correspondência unicode.
- **Flag `y`**: O modificador sticky se comporta de forma muito semelhante ao modificador global, mas com algumas exceções. A maior delas é que uma expressão regular global começará a partir de `lastIndex` e buscará em todo o restante da string por outra correspondência, mas uma expressão regular sticky retornará null e resetará o `lastIndex` para 0 se não houver uma correspondência imediatamente no `lastIndex` anterior.
- **Flag `s`**: O modificador de linha única permite que um caractere curinga, representado por um `.` em regex, corresponda a quebras de linha - tratando efetivamente a string como uma única linha de texto.

## Classes de Caracteres

- **Curinga `.`**: Classes de caracteres são uma sintaxe especial que você pode usar para corresponder a conjuntos ou subconjuntos de caracteres. A primeira classe de caracteres que você deve aprender é a classe curinga. O curinga é representado por um ponto e corresponde a QUALQUER caractere único EXCETO quebras de linha. Para permitir que a classe curinga corresponda a quebras de linha, lembre-se de que você precisaria usar a flag `s`.

```js
const regex = /a./;
```

- **`\d`**: Isso irá corresponder a todos os dígitos (`0-9`) em uma string.

```js
const regex = /\d/;
```

- **`\w`**: Isso é usado para corresponder a qualquer caractere de palavra (`a-z0-9_`) em uma string. Um caractere de palavra é definido como qualquer letra, de a a z, ou um número de 0 a 9, ou o caractere underscore.

```js
const regex = /\w/;
```

- **`\s`**: A classe de espaço em branco `\s`, representada por uma barra invertida seguida de um `s`. Essa classe de caracteres corresponderá a qualquer espaço em branco, incluindo quebras de linha, espaços, tabulações e caracteres especiais de espaço unicode.
- **Negando Classes de Caracteres Especiais**: Para negar uma dessas classes de caracteres, em vez de usar uma letra minúscula após a barra invertida, você pode usar o equivalente em maiúscula. O exemplo a seguir não corresponde a um caractere numérico. Em vez disso, corresponde a qualquer caractere único que NÃO seja um caractere numérico. 

```js
const regex = /\D/;
```

- **Classes de Caracteres Personalizadas**: Você pode criar classes de caracteres personalizadas colocando o caractere que deseja corresponder dentro de um conjunto de colchetes.

```js
const regex = /[abcdf]/;
```

## Asserções Lookahead e Lookbehind

- **Definição**: Asserções de lookahead e lookbehind permitem que você combine padrões específicos com base na presença ou ausência de padrões ao redor.
- **Positive Lookahead Assertion**: This assertion will match a pattern when the pattern is followed by another pattern. Para construir um lookahead positivo, você precisa começar com o padrão que deseja corresponder. Então, use parênteses para envolver o padrão que você quer usar como sua condição. Após o parêntese de abertura, use `?=` para definir esse padrão como um lookahead positivo.

```js
const regex = /free(?=code)/i;
```

- **Negative Lookahead Assertion**: Este é um tipo de condição usada em expressões regulares para verificar que um determinado padrão não ocorre à frente na string.

```js
const regex = /free(?!code)/i;
```

- **Positive Lookbehind Assertion**: Esta asserção corresponderá a um padrão somente se ele for precedido por outro padrão específico, sem incluir o padrão precedente na correspondência.

```js
const regex = /(?<=free)code/i;
```

- **Negative Lookbehind Assertion**: Esta asserção garante que um padrão não seja precedido por outro padrão específico. Ela corresponde apenas se o padrão especificado não for imediatamente precedido pela sequência dada, sem incluir a sequência precedente na correspondência.

```js
const regex = /(?<!free)code/i;
```

## Quantificadores de Regex

- **Definição**: Quantificadores em expressões regulares especificam quantas vezes um padrão (ou parte de um padrão) deve aparecer. Eles ajudam a controlar o número de ocorrências de caracteres ou grupos em uma correspondência. O exemplo a seguir é usado para corresponder ao caractere anterior exatamente quatro vezes.

```js
const regex = /^\d{4}$/;
```

- **`*`** : Corresponde a 0 ou mais ocorrências do elemento precedente.
- **`+`**: Corresponde a 1 ou mais ocorrências do elemento precedente.
- **`?`**: Corresponde a 0 ou 1 ocorrência do elemento precedente.
- **`{n}`**: Corresponde exatamente a n ocorrências do elemento precedente.
- **`{n,}`**: Corresponde a n ou mais ocorrências do elemento precedente.
- **`{n,m}`**: Corresponde entre n e m ocorrências do elemento precedente.

## Grupos de Captura e Referências Retroativas

- **Grupos de Captura**: Um grupo de captura permite que você "capture" uma parte da string correspondida para usar como precisar. Grupos de captura são definidos por parênteses contendo o padrão a ser capturado, sem caracteres iniciais como um lookahead.

```js
const regex = /free(code)camp/i;
```

- **Backreferences**: Uma backreference em expressões regulares refere-se a uma forma de reutilizar uma parte do padrão que foi correspondida anteriormente na mesma expressão. Ela permite que você se refira a um grupo capturado (uma parte do padrão entre parênteses) pelo seu número. Por exemplo, `$1` refere-se ao primeiro grupo capturado.

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

## Validando Formulários com JavaScript

- **Constraint Validation API**: Certos elementos HTML, como os elementos `textarea` e `input`, expõem uma API de validação de restrições. Essa API permite que você afirme que o valor fornecido pelo usuário para esse elemento passa por qualquer validação em nível HTML que você tenha escrito, como comprimento mínimo ou correspondência de padrão. 
- **Método `checkValidity()`**: Este método retorna `true` se o elemento corresponder a toda a validação HTML (baseada em seus atributos) e `false` se falhar.

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.setCustomValidity("You must use a .com email.")
  }
})
```

- **Método `reportValidity()`**: Este método informa ao navegador que o `input` é inválido.

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.reportValidity();
  }
})
```

- **Propriedade `validity`**: Esta propriedade é usada para obter ou definir o estado de validade dos controles de formulário (como `<input>`, `<select>`, etc.) e fornece informações sobre se a entrada do usuário atende às restrições definidas para esse elemento (por exemplo, campos `required`, restrições de padrão, comprimento máximo, etc.).

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.validity);
})
```

- **Propriedade `patternMismatch`**: Isso será `true` se o valor não corresponder ao padrão de expressão regular especificado.

## Método `preventDefault()`

- **Definição**: Todo evento que é disparado no DOM possui algum tipo de comportamento padrão. O evento de clique em uma checkbox alterna o estado dessa checkbox, por padrão. Pressionar a barra de espaço em um botão focado ativa o botão. O método `preventDefault()` nesses objetos `Event` impede que esse comportamento aconteça.

```js
button.addEventListener('click', (event) => {
  // Prevent the default button click behavior  
  event.preventDefault(); 
  alert('Button click prevented!');
});
```

## Enviando Formulários

- **Definição**: Existem três maneiras de um formulário ser enviado. A primeira é quando o usuário clica em um botão no formulário que possui o atributo `type` definido como `submit`. A segunda é quando o usuário pressiona a tecla `Enter` em qualquer campo `input` editável no formulário. A terceira é por meio de uma chamada JavaScript aos métodos `requestSubmit()` ou `submit()` do elemento `form`.
- **Atributo `action`**: O atributo `action` deve conter uma URL ou um caminho relativo para o domínio atual. Esse valor determina para onde o formulário tenta enviar os dados - se você não definir um atributo `action`, o formulário enviará os dados para a URL da página atual. 

```html
<form action="https://freecodecamp.org">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **Atributo `method`**: Este atributo aceita um `HTTP` method padrão, como `GET` ou `POST`, e usa esse método ao fazer a requisição para a URL da ação. Quando um método não é definido, o formulário usará por padrão uma requisição `GET`. Os dados no formulário serão codificados na URL como pares `name=value` e anexados à URL da ação como parâmetros de consulta.

```html
<form action="/data" method="POST">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **Atributo `enctype`**: O elemento `form` aceita um atributo `enctype`, que representa o tipo de codificação a ser usado para os dados. Esse atributo aceita apenas três valores: `application/x-www-form-urlencoded` (que é o padrão, enviando os dados como um corpo de formulário codificado em URL), `text/plain` (que envia os dados em texto simples, em pares `name=value` separados por quebras de linha) ou `multipart/form-data`, que é especificamente para lidar com formulários com upload de arquivos.

## O Objeto `date()` e Métodos Comuns

- **Definição**: O objeto `date()` é usado para criar, manipular e formatar datas e horários em JavaScript. No exemplo a seguir, a palavra-chave `new` é usada para criar uma nova instância do objeto `Date` e o objeto `Date` é então atribuído à variável `now`. Se você registrar o valor de `now` no console, verá a data e hora atuais com base no relógio do sistema do computador que executa o código.

```js
const now = new Date();
```

- **`Date.now()` Method**: This method is used to get the current date and time. `Date.now()` returns the number of milliseconds since January 1, 1970, 00:00:00 UTC. Isto é conhecido como o tempo epoch do Unix. O tempo epoch Unix é uma forma comum de representar datas e horários em sistemas computacionais porque é um inteiro que pode ser facilmente armazenado e manipulado. UTC significa Tempo Universal Coordenado, que é o padrão de tempo principal pelo qual o mundo regula relógios e tempo.
- **Método `getDate()`**: Este método é usado para obter um dia do mês com base na data atual. `getDate()` retornará um valor inteiro entre 1 e 31, dependendo do dia do mês. Se a data for inválida, ele retornará `NaN` (Not a Number).

```js
const now = new Date();
const date = now.getDate();
console.log(date); // 15
```

- **Método `getMonth()`**: Este método é usado para obter o mês. O mês é baseado em zero, então janeiro é 0, fevereiro é 1 e assim por diante. Neste exemplo, a saída é 2, que corresponde a março. Se o mês for inválido, ele retornará `NaN`.

```js
const now = new Date();
const month = now.getMonth();
console.log(month); // 2
```

- **Método `getFullYear()`**: Este método é usado para obter o ano completo. Se o ano for inválido, ele retornará `NaN`.

```js
const now = new Date();
const year = now.getFullYear();
console.log(year); // 2024
```

## Diferentes Formas de Format Date

- **`toISOString()` Method**: This method is used to format the date in an extended `ISO` (ISO 8601) format. ISO 8601 é um padrão internacional para representar datas e horários. O formato é `YYYY-MM-DDTHH:mm:ss.sssZ`.

```js
const date = new Date();
console.log(date.toISOString());
```

- **Método `toLocaleDateString()`**: Este método é usado para formatar a data com base na localidade do usuário.

```js
const date = new Date();
console.log(date.toLocaleDateString());  // 11/23/2024
```

O método `toLocaleDateString()` aceita dois parâmetros opcionais: locales e options.

O parâmetro locales é uma string que representa o locale a ser usado. Por exemplo, você pode passar `"en-US"` para inglês (Estados Unidos) ou `"fr-FR"` para francês (França). Se você não passar um parâmetro locales, o locale padrão será usado. O segundo parâmetro opcional é o parâmetro options. Esse parâmetro é um objeto que permite especificar o formato da string de data.

```js
const date = new Date();
const options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(date.toLocaleDateString("en-GB", options)); // Saturday, November 23, 2024
```

## Construtor `Audio` e Métodos Comuns

- **Definição**: O construtor `Audio`, como outros construtores, é uma função especial chamada com a palavra-chave `new`. Ele retorna um `HTMLAudioElement`, que você pode usar para reproduzir áudio para o usuário ou anexar ao DOM para que o usuário controle por conta própria. Quando você chama o construtor, pode opcionalmente passar uma URL como o (único) argumento. Essa URL deve apontar para a fonte do arquivo de áudio que você deseja reproduzir. Ou, se precisar alterar a fonte dinamicamente, pode atribuir a URL à propriedade `src` do elemento de áudio retornado.
- **Método `play()`**: Este método é usado com os elementos `audio` ou `video` para iniciar a reprodução da mídia.

```js
const audio = document.getElementById('audio');

// Starts playing the audio
audio.play();  
```

- **Método `pause()`**: Este método é usado com os elementos `audio` ou `video` para pausar a reprodução da mídia.

```js
function pauseAudio() {
  const audio = document.getElementById('myAudio');
  audio.pause();  // Pauses the audio playback
}
```

- **Método `addTextTrack()`**: Este método permite especificar uma faixa de texto para associar ao elemento de mídia - o que é especialmente útil para adicionar legendas a um vídeo.
- **Método `fastSeek()`**: Este método permite que você mova a posição de reprodução para um tempo específico dentro da mídia.

## Diferentes Formatos de Áudio e Vídeo

- **MIME type**: A MIME type, standing for Multipurpose Internet Mail Extensions, is a standardized way to programmatically indicate a file type. O tipo MIME pode informar a uma aplicação, como seu navegador, como lidar com um arquivo específico. No caso de áudio e vídeo, o tipo MIME indica que é um formato multimídia que pode ser incorporado na página web.
- **Elemento `source`**: Isso é usado para especificar um tipo de arquivo e fonte - e pode incluir vários tipos diferentes usando múltiplos elementos source. Quando você faz isso, o navegador determinará o melhor formato para usar no ambiente atual do usuário.
- **MP3**: Este é um tipo de formato de arquivo digital usado para armazenar música, áudio ou som. É uma versão comprimida de uma gravação sonora que torna o tamanho do arquivo menor, facilitando o armazenamento e o compartilhamento. Um arquivo MP3 tem o tipo MIME audio/mp3
- **MP4**: Um MP4 é um tipo de formato de arquivo digital usado para armazenar vídeo e áudio. Ele serve como um contêiner que contém tanto o vídeo (imagens) e o som (música ou fala) em um único arquivo. Um MP4 pode ter o tipo MIME audio/mp4 OU video/mp4, dependendo se é um arquivo de vídeo ou apenas de áudio. 

## codecs

- **Definition**: A codec, short for "encoder/decoder", is an algorithm or software that can convert audio and video between analogue and digital formats. Codecs podem ser especificados como parte do tipo MIME. A sintaxe básica para definir um codec é adicionar um ponto e vírgula após o tipo de mídia, depois `codecs=` e o codec.

## API do HTMLMediaElement

- **Definição**: A API `HTMLMediaElement` é usada para controlar o comportamento dos elementos de áudio e vídeo na sua página. Ela estende a interface base `HTMLElement`, então você tem acesso às propriedades base assim como a esses métodos úteis. Exemplos desses métodos incluem `play()`, `fastSeek()` e `pause()`.

## API de Captura de Mídia e Streams

- **Definição**: A Media Capture and Streams API, ou a MediaStream API, é usada para capturar áudio e vídeo do seu dispositivo. Para usar a API, você precisa criar o objeto `MediaStream`. Você poderia fazer isso com o construtor, mas ele não estaria vinculado ao hardware do usuário. Em vez disso, a propriedade `mediaDevices` do objeto `global` navigator possui um método `getUserMedia()` para você usar.

```js
window.navigator.mediaDevices.getUserMedia({
  audio: true,
  video: {
    width: {
      min: 1280,
      ideal: 1920,
      max: 3840
    },
    height: {
      min: 720,
      ideal: 1080,
      max: 2160
    }
  }
});
```

## API de Captura de Tela

- **Definição**: A Screen Capture API é usada para gravar a tela do usuário. Esta API é acessada chamando o método `getDisplayMedia()` do objeto `mediaDevices` e consumindo o fluxo de mídia retornado.

## API de Gravação MediaStream

- **Definição**: A MediaStream Recording API funciona em conjunto com as MediaStreams APIs, permitindo que você grave um MediaStream (ou até mesmo um `HTMLMediaElement` diretamente).

## API de Media Source Extensions

- **tópico**: A API Media Source Extensions é o que permite que você passe diretamente o feed da webcam de um usuário para um elemento de vídeo com a propriedade `srcObject`.

## Web Audio API

- **Definição**: A Web Audio API que alimenta tudo que é audível na web. Esta API inclui objetos importantes como um `AudioBuffer` (que representa um Buffer contendo especificamente dados de áudio) e o `AudioContext`. 

## Conjuntos em JavaScript

- Um `Set` é uma opção embutida para gerenciar coleções de dados. 
- Conjuntos garantem que cada valor nele apareça apenas uma vez, tornando-os úteis para eliminar duplicatas de um array ou para lidar com coleções de valores distintos.
- Você pode criar um `Set` usando o construtor `Set()`:

```js
const set = new Set([1, 2, 3, 4, 5]);
console.log(set); // Set { 1, 2, 3, 4, 5 }
```

- Conjuntos podem ser manipulados usando esses métodos: 
  
  - `add()`: Adiciona um novo elemento ao `Set`.
  - `delete()`: Remove um elemento do `Set`.
  - `has()`: Verifica se um elemento existe no `Set`.
  - `clear()`: Remove todos os elementos do `Set`.

## Weaksets em JavaScript

- `WeakSet` é uma coleção de objetos que permite armazenar objetos mantidos de forma fraca.

## Conjuntos vs WeakSets

- Ao contrário dos Sets, um `WeakSet` não suporta tipos primitivos como números ou strings.
- Um `WeakSet` armazena apenas objetos e as referências a esses objetos são "fracas", o que significa que, se o objeto não estiver sendo usado em nenhum outro lugar do seu código, ele é removido automaticamente para liberar memória.

## Mapas em JavaScript

- Um `Map` é um objeto embutido que armazena pares chave-valor assim como um objeto. 
- Maps diferem dos objetos padrão do JavaScript pela sua capacidade de permitir chaves de qualquer tipo, incluindo objetos e funções.
- Um `Map` oferece melhor desempenho em relação ao objeto padrão quando se trata de adições e remoções frequentes de pares chave-valor.
- Você pode criar um `Map` usando o construtor `Map()`:

```js
const map = new Map([
  ['flower', 'rose'],
  ['fruit', 'apple'],
  ['vegetable', 'carrot']
]);
console.log(map); // Map(3) { 'flower' => 'rose', 'fruit' => 'apple', 'vegetable' => 'carrot' }
```

- Mapas podem ser manipulados usando esses métodos:

  - `set()`: Adiciona um novo par chave-valor ao `Map`.
  - `get()`: Recupera o valor de uma chave do `Map`.
  - `delete()`: Remove um par chave-valor do `Map`.
  - `has()`: Verifica se uma chave existe no `Map`.
  - `clear()`: Remove todos os pares chave-valor do `Map`.

## WeakMaps em JavaScript

- Um `WeakMap` é uma coleção de pares chave-valor assim como `Map`, mas com referências fracas para as chaves. As chaves devem ser um objeto e os valores podem ser qualquer coisa que você quiser.

## Mapas vs WeakMaps

- WeakMaps são semelhantes a WeakSets no sentido de que eles armazenam apenas objetos e as referências a esses objetos são "fracas."

## Armazenamento Persistente

- **Definição**: Armazenamento persistente refere-se a uma forma de salvar dados de modo que eles permaneçam disponíveis mesmo após a energia ser desligada ou o dispositivo ser reiniciado.

## Criar, Ler, Atualizar, Deletar (CRUD)

- **Criar**: Isso se refere ao processo de criar novos dados. Por exemplo, em um aplicativo web, isso pode ser quando um usuário adiciona um novo post a um blog.
- **Ler**: Esta é a operação onde os dados são recuperados de um banco de dados. Por exemplo, quando você visita um post de blog ou visualiza seu perfil em um site, você está realizando uma operação de leitura para buscar e exibir os dados armazenados no banco de dados.
- **Atualizar**: Isso envolve modificar dados existentes no banco de dados. Um exemplo seria editar uma postagem no blog ou atualizar as informações do seu perfil.
- **Excluir**: Esta é a operação que remove dados de um banco de dados. Por exemplo, quando você exclui uma postagem de blog ou uma conta, você está realizando uma operação de exclusão.

## Métodos HTTP

- **Definição**: HTTP significa Hypertext Transfer Protocol e é a base para a comunicação de dados na web. Existem métodos HTTP que definem as ações que podem ser realizadas em recursos na web. Os métodos comuns são GET, POST, PUT, PATCH e DELETE.
- **Método `GET`**: Isso é usado para buscar dados de um servidor. 
- **Método `POST`**: Isso é usado para enviar dados a um servidor que cria um novo recurso.
- **Método `PUT`**: Isso é usado para atualizar um recurso substituindo-o completamente.
- **Método `PATCH`**: Isso é usado para atualizar parcialmente um recurso.
- **Método `DELETE`**: Isso é usado para remover registros de um banco de dados. 

## Propriedades `localStorage` e `sessionStorage`

- **Web Storage API**: Esta API fornece um mecanismo para os navegadores armazenarem pares chave-valor diretamente no navegador, permitindo que os desenvolvedores armazenem informações que podem ser usadas em diferentes recarregamentos de página e sessões. Os dois principais componentes da Web Storage API são as propriedades `localStorage` e `sessionStorage`.
- **Propriedade `localStorage`**: `localStorage` é a parte da Web Storage API que permite que os dados persistam mesmo depois que a janela do navegador é fechada ou a página é atualizada. Esses dados permanecem disponíveis até que sejam explicitamente removidos pela aplicação ou pelo usuário.
- **Método `localStorage.setItem()`**: Este método é usado para armazenar um par chave-valor em `localStorage`.

```js
localStorage.setItem('username', 'Jessica');
```

- **Método `localStorage.getItem()`**: Este método é usado para recuperar o valor de uma chave específica do `localStorage`.

```js
localStorage.setItem('username', 'codingRules');

let username = localStorage.getItem('username');
console.log(username); // codingRules
```

- **Método `localStorage.removeItem()`**: Este método é usado para remover um item específico do `localStorage` usando sua chave.

```js
localStorage.removeItem('username');
```

- **Método `localStorage.clear()`**: Este método é usado para limpar todos os dados armazenados em `localStorage`.

```js
localStorage.clear();
```

- **Propriedade `sessionStorage`**: Armazena dados que duram apenas para a sessão atual e são apagados quando a aba ou janela do navegador é fechada.
- **Método `sessionStorage.setItem()`**: Este método é usado para armazenar um par chave-valor em `sessionStorage`.

```js
sessionStorage.setItem('cart', '3 items');
```

- **Método `sessionStorage.getItem()`**: Este método é usado para recuperar o valor de uma chave específica do `sessionStorage`.

```js
sessionStorage.setItem('cart', '3 items');

let cart = sessionStorage.getItem('cart');
console.log(cart); // '3 items'
```

- **Método `sessionStorage.removeItem()`**: Este método é usado para remover um item específico do `sessionStorage` usando sua chave.

```js
sessionStorage.removeItem('cart');
```

- **Método `sessionStorage.clear()`**: Este método é usado para limpar todos os dados armazenados em `sessionStorage`.

```js
sessionStorage.clear();
```

## Trabalhando com Cookies

- **Definition**: Cookies, also known as web cookies or browser cookies, are small pieces of data that a server sends to a user's web browser. Esses cookies são armazenados no dispositivo do usuário e enviados de volta ao servidor com as solicitações subsequentes. Cookies são essenciais para ajudar aplicações web a manter o estado e lembrar informações do usuário, o que é especialmente importante já que HTTP é um protocolo sem estado.
- **Session Cookies**: These cookies only last for the duration of the user's session on the website. Uma vez que o usuário fecha o navegador ou a aba, o cookie de sessão é excluído. Esses cookies são normalmente usados para tarefas como manter um usuário logado durante a visita.
- **Cookies Seguros**: Esses cookies são enviados apenas via HTTPS, garantindo que não possam ser interceptados por um invasor durante o trânsito.
- **Cookies HttpOnly**: Esses cookies não podem ser acessados ou modificados pelo JavaScript executado no navegador, tornando-os mais seguros contra ataques de cross-site scripting (XSS).
- **Cabeçalho Set-Cookie**: Quando você visita um site, o servidor pode enviar um cabeçalho Set-Cookie na resposta HTTP. Esse cabeçalho instrui seu navegador a salvar um cookie com informações específicas. Por exemplo, ele pode armazenar um ID único que ajuda o site a reconhecê-lo na próxima vez que você visitar.  
Você pode definir manualmente um cookie em JavaScript usando `document.cookie`:

```js
document.cookie = "organization=freeCodeCamp; expires=Fri, 31 Dec 2021 23:59:59 GMT; path=/";
```

Para deletar um cookie, você pode definir sua data de expiração para um momento no passado.

```js
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
```

## API de Cache

- **Definição**: Cachear é o processo de armazenar cópias de arquivos em um local de armazenamento temporário, para que possam ser acessados mais rapidamente. A `Cache API` é usada para armazenar requisições e respostas de rede, fazendo com que aplicações web funcionem de forma mais eficiente e até mesmo offline. Ela faz parte da API mais ampla do `Service Worker` e é crucial para criar Progressive Web Apps (PWAs) que podem funcionar em condições de rede instáveis ou lentas.  
A `Cache API` é um mecanismo de armazenamento que guarda objetos `Request` e `Response`. Quando uma requisição é feita a um servidor, a aplicação pode armazenar a resposta e recuperá-la depois do cache em vez de fazer uma nova requisição de rede. Isso reduz o tempo de carregamento, economiza largura de banda e melhora a experiência geral do usuário.
- **Cache Storage**: Isso é usado para armazenar pares chave-valor de requisições HTTP e suas respostas correspondentes. Isso permite a recuperação eficiente de recursos previamente solicitados, reduzindo a necessidade de buscá-los na rede em visitas subsequentes e melhorando o desempenho.
- **Cache-Control**: Desenvolvedores podem definir por quanto tempo um recurso em cache deve ser mantido e se ele deve ser revalidado ou servido diretamente do cache.
- **Suporte Offline**: Usando a Cache API, você pode criar aplicações web offline-first. Por exemplo, uma PWA pode fornecer recursos em cache quando o usuário está desconectado da rede.

## Padrões Negativos e Armazenamento no Lado do Cliente

- **Rastreamento Excessivo**: Isso se refere à prática de coletar e armazenar uma quantidade excessiva de dados do usuário em armazenamento do lado do cliente (como cookies, local storage ou session storage) sem consentimento claro, informado ou uma necessidade legítima. Isso frequentemente envolve rastrear o comportamento do usuário, preferências e interações em vários sites ou sessões, o que pode infringir a privacidade do usuário. 
- **Browser Fingerprinting**: Uma técnica usada para rastrear e identificar usuários individuais com base em características únicas do seu dispositivo e navegador, em vez de depender de cookies ou outros métodos tradicionais de rastreamento. Ao contrário dos cookies, que são armazenados localmente no dispositivo do usuário, o fingerprinting envolve a coleta de uma variedade de informações que podem ser usadas para criar uma "impressão digital" distinta da sessão do navegador do usuário. 
- **Configurando Senhas no LocalStorage**: Isso pode parecer um padrão negativo mais óbvio, mas armazenar qualquer dado sensível como senhas no local storage representa um risco de segurança. O Local Storage não é criptografado e pode ser acessado facilmente. Portanto, você nunca deve armazenar qualquer tipo de dado sensível nele.

## IndexedDB

- **Definição**: IndexedDB é usado para armazenar dados estruturados no navegador. Isso está incorporado nos navegadores modernos, permitindo que aplicativos web armazenem e recuperem objetos JavaScript de forma eficiente. 

## Cache/Service Workers

- **Definição**: Um Service Worker é um script que roda em segundo plano separado da sua página web. Ele pode interceptar requisições de rede, acessar o cache e fazer o aplicativo web funcionar offline. Este é um componente chave dos Progressive Web Apps.

## Noções básicas de trabalho com classes

- **Definição**: Classes em JavaScript são usadas para definir modelos para criar objetos e encapsular dados. Classes incluem um construtor que é um método especial chamado automaticamente quando um novo objeto é criado a partir da classe. Ele é usado para inicializar as propriedades do objeto. A palavra-chave `this` é usada aqui para se referir à instância atual da classe. Abaixo do construtor, você pode ter o que são chamados de métodos. Métodos são funções definidas dentro de uma classe que executam ações ou operações nos dados ou estado da classe. Eles são usados para definir comportamentos que as instâncias da classe podem executar.

```js
class Dog {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
}
```

Para criar uma nova instância da classe, você usará a palavra-chave `new` seguida pelo nome da classe:

```js
const dog = new Dog("Gino");
```

Você também pode criar classes como expressões de classe. É quando a classe é anônima e atribuída a uma variável. 

```js
const Dog = class {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
};
```

## Herança de Classe

- **Definition**: In programming, inheritance allows you to define classes that inherit properties and methods from parent classes.  This promotes code reuse and establishes a hierarchical relationship between classes. Uma classe pai é uma classe que funciona como um modelo para outras classes. Ele define propriedades e métodos que são herdados por outras classes. Uma classe filha é uma classe que herda as propriedades e métodos de outra classe. Classes filhas também podem estender a funcionalidade de suas classes pai adicionando novas propriedades e métodos. Em JavaScript, usamos a palavra-chave `extends` para implementar herança. Esta palavra-chave indica que uma classe é a classe filha de outra classe.

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

A palavra-chave `super` é usada para acessar os métodos, construtores e campos da classe pai.


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

## Trabalhando com Métodos Estáticos e Propriedades Estáticas

- **Static methods**: These methods are often used for utility functions that don't need access to the specific state of an object. Eles são definidos dentro de classes para encapsular funcionalidades relacionadas. Métodos estáticos também são úteis para implementar métodos "factory". Um método factory é um método que você define além do construtor para criar objetos com base em critérios específicos.

```js
class Movie {
  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }
}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);

Movie.compareMovies(movieA, movieB);
```

- **Propriedades Estáticas**: Essas propriedades são usadas para definir valores ou atributos que estão associados à própria classe, e não às instâncias da classe. Propriedades estáticas são compartilhadas entre todas as instâncias da classe e podem ser acessadas sem criar uma instância da classe.

```js
class Car {
  // Static property
  static numberOfWheels = 4;

  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  // Instance method
  getCarInfo() {
    return `${this.make} ${this.model}`;
  }

  // Static method
  static getNumberOfWheels() {
    return Car.numberOfWheels;
  }
}

// Accessing static property directly from the class
console.log(Car.numberOfWheels); 
```


- Recursão é um conceito de programação que permite chamar uma função repetidamente até que um caso base seja alcançado.

Aqui está um exemplo de uma função recursiva que calcula o fatorial de um número:

```js
function findFactorial(n) {
  if (n === 0) {
    return 1;
  }
  return n * findFactorial(n - 1);
}
```

No exemplo acima, a função `findFactorial` é chamada recursivamente até que `n` alcance `0`. Quando `n` é `0`, o caso base é alcançado e a função retorna `1`. A função então retorna o produto de `n` e o resultado da chamada recursiva para `findFactorial(n - 1)`.

- Recursão permite que você lide com algo de profundidade desconhecida, como objetos/arrays profundamente aninhados ou uma árvore de arquivos. 
- Uma pilha de chamadas é usada para acompanhar as chamadas de função em uma função recursiva. Cada vez que uma função é chamada, ela é adicionada à pilha de chamadas. Quando o caso base é alcançado, as chamadas de função são removidas da pilha.
- Você deve definir cuidadosamente o caso base, pois chamá-lo indefinidamente pode fazer seu código travar. Isso acontece porque a recursão continua acumulando cada vez mais chamadas de função até que o sistema fique sem memória.
- Recursões encontram suas aplicações na resolução de problemas matemáticos como fatorial e Fibonacci, percorrendo árvores e grafos, gerando permutações e combinações e muito mais.

## Funções Puras vs Impuras

- Uma função pura é aquela que sempre produz a mesma saída para a mesma entrada e não possui efeitos colaterais. Sua saída depende apenas da sua entrada e ela não modifica nenhum estado externo.
- Funções impuras têm efeitos colaterais, que são mudanças no estado do programa que são observáveis fora da função.

## Programação funcional

- Programação Funcional é uma abordagem para desenvolvimento de software que enfatiza o uso de funções para resolver problemas, focando no que precisa ser feito e não em como fazer.
- A programação funcional incentiva o uso de técnicas que ajudam a evitar efeitos colaterais, como o uso de estruturas de dados imutáveis e funções de ordem superior. 
- Quando usados corretamente, os princípios da programação funcional levam a um código mais limpo e mais fácil de manter

## Currying

- Currying é uma técnica de programação funcional que transforma uma função com múltiplos argumentos em uma sequência de funções, cada uma recebendo um único argumento.

Aqui está um exemplo de uma função regular e uma função curried:

```js
// Regular function

function average(a, b, c) {
  return (a + b + c) / 3;
}

// Curried function

function curriedAverage(a) {
  return function(b) {
    return function(c) {
      return (a + b + c) / 3;
    };
  };
}

// Usage of curried function

const avg = curriedAverage(2)(3)(4);
```

- Currying pode ser particularmente poderoso ao trabalhar com funções que recebem muitos argumentos.
- Currying torna seu código mais flexível e mais fácil de reutilizar.
- Você pode usar funções arrow para criar funções curried de forma mais concisa:

```js
const curriedAverage = a => b => c => (a + b + c) / 3;
```

- Embora o currying possa levar a um código mais flexível e reutilizável, ele também pode tornar o código mais difícil de ler se for usado em excesso. 

- **JavaScript Síncrono** é executado sequencialmente e espera a operação anterior terminar antes de passar para a próxima.
- **JavaScript Assíncrono** permite que múltiplas operações sejam executadas em segundo plano sem bloquear a thread principal.
- **Thread** é uma sequência de instruções que pode ser executada independentemente do fluxo principal do programa.
- **Funções callback** são funções que são passadas como argumentos para outras funções e são executadas após a conclusão da operação ou como resultado de um evento.

## O motor JavaScript e o runtime JavaScript

- O **JavaScript engine** é um programa que executa código JavaScript em um navegador web. Ele funciona como um conversor que pega seu código, transforma em instruções que o computador pode entender e agir de acordo. 
- V8 é um exemplo de um motor JavaScript desenvolvido pelo Google.
- O **JavaScript runtime** é o ambiente no qual o código JavaScript é executado. Ele inclui o motor JavaScript que processa e executa o código e recursos adicionais como um navegador web ou Node.js.

## A API Fetch

- A Fetch API permite que aplicativos web façam requisições de rede, tipicamente para recuperar ou enviar dados ao servidor. Ela fornece um método `fetch()` que você pode usar para fazer essas requisições.
- Você pode recuperar texto, imagens, áudio, JSON e outros tipos de dados usando a Fetch API.

## Métodos HTTP para a Fetch API

A Fetch API suporta vários métodos HTTP para interagir com o servidor. Os métodos mais comuns são:

- **GET**: Usado para recuperar dados do servidor. Por padrão, a Fetch API usa o método `GET` para recuperar dados.

```js
fetch('https://api.example.com/data')
```

Para usar os dados obtidos, eles devem ser convertidos para o formato JSON usando o método `.json()`:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

Neste código, a resposta vinda da Fetch API é uma promise e o manipulador `.then` está convertendo a resposta para o formato JSON.

- **POST**: Usado para enviar dados ao servidor. O método `POST` é usado para criar novos recursos no servidor.

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

Neste exemplo, estamos enviando uma requisição `POST` para criar um novo usuário. Especificamos o método como `POST`, definimos os cabeçalhos apropriados e incluímos um corpo com os dados que queremos enviar. O corpo precisa ser uma string, então usamos `JSON.stringify()` para converter nosso objeto em uma string JSON.

- **PUT**: Usado para atualizar dados no servidor. O método `PUT` é usado para atualizar recursos existentes no servidor.

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

Neste exemplo, estamos atualizando o ID `45` que está especificado no final da URL. Usamos o método `PUT` no código e também especificamos os dados como o corpo que será usado para atualizar os dados identificados. 

- **DELETE**: Usado para deletar dados no servidor. O método `DELETE` é usado para deletar recursos no servidor.

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

Neste exemplo, estamos enviando uma requisição `DELETE` para remover um usuário com o ID `45`.

## Promise e encadeamento de promise

- **Promises** são objetos que representam a conclusão eventual ou falha de uma operação assíncrona e seu valor resultante. O valor da promise é conhecido somente quando a operação `async` é concluída.
- Aqui está um exemplo para criar uma promise simples:

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- O método `.then()` é usado em uma Promise para especificar o que deve acontecer quando a Promise é resolvida, enquanto `.catch()` é usado para tratar quaisquer erros que ocorram.
- Aqui está um exemplo de uso de `.then()` e `.catch()` com uma Promise:

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

No exemplo acima, o método `.then()` é usado para registrar os dados recebidos da Promise, enquanto o método `.catch()` é usado para registrar quaisquer erros que ocorram.

- **Encadeamento de Promise**: Uma das funcionalidades poderosas das Promises é que podemos encadear múltiplas operações assíncronas juntas. Cada `.then()` pode retornar uma nova Promise, permitindo que você execute uma sequência de operações assíncronas uma após a outra.
- Aqui está um exemplo de encadeamento de Promise:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

No exemplo acima, primeiro buscamos dados de uma URL, depois buscamos dados de outra URL com base na primeira resposta e finalmente registramos o segundo dado recebido. 

O método `catch` lidaria com quaisquer erros que ocorram durante o processo. Isso significa que você não precisa adicionar tratamento de erros a cada etapa individual, o que pode simplificar muito o seu código.

## Usando `async/await` para lidar com promises

Async/await facilita a escrita e a leitura de código assíncrono que é construído sobre Promises.

- **async**: A palavra-chave `async` é usada para definir uma função assíncrona. Uma função `async` retorna uma Promise, que é resolvida com o valor retornado pela função `async`.
- **await**: A palavra-chave `await` é usada dentro de uma função `async` para pausar a execução da função até que a Promise seja resolvida. Ela só pode ser usada dentro de uma função `async`.
- Aqui está um exemplo de uso de `async/await`:

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

No exemplo acima, a função `delayedGreeting` é uma função `async` que pausa por 2 segundos antes de imprimir a mensagem de saudação. A palavra-chave `await` é usada para pausar a execução da função até que a `Promise` seja resolvida.

- Uma das maiores vantagens do `async/await` é o tratamento de erros via blocos `try/catch`. Aqui está um exemplo:

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

No exemplo acima, o bloco `try` contém o código que pode gerar um erro e o bloco `catch` trata o erro caso ele ocorra. Isso torna o tratamento de erros mais direto e legível.

## O atributo `async`

- O atributo `async` informa ao navegador para baixar o arquivo de script de forma assíncrona enquanto continua a analisar o documento HTML. 
- Uma vez que o script é baixado, o parsing do HTML é pausado, o script é executado e então o parsing do HTML é retomado.
- Você deve usar `async` para scripts independentes onde a ordem de execução não importa

## O atributo `defer`

- O atributo `defer` também baixa o script de forma assíncrona, mas adia a execução do script até que o documento HTML tenha sido totalmente analisado. 
- Os scripts `defer` mantêm a ordem de execução conforme aparecem no documento HTML.

- É importante notar que os atributos `async` e `defer` são ignorados para scripts inline e funcionam apenas para arquivos de script externos.

- Quando os atributos `async` e `defer` estão presentes, o atributo `async` tem precedência.

## API de Geolocalização

- A API de Geolocalização fornece uma maneira para os sites solicitarem a localização do usuário.

- O exemplo abaixo demonstra o método `getCurrentPosition()` da API que é usado para obter a localização atual do usuário.

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

Neste código, estamos chamando `getCurrentPosition` e passando uma função que será chamada quando a posição for obtida com sucesso. 

O objeto `position` contém uma variedade de informações, mas aqui selecionamos apenas `latitude` e `longitude`.

Se houver um problema ao obter o `position`, o erro será registrado no console. É importante respeitar a privacidade do usuário e solicitar a localização dele somente quando necessário.


# --assignment--

Revise os tópicos e conceitos de JavaScript.
