---
id: 691b559495c5cb5a37b9b485
title: "Desafio 125: Game of Life"
challengeType: 29
dashedName: challenge-125
---

# --description--

Dada uma matriz (array de arrays) que representa o estado atual no Jogo da Vida de Conway, retorne o próximo estado da matriz usando estas regras:

- Cada célula é `1` (viva) ou `0` (morta).
- Os vizinhos de uma célula são até oito células ao redor (verticalmente, horizontalmente e diagonalmente).
- Células nas bordas têm menos de oito vizinhos.

Regras para atualizar cada célula:

- Qualquer célula viva com menos de dois vizinhos vivos morre (subpopulação).
- Qualquer célula viva com dois ou três vizinhos vivos continua viva.
- Qualquer célula viva com mais de três vizinhos vivos morre (superpopulação).
- Qualquer célula morta com exatamente três vizinhos vivos se torna viva (reprodução).

Por exemplo, dado:

```json
[
  [0, 1, 0],
  [0, 1, 1],
  [1, 1, 0]
]
```

retornar:

```json
[
  [0, 1, 1],
  [0, 0, 1],
  [1, 1, 1]
]
```

Cada célula é atualizada de acordo com o número de vizinhos vivos. Por exemplo, `[0][0]` permanece morta (2 vizinhos vivos), `[0][1]` permanece viva (2 vizinhos vivos), `[0][2]` morre (3 vizinhos vivos) e assim por diante.

# --hints--

`game_of_life([[0, 1, 0], [0, 1, 1], [1, 1, 0]])` deve retornar `[[0, 1, 1], [0, 0, 1], [1, 1, 1]]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(game_of_life([[0, 1, 0], [0, 1, 1], [1, 1, 0]]), [[0, 1, 1], [0, 0, 1], [1, 1, 1]])`)
}})
```

`game_of_life([[1, 1, 0, 0], [1, 0, 1, 0], [0, 1, 1, 1], [0, 0, 1, 0]])` deve retornar `[[1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 1, 1, 1]]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(game_of_life([[1, 1, 0, 0], [1, 0, 1, 0], [0, 1, 1, 1], [0, 0, 1, 0]]), [[1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 1, 1, 1]])`)
}})
```

`game_of_life([[1, 0, 0], [0, 1, 0], [0, 0, 1]])` deve retornar `[[0, 0, 0], [0, 1, 0], [0, 0, 0]]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(game_of_life([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), [[0, 0, 0], [0, 1, 0], [0, 0, 0]])`)
}})
```

`game_of_life([[0, 1, 1, 0], [1, 1, 0, 1], [0, 1, 1, 0], [0, 0, 1, 0]])` deve retornar `[[1, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(game_of_life([[0, 1, 1, 0], [1, 1, 0, 1], [0, 1, 1, 0], [0, 0, 1, 0]]), [[1, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]])`)
}})
```

# --seed--

## --seed-contents--

```py
def game_of_life(grid):

    return grid
```

# --solutions--

```py
def game_of_life(grid):
    rows, cols = len(grid), len(grid[0])

    def count_live_neighbors(r, c):
        count = 0
        for i in range(r-1, r+2):
            for j in range(c-1, c+2):
                if 0 <= i < rows and 0 <= j < cols and (i != r or j != c):
                    count += grid[i][j]
        return count

    next_state = [row[:] for row in grid]

    for r in range(rows):
        for c in range(cols):
            live_neighbors = count_live_neighbors(r, c)

            if grid[r][c] == 1:
                if live_neighbors < 2 or live_neighbors > 3:
                    next_state[r][c] = 0
            else:
                if live_neighbors == 3:
                    next_state[r][c] = 1

    return next_state
```
