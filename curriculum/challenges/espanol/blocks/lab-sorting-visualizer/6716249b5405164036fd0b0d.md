---
id: 6716249b5405164036fd0b0d
title: Construir un Visualizador de Ordenamiento
challengeType: 25
dashedName: build-a-sorting-visualizer
demoType: onClick
---

# --description--

El algoritmo de ordenamiento Burbuja ordena una secuencia de enteros comparando parejas de elementos adyacentes desde el principio de la secuencia. Si el primer elemento es mayor que el segundo, los intercambia. Luego, procede con la siguiente pareja. Cuando se alcanza el último elemento de la secuencia, comienza un nuevo ciclo desde el inicio de la secuencia y repite el proceso hasta que los elementos estén ordenados. El algoritmo se detiene después de completar un ciclo sin intercambios.

Para este laboratorio, se le ha proporcionado todo el HTML y CSS. Utilizarás JavaScript para completar el Visualizador de Ordenamiento Burbuja, para que visualice cada paso necesario del algoritmo para ordenar un arreglo de cinco enteros.

**Objetivo:** Cumplir con las historias de usuario a continuación y pasar todas las pruebas para completar el laboratorio.

**Historias de usuario:**

1. Debes tener una función llamada `generateElement` que devuelva un número entero aleatorio entre `1` y `100`, inclusive.
1. Debes tener una función llamada `generateArray` que utilice la función `generateElement` para devolver un arreglo que contenga cinco números enteros aleatorios.
1. Debes tener una función llamada `generateContainer` que cree y devuelva un elemento `div` vacío.
1. Debes tener una función llamada `fillArrContainer` que tome un elemento HTML como primer argumento y un arreglo como segundo argumento.
1. El `fillArrContainer` debe tomar un elemento como primer parámetro y un arreglo de enteros como segundo parámetro, luego llenar el elemento con cinco elementos `span`, donde cada `span` muestra uno de los enteros del arreglo.
1. Debes tener una función llamada `isOrdered` que tome dos números enteros y devuelva un booleano que indique si el primer entero es menor o igual al segundo.
1. Debes tener una función llamada `swapElements` que tome un arreglo de enteros y un índice numérico.
1. La función `swapElements` debería modificar el arreglo en su lugar intercambiando el elemento en el índice pasado y el siguiente elemento si `isOrdered` devuelve `false`.
1. Debes tener una función llamada `highlightCurrentEls` que tome un elemento HTML y un índice numérico.
1. La función `highlightCurrentEls` debe configurar el `borde` del hijo del elemento dado en el índice proporcionado, y el hijo inmediatamente después del índice, para que tengan un estilo `discontinua`, un color `rojo` y un ancho de tu elección.
1. Al hacer clic en `#generate-btn` debes usar la función `fillArrContainer` para llenar `#starting-array` con cinco elementos `span`, cada uno con un número aleatorio como su texto. Si están presentes, otros elementos deben ser eliminados de `#array-container`.
1. Debes implementar el algoritmo de ordenamiento Burbuja para que después de hacer clic en `#sort-btn`, `#array-container` contenga un elemento `div` para cada uno de los pasos necesarios del algoritmo para ordenar el arreglo inicial, incluyendo el `div` que representa el arreglo inicial y un `div` que representa el arreglo ordenado. Las funciones que has creado hasta ahora pueden ser útiles aquí.
1. Cada `div` debe contener cinco elementos `span`, representando el arreglo en su estado actual de ordenamiento.
1. Después de hacer clic en `#sort-btn`, `#starting-array` debe representar el paso inicial con el arreglo inicial y los primeros dos números enteros destacados.
1. Para cada paso de ordenamiento, debes usar `highlightCurrentEls` para resaltar los dos números que se están comparando e intercambiarlos en el siguiente paso usando `swapElements`.

# --hints--

Debes tener una función llamada `generateElement`.

```js
assert.isFunction(generateElement);
```

Tu función `generateElement` debe devolver un número entero aleatorio entre `1` y `100` inclusive.

```js
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {    
    assert.strictEqual(generateElement(), 26);
    assert.strictEqual(generateElement(), 9);
} finally {
    randomMocker.restore();
}
```

Debes tener una función llamada `generateArray`.

```js
assert.isFunction(generateArray)
```

Tu función `generateArray` debe hacer uso de la función `generateElement`.

```js
let flag = false;
const temp = generateElement;
generateElement = () => flag = true;
try {
    generateArray();
    assert.isTrue(flag);
} finally {
    generateElement = temp;
}
```

Tu función `generateArray` debe devolver un arreglo que contenga cinco números enteros aleatorios entre `1` y `100`.

```js
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {
    assert.deepEqual(generateArray(), [26, 9, 58, 23, 38])
} finally {
    randomMocker.restore();
}
```

Debes tener una función llamada `generateContainer`.

```js
assert.isFunction(generateContainer);
```

Tu función `generateContainer` debe devolver un elemento `div` vacío.

```js
const div = generateContainer();
assert.equal(div.tagName, "DIV");
assert.isEmpty(div.children);
```

Debes tener una función llamada `fillArrContainer`.

```js
assert.isFunction(fillArrContainer);
```

Tu `fillArrContainer()` debe tomar un elemento como primer parámetro y un arreglo de enteros como segundo parámetro, luego llenar el elemento con cinco elementos `span`, donde cada `span` muestre uno de los enteros del arreglo.

```js
const testDiv = document.createElement("div");
const testArr = [15, 98, 17, 5, 63]
fillArrContainer(testDiv, testArr);
const children = testDiv.children;
assert.lengthOf(children, 5);
Array.from(children).forEach((el, i) => {
    assert.equal(el.tagName, "SPAN");
    assert.equal(el.innerText.trim(), testArr[i])
})
```

Debes tener una función llamada `isOrdered`.

```js
assert.isFunction(isOrdered);
```

Tu función `isOrdered` debe tomar dos números enteros y devolver un booleano que indique si el primer entero es menor o igual al segundo.

```js
assert.lengthOf(isOrdered, 2);
assert.isTrue(isOrdered(2, 60));
assert.isFalse(isOrdered(10, 3));
assert.isTrue(isOrdered(5, 5));
```

Debes tener una función llamada `swapElements`.

```js
assert.isFunction(swapElements);
```

Tu función `swapElements` debe tomar un arreglo de enteros y un índice numérico como argumentos. Debe modificar el arreglo pasado en su lugar intercambiando el elemento en el índice proporcionado y el elemento siguiente si el primer elemento es mayor que el segundo.

```js
const testArr = [22, 4, 87, 47, 33];
swapElements(testArr, 0);
assert.deepEqual(testArr, [4, 22, 87, 47, 33]);
swapElements(testArr, 1);
assert.deepEqual(testArr, [4, 22, 87, 47, 33]);
swapElements(testArr, 2);
assert.deepEqual(testArr, [4, 22, 47, 87, 33]);
swapElements(testArr, 3);
assert.deepEqual(testArr, [4, 22, 47, 33, 87]);
```

Debes tener una función llamada `highlightCurrentEls`.

```js
assert.isFunction(highlightCurrentEls);
```

Tu función `highlightCurrentEls` debe dar a los descendientes del elemento especificado, ubicados en el índice proporcionado y el siguiente índice, un borde que sea `discontinua`, `rojo` y configurado a un ancho de tu elección.

```js
const testDiv = document.createElement("div");
document.querySelector("body").appendChild(testDiv)
for (let i = 0; i < 5; i++) {
    testDiv.appendChild(document.createElement("span"));
}
const redBorderRegex = /dashed (rgb\(255,\s*0,\s*0\)|#FF0000|#F00|hsl\(0,\s*100%,\s*50%\))/;
const revertBorder = () => {
    for (const el of children) {
        el.style.border = "revert";
    }
}
const children = testDiv.children;

for (let i = 0; i < 3; i++) {
    highlightCurrentEls(testDiv, i);
    for (let j = 0; j < 5; j++) {
        let b = getComputedStyle(children[j]).border;
        if (j == i || j == i + 1) {            
            assert.match(b, redBorderRegex);
            assert.isAbove(parseFloat(b), 0);
        } else {
            assert.notMatch(b, redBorderRegex);
        }
    }
    revertBorder();
}
testDiv.remove();
```

Al hacer clic en `#generate-btn` debes llenar `#starting-array` con cinco elementos `span`, cada uno con un número aleatorio entre `1` y `100` como su texto.

```js
const genBtn = document.querySelector("#generate-btn");
genBtn.click();
const children = document.querySelector("#starting-array").querySelectorAll("span");
assert.lengthOf(children, 5);
Array.from(children).forEach(el => {
    assert.equal(el.tagName, "SPAN");
    const num = Number(el.innerText.trim());
    assert.isAtMost(num, 100);
    assert.isAtLeast(num, 1);
})
```

Cuando `#starting-array` ya contiene un arreglo generado, o `#array-container` contiene el arreglo ordenado, al hacer clic en el `#generate-btn` deben eliminarse otros elementos en `#array-container`, dejando solo `#starting-array` con números recién generados.

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
genBtn.dispatchEvent(new Event("click"));

const prevNumbers = Array.from(document.querySelector("#starting-array").querySelectorAll("span")).map(el => Number(el.innerText.trim()));

sortBtn.dispatchEvent(new Event("click"));
genBtn.dispatchEvent(new Event("click"));

const container = document.querySelector("#array-container");
assert.lengthOf(container.children, 1);
const numbers = Array.from(document.querySelector("#starting-array").querySelectorAll("span")).map(el => Number(el.innerText.trim()));
assert.lengthOf(numbers, 5);
assert.isTrue(prevNumbers.some((num, index) => num !== numbers[index]))
```

Después de hacer clic en `#sort-btn`, `#array-container` debe contener tantos elementos `div` como pasos necesite el algoritmo de ordenamiento Burbuja para ordenar el arreglo inicial, incluyendo el `div` que representa el arreglo inicial y un `div` que representa el arreglo ordenado.

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
// using randomMocker to be sure that the starting array requires 13 steps to be sorted
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {    
    genBtn.dispatchEvent(new Event("click"));
    sortBtn.dispatchEvent(new Event("click"));
    const container = document.querySelector("#array-container");
    assert.lengthOf(container.children, 13)
    Array.from(container.children).forEach(el => {assert.equal(el.tagName, "DIV")})
} finally {
    randomMocker.restore();
}
```

Después de hacer clic en `#sort-btn`, cada `div` dentro de `#array-container` debe contener cinco `span`, cada uno con un número como su texto, y organizados para representar los pasos que requiere el algoritmo de ordenamiento Burbuja para ordenar el arreglo inicial.

```js
const finalArr = [9, 23, 26, 38, 58];
const arrays = [
    [26, 9, 58, 23, 38],
    [9, 26, 58, 23, 38],
    [9, 26, 58, 23, 38],
    [9, 26, 23, 58, 38],
    [9, 26, 23, 38, 58],
    [9, 26, 23, 38, 58],
    finalArr,
    finalArr,
    finalArr,
    finalArr,
    finalArr,
    finalArr,
    finalArr
]
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {    
    genBtn.dispatchEvent(new Event("click"));
    sortBtn.dispatchEvent(new Event("click"));
    const container = document.querySelector("#array-container");
    assert.isNotEmpty(container.children);
    Array.from(container.children).forEach((el, i) => {
        Array.from(el.children).forEach((j, k) => {
            assert.strictEqual(Number(j.innerText.trim()), arrays[i][k])
        })
    })
} finally {
    randomMocker.restore();
}
```

Al hacer clic en el `#sort-btn`, debes hacer uso de la función `highlightCurrentEls` para resaltar los elementos que se están comparando en cada paso.

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
let flag = false;
const temp = highlightCurrentEls;
highlightCurrentEls = () => flag = true;
try {
    genBtn.dispatchEvent(new Event("click"));
    sortBtn.dispatchEvent(new Event("click"));
    assert.isTrue(flag);
} finally {
    highlightCurrentEls = temp;
}
```

Después de hacer clic en `#sort-btn`, `#starting-array` debe representar el paso inicial con el arreglo inicial y los primeros dos números enteros destacados utilizando `highlightCurrentEls`.

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");   
genBtn.dispatchEvent(new Event("click"));
sortBtn.dispatchEvent(new Event("click"));
const firstContainer = document.querySelector("#starting-array");
const children = firstContainer.children
const redBorderRegex = /dashed (rgb\(255,\s*0,\s*0\)|#FF0000|hsl\(0,\s*100%,\s*50%\))/;
assert.match(getComputedStyle(children[0]).border, redBorderRegex);
assert.match(getComputedStyle(children[1]).border, redBorderRegex);
```

# --seed--

## --seed-contents--

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sorting Visualizer</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <main>
        <div id="array-container">
            <div id="starting-array"></div>
        </div>
        <div id="btn-container">
            <button id="generate-btn" type="button">Generate Array</button>
            <button id="sort-btn" type="button">Sort Array</button>
        </div>
    </main>
    <script src="script.js"></script>
</body>

</html>
```

```css
* {
    box-sizing: border-box;
}

main {
    height: 100vh;
    display: flex;
    justify-content: center;
    flex-direction: column;
    align-items: center;
}

#array-container {
    max-height: 95vh;
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    gap: 2px;

}

#array-container>div {
    min-width: 8rem;
    height: 2rem;
    box-shadow: rgba(50, 50, 93, 0.25) 0px 2px 5px -1px, rgba(0, 0, 0, 0.3) 0px 1px 3px -1px;
    border-radius: 10px;
    margin-bottom: 0.2rem;
    border: 2px solid darkgray;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
}

#starting-array {
    border: 4px solid darkblue !important;
}

#btn-container {
    display: flex;
    justify-content: space-around;
}

button {
    padding: 2px;
    margin: 5px;
}

span {
    border-radius: 2px;
    padding: 0.5px;
    margin: 0
}

@media (min-width: 430px) {
  #array-container>div {
    min-width: 12rem;    
  }
  span {
    padding: 1px;
    margin: 1px;
  }
}
```

```js

```

# --solutions--

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sorting Visualizer</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <main>
        <div id="array-container">
            <div id="starting-array"></div>
        </div>
        <div id="btn-container">
            <button id="generate-btn" type="button">Generate Array</button>
            <button id="sort-btn" type="button">Sort Array</button>
        </div>
    </main>
    <script src="script.js"></script>
</body>

</html>
```

```css
* {
    box-sizing: border-box;
}

main {
    height: 100vh;
    display: flex;
    justify-content: center;
    flex-direction: column;
    align-items: center;
}

#array-container {
    max-height: 95vh;
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    gap: 2px;

}

#array-container>div {
    min-width: 8rem;
    height: 2rem;
    box-shadow: rgba(50, 50, 93, 0.25) 0px 2px 5px -1px, rgba(0, 0, 0, 0.3) 0px 1px 3px -1px;
    border-radius: 10px;
    margin-bottom: 0.2rem;
    border: 2px solid darkgray;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
}

#starting-array {
    border: 4px solid darkblue !important;
}

#btn-container {
    display: flex;
    justify-content: space-around;
}

button {
    padding: 2px;
    margin: 5px;
}

#sort-btn {
   display: none 
}

span {
    border-radius: 2px;
    padding: 0.5px;
    margin: 0
}

@media (min-width: 430px) {
  #array-container>div {
    min-width: 12rem;    
  }
  span {
    padding: 1px;
    margin: 1px;
  }
}
```

```js
const arrayContainer = document.getElementById("array-container");
const generateArrayBtn = document.getElementById("generate-btn");
const sortArrayBtn = document.getElementById("sort-btn");
const arrayLength = 5;
const minVal = 1;
const maxVal = 100;
const isStart = () => arrayContainer.children.length === 1;
const clearArrayContainer = () => { arrayContainer.innerHTML = '<div id="starting-array"></div>' };
const showSortBtn = () => {sortArrayBtn.style.display = "inline-block"};
const hideSortBtn = () => {sortArrayBtn.style.display = "none"};
const generateElement = () => Math.floor(Math.random() * maxVal + minVal);
const generateArray = () => Array.from({ length: arrayLength }, generateElement);
const fillArrContainer = (container, arr) => {
    container.innerHTML = "";
    arr.forEach(i => {
        const el = document.createElement("span");
        el.innerText = i;
        el.id = `number-${i}`
        container.appendChild(el);
    })
}
const isOrdered = (el1, el2) => el1 <= el2;

const swapElements = (arr, n = 0) => {
    if (n < arr.length - 1 && !isOrdered(arr[n], arr[n + 1])) {
        const temp = arr[n];
        arr[n] = arr[n + 1];
        arr[n + 1] = temp;
    }
}
const getLastChildren = () => arrayContainer.lastElementChild;
const getLastArr = () => {
    const els = Array.from(getLastChildren().children);
    const arr = els.map(el => Number(el.id.replace("number-", "")));
    return arr;
}
const generateContainer = () => {
    const container = document.createElement("div");
    arrayContainer.appendChild(container);
    return container;
}
const highlightCurrentEls = (container, n = 0) => {
    const children = container.children;
    children[n].style.border = "2px dashed red";
    children[n + 1].style.border = "2px dashed red";
}

const highlightSorted = () => {
    getLastChildren().style.border = "4px solid green";
}

const bubbleSort = () => {
    let swapped = true;
    while (swapped) {
        const startingArr = getLastArr();
        startingArr.forEach((_, i) => {
            if (i + 1 < arrayLength) {
                highlightCurrentEls(getLastChildren(), i);
                const arr = getLastArr();
                swapElements(arr, i);
                fillArrContainer(generateContainer(), arr);
            }
        })
        const lastArr = getLastArr()
        if (startingArr.every((el, i) => el === lastArr[i])) swapped = false;
    }
}


generateArrayBtn.addEventListener("click", () => {
    if (!isStart()) {
        clearArrayContainer();
    }
    fillArrContainer(document.getElementById("starting-array"), generateArray());
    showSortBtn();
});

sortArrayBtn.addEventListener("click", () => {
    bubbleSort();
    highlightSorted();
    hideSortBtn();
})
```

