---
id: 5a24c314108439a4d4036174
title: 將 `this` 綁定到類別方法
challengeType: 6
forumTopicId: 301379
dashedName: bind-this-to-a-class-method
---

# --description--

除了設定和更新 `state`，你也可以為你的組件類別定義方法。類別方法通常需要使用 `this` 關鍵字，這樣它才能在方法的範圍內存取類別上的屬性（例如 `state` 和 `props`）。有幾種方法可以讓你的類別方法存取 `this`。

一個常見的方法是在建構式中明確地綁定 `this`，使得當組件初始化時，`this` 會綁定到類別的方法。你可能已經注意到，上一個挑戰在建構式中對其 `handleClick` 方法使用了 `this.handleClick = this.handleClick.bind(this)`。然後，當你在類別方法中呼叫像 `this.setState()` 這樣的函式時，`this` 會指向類別，而不會是 `undefined`。

**注意：** `this` 關鍵字是 JavaScript 中最令人困惑的部分之一，但它在 React 中扮演重要角色。雖然它在這裡的行為完全正常，但這些課程並非深入檢視 `this` 的場所，因此如果上述內容讓你感到困惑，請參考其他課程！

# --instructions--

程式碼編輯器有一個帶有 `state` 的組件，用來追蹤文字。它也有一個方法，允許你將文字設為 `You clicked!`。然而，該方法無法運作，因為它使用了未定義的 `this` 關鍵字。請在組件的建構式中明確地將 `this` 綁定到 `handleClick()` 方法來修正它。

接著，為 `button` 元素在呈現方法中添加點擊處理常式。當按鈕接收到點擊事件時，應該觸發 `handleClick()` 方法。請記得你傳給 `onClick` 控制代碼的方法需要使用大括號，因為它應該被直接解讀為 JavaScript。

完成上述步驟後，你應該能夠點擊按鈕並看到 `You clicked!`。

# --hints--

`MyComponent` 應該傳回一個 `div` 元素，該元素依序包裹兩個元素，一個按鈕和一個 `h1` 元素。

```js
assert(
  Enzyme.mount(React.createElement(MyComponent)).find('div').length === 1 &&
    Enzyme.mount(React.createElement(MyComponent))
      .find('div')
      .childAt(0)
      .type() === 'button' &&
    Enzyme.mount(React.createElement(MyComponent))
      .find('div')
      .childAt(1)
      .type() === 'h1'
);
```

`MyComponent` 的狀態應該以鍵值對 `{ text: "Hello" }` 初始化。

```js
assert(
  Enzyme.mount(React.createElement(MyComponent)).state('text') === 'Hello'
);
```

點擊 `button` 元素應該會執行 `handleClick` 方法，並將狀態 `text` 設定為 `You clicked!`。

```js
  const waitForIt = (fn) =>
    new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250));
  const mockedComponent = Enzyme.mount(React.createElement(MyComponent));
  const first = () => {
    mockedComponent.setState({ text: 'Hello' });
    return waitForIt(() => mockedComponent.state('text'));
  };
  const second = () => {
    mockedComponent.find('button').simulate('click');
    return waitForIt(() => mockedComponent.state('text'));
  };
  const firstValue = await first();
  const secondValue = await second();
  assert(firstValue === 'Hello' && secondValue === 'You clicked!');
```

# --seed--

## --after-user-code--

```jsx
ReactDOM.render(<MyComponent />, document.getElementById('root'))
```

## --seed-contents--

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      text: "Hello"
    };
    // Change code below this line

    // Change code above this line
  }
  handleClick() {
    this.setState({
      text: "You clicked!"
    });
  }
  render() {
    return (
      <div>
        { /* Change code below this line */ }
        <button>Click Me</button>
        { /* Change code above this line */ }
        <h1>{this.state.text}</h1>
      </div>
    );
  }
};
```

# --solutions--

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      text: "Hello"
    };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    this.setState({
      text: "You clicked!"
    });
  }
  render() {
    return (
      <div>
        <button onClick = {this.handleClick}>Click Me</button>
        <h1>{this.state.text}</h1>
      </div>
    );
  }
};
```
