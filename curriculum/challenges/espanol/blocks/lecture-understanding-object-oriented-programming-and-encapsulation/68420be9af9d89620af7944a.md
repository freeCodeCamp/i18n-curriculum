---
id: 68420be9af9d89620af7944a
title: ¿Qué es la Programación Orientada a Objetos y cómo funciona la encapsulación?
challengeType: 19
dashedName: what-is-object-oriented-programming-and-how-does-encapsulation-work
---

# --description--

La programación orientada a objetos, también conocida como OOP, es un estilo de programación en el que los desarrolladores tratan todo en su código como un objeto del mundo real.

Una clase es como una estructura para crear objetos. Cada objeto creado a partir de una clase tiene atributos que definen datos y métodos que definen los comportamientos de los objetos.

En una lección anterior, aprendiste cómo crear clases. Aquí tienes un recordatorio de la sintaxis:

```py
class ClassName:
   def __init__(self, parameters):
       attribute = value

   def method_name(self):
       # method logic
```

Aquí tienes un ejemplo de una clase que usa el método especial `__init__` para inicializar los atributos brand y color cada vez que se crea un objeto usando la clase:

```py
class Car:
   def __init__(self, brand, color):
       self.brand = brand
       self.color = color

# create two objects from the Car class
car1 = Car('Toyota', 'red')
car2 = Car('Lambo', 'green')

print('Car 1 Brand:', car1.brand) # Car 1 Brand: Toyota
print('Car 1 Color:', car1.color) # Car 1 Color: red

print('Car 2 Brand:', car2.brand) # Car 2 Brand: Lambo
print('Car 2 Color:', car2.color) # Car 2 Color: green
```

La programación orientada a objetos tiene cuatro principios clave que te ayudan a organizar y gestionar el código de manera efectiva. Son encapsulación, herencia, polimorfismo y abstracción.

El resto de esta lección se centrará en cómo funciona la encapsulación.

La encapsulación es la agrupación de los atributos y métodos de un objeto en una sola unidad, la clase.

Con la encapsulación, puedes ocultar el estado interno del objeto detrás de un conjunto simple de métodos y atributos públicos que actúan como puertas. Detrás de esas puertas están los atributos y métodos privados que controlan cómo cambian los datos y quién puede verlos.

Supongamos que quieres rastrear el saldo de una billetera. Quieres permitir que las personas depositen o retiren dinero de la billetera, pero nadie debería poder manipular el saldo directamente.

En ese caso, puedes hacer que `deposit()` y `withdraw()` sean métodos públicos, y ocultas el balance bajo el atributo `_balance`:

```py
class Wallet:
   def __init__(self, balance):
       self._balance = balance # For internal use by convention

   def deposit(self, amount):
       if amount > 0:
           self._balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self._balance:
           self._balance -= amount # Remove from the balance safely
```

Por convención, anteponer un guion bajo a atributos y métodos significa que están destinados para uso interno. Nadie debería acceder a ellos directamente desde fuera de la clase, ya que va en contra de los principios de encapsulación, lo que puede causar errores.

Aunque un prefijo de un solo guion bajo es solo una convención, anteponer un doble guion bajo a los atributos y métodos evita efectivamente que sean accesados desde fuera de su clase, haciendo que esos atributos y métodos sean privados.

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

Para obtener el valor actual de `__balance`, puedes definir un método get_balance. Por ejemplo:

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount
  
   def get_balance(self):
       return self.__balance


acct_one = Wallet(100)
acct_one.deposit(50)
print(acct_one.get_balance()) # 150

acct_two = Wallet(450)
acct_two.withdraw(28)
print(acct_two.get_balance()) # 422

acct_two.deposit(150)
print(acct_two.get_balance()) # 572
```

También puedes definir un método privado `__validate` para verificar si cada monto de depósito o retiro es un número positivo:

```py
class Wallet:
   def __init__(self):
       self.__balance = 0

   def __validate(self, amount):
       if amount < 0:
           raise ValueError('Amount must be positive')

   def deposit(self, amount):
       self.__validate(amount)
       self.__balance += amount

   def withdraw(self, amount):
       self.__validate(amount)
       if amount > self.__balance:
           raise ValueError('Insufficient funds')
       self.__balance -= amount

   def get_balance(self):
       return self.__balance

acct_one = Wallet()
acct_one.deposit(3)
print(acct_one.get_balance()) # 3

acct_one.deposit(50)
print(acct_one.get_balance()) # 53

acct_one.deposit(-4)  # ValueError: Amount must be positive
acct_one.withdraw(-8) # ValueError: Amount must be positive
acct_one.withdraw(58) # ValueError: Insufficient funds
```

Como puedes ver, el método `__validate` es privado y se ejecuta detrás de escena en los métodos públicos `deposit()` y `withdraw()` para asegurarse de que la cantidad siempre sea válida.

En una próxima lección, aprenderás más sobre cómo funcionan los atributos que comienzan con un doble guion bajo.

En resumen, la encapsulación protege los datos internos detrás de métodos públicos claros. Así es como mantienes tus clases seguras contra manipulaciones y centralizas la validación en un solo lugar. Puedes actualizar o ampliar tu código libremente, sabiendo que el código externo solo interactúa con las interfaces que expones.

# --questions--

## --text--

¿Cuáles son los cuatro principios clave de la Programación Orientada a Objetos (OOP)?

## --answers--

Encapsulación, Herencia, Polimorfismo, Abstracción

---

Variables, Funciones, Bucles, Condicionales

### --feedback--

Presta atención a los principios que definen cómo se organizan los datos y el comportamiento en OOP.

---

Clases, Objetos, Métodos, Atributos

### --feedback--

Presta atención a los principios que definen cómo se organizan los datos y el comportamiento en OOP.

---

Público, Privado, Protegido, Estático

### --feedback--

Presta atención a los principios que definen cómo se organizan los datos y el comportamiento en OOP.

## --video-solution--

1

## --text--

¿Por qué es una mala práctica acceder directamente a atributos/métodos que comienzan con un guion bajo simple?

## --answers--

Porque Python generará un error de sintaxis si lo intentas.

### --feedback--

Piensa en cómo la encapsulación existe para proteger el estado interno de un objeto.

---

Porque viola la encapsulación, permitiendo el acceso no controlado a los datos.

---

Porque las propiedades privadas son más lentas de acceder que las públicas.

### --feedback--

Piensa en cómo la encapsulación existe para proteger el estado interno de un objeto.

---

Porque solo pueden ser accedidos desde clases hijas.

### --feedback--

Porque solo pueden ser accedidos desde clases hijas.

## --video-solution--

2

## --text--

¿Cuál es la forma de indicar atributos o métodos privados?

## --answers--

Prefijo con un solo guion bajo

### --feedback--

Presta atención a los símbolos usados para prefijar el nombre de un atributo o método privado.

---

Usa dobles guiones bajos al principio y al final

### --feedback--

Presta atención a los símbolos usados para prefijar el nombre de un atributo o método privado.

---

Prefijo con un doble guion bajo

---

Usa la palabra clave private

### --feedback--

Presta atención a los símbolos usados para prefijar el nombre de un atributo o método privado.

## --video-solution--

3

