---
id: 68420c314cdf5c6863ca8330
title: ¿Qué es un algoritmo y cómo funciona la notación Big O?
challengeType: 19
dashedName: what-is-an-algorithm-and-how-does-big-o-notation-work
---

# --description--

Cada programa de computadora que se ejecuta en tu dispositivo tiene un conjunto específico de instrucciones, que se ejecutan en un orden específico para completar una tarea.

La tarea podría ser ordenar un conjunto de números, modificar una imagen, rastrear inventario o incluso ejecutar tu videojuego favorito.

Aquí es donde entran en juego los algoritmos. Un **algorithm** es un conjunto de instrucciones inequívocas para resolver un problema o realizar una tarea.

Puedes pensar en los algoritmos como "recetas". Cuando cocinas, las recetas enumeran todos los ingredientes que necesitarás y proporcionan instrucciones paso a paso sobre cómo preparar un plato.

De manera equivalente, puedes pensar en los algoritmos como "recetas" que le indican a las computadoras exactamente qué debe hacerse y cómo hacerlo.

Los algoritmos tienen dos características clave:

* No pueden continuar indefinidamente. Deben terminar en un número finito de pasos.
    
* Cada paso debe ser preciso y sin ambigüedades.
    

Pueden tener cero, uno o más inputs, y generar uno o más outputs.

Los pasos de un algoritmo son independientes de cualquier lenguaje de programación.

Pero para hacer que realmente se ejecuten en una computadora, necesitas implementarlas en un lenguaje de programación, como Python o JavaScript.

Si un algoritmo es correcto, la salida para cualquier entrada válida debería coincidir con la salida esperada.

Además de ser correctos, los algoritmos también deben ser eficientes.

La eficiencia del algoritmo se puede medir en términos de cuánto tiempo tardan en ejecutarse y cuánto espacio requieren en la memoria para completar la tarea.

Conocer la eficiencia de un algoritmo es muy importante porque te da una idea de qué tan bien funcionará a medida que crezca el tamaño de la entrada.

Por ejemplo, ordenar 15 enteros no es lo mismo que ordenar 1 millón de enteros.

A medida que el proceso crece en tamaño y complejidad, si el algoritmo no es lo suficientemente eficiente para manejarlo, podrías terminar con un programa de computadora muy lento que incluso podría bloquear todo el sistema.

Por eso es muy importante desarrollar y elegir los algoritmos más eficientes posibles.

Aquí es donde la notación Big O se vuelve muy importante.

La notación Big O describe el rendimiento en el peor caso, o la tasa de crecimiento, de un algoritmo a medida que aumenta el tamaño de la entrada.

La tasa de crecimiento de un algoritmo se refiere a cómo aumentan los recursos que requiere a medida que crece el tamaño de la entrada.

La notación Big O se centra en el rendimiento en el peor caso porque este caso es muy importante para entender qué tan eficiente puede ser el algoritmo, incluso en el peor escenario, sin importar la entrada.

Volviendo a nuestro ejemplo de ordenamiento, ordenar 1 millón de enteros debería intuitivamente tomar más tiempo y recursos que ordenar 15 enteros.

¿Pero cuánto más?

Esto realmente depende del algoritmo que elijas para ordenarlos.

La notación Big O no te dará un número exacto para describir la eficiencia del algoritmo, pero te dará una idea de cómo escala a medida que crece el tamaño de la entrada, basado en el número de operaciones realizadas por el algoritmo.

En la notación Big O, usualmente denotamos el tamaño de la entrada con la letra `n`. Por ejemplo, si la entrada es una lista, `n` denotaría el número de elementos en esa lista.

Los factores constantes y los términos de orden inferior no se toman en cuenta para encontrar la complejidad temporal de un algoritmo basada en el número de operaciones. Esto se debe a que, a medida que el tamaño de `n` crece, el impacto de estos términos menores en el número total de operaciones realizadas será cada vez más pequeño.

El término que dominará el comportamiento general del algoritmo será el término de mayor orden con `n`, el tamaño de la entrada.

Por ejemplo, si un algoritmo realiza `7n + 20` operaciones para completarse, el impacto de la constante `20` en el resultado final será cada vez menor a medida que `n` crece. El término `7n` tenderá a dominar y esto definirá el comportamiento y la eficiencia general del algoritmo.

Otro ejemplo sería un algoritmo que requiere `20n² + 15n + 7` operaciones para completarse. El término `20n²` tenderá a dominar a medida que `n` crece, por lo que este algoritmo tendría una complejidad temporal cuadrática porque el término dominante tiene `n²`.

La complejidad temporal cuadrática es uno de los muchos tipos diferentes de complejidades temporales que puedes encontrar en el mundo de los algoritmos.

Vamos a aprender sobre algunos de los más comunes.

**`O(1)`** se conoce como "Complejidad de Tiempo Constante". Cuando un algoritmo tiene complejidad de tiempo constante, tarda la misma cantidad de tiempo en ejecutarse, sin importar el tamaño de la entrada.

Por ejemplo, verificar si un número es par o impar siempre tomará la misma cantidad de tiempo, sin importar el número en sí.

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

**`O(log n)`** se conoce como "Complejidad Temporal Logarítmica". Esto significa que el tiempo requerido por el algoritmo aumenta lentamente a medida que crece el tamaño de la entrada. Esto es común en problemas en los que el tamaño del problema se reduce repetidamente por una fracción constante.

Por ejemplo, un algoritmo de búsqueda popular llamado Binary Search tiene una complejidad temporal en el peor caso de `O(log n)`. Esto se debe a que elimina la mitad de los elementos restantes en cada comparación, lo que lo hace más eficiente en general.

**`O(n)`** se conoce como "Complejidad Temporal Lineal". El tiempo de ejecución de algoritmos con esta complejidad temporal aumenta proporcionalmente al tamaño de la entrada.

Por ejemplo, un ciclo `for` que itera sobre todos los elementos de una lista realizará más iteraciones a medida que aumenta el número de elementos de la lista. Si la lista se duplica en tamaño, el número de operaciones también se duplicará aproximadamente.

```python
for grade in grades:  # grades is a list.
    print(grade)
```

**`O(n log n)`** es conocido como "Complejidad Temporal Log-Lineal". Esta es una complejidad temporal común de algoritmos de ordenamiento eficientes, como Merge Sort y Quick Sort.

**`O(n²)`** se conoce como "Complejidad Temporal Cuadrática". El tiempo de ejecución de estos algoritmos aumenta de forma cuadrática en relación con el tamaño de la entrada, lo cual generalmente no es eficiente para problemas del mundo real.

Los bucles anidados son un ejemplo común de complejidad temporal cuadrática. El bucle interno realizará `n` iteraciones por cada una de las `n` iteraciones del bucle externo, resultando en `n` al cuadrado iteraciones.

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

Otras complejidades temporales incluyen la "Complejidad Temporal Exponencial", denotada como `O(2^n)`, y la "Complejidad Temporal Factorial", denotada como `O(n!)`. Ambas son ineficientes para escenarios del mundo real.

En este gráfico, puedes comparar el crecimiento de las funciones matemáticas que representan las complejidades de tiempo más comunes. Piensa en el eje x (horizontal) como el tamaño de la entrada y en el eje y (vertical) como el tiempo de ejecución del algoritmo.

Puedes ver que la Complejidad Temporal Cuadrática (`O(n²)`) (amarillo) crece mucho más rápido que las otras, mientras que la Complejidad Temporal Constante (`O(1)`) (rojo) se mantiene constante, incluso si la entrada crece.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-is-an-algorithm-and-how-does-big-o-notation-work-1.png" alt="graph comparing time complexity">

Genial. Hasta ahora, has aprendido sobre la notación Big O en términos de requisitos de tiempo, pero esta notación también se puede aplicar al contexto de los requisitos de espacio.

En este contexto, describe cómo el espacio de memoria requerido por el algoritmo crece a medida que crece el tamaño de la entrada.

Los algoritmos con "Complejidad Espacial Constante" `O(1)` siempre requieren una cantidad constante de espacio de memoria, incluso cuando la entrada crece.

Un ejemplo sería un algoritmo que solo crea y almacena unas pocas variables en memoria.

En contraste, el espacio requerido por algoritmos con "Complejidad de Espacio Lineal" `O(n)` aumenta proporcionalmente a medida que crece el tamaño de la entrada.

Un ejemplo de esto sería un algoritmo que crea y almacena una copia de una lista de longitud `n`.

Y finalmente, los requisitos de espacio de un algoritmo con "Complejidad de Espacio Cuadrática" `O(n²)` aumentan cuadráticamente a medida que crece el tamaño de la entrada.

Un ejemplo de esto sería crear una matriz 2D, donde las dimensiones se determinan por el tamaño de entrada, almacenando todos los pares posibles.

Los algoritmos son los bloques fundamentales de los programas de computadora, mientras que la notación Big O es una estructura poderosa para analizar qué tan eficientes son, basándose en cómo sus requisitos de tiempo y espacio en el peor de los casos escalan a medida que crece el tamaño de la entrada. Entender su eficiencia es muy importante para desarrollar software que funcione eficientemente en escenarios del mundo real.

# --questions--

## --text--

¿Cuál de las siguientes opciones describe mejor un algoritmo?

## --answers--

Un lenguaje de programación específico usado para escribir código.

### --feedback--

Piensa en lo que sigues cuando intentas lograr una tarea específica.

---

Un conjunto de instrucciones paso a paso diseñadas para resolver un problema o realizar una tarea.

---

Un tipo de componente de hardware de computadora.

### --feedback--

Piensa en lo que sigues cuando intentas lograr una tarea específica.

---

Una aplicación de software usada para desarrollar y jugar juegos.

### --feedback--

Piensa en lo que sigues cuando intentas lograr una tarea específica.

## --video-solution--

2

## --text--

¿Cuál es el propósito principal de la notación Big O en el contexto de los algoritmos?

## --answers--

Para medir el tiempo exacto que un algoritmo tarda en ejecutarse en una computadora específica en segundos.

### --feedback--

Piensa en cómo la notación Big O te ayuda a entender el rendimiento de un algoritmo cuando la cantidad de datos que procesa se vuelve muy grande.

---

Para contar el número total de líneas de código en un algoritmo.

### --feedback--

Piensa en cómo la notación Big O te ayuda a entender el rendimiento de un algoritmo cuando la cantidad de datos que procesa se vuelve muy grande.

---

Para describir cómo el uso de recursos de un algoritmo crece a medida que aumenta el tamaño de la entrada.

---

Para determinar el rendimiento en el mejor caso de un algoritmo.

### --feedback--

Piensa en cómo la notación Big O te ayuda a entender el rendimiento de un algoritmo cuando la cantidad de datos que procesa se vuelve muy grande.

## --video-solution--

3

## --text--

Si un algoritmo tiene una complejidad temporal de `O(n)`, ¿qué significa esto sobre su rendimiento?

## --answers--

El tiempo de ejecución del algoritmo aumenta proporcionalmente con el tamaño de la entrada.

---

El tiempo de ejecución del algoritmo permanece constante sin importar el tamaño de la entrada.

### --feedback--

Piensa en lo que significa "linear" en términos de una relación directa o una línea recta en un gráfico.

---

El tiempo de ejecución del algoritmo crece exponencialmente con el tamaño de la entrada.

### --feedback--

Piensa en lo que significa "linear" en términos de una relación directa o una línea recta en un gráfico.

---

El tiempo de ejecución del algoritmo disminuye a medida que el tamaño de la entrada aumenta.

### --feedback--

Piensa en lo que significa "linear" en términos de una relación directa o una línea recta en un gráfico.

## --video-solution--

1

