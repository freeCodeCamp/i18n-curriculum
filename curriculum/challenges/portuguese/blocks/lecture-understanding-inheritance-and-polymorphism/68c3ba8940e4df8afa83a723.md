---
id: 68c3ba8940e4df8afa83a723
title: O que é Herança e Como Ela Promove a Reutilização de Código?
challengeType: 19
dashedName: what-is-inheritance-and-how-does-it-promote-code-reuse
---

# --description--

Herança é o próximo conceito chave da programação orientada a objetos (OOP) que abordaremos.

Vamos analisar mais profundamente esse conceito e como ele permite que você escreva código reutilizável.

Com herança, uma subclasse (ou classe filha) pode usar os atributos e métodos de uma classe base (ou classe pai). Isso permite reutilizar código, criar hierarquias claras de classes e personalizar o comportamento sem reescrever tudo. Você pode personalizar estendendo métodos existentes ou sobrescrevendo-os na classe filha.

Aqui está a sintaxe básica para herança:

```py
class Parent:
    # Parent attributes and methods

class Child(Parent):
    # Child inherits, extends, and/or overrides where necessary
```

Para a classe `Child` herdar da classe `Parent`, você precisa passar o `Parent` para o `Child`.

Esse estilo é chamado de herança simples, já que uma classe filha herda de exatamente uma classe pai.

Aqui está um exemplo:

```py
class Animal:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return f'{self.name} makes a sound'

class Dog(Animal):
    bark = 'woof! woof!! woof!!!'

jack = Dog('Jack')
print(jack.sound())  # Jack makes a sound
print(jack.bark)  # woof! woof!! woof!!!
```

Você pode ver que somos capazes de reutilizar o atributo `self.name` e o método `sound()` da classe pai `Animal` na classe filha `Dog`.

Vamos sobrescrever o método `sound()` da classe pai `Animal` na classe filha `Dog` para que possamos fazer o `sound()` usar a variável de classe `bark`:

```py
class Animal:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return f'{self.name} makes a sound.'

class Dog(Animal):
    bark = 'woof! woof!! woof!!!'

    # Override sound() to use bark class variable
    def sound(self):
        return f'{self.name} barks {self.bark}'

jack = Dog('Jack')
print(jack.sound())  # Jack barks woof! woof!! woof!!!
```

Se você quiser manter o valor de retorno de `sound()` e adicionar a variável de classe bark depois, você pode estender `sound()` usando a função `super()`:

```py
class Animal:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return f'{self.name} makes a sound'

class Dog(Animal):
    bark = 'woof! woof!! woof!!!'

    # Call Animal.sound(), then append bark
    def sound(self):
        base = super().sound()
        return f'{base}, then {self.name} barks {self.bark}'

jack = Dog('Jack')
print(jack.sound())  # Jack makes a sound, then Jack barks woof! woof!! woof!!!
```

Neste exemplo, `base` é o resultado de chamar o método `sound()` da classe `Animal` e então adicionamos o som específico da classe `Dog` a ele. Desta forma, você pode estender a funcionalidade da classe pai `Animal` mantendo seu comportamento original.

Também existe herança múltipla, onde uma classe filha pode herdar de mais de uma classe pai.

Aqui está a sintaxe básica de herança múltipla:

```py
class Parent:
    # Attributes and methods for Parent

class Child:
    # Attributes and methods for Child

class GrandChild(Parent, Child):
    # GrandChild inherits from both Parent and Child
    # GrandChild can combine or override behavior from each
```

Uma maneira simples de demonstrar herança múltipla é com um sapo, que pode tanto andar em terra e nadar na água:

```py
class Walker:
    def walk(self):
        return 'I can walk on land'

class Swimmer:
    def swim(self):
        return 'I can swim in water'

# Amphibian inherits from both Walker and Swimmer
class Amphibian(Walker, Swimmer):
    def __init__(self, name):
        self.name = name

    def introduce(self):
        return f"I'm {self.name} the frog. {self.walk()} and {self.swim()}."

frog = Amphibian('Freddy')
print(frog.introduce())
# Output: I'm Freddy the frog. I can walk on land and I can swim in water.
```

# --questions--

## --text--

Qual é o propósito principal da herança na programação orientada a objetos?

## --answers--

Para criar cópias idênticas de uma classe pai.

### --feedback--

Pense em como uma classe filha pode reutilizar e estender atributos e métodos de uma classe pai.

---

Para permitir que uma classe filha reutilize e estenda atributos/métodos de uma classe pai.

### --feedback--

Pense em como uma classe filha pode reutilizar e estender atributos e métodos de uma classe pai.

---

Para tornar todos os métodos em uma classe privados.

---

Para evitar a duplicação de código mesclando classes não relacionadas.

### --feedback--

Pense em como uma classe filha pode reutilizar e estender atributos e métodos de uma classe pai.

## --video-solution--

2

## --text--

O que é herança múltipla em Python?

## --answers--

Uma classe filha herdando de uma classe pai.

### --feedback--

Pense no estilo de herança que permite que um filho herde de várias classes.

---

Uma classe pai com múltiplas classes filhas.

### --feedback--

Pense no estilo de herança que permite que um filho herde de várias classes.

---

Uma classe filha herdando de múltiplas classes pai.

---

Uma classe que não pode herdar de forma alguma.

### --feedback--

Pense no estilo de herança que permite que um filho herde de várias classes.

## --video-solution--

3

## --text--

Como fazer uma classe filha herdar de uma classe pai em Python?

## --answers--

Ao chamar `Parent.inherit(Child)`.

### --feedback--

A sintaxe envolve parênteses na definição da classe.

---

Copiando todos os métodos manualmente.

### --feedback--

A sintaxe envolve parênteses na definição da classe.

---

Ao usar a palavra-chave `extends`.

### --feedback--

A sintaxe envolve parênteses na definição da classe.

---

Passando a classe Parent como argumento para a classe Child.

## --video-solution--

4
