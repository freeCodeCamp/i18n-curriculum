---
id: 6724e46581a1742244e45b59
title: Revisão de Bash e SQL
challengeType: 31
dashedName: review-bash-and-sql
---

# --description--

## Normalização de Banco de Dados

Este é o processo de organizar um banco de dados relacional para reduzir a redundância de dados e melhorar a integridade.

Seus benefícios incluem:

- Minimizar dados duplicados, o que economiza armazenamento e reduz inconsistências.
- Garantindo a integridade dos dados por meio do uso de chaves primárias e estrangeiras.
- Tornando bancos de dados mais fáceis de manter e entender.

### Formas Normais

- **1NF (Primeira Forma Normal)**
  - Cada célula contém um único valor (atômico).
  - Cada registro é único (garantido por uma chave primária).
  - A ordem das linhas/colunas é irrelevante.
  - Exemplo: Mova vários números de telefone da tabela `students` para uma tabela separada `student_phones`.

- **2NF (Segunda Forma Normal)**
  - Atende aos requisitos da 1NF.
  - Sem **partial dependencies**: todo atributo não-chave deve depender da chave primária composta inteira.
  - Exemplo: Divida a tabela `orders` em `order_header` e `order_items` para evitar atributos que dependam de apenas parte da chave.

- **3NF (Terceira Forma Normal)**
  - Atende aos requisitos da 2NF.
  - Sem **dependências transitivas**: atributos não-chave não podem depender de outros atributos não-chave.
  - Exemplo: Mova `city_postal_code` para uma tabela `cities` em vez de armazená-lo com cada pedido.

- **BCNF (Boyce-Codd Normal Form)**
  - Atende aos requisitos da 3NF.
  - Todo determinante (lado esquerdo de uma dependência funcional) deve ser uma superchave.

**Dica**: Busque a 3NF na maioria dos designs para um bom equilíbrio entre integridade e desempenho.

## Conceitos-chave de SQL

- SQL é uma Linguagem de Consulta Estruturada para comunicação com bancos de dados relacionais.
- **Comandos básicos** → `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`, `ALTER TABLE`, etc.
- `Joins` → Combina dados de múltiplas tabelas (`INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`).

## Executando Comandos SQL no Bash

Você pode executar comandos SQL diretamente da linha de comando usando o cliente de linha de comando `psql` para PostgreSQL ou ferramentas similares para outros bancos de dados.

Por exemplo, para executar um arquivo SQL no PostgreSQL:

```bash
psql -U username -d database_name -c "SELECT * FROM students;"
```

Você também pode executar comandos MySQL diretamente:

```bash
mysql -u username -p database_name -e "SELECT * FROM students;"
```

### Executar SQL a partir de um Arquivo

```bash
# PostgreSQL
psql -U username -d database_name -f script.sql

# MySQL
mysql -u username -p database_name < script.sql
```

### Incorporar SQL em um Script Bash

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Insert student data
psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'CS');"
```

### Uso de Variáveis em SQL

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"
STUDENT_NAME="Bob"
AGE=21

psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age) VALUES ('$STUDENT_NAME', $AGE);"
```

**Dica**: Sanitizar variáveis para evitar SQL injection.

## Recuperando e Usando Resultados de Consultas SQL no Bash

Quando você executa consultas SQL via `psql`, você pode **capturar** e **processar** os valores retornados em seus scripts Bash.

### Capturando um Valor Único

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get total student count
STUDENT_COUNT=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -c \
"SELECT COUNT(*) FROM students;")

echo "Total students: $STUDENT_COUNT"
```

Saída → 42

### Recuperando Múltiplas Colunas

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get top 3 students' names and ages
RESULTS=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, age FROM students LIMIT 3;")

echo "Top 3 students:"
echo "$RESULTS"
```

Saída

```bash
Alice,20
Bob,21
Charlie,22
```

### Iterando pelos Resultados da Consulta

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get student names and majors
psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, major FROM students;" | while IFS="," read -r name major
do
    echo "Student: $name | Major: $major"
done
```

Formato da Saída

```bash
Student: Alice | Major: CS
Student: Bob   | Major: Math
Student: Carol | Major: Physics
```

## Injeção de SQL

É uma vulnerabilidade de segurança web onde atacantes inserem código SQL malicioso em campos de entrada para manipular o banco de dados.

Isso pode levar a ações arriscadas como:

- Ignorando a autenticação.
- Roubando dados sensíveis.
- Modificando ou excluindo registros.

Um exemplo de ataque de injeção SQL:

```sql
SELECT * FROM users WHERE username = ' " " OR "1"="1" -- ' AND password = 'anything';
```

Esta consulta retornaria todos os usuários porque a condição `OR "1"="1"` é sempre verdadeira, permitindo que atacantes contornem as verificações de login.

### Prevenção de SQL Injection

1. **Use Prepared Statements**: Eles separam o código SQL dos dados, prevenindo injeções. Aqui está um exemplo (Node.js com pg):

    ```sql
    client.query('SELECT * FROM users WHERE username = $1 AND password = $2', [username, password]);
    ```

2. **Validação de Entrada**: Sanitizar e validar todas as entradas do usuário para garantir que elas estejam em conformidade com os formatos esperados.

3. **Privilégio Mínimo**: Use contas de banco de dados com as permissões mínimas necessárias para a aplicação.

**Nota**: Nunca conceda direitos de administrador a contas de aplicação.

## Problema N+1

O problema N+1 ocorre quando uma aplicação faz uma consulta para recuperar uma lista de itens (N) e depois faz uma consulta adicional para cada item para recuperar dados relacionados, resultando em N+1 consultas.

**Por que é ruim**

- Cada consulta adiciona sobrecarga de rede e processamento.
- Múltiplas pequenas consultas são mais lentas do que uma consulta otimizada.

### Exemplo do Padrão N+1

```sql
-- 1: Get list of orders
SELECT * FROM orders LIMIT 50;

-- N: For each order, get customer
SELECT * FROM customers WHERE customer_id = ...;
```

**Solução**: Use `JOINs` ou outras operações baseadas em conjuntos.

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name,
  customers.email,
  customers.address
FROM orders
JOIN customers 
  ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50);
```

Sempre procure oportunidades para combinar dados relacionados em uma única consulta.

# --assignment--

Revise os tópicos e conceitos de Bash e SQL.
