---
id: 58a25bcff9fc0f352b528e7d
title: 非同步地雜湊並比較密碼
challengeType: 2
forumTopicId: 301578
dashedName: hash-and-compare-passwords-asynchronously
---

# --description--

提醒你，這個專案是基於從 <a href="https://github.com/freeCodeCamp/boilerplate-bcrypt/" target="_blank" rel="noopener noreferrer nofollow">GitHub</a> 複製的以下起始專案所建立。

由於雜湊設計為計算密集型，建議在你的伺服端非同步執行，以避免在進行雜湊時阻塞進來的連接。你所要做的就是非同步呼叫 `hash` 來雜湊密碼。

```js
bcrypt.hash(myPlaintextPassword, saltRounds, (err, hash) => {
  /*Store hash in your db*/
});
```

# --instructions--

將此雜湊函式添加到你的伺服器（我們已經為你定義好函式中使用的變數）並將其記錄到主控台讓你查看！此時你通常會將雜湊值存檔到你的資料庫。

現在當你需要判斷新的輸入是否與該雜湊的資料相同時，你只要使用 compare 函式。

```js
bcrypt.compare(myPlaintextPassword, hash, (err, res) => {
  /*res == true or false*/
});
```

將此加入你現有的 hash 函式（因為你需要等待 hash 完成後才能呼叫 compare 函式），在你記錄完成的 hash 之後，並在 compare 中將 'res' 記錄到主控台。你應該會在主控台看到一個 hash，然後列印出 'true'！如果你將 compare 函式中的 'myPlaintextPassword' 改成 'someOtherPlaintextPassword'，那麼它應該會顯示 false。

```js
bcrypt.hash('passw0rd!', 13, (err, hash) => {
  console.log(hash);
  //$2a$12$Y.PHPE15wR25qrrtgGkiYe2sXo98cjuMCG1YwSI5rJW1DSJp0gEYS
  bcrypt.compare('passw0rd!', hash, (err, res) => {
    console.log(res); //true
  });
});

```

當你認為已經正確時，提交你的頁面。

# --hints--

應該產生非同步雜湊並正確比較。

```js
const response = await fetch(code + '/_api/server.js');
if (!response.ok) {
  throw Error(await response.text());
}
const data = await response.text();
assert.match(
  data,
  /START_ASYNC[^]*bcrypt.hash.*myPlaintextPassword( |),( |)saltRounds( |),( |).*err( |),( |)hash[^]*END_ASYNC/gi,
  'You should call bcrypt.hash on myPlaintextPassword and saltRounds and handle err and hash as a result in the callback'
);
assert.match(
  data,
  /START_ASYNC[^]*bcrypt.hash[^]*bcrypt.compare.*myPlaintextPassword( |),( |)hash( |),( |).*err( |),( |)res[^]*}[^]*}[^]*END_ASYNC/gi,
  'Nested within the hash function should be the compare function comparing myPlaintextPassword to hash'
);
```

