---
id: 697dc755c709772fad37de9e
title: ¿Cómo funcionan las matrices y las listas de adyacencia?
challengeType: 19
dashedName: how-do-matrices-and-adjacency-lists-work
---

# --description--

Los grafos son estructuras de datos muy poderosas formadas por un conjunto de nodos, también conocidos como vértices, y aristas que los conectan.

Hay dos formas comunes de implementar grafos en tu código:

* Matrices de adyacencia
    
* Listas de adyacencia
    

Veamos más a fondo estos, y revisemos sus ventajas y limitaciones.

## Matrices de Adyacencia

Comenzaremos con matrices de adyacencia.

Una matriz de adyacencia es un arreglo bidimensional en el que las filas y columnas representan los vértices del grafo.

Los valores en la matriz representan las aristas o conexiones entre los nodos.

Por ejemplo, si tienes una matriz almacenada en una variable llamada `matrix`, el valor almacenado en `matrix[i][j]`, donde `i` es la fila y `j` es la columna, representa el borde o conexión entre los nodos `i` y `j`.

Los valores pueden tener diferentes significados dependiendo de si el grafo es ponderado o no ponderado:

* Si el grafo no tiene pesos, un valor de `1` significa que hay una arista que conecta estos nodos, mientras que un valor de `0` significa que no hay arista entre ellos.
    
* Si el grafo es ponderado, el valor representaría el peso de la arista que conecta los nodos.

Una de las grandes ventajas de usar una matriz de adyacencia es que verificar si hay una arista entre dos nodos toma tiempo constante `O(1)`. Esto se debe a que el programa solo necesita encontrar ese valor particular en el arreglo 2D.

Sin embargo, esta eficiencia para encontrar los bordes viene con un compromiso. Las matrices de adyacencia tienen un gran requerimiento de espacio cuadrático `O(V²)`, donde `V` es el número de nodos en el grafo.

Esto es ineficiente para grafos dispersos, que son grafos que solo tienen unas pocas aristas. ¿Por qué? Porque si el grafo es disperso, estarás almacenando muchos 0s en la matriz para representar la falta de aristas entre los nodos, y estos 0s aún ocuparán espacio en la memoria.

Las matrices de adyacencia también son ineficientes para encontrar los vecinos de un nodo porque el programa tiene que iterar sobre toda la fila o columna para encontrar los 0s y 1s que representan las aristas. En el peor de los casos, este proceso puede tomar `O(V)` tiempo, donde `V` es el número de nodos en el grafo.

Veamos un ejemplo de una matriz de adyacencia para este grafo en particular:

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png" alt="A graph with four nodes labeled A, B, C, and D. Node A connects to B, C, and D. Node B connects to A and D. Node C connects to A. Node D connects to A and B.">

En la matriz de adyacencia:

* Cada fila representa un nodo. La primera fila representa el nodo A, la segunda fila representa el nodo B, y así sucesivamente.
    
* Cada columna también representa un nodo.
    
* Cada valor en la matriz representa si hay una arista entre cada par de nodos. Un valor de 0 significa que no hay una arista conectando estos nodos, mientras que un valor de 1 significa que sí hay una arista.
    
Los valores en la diagonal representan si cada nodo tiene o no un self-loop, una arista que conecta el nodo consigo mismo. En nuestro ejemplo, todos son 0 porque el grafo no tiene ningún self-loop.

Esta es una representación visual de la matriz de adyacencia para mostrarte cómo las filas y columnas representan los nodos correspondientes.

Por ejemplo, la primera fila es `[0, 1, 1, 1]` porque el nodo A tiene aristas que lo conectan con los nodos B, C y D:

```markdown
#      A  B  C  D
# A   [0, 1, 1, 1],
# B   [1, 0, 0, 1],
# C   [1, 0, 0, 0],
# D   [1, 1, 0, 0]
```

Y esta es la misma matriz de adyacencia, pero implementada en código JavaScript:

```javascript
const adjacencyMatrix = [
  [0, 1, 1, 1], // The neighbors of A are B, C, and D
  [1, 0, 0, 1], // The neighbors of B are A and D
  [1, 0, 0, 0], // The only neighbor of C is A
  [1, 1, 0, 0]  // The neighbors of D are A and B
];
```

## Listas de Adyacencia

Otra forma común de representar grafos es usando listas de adyacencia.

Una lista de adyacencia es un arreglo u objeto (o un `Map`) que almacena todos los vecinos de cada nodo.

Hay dos formas comunes de implementar listas de adyacencia:

* Como un arreglo, donde cada índice representa un nodo y el arreglo almacenado en ese índice contiene sus vecinos.
* Como un objeto (o `Map`), donde cada clave representa un nodo y el valor asociado a esa clave (un arreglo) contiene sus vecinos.

Las listas de adyacencia son más eficientes que las matrices de adyacencia en términos de requisitos de espacio. Tienen una complejidad de espacio de `O(V + E)`, donde `V` es el número de vértices (nodos) y `E` es el número de aristas.

También es eficiente para encontrar todos los nodos vecinos, ya que esta operación solo requiere acceder a la lista asociada al nodo.

Sin embargo, también hay una compensación.

Las listas de adyacencia son menos eficientes que las matrices de adyacencia para determinar si existe una arista entre dos nodos.

El proceso de búsqueda típicamente toma `O(deg(v))` tiempo (donde `deg(v)` es el número de vecinos del nodo que estás revisando), y en el peor de los casos puede ser `O(V)` si un nodo está conectado a todos los demás nodos en el grafo.

Aquí tienes un ejemplo de una lista de adyacencia para este grafo:

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png" alt="A graph with four nodes labeled A, B, C, and D. Node A connects to B, C, and D. Node B connects to A and D. Node C connects to A. Node D connects to A and B. It's the same image as before.">

Esta lista de adyacencia está implementada como un objeto. Cada clave en el objeto representa un nodo, y el valor asociado a esa clave es un arreglo con todos los vecinos del nodo correspondiente:

```javascript
const adjacencyList = {
  A: ["B", "C", "D"],
  B: ["A", "D"],
  C: ["A"],
  D: ["A", "B"]
};
```

Alternativamente, podríamos implementarlo como un arreglo 2D, donde cada índice representa un nodo. Por ejemplo, el índice 0 representa el nodo A, el índice 1 representa el nodo B, y así sucesivamente:

```javascript
const adjacencyList = [
  ["B", "C", "D"], // Neighbors of A (index 0)
  ["A", "D"],      // Neighbors of B (index 1)
  ["A"],           // Neighbors of C (index 2)
  ["A", "B"]       // Neighbors of D (index 3)
];
```

Nota que aunque este arreglo 2D pueda parecer similar a la matriz de adyacencia, son bastante diferentes.

* La matriz de adyacencia almacena 0s, 1s u otros valores que representan las aristas o los pesos de las aristas en el grafo.

* La lista de adyacencia almacena la lista real de todos los vecinos de cada nodo.

Esta es una diferencia muy importante con la que deberías estar familiarizado.

Tanto las matrices de adyacencia como las listas de adyacencia son muy importantes para implementar grafos. Elegir entre ellas depende del tamaño del grafo y de cómo necesitas usar los datos. Las matrices de adyacencia son útiles para grafos densos con muchas aristas, mientras que las listas de adyacencia suelen ser la opción preferida para escenarios del mundo real, donde los grafos dispersos son más comunes.

# --questions--

## --text--

¿Para cuál de los siguientes escenarios es una matriz de adyacencia la opción más eficiente para representar un grafo?

## --answers--

Una red social con miles de millones de personas y muy pocas conexiones por persona.

### --feedback--

Piensa en cuánta memoria usa una matriz y cómo eso cambia según el número de conexiones.

---

Una red de computadoras con solo cinco conexiones.

### --feedback--

Piensa en cuánta memoria usa una matriz y cómo eso cambia según el número de conexiones.

---

Un grafo denso donde cada nodo está conectado con la mayoría de los otros nodos.

---

Un grafo donde la operación principal es encontrar todos los vecinos de un nodo específico.

### --feedback--

Piensa en cuánta memoria usa una matriz y cómo eso cambia según el número de conexiones.

## --video-solution--

3

## --text--

¿Cuándo sería más eficiente usar una lista de adyacencia en lugar de una matriz de adyacencia?

## --answers--

Cuando el grafo es denso y tiene muchas aristas.

### --feedback--

Piensa en cómo una lista de adyacencia ahorra memoria cuando un grafo no está muy conectado.

---

Cuando necesites verificar si existe una arista entre dos nodos muy rápidamente.

### --feedback--

Piensa en cómo una lista de adyacencia ahorra memoria cuando un grafo no está muy conectado.

---

Cuando el grafo tiene un alto número de vértices y muchas conexiones.

### --feedback--

Piensa en cómo una lista de adyacencia ahorra memoria cuando un grafo no está muy conectado.

---

Cuando el grafo es disperso, con un alto número de vértices y un bajo número de aristas.

## --video-solution--

4

## --text--

¿Cuál de las siguientes operaciones es más rápida en una matriz de adyacencia comparada con una lista de adyacencia?

## --answers--

Encontrar todos los vecinos de un solo nodo.

### --feedback--

Piensa en cómo realizarías cada una de estas operaciones en una estructura basada en cuadrícula y en una lista.

---

Comprobando si existe una arista directa entre dos nodos específicos.

---

Iterando a través de todos los nodos en el grafo.

### --feedback--

Piensa en cómo realizarías cada una de estas operaciones en una estructura basada en cuadrícula y en una lista.

---

Agregando un nuevo nodo al grafo.

### --feedback--

Piensa en cómo realizarías cada una de estas operaciones en una estructura basada en cuadrícula y en una lista.

## --video-solution--

2
