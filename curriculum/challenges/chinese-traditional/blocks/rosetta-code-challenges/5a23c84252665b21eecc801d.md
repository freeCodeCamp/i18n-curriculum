---
id: 5a23c84252665b21eecc801d
title: 根據字元變化拆分字串
challengeType: 1
forumTopicId: 302322
dashedName: split-a-character-string-based-on-change-of-character
---

# --description--

將 (字元) 字串依字元變化（由左至右）拆分為以逗號（加空白）分隔的字串。空白應視為其他字元（除了它們在顯示上較難清楚呈現）。逗號亦同理。例如，字串：

<pre>
"gHHH5YY++///\\"
</pre>

應該被拆分為：

<pre>
["g", "HHH", "5", "YY", "++", "///", "\\" ];
</pre>

# --hints--

`split` 應該是一個函式（程式）。

```js
assert(typeof split == 'function');
```

`split("hello")` 應該傳回一個陣列。

```js
assert(Array.isArray(split('hello')));
```

`split("hello")` 應該傳回 `["h", "e", "ll", "o"]`。

```js
assert.deepEqual(split('hello'), ['h', 'e', 'll', 'o']);
```

`split("commission")` 應該傳回 `["c", "o", "mm", "i", "ss", "i", "o", "n"]`。

```js
assert.deepEqual(split('commission'), [
  'c',
  'o',
  'mm',
  'i',
  'ss',
  'i',
  'o',
  'n'
]);
```

`split("ssss----====llloooo")` 應該傳回 `["ssss", "----", "====", "lll", "oooo"]`。

```js
assert.deepEqual(split('ssss----====llloooo'), [
  'ssss',
  '----',
  '====',
  'lll',
  'oooo'
]);
```

`split("sssmmmaaammmaaat")` 應該傳回 `["sss", "mmm", "aaa", "mmm", "aaa", "t"]`。

```js
assert.deepEqual(split('sssmmmaaammmaaat'), [
  'sss',
  'mmm',
  'aaa',
  'mmm',
  'aaa',
  't'
]);
```

`split("gHHH5YY++///\\")` 應該傳回 `["g", "HHH", "5", "YY", "++", "///", "\\"]`。

```js
assert.deepEqual(split('gHHH5YY++///\\'), [
  'g',
  'HHH',
  '5',
  'YY',
  '++',
  '///',
  '\\'
]);
```

# --seed--

## --seed-contents--

```js
function split(str) {

}
```

# --solutions--

```js
function split(str) {
  const concat = xs =>
    xs.length > 0
      ? (() => {
          const unit = typeof xs[0] === 'string' ? '' : [];
          return unit.concat.apply(unit, xs);
        })()
      : [];

  const group = xs => groupBy((a, b) => a === b, xs);

  const groupBy = (f, xs) => {
    const dct = xs.slice(1).reduce(
      (a, x) => {
        const h = a.active.length > 0 ? a.active[0] : undefined,
          blnGroup = h !== undefined && f(h, x);
        return {
          active: blnGroup ? a.active.concat([x]) : [x],
          sofar: blnGroup ? a.sofar : a.sofar.concat([a.active])
        };
      },
      {
        active: xs.length > 0 ? [xs[0]] : [],
        sofar: []
      }
    );
    return dct.sofar.concat(dct.active.length > 0 ? [dct.active] : []);
  };

  const map = (f, xs) => xs.map(f);

  const stringChars = s => s.split('');

  return map(concat, group(stringChars(str)));
}
```
