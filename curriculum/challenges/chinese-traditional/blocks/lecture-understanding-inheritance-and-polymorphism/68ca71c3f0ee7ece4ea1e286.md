---
id: 68ca71c3f0ee7ece4ea1e286
title: 什麼是 Name Mangling 以及它如何運作？
challengeType: 19
dashedName: what-is-name-mangling-and-how-does-it-work
---

# --description--

在之前的課程中，你學習了如何為屬性加上單一底線和雙底線的前置式。

為了提醒你它們之間的差異，單一底線是一種慣例，表示該屬性是供類別內部使用，不應該從類別外部直接存取。另一方面，雙底線則防止該屬性被從類別外部直接存取。

這裡有一個範例示範這兩者如何運作：

```py
class Example:
    def __init__(self):
        self._internal = 'I can be accessed from outside the class, but should not'
        self.__private = 'You cannot access me directly from outside the class'

obj = Example()

print(obj._internal) # I can be accessed from outside the class, but should not
print(obj.__private)  # AttributeError: 'Example' object has no attribute '__private'
```

為屬性加上雙底線前置式會觸發 Python 的名稱混淆處理程序，在此程序中，Python 會在內部將該屬性重新命名，方法是加上一個底線和類別名稱作為前置式，將 `__attribute` 變成 `_ClassName__attribute`。

要看到這個效果，你需要創建該類別的實體，並使用該實體的 `__dict__` 特殊屬性，該屬性是一個包含物件屬性的字典：

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    'I can be accessed from outside the class, but should not',
    'I cannot be accessed directly from outside the class'
)

print(example1.__dict__)
```

結果將會是：

```py
{
  '_internal': 'I can be accessed from outside the class, but should not',
  '_Example__private': 'I cannot be accessed directly from outside the class'
}
```

如你所見，`__private` 屬性會以 `_Example__private` 形式儲存。這表示你仍然可以用這種方式在類別外部存取該屬性：

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    'I can be accessed from outside the class, but should not',
    'I cannot be accessed directly from outside the class'
)
example2 = Example(
    'I should not be accessed from outside the class',
    'But I can be accessed from outside the class with name mangling'
)

print(example1._Example__private) # I cannot be accessed directly from outside the class
print(example2._Example__private) # But I can be accessed from outside the class with name mangling
```

那麼，為什麼 Python 要進行名稱改寫？

名稱改編的主要目的是在你使用繼承時防止意外的屬性和方法覆寫。以下是一個能清楚說明這點的範例：

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

你可以看到 `Parent` 類別和繼承自它的 `Child` 都有各自獨立的 `_class__data` 屬性。這是透過名稱改寫實現的。否則，`Child` 會意外地覆寫 Parent 的資料。

以下是在不允許 Python 執行名稱改寫的情況下會發生的情況，也就是如果你沒有在兩個類別中的屬性前面加上雙底線：

```py
class Parent:
   def __init__(self):
       self.data = 'Parent data'

class Child(Parent):
   def __init__(self):
       super().__init__()
       self.data = 'Child data'

c = Child()
print(c.__dict__)  # {'data': 'Child data'}
```

那麼，你應該使用單底線（`_`）還是雙底線（`__`）來作為屬性的前置式呢？這取決於情況。如果屬性僅用於類別內部，請使用單底線。 

但是如果你正在使用一個會被繼承的類別，你應該使用雙底線，以免父類別的屬性被覆寫。 

# --questions--

## --text--

單底線和雙底線之間有什麼差別？

## --answers--

單底線和雙底線在 Python 中被視為相同。

### --feedback--

專注於 Python 如何處理以 `_` 與 `__` 開頭的屬性。

---

單個底線使屬性完全私有，而雙底線使它們受保護。

### --feedback--

專注於 Python 如何處理以 `_` 與 `__` 開頭的屬性。

---

單個底線可防止直接存取，而雙底線允許直接存取。

### --feedback--

專注於 Python 如何處理以 `_` 與 `__` 開頭的屬性。

---

單個底線只是慣例，而雙底線會觸發名稱改寫。

## --video-solution--

4

## --text--

什麼是名稱混淆？

## --answers--

Python 將所有屬性轉換成方法以便更容易存取的處理程序。

### --feedback--

思考 Python 如何在內部重新命名雙底線屬性。

---

Python 刪除帶有單一底線的屬性的處理程序，以保持它們隱藏。

### --feedback--

思考 Python 如何在內部重新命名雙底線屬性。

---

Python 將 `__attribute` 變更為 `_ClassName__attribute` 的處理程序，以避免子類別中意外覆寫。

---

Python 將私有資料加密以使其無法從類別外部存取的處理程序。

### --feedback--

思考 Python 如何在內部重新命名雙底線屬性。

## --video-solution--

3

## --text--

當你沒有在父類別和子類別中的屬性前加上雙底線前置式時，會發生什麼？

## --answers--

兩個類別各自保有自己的屬性副本，彼此不會互相干擾。

### --feedback--

思考當兩個類別在沒有 `__` 的情況下使用相同屬性名稱時，`print(c.__dict__)` 顯示了什麼。

---

子類別完全改寫父類別的屬性，且父類別的資料遺失。

---

父類別屬性變成唯讀，且無法被子類別更改。

### --feedback--

思考當兩個類別在沒有 `__` 的情況下使用相同屬性名稱時，`print(c.__dict__)` 顯示了什麼。

---

Python 會引發錯誤，因為屬性必須始終以雙底線作為前置式。

### --feedback--

思考當兩個類別在沒有 `__` 的情況下使用相同屬性名稱時，`print(c.__dict__)` 顯示了什麼。

## --video-solution--

2
