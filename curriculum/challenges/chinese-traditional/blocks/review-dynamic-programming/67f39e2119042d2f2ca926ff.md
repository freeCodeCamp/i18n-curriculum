---
id: 67f39e2119042d2f2ca926ff
title: 動態規劃複習
challengeType: 31
dashedName: review-dynamic-programming
---

# --description--

## 動態規劃簡介

- **定義**：動態規劃是一種演算法技術，透過將複雜問題拆解成較簡單的子問題並儲存結果，以避免重複計算來解決問題。
- **重疊子問題**：在解決較大問題時，相同的較小問題會出現多次。與其反覆重新計算這些子問題，不如將它們的解決方案儲存起來。
- **最佳子結構**：問題的最佳解法包含其子問題的最佳解法。這表示我們可以透過結合較小零件的最佳解法來建置最佳解法。

## 動態規劃解法

- **備忘錄化（自頂向下方法）**：備忘錄化會儲存昂貴函式（程式）呼叫的結果，並在相同輸入再次出現時傳回快取結果。

```py
def climb_stairs_memo(n, memo={}):
    """Dynamic programming with memoization"""
    # Check if we've already calculated this value
    if n in memo:
        return memo[n]  # Return cached result - O(1) lookup!
    
    # Base cases
    if n <= 2:
        return n
    
    # Calculate once and store in memo for future use
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    return memo[n]
```

- **表格法（自底向上方法）**：表格法從基礎開始建置解決方案，透過填寫一個表格來存放子問題的解答。

```py
def climb_stairs_tabulation(n):
    """Dynamic programming with tabulation"""
    if n <= 2:
        return n
    
    # Create array to store results for all steps from 0 to n
    dp = [0] * (n + 1)
    dp[1] = 1  # 1 way to reach step 1
    dp[2] = 2  # 2 ways to reach step 2
    
    # Build up the solution iteratively
    for i in range(3, n + 1):
        # Ways to reach step i = ways to reach (i-1) + ways to reach (i-2)
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

## 使用動態規劃的實際應用

- **路徑優化**：GPS 系統使用動態規劃演算法來尋找位置之間的最短路徑。
- **文字處理**：拼字檢查器和自動完成特性通常依賴動態程式設計來計算字與字之間的編輯距離。
- **財務模式化**：投資策略和投資組合優化經常使用動態程式設計技術。
- **資源分配**：背包問題及其變體出現在排程、預算編列和資源管理中。

## 何時使用動態規劃

你應該考慮在以下情況使用動態程式設計：

- 這個問題可以拆解成重疊的子問題。
- 該問題展現最佳子結構。
- 一個天真的遞迴解法會涉及重複計算。
- 你需要以空間複雜度為代價來最佳化時間複雜度。

# --assignment--

複習動態規劃主題和概念。
