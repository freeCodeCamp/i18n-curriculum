---
id: 6724e2dbf723fe1c8883cc69
title: Revisión de bibliotecas de interfaz de usuario
challengeType: 24
dashedName: review-front-end-libraries
---

# --description--

## Bibliotecas y frameworks de JavaScript

- Las bibliotecas y frameworks de JavaScript ofrecen soluciones rápidas a problemas comunes y aceleran el desarrollo al proporcionar código preconstruido.
- Las bibliotecas generalmente se enfocan en proporcionar soluciones a tareas específicas, como manipular el DOM, manejar eventos, o gestionar solicitudes AJAX.
- Un par de ejemplos de bibliotecas de JavaScript son jQuery y React.
- Los frameworks, por otro lado, ofrecen una estructura más definida para construir aplicaciones. A menudo vienen con un conjunto de reglas y convenciones que los desarrolladores deben seguir.
- Ejemplos de frameworks incluyen Angular y Next.js, un meta framework para React.
- **Aplicaciones de una sola página** (SPAs) son aplicaciones web que cargan una sola página HTML y actualizan dinámicamente esa página a medida que el usuario interactúa con la aplicación sin recargar la página completa.
- Las SPAs usan JavaScript para gestionar el estado de la aplicación y renderizar contenido. Esto a menudo se hace utilizando frameworks que proporcionan grandes herramientas para construir interfaces de usuario complejas.
- Algunos problemas que rodean a las SPAs incluyen:

  - Los lectores de pantalla tienen dificultades con contenido actualizado dinámicamente.
  - La URL no cambia cuando el usuario navega dentro de la aplicación, lo que puede dificultar el marcado, el retroceso o el compartir páginas específicas.
  - El tiempo de carga inicial puede ser lento si la aplicación es grande, ya que todos los recursos necesitan cargarse de antemano.

## React js

- React es una librería muy popular de JavaScript para construir interfaces de usuario y aplicaciones web.
- Un concepto fundamental de React es la creación de componentes de UI reutilizables que pueden actualizarse y renderizarse independientemente a medida que cambian los datos.
- React permite a los desarrolladores describir cómo debería parecer la UI basándose en el estado de la aplicación. React luego actualiza y renderiza los componentes correctos cuando los datos o el estado cambian.

## Componentes de React

- Los componentes son las piezas fundamentales de las aplicaciones React que permiten a los desarrolladores descomponer interfaces de usuario complejas en partes más pequeñas y manejables.
- La UI se describe utilizando JSX, una extensión de la sintaxis de JavaScript, que permite a los desarrolladores escribir código similar a HTML dentro de JavaScript.
- Los componentes son básicamente funciones o clases JS que retornan un fragmento de UI.

Aquí tienes un ejemplo de un componente React simple que renderiza un mensaje de saludo:

```jsx
function Greeting() {
  const name = 'Anna';
  return <h1>Welcome, {name}!</h1>;
}
```

Para usar el componente, simplemente puedes llamar:

```jsx
  <Greeting />
```

## Importando y Exportando componentes React

- Los componentes React pueden ser exportados de un archivo y importados en otro archivo.
- Digamos que tienes un componente llamado `City` en un archivo llamado `City.js`. Puedes exportar el componente usando la palabra clave `export`:

```jsx
// City.js
function City() {
  return <p>New York</p>;
}

export default City;
```

- Para importar el componente `City` en otro archivo, puedes usar la palabra clave `import`:

```jsx
// App.js
import City from './City';

function App() {
  return (
    <div>
      <h1>My favorite city is:</h1>
      <City />
    </div>
  );
}
```

- La palabra clave `default` se usa ya que es la exportación por defecto del archivo `City.js`.

- También puedes elegir exportar el componente en la misma línea que la definición del componente de esta manera:

```jsx
export default function City() {
  return <p>New York</p>;
}
```

## Configuración de un proyecto React usando Vite

- Las herramientas de configuración de proyectos y CLIs proporcionan una manera rápida y fácil de comenzar nuevos proyectos, permitiendo a los desarrolladores enfocarse en escribir código en lugar de lidiar con la configuración.
- Vite, una herramienta popular de configuración de proyectos, puede ser usado con React.
- Para crear un nuevo proyecto con Vite, puedes usar el siguiente comando en tu terminal:

```bash
npm create vite@latest my-react-app -- --template react
```

Este comando crea un nuevo proyecto React llamado `my-react-app` utilizando la plantilla React de Vite. En el directorio del proyecto, verás un archivo `package.json` con las dependencias del proyecto y los comandos listados en él.

- Para ejecutar el proyecto, navega al directorio del proyecto y ejecuta los siguientes comandos:

```bash
cd my-react-app # path to the project directory
npm install # installs the dependencies listed in the package.json file
```

- Una vez instaladas las dependencias, deberías notar una nueva carpeta en tu proyecto llamada `node_modules`.

- La carpeta `node_modules` es donde se almacenan todos los paquetes y bibliotecas requeridos por tu proyecto.

- Para ejecutar tu proyecto, usa el siguiente comando:

```bash
npm run dev
```

- Después de eso, abre tu navegador y navega a `http://localhost:5173` para ver tu aplicación React funcionando.

- Para ver realmente el código de la plantilla inicial, puedes ir a tu proyecto dentro de la carpeta `src` y deberías ver el archivo `App.jsx`.

## Pasando props en componentes React

- En React, props (abreviatura de propiedades) son una manera de pasar datos de un componente padre a un componente hijo. Este mecanismo es necesario para crear elementos de UI reutilizables y dinámicos.
- Los props pueden ser cualquier valor de JavaScript. Para pasar props de un padre a un componente hijo, debes añadir los props como atributos cuando usas el componente hijo en el JSX del padre. Aquí tienes un ejemplo simple:

```jsx
// Parent component
function Parent() {
  const name = 'Anna';
  return <Child name={name} />;
}

// Child component
function Child(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

Puedes pasar múltiples props usando el operador de propagación `(...)`, después de convertirlos en un objeto. Aquí va un ejemplo:

```jsx
// Parent component
function Parent() {
  const person = {
    name: 'Anna',
    age: 25,
    city: 'New York'
  };
  return <Child {...person} />;
}
```

En este código, el operador de propagación `{...person}` convierte el objeto person en props individuales que son pasados al componente hijo.

## Renderizado condicional en React

- El renderizado condicional en React te permite crear interfaces de usuario dinámicas. Se usa para mostrar contenido diferente basado en ciertas condiciones o estados dentro de tu aplicación.
- Hay varias maneras de renderizar contenido condicionalmente en React. Una aproximación común es usar el operador ternario. Aquí tienes un ejemplo:

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please log in</h1>}
    </div>
  );
}
```

- Otra forma de renderizar contenido condicionalmente es usar el operador lógico Y (`&&`). Esto es útil cuando quieres renderizar contenido sólo si se cumple cierta condición. Aquí tienes un ejemplo:

```jsx
function Greeting({ user }) {
  return (
    <div>
      {user && <h1>Welcome, {user.name}!</h1>}
    </div>
  );
}
```

En el código anterior, el elemento `h1` sólo se renderiza si el objeto usuario es verdadero.

También puedes usar directamente una sentencia `if` de esta manera:

```js
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  }
  return <h1>Please sign in</h1>;
}
```

## Renderizando listas en React

- Renderizar listas en React es una tarea común al construir interfaces de usuario.
- Las listas pueden ser renderizadas usando el método `map()` del arreglo JS para iterar sobre un arreglo de elementos y retornar un nuevo arreglo de elementos JSX.
- Por ejemplo, si tienes un arreglo de nombres que deseas renderizar como una lista, puedes hacer lo siguiente:

```jsx
function NameList({ names }) {
  return (
    <ul>
      {names.map((name, index) => (
        <li key={`${name}-${index}`}>{name}</li>
      ))}
    </ul>
  );
}
```

- Siempre recuerda proporcionar una clave única para cada elemento de la lista para ayudar a React a gestionar el papel de actualización y renderizado. Con estas técnicas, puedes crear listas flexibles, eficientes y dinámicas en tus aplicaciones React.

## Estilos en línea en React

- Los estilos en línea en React te permiten aplicar estilos CSS directamente a elementos JSX usando objetos JavaScript.
- Para aplicar estilos en línea en React, puedes usar el atributo style en los elementos JSX. El atributo style toma un objeto donde las claves son propiedades CSS en camelCase y los valores son los valores correspondientes. Aquí tienes un ejemplo:

```js
function Greeting() {
  return (
    <h1
      style={{ color: 'blue', fontSize: '24px', backgroundColor: 'lightgray' }}
    >
      Hello, world!
    </h1>
  );
}

export default Greeting;
```

También puedes extraer los estilos en un objeto separado y referenciarlo en el atributo `style` de esta manera:

```jsx
function Greeting() {

  const styles = {
    color: 'blue',
    fontSize: '24px',
    backgroundColor: 'lightgray'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- Los estilos en línea soportan estilos dinámicos al permitirte aplicar estilos condicionalmente basados en props o estado. Aquí tienes un ejemplo de cómo puedes aplicar estilos condicionalmente basados en un prop:

```jsx
function Greeting({ isImportant }) {

  const styles = {
    color: isImportant ? 'red' : 'black',
    fontSize: isImportant ? '24px' : '16px'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- En el código anterior, los estilos `color` y `fontSize` se establecen condicionalmente basándose en el prop `isImportant`.

## Trabajando con eventos en React

- **Sistema de eventos sintéticos**: Esta es la manera en que React maneja los eventos. Sirve como un envoltorio alrededor de los eventos nativos como los eventos `click`, `keydown`, y `submit`. Los manejadores de eventos en React usan la convención de nomenclatura en camelCase. (Ej. `onClick`, `onSubmit`, etc.)

Aquí tienes un ejemplo de usar el atributo `onClick` para un elemento `button` en React:

```jsx
function handleClick() {
  console.log("Button clicked!");
}

<button onClick={handleClick}>Click Me</button>;
```

En React, las funciones manejadoras de eventos usualmente empiezan con el prefijo `handle` para indicar que son responsables de manejar eventos, como `handleClick` o `handleSubmit`.

Cuando una acción de usuario desencadena un evento, React pasa un objeto de Evento Sintético a tu manejador. Este objeto se comporta mucho como el objeto Event nativo en JavaScript puro, proporcionando propiedades como `type`, `target`, y `currentTarget`.

Para prevenir comportamientos por defecto como la actualización del navegador durante un evento `onSubmit`, por ejemplo, puedes llamar al método `preventDefault()`:

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("Form submitted!");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>Submit</button>
</form>;
```

También puedes envolver una función manejadora dentro de una función flecha de esta manera:

```jsx
function handleDelete(id) {
  console.log("Deleting item:", id);
}

<button onClick={() => handleDelete(1)}>Delete Item</button>;
```

## Trabajando con el Estado y el Gancho `useState`

- **Definición de estado**: En React, el estado es un objeto que contiene datos para un componente. Cuando el estado se actualiza, el componente se vuelve a renderizar. React trata al estado como inmutable, lo que significa que no debes modificarlo directamente.
- **`useState()` Gancho**: El gancho `useState` es una función que te permite declarar variables de estado en componentes funcionales.  Aquí tienes una sintaxis básica:

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

En la variable de estado tienes lo siguiente:

- `stateVariable` mantiene el valor de estado actual
- `setStateFunction` (la función de establecer) actualiza la variable de estado
- `initialValue` establece el estado inicial

Aquí tienes un ejemplo completo para un componente `Counter`:

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

## Renderizado y Componentes React

- **Definición**: En React, el renderizado es el proceso mediante el cual los componentes aparecen en la interfaz de usuario (UI), generalmente en el navegador. El proceso de renderizado consta de tres etapas: disparador, renderización y commit.

La etapa de disparador ocurre cuando React detecta que algo ha cambiado y la interfaz de usuario (UI) podría necesitar ser actualizada. Este cambio a menudo se debe a una actualización en el estado o props.

Una vez que sucede el disparador, React entra en la etapa de renderización. Aquí, React reevalúa tus componentes y decide qué mostrar. Para hacer esto, React usa una copia liviana del DOM "real" llamada el DOM virtual. Con el DOM virtual, React puede verificar rápidamente que necesita cambiar en el componente.

La etapa de commit es donde React toma los cambios preparados del DOM virtual y los aplica al DOM real. En otras palabras, esta es la etapa donde ves el resultado final en la pantalla.

## Actualizando Objetos y Arreglos en Estado

- **Actualizando Objetos en Estado**: Si necesitas actualizar un objeto en estado, entonces debes hacer un nuevo objeto o copiar un objeto existente primero, y luego establecer el estado para ese nuevo objeto. Cualquier objeto colocado en estado debe considerarse como de solo lectura. Aquí tienes un ejemplo de establecer el nombre, la edad y la ciudad de un usuario. La función `handleChange` se utiliza para manejar actualizaciones a la información del usuario:

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **Actualizando Arreglos en Estado**: Al actualizar arreglos en estado, es importante no modificar directamente el arreglo usando métodos como `push()` o `pop()`. En cambio, debes crear un nuevo arreglo al actualizar el estado:

```jsx
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

Si quieres eliminar elementos de un arreglo, debes usar el método `filter()`, que devuelve un nuevo arreglo después de filtrar lo que deseas eliminar:

```jsx
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## Referenciando Valores Usando Refs

- **`ref` Atributo**: Puedes acceder a un nodo DOM en React usando el atributo `ref`. Aquí tienes un ejemplo para mostrar un `ref` para enfocar un elemento `input`. La propiedad `current` se usa para acceder al valor actual de ese `ref`:

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Focus;
```

## Trabajando con el Gancho `useEffect`

- **`useEffect()` Gancho**: En React, un efecto es cualquier cosa que sucede fuera del proceso de renderización de componentes. Es decir, cualquier cosa que React no maneja directamente como parte de la renderización de la UI. Ejemplos comunes incluyen la obtención de datos, la actualización del título de la pestaña del navegador, la lectura o escritura en el almacenamiento local del navegador, la obtención de la ubicación del usuario y mucho más. Estas operaciones interactúan con el mundo exterior y se conocen como efectos secundarios. React proporciona el gancho `useEffect` para permitirte manejar esos efectos secundarios. `useEffect` te permite ejecutar una función después de que el componente renderiza o se actualiza.

```js
import { useEffect } from "react";

useEffect(() => {
 // Your side effect logic (usually a function) goes here
}, [dependencies]);
```

La función de efecto se ejecuta después de que el componente se renderiza, mientras que el argumento opcional `dependencies` controla cuándo se ejecuta el efecto.

Ten en cuenta que `dependencies` puede ser un arreglo de "valores reactivos" (estado, props, funciones, variables, etc.), un arreglo vacío o omitido por completo. Aquí te explicamos cómo todas estas opciones controlan cómo funciona `useEffect`:

- Si `dependencies` es un arreglo que incluye uno o más valores reactivos, el efecto se ejecutará cada vez que cambien.

- Si `dependencies` es un arreglo vacío, `useEffect` se ejecutará solo una vez cuando el componente se renderiza por primera vez.

- Si omites `dependencies`, el efecto se ejecutará cada vez que el componente se renderiza o actualiza.

## Cómo Crear Ganchos Personalizados

- **Ganchos Personalizados**: Un gancho personalizado te permite extraer la lógica reutilizable de los componentes, como la obtención de datos, la gestión del estado, el alternar, y efectos secundarios como rastrear el estado en línea. En React, todos los ganchos incorporados comienzan con la palabra `use`, por lo que tu gancho personalizado debería seguir la misma convención.

Aquí tienes un ejemplo de la creación de un gancho `useDebounce`:

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

## Trabajando con Formularios en React

- **Entradas Controladas**: Esto es cuando almacenas el valor del campo de entrada en el estado y lo actualizas a través de eventos `onChange`. Esto te da control completo sobre los datos del formulario y permite una validación instantánea y el renderizado condicional.

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form>
    </>
  );
}

export default App;
```

- **Entradas No Controladas**: En lugar de manejar las entradas a través del gancho `useState`, las entradas no controladas en HTML mantienen su propio estado interno con la ayuda del DOM. Dado que el DOM controla los valores de entrada, necesitas extraer los valores de los campos de entrada con un `ref`.

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">Your</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">Submit</button>
   </form>
 );
}

export default App;
```

## Trabajando con el Gancho `useActionState`

- **Acciones del servidor**: Son funciones que se ejecutan en el servidor para permitir el manejo de formularios directamente en el servidor sin necesidad de puntos finales API. Aquí tienes un ejemplo de una aplicación Next.js:

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `Hello, ${name}!` };
}
```

La directiva `"use server"` marca la función como una acción del servidor.

- **`useActionState` Gancho**: Este gancho actualiza el estado basado en el resultado de un envío de formulario. Aquí tienes la sintaxis básica del gancho `useActionState`:

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` es el estado actual que la acción devuelve.
- `action` es la función que desencadena la acción del servidor.
- `isPending` es un booleano que indica si la acción se está ejecutando actualmente o no.
- `actionFunction` parámetro es la acción del servidor en sí misma.
- `initialState` es el parámetro que representa el punto de partida para el estado antes de que la acción se ejecute.
- `permalink` es una cadena opcional que contiene la URL única de la página que el formulario modifica.

## Recolección de Datos en React

- **Opciones para Recoger Datos**: Hay muchas maneras diferentes de obtener datos en React. Puedes usar la API Fetch nativa, o herramientas de terceros como Axios o SWR.
- **Variables de Estado Comúnmente Utilizadas al Obtener Datos**: Indiferentemente del método que elijas para obtener tus datos en React, hay algunos fragmentos de estado que necesitarás seguir. El primero es el mismo dato. El segundo rastrea si los datos aún se están obteniendo. El tercero es una variable de estado que capturará cualquier error que pueda ocurrir durante el proceso de obtención de datos.

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

Dado que la recolección de datos es un efecto colateral, es mejor usar la `API de Fetch` dentro de un gancho `useEffect`.

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");

      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Luego puedes renderizar un mensaje de carga si la recolección de datos no está completa, un mensaje de error si hubo algún error al recoger los datos o los resultados.

```jsx
if (loading) {
  return <p>Loading...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

Si deseas usar Axios, necesitas instalarlo e importarlo:

```bash
npm i axios
```

```js
import axios from "axios";
```

Entonces puedes obtener los datos usando `axios.get`:

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Para recoger datos utilizando el gancho `useSWR`, primero debes instalarlo e importarlo.

```bash
npm i swr
```

```js
import useSWR from "swr";
```

Aquí tienes cómo puedes usar el gancho para obtener datos:

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>Loading...</h2>;
 }
 if (error) {
   return <h2>Error: {error.message}</h2>;
 }

 return (
   <>
     <h2>Todos</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## Trabajando con el Gancho `useOptimistic`

- **`Gancho useOptimistic`**: Este gancho se utiliza para mantener las UI's receptivas mientras se espera que una acción asíncrona se complete en segundo plano. Ayuda a gestionar "actualizaciones optimistas" en la interfaz de usuario, una estrategia en la que se proporcionan actualizaciones inmediatas a la UI basadas en el resultado esperado de una acción, como esperar una respuesta del servidor.

Aquí tienes la sintaxis básica:

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` es el estado temporal que se actualiza inmediatamente para una mejor experiencia de usuario.
- `addOptimistic` es la función que aplica la actualización optimista antes de que el estado actual cambie.
- `actualState` es el valor real del estado que proviene del resultado de una acción, como la obtención de datos de un servidor.
- `updateFunction` es la función que determina cómo debería actualizarse el estado optimista cuando se llame.

Aquí tienes un ejemplo del uso del gancho `useOptimistic` en un componente `TaskList`:

```js
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**: Esto se utiliza para renderizar parte de la interfaz de usuario y marcar una actualización del estado como una transición no urgente. Esto permite que la interfaz de usuario sea receptiva durante actualizaciones costosas. Aquí tienes la sintaxis básica:

```js
startTransition(action)
```

La `acción` realiza una actualización del estado o desencadena alguna lógica relacionada con la transición. Esto garantiza que las actualizaciones urgentes de la UI (como escribir o hacer clic) no se bloqueen.

## Trabajando con el Gancho `useMemo`

- **Memorización**: Esta es una técnica de optimización en la que se almacenan en caché (se recuerdan) los resultados de llamadas a funciones costosas basadas en argumentos específicos. Cuando se proporcionan los mismos argumentos de nuevo, se devuelve el resultado almacenado en caché en lugar de volver a calcular la función.
- **`Gancho useMemo`**: Este gancho se utiliza para memorizar valores calculados. Aquí tienes un ejemplo de la memorización del resultado de ordenar un arreglo grande. La `expensiveSortFunction` solo se ejecutará cuando `largeArray` cambie:

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## Trabajando con el Gancho `useCallback`

- **`Gancho useCallback`**: Este se utiliza para memorizar referencias de funciones.

```js
const handleClick = useCallback(() => {
 // code goes here
}, [dependency]);
```

- **`React.memo`**: Esto se utiliza para memorizar un componente para evitar que se renderice innecesariamente cuando su prop no ha cambiado.

```js
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* Presentation */}
   </>
 )
});
```

## Herramientas de Gestión de Dependencias

- **Definición de Dependencia**: En software, una dependencia es cuando un componente o módulo en una aplicación depende de otro para funcionar correctamente. Las dependencias son comunes en las aplicaciones de software porque permiten a los desarrolladores usar funciones o herramientas preconstruidas creadas por otros. Las dos dependencias principales necesarias para un proyecto de React serán los paquetes `react` y `react-dom`:

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **Definición de Gestor de Paquetes**: Para gestionar dependencias de software en un proyecto, necesitarás usar un gestor de paquetes. Un gestor de paquetes es una herramienta usada para la instalación, actualizaciones y eliminación de dependencias. Muchos lenguajes de programación populares como JavaScript, Python, Ruby y Java utilizan gestores de paquetes. Gestores de paquetes populares para JavaScript incluyen npm, Yarn y pnpm.
- **`package.json` Archivo**: Este es un archivo clave de configuración en proyectos que contiene metadatos sobre tu proyecto, incluidos su nombre, versión y dependencias. También define scripts, información de licencia y otros ajustes que ayudan a gestionar el proyecto y sus dependencias.
- **`package-lock.json` Archivo**: Este archivo bloquea las versiones exactas de todos los paquetes que tu proyecto está utilizando. Cuando actualizas un paquete, entonces las nuevas versiones también se actualizarán en el archivo de bloqueo.
- **Carpeta `node_modules`**:
- **Dependencias Dev**: Estos son paquetes que solo se utilizan para desarrollo y no en producción. Un ejemplo de esto sería una biblioteca de pruebas como Jest. Instalarías Jest como una dev dependency

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **Introducción**: Para comenzar, necesitarás instalar React Router en un proyecto de React existente de esta manera:

```bash
npm i react-router
```

Luego, dentro del archivo `main.jsx` o `index.jsx`, necesitarás configurar la estructura de la ruta de esta manera:

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

Los `path` y `element` se utilizan para acoplar la URL y los componentes de la UI juntos. En este caso, estamos configurando una ruta para la página de inicio que apunta al componente `App`.

- **Vistas Múltiples y Configuración de Ruta**: Es común en aplicaciones más grandes tener múltiples vistas y rutas configuradas de esta manera:

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

La prop `index` en estos ejemplos está destinada a representar la ruta predeterminada para un segmento de ruta dado. Así que el componente `Home` se mostrará en la ruta raíz `/` mientras que el componente `ProductsHome` se mostrará en la ruta `/products`.

- **Anidación de Rutas**: Puedes anidar rutas dentro de otras rutas, lo que resulta en que la ruta del hijo se añada a la ruta del padre.

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

En el ejemplo anterior, la ruta para los productos de moda será products/trending.

- **Segmentos Dinámicos**: Un segmento dinámico es donde cualquier parte de la ruta URL es dinámica.

```jsx
<Route path=":category" element={<Category />} />
```

En este ejemplo tenemos un segmento dinámico llamado `category`. Cuando un usuario navega a una URL como products/brass-instruments, entonces la vista cambiará al componente `Category` y puedes obtener dinámicamente los datos apropiados basados en el segmento.

- **`Gancho useParams`**: Este gancho se utiliza para acceder a los parámetros dinámicos desde una ruta URL.

```js
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
   {/* Accessing the category param: params.category */}
   {/* rest of code goes here */}
}
```

## React Frameworks

- **Introducción**: Los frameworks de React proporcionan funciones como enrutamiento, optimización de imágenes, apertura de datos, autenticación y más. Esto significa que es posible que no necesites configurar aplicaciones de frontend y backend por separado para ciertos casos de uso. Ejemplos de frameworks de React incluyen Next.js y Remix.
- **Enrutamiento de Next.js**: Este sistema de enrutamiento incluye soporte para rutas dinámicas, rutas paralelas, gestores de rutas, redirecciones, internalización y más.

Aquí tienes un ejemplo de la creación de un gestor de peticiones personalizada:

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Optimización de Imagen de Next.js**: El componente `Image` extiende el elemento HTML nativo `img` y permite cargas de página más rápidas y optimizaciones de tamaño. Esto significa que las imágenes solo se cargarán cuando entren a la vista y el componente `Image` servirá automáticamente imágenes de tamaño adecuado para cada dispositivo.

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
```

## Pasaje de Propiedades

- **Definición**: Pasaje de propiedades es el proceso de pasar props de un componente padre a componentes secundarios fuertemente anidados, incluso cuando algunos de los componentes secundarios no necesitan los props.

## Gestión del Estado

- **API de Contexto**: Contexto se refiere a cuando un componente padre pone a disposición información para componentes hijos sin necesidad de pasarla explícitamente a través de props. `createContext` se usa para crear un objeto de contexto que representa el contexto que otros componentes leerán. El `Proveedor` se utiliza para proporcionar valores de contexto a los componentes hijos.

```js
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**: Redux maneja la gestión del estado proporcionando una tienda central y un control estricto sobre las actualizaciones del estado. Utiliza un patrón predecible con acciones, reductores y middleware. Las acciones son cargas de información que envían datos desde tu aplicación a la tienda Redux, a menudo desencadenadas por interacciones del usuario. Los reductores son funciones que especifican cómo debe cambiar el estado en respuesta a esas acciones, asegurando que el estado se actualice de forma inmutable. El middleware, por otro lado, actúa como un puente entre el despacho de acciones y el reductor, permitiéndote extender la funcionalidad de Redux (por ejemplo, registro, manejo de operaciones asíncronas) sin modificar el flujo principal.

- **Zustand**: Esta solución de gestión del estado es ideal para aplicaciones de pequeña a mediana escala. Funciona usando un gancho `useStore` para acceder directamente al estado en componentes y páginas. Esto te permite modificar y acceder a datos sin necesitar acciones, reductores o un proveedor.

## Depuración de Componentes de React Usando las Herramientas del Desarrollador de React

- **Herramientas del Desarrollador de React**: Esta es una extensión del navegador que puedes usar en Chrome, Firefox y Edge para inspeccionar componentes de React e identificar problemas de rendimiento. Para Safari, necesitarás instalar el paquete npm `react-devtools`. Después de instalar las Herramientas del Desarrollador de React y abrir una aplicación React en el navegador, abre las herramientas de desarrollador del navegador para acceder a las dos pestañas adicionales proporcionadas para depurar React - Componentes y Perfilador.
- **Pestaña de Componentes**: Esta pestaña muestra cada componente en un formato de vista de árbol. Aquí hay algunas cosas que puedes hacer en esta pestaña:
  - ver la jerarquía de componentes de la aplicación
  - verificar y modificar props, estados y valores contextuales en tiempo real
  - revisar el código fuente de cada componente seleccionado
  - registrar los datos del componente en la consola
  - inspeccionar los elementos DOM para el componente
- **Pestaña de Perfilador**: Esta pestaña te ayuda a analizar el rendimiento del componente. Puedes registrar el rendimiento del componente para identificar renderizados innecesarios, ver duraciones de commits y, posteriormente, optimizar componentes lentos.

## Componentes de Servidor de React

- **Definición**: Los componentes del servidor de React son componentes de React que se renderizan exclusivamente en el servidor, enviando solo el HTML final al cliente. Esto significa que esos componentes pueden acceder directamente a recursos del servidor y reducir drásticamente la cantidad de JavaScript enviado al navegador.

## Diferencias entre Rendimiento Real y Percibido

- **Rendimiento Percibido**: Así es como los usuarios perciben el rendimiento de un sitio web. Es cómo lo evalúan en términos de capacidad de respuesta y fiabilidad. Esta es una medida subjetiva, por lo que es difícil cuantificarla, pero es muy importante, ya que la experiencia del usuario determina el éxito o el fracaso de un sitio web.
- **Rendimiento Real**: Este es el rendimiento objetivo y medible del sitio web. Se mide usando métricas como el tiempo de carga de la página, el tiempo de respuesta del servidor y el tiempo de renderizado. Estas medidas se ven influenciadas por múltiples factores relacionados con la red y el propio código.

## Técnicas para Mejorar el Rendimiento Percibido

- **Carga Diferida**: Esta técnica reduce el tiempo de carga inicial tanto como sea posible cargando recursos no esenciales en el fondo.
- **Minimizar Retrasos de Carga de Fuentes**: Si tu sitio web tiene fuentes personalizadas, también deberías intentar minimizar los retrasos de carga de fuentes, ya que esto puede resultar en parpadeos o mostrar la fuente de respaldo mientras se carga la fuente personalizada. Una sugerencia para esto es usar una fuente de respaldo que sea similar a la fuente personalizada, por lo que en caso de que esto ocurra, el cambio será más sutil.
- **Uso de Indicadores de Carga**: Mostrar un indicador de carga para un proceso de larga duración tan pronto como el usuario haga clic en un elemento puede ayudar a que el usuario se sienta conectado e involucrado con el proceso, haciendo que el tiempo de espera parezca más corto.

## Conceptos Centrales de Rendimiento

- **Orden de Código Fuente**: Esto se refiere a la manera en que los elementos HTML están estructurados en el documento. Esto determina qué se carga primero y puede impactar significativamente en el rendimiento y accesibilidad.

Algunas mejores prácticas para el orden de código fuente incluyen:

- Colocar contenido crítico como títulos, navegación o texto principal más alto en la estructura HTML.
- Diferir scripts no esenciales como los de análisis, o widgets de terceros, para que no bloqueen el renderizado.
- Usar mejora progresiva, para asegurar que la experiencia principal funcione incluso antes de que se carguen los estilos y scripts. La mejora progresiva es una forma de construir sitios web y aplicaciones basadas en la idea de que deberías hacer que tu página funcione con HTML primero.

Aquí tienes un ejemplo de buen orden de código fuente, usando las mejores prácticas que acabamos de pasar:

```html
<h1>Welcome to FastSite!</h1>
<p>Critical information loads first.</p>
<script src="slow-script.js" defer></script>
```

- **Ruta de Renderizado Crítica**: Esta es la secuencia de pasos que el navegador sigue para convertir el código en píxeles en la pantalla.
- **Latencia**: Este es el tiempo que toma para que una petición viaje entre el navegador y el servidor. En otras palabras, alta latencia equivale a páginas lentas.

Algunas maneras de reducir la latencia incluyen:

- Usar CDNs, o Redes de Distribución de Contenidos, para servir archivos desde ubicaciones más cercanas.
- Habilitar compresión usando cosas como Gzip para reducir el tamaño de archivos.
- Optimizar imágenes y usar carga diferida.

```html
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
```

## Mejorando INP

- **Definición**: INP (Interacción a la Próxima Pintura) evalúa la capacidad de respuesta general de una página al medir el tiempo desde que un usuario interactúa, como un clic o una pulsación de tecla, hasta la próxima vez que el navegador actualiza la pantalla. Un INP más bajo indica una página más receptiva.

Aquí hay algunas maneras de mejorar INP:

- Reducir el trabajo del hilo principal dividiendo las tareas largas de JavaScript.
- Usar `requestIdleCallback()` para scripts no críticos. Esto encolará una función para que se ejecute durante los periodos de inactividad del navegador.
- Diferir o cargar de forma diferida activos pesados que ya discutimos anteriormente.
- Optimizar los manejadores de eventos. Si estos manejadores se ejecutan con demasiada frecuencia o realizan operaciones pesadas, pueden hacer que la página sea lenta e incrementan el INP. La solución para esto es debouncing. La debouncing asegura que la función solo se ejecute después de que el usuario deje de escribir por un retraso breve - por ejemplo, 300ms. Esto previene cálculos innecesarios y mejora el rendimiento.

## Cómo Funciona el Renderizado en el Navegador

- **Cómo funciona el Rendering**: Primero el navegador analiza el HTML y construye el DOM. Luego, el navegador procesa el CSS, construyendo el Modelo de Objeto CSS, o CSSOM. Esta es otra estructura de árbol que dicta cómo deben ser estilizados los elementos. Finalmente, el navegador pinta los píxeles en la pantalla, renderizando cada elemento basado en los estilos calculados y el diseño. En páginas complejas, esto podría involucrar múltiples capas que se combinan para formar la salida visual final.

## Cómo el Rendimiento Impacta la Sostenibilidad

- **Información de Fondo**: El internet representa alrededor del 2% de las emisiones de carbono a nivel mundial—¡es lo mismo que la industria aérea! Cada byte transferido requiere electricidad, desde los centros de datos hasta los dispositivos de los usuarios. Archivos más grandes y scripts ineficientes significan más consumo de energía. Un sitio web de alto rendimiento no solo es más rápido, también reduce el procesamiento innecesario y el uso de energía.

## Formas de Reducir los Tiempos de Carga de las Páginas

- **Optimizar Recursos de Medios**: Imágenes y videos grandes son culpables comunes de tiempos de carga lentos. Al optimizar estos recursos, puedes acelerar significativamente tu sitio. Esto incluye cosas como comprimir imágenes, usar formatos modernos como WebP y usar carga diferida para los recursos.
- **Aprovechar Caché del Navegador**: El almacenamiento en caché permite a los navegadores almacenar partes de tu sitio web localmente, reduciendo los tiempos de carga para los visitantes que regresan.
- **Minificar y Comprimir Archivos**: Reducir el tamaño de tus archivos puede llevar a descargas más rápidas. Esto incluye reducir el tamaño de los archivos transmitidos y minificar archivos CSS y JavaScript.

## Mejorando "tiempo para ser usable"

- **Definición**: "tiempo para ser usable" es el intervalo desde que un usuario solicita una página hasta que puede interactuar significativamente con ella. Para mejorar el "tiempo para ser usable" puedes cargar tus recursos de manera diferida o minimizar los recursos que bloquean el renderizado.

## Métricas clave para medir el rendimiento

- **Primer Pintado con Contenido o FCP**: Mide qué tan rápido aparece el primer contenido—texto o imagen—en la pantalla. Un buen FCP se considera un tiempo por debajo de 1.8 segundos, y un mal FCP es superior a 3 segundos. Puedes verificar tu FCP usando las DevTools de Chrome y revisando la pestaña de rendimiento.
- **Tiempo Total de Bloqueo**: Esto muestra cuánto tiempo el hilo principal está bloqueado por tareas pesadas de JavaScript. Si el Tiempo Total de Bloqueo (TBT) es alto, los usuarios experimentan interacciones lentas. Para mejorar el TBT, divide tareas largas y pospone scripts no esenciales.
- **Tasa de Rebote**: Este es el porcentaje de visitantes que se van sin interactuar. Si tu sitio tiene altas tasas de rebote podría ser porque tu página es demasiado lenta.
- **Usuarios Únicos**: Esta métrica sigue cuántos visitantes individuales llegan a tu sitio. Para ver la Tasa de Rebote y los Usuarios Únicos, puedes utilizar Google Analytics. Te permitirá monitorear estas métricas y mejorar el engagement.

## Herramientas Comunes de Medición de Rendimiento

- **Chrome DevTools**: Chrome DevTools es una herramienta incorporada dentro de Google Chrome que te permite analizar y depurar el rendimiento en tiempo real. DevTools mostrará tiempos de carga, uso de CPU, y retrasos en el renderizado. Es especialmente útil para medir el Primer Pintado con Contenido, o FCP, que es qué tan rápido un usuario ve el primer contenido visible. Si tu sitio web se siente lento, DevTools te ayudará a detectar los cuellos de botella.
- **Lighthouse**: Esta es una herramienta automatizada que verifica el rendimiento, SEO y accesibilidad.
- **WebPageTest**: Esta herramienta te permite probar cómo carga tu sitio desde diferentes ubicaciones y dispositivos. Esta herramienta te da un desglose detallado del Índice de Velocidad de tu sitio, Tiempo Total de Bloqueo y otras métricas clave de rendimiento. Si deseas saber cómo los usuarios reales experimentan tu sitio a nivel mundial, WebPageTest es la herramienta para ello.
- **PageSpeed Insights**: Esta herramienta analiza tu sitio web y sugiere mejoras rápidas tanto para móviles como para escritorio. Te dirá qué está ralentizando tu sitio y dará recomendaciones específicas como optimizar imágenes, eliminar scripts que bloquean el renderizado y reducir tiempos de respuesta del servidor. PageSpeed Insights es una manera rápida y fácil de verificar cómo Google percibe el rendimiento de tu sitio.
- **Monitoreo Real de Usuarios (RUM)**: Las herramientas RUM rastrean el comportamiento real del usuario, mostrando cómo los visitantes reales experimentan tu sitio. Las herramientas RUM populares incluyen Google Analytics, que rastrean tiempos de carga de páginas y tasas de rebote, y New Relic o Datadog, que monitorean problemas de rendimiento en tiempo real. Si deseas datos de usuarios reales, las herramientas RUM son esenciales.

## Trabajando con APIs de Rendimiento Web

- **Definición**: Las APIs de Rendimiento Web permiten a los desarrolladores rastrear qué tan eficientemente una página web se carga y responde directamente en el código. Estas APIs te permiten medir tiempos de carga de páginas, rastrear retrasos de renderizado e interacción y analizar el tiempo de ejecución de JavaScript.
- **`performance.now()`**: Esta API te da marcas de tiempo de alta precisión (en milisegundos) para medir cuánto tiempo toma cargar diferentes partes de tu sitio.

```js
const start = performance.now();  
// Run some code here  
const end = performance.now();  

console.log(`Execution time: ${end - start}ms`);
```

- **API de Tiempo de Rendimiento**: Esta API te da un desglose de cada etapa de la carga de página, desde la búsqueda DNS hasta `DOMContentLoaded`.

```js
const timing = performance.timing;  

const pageLoadTime = timing.loadEventEnd - timing.navigationStart;  
console.log(`Page load time: ${pageLoadTime}ms`);
```

- **`PerformanceObserver`**: Esta API escucha eventos de rendimiento como cambios de diseño, tareas largas, e interacciones de usuario.

```js
const observer = new PerformanceObserver((list) => {  
  list.getEntries().forEach((entry) => {  
    console.log(`Long task detected: ${entry.duration}ms`);  
  });  
});  

observer.observe({ type: "longtask", buffered: true });
```

## Técnicas para Mejorar el Rendimiento de CSS

- **Animaciones CSS**: Animar ciertas propiedades CSS, como dimensiones, posición y diseño, activa un proceso llamado "reflujo", durante el cual el navegador recalcula la posición y geometría de ciertos elementos en la página. Esto requiere un repintado, lo cual es computacionalmente caro. Por lo tanto, se recomienda reducir el número de animaciones CSS tanto como sea posible o al menos dar al usuario la opción de activarlas o desactivarlas.

## Técnicas para Mejorar el Rendimiento de JavaScript

- **División de Código**: Dividir tu código JavaScript en módulos que realizan tareas críticas y no críticas también es útil. De esta manera, podrás precargar las críticas lo más pronto posible y posponer las no críticas para renderizar la página lo más rápido posible.
- **Manipulación del DOM**: Recuerda que la Manipulación del DOM se refiere al proceso de cambiar dinámicamente el contenido de una página con JavaScript interactuando con el Modelo de Objeto de Documento (DOM). Manipular el DOM es computacionalmente caro. Al reducir la cantidad de manipulación del DOM en tu código JavaScript mejorarás el rendimiento.

## Frameworks CSS

- **Frameworks CSS**: Los frameworks CSS pueden acelerar tu flujo de trabajo, crear un estilo visual uniforme en un sitio web, hacer que tu diseño se vea consistente en múltiples navegadores y mantener tu código CSS más organizado.
- **Frameworks CSS populares**: Algunos de los frameworks CSS populares son Tailwind CSS, Bootstrap, Materialize y Foundation.
- **Posibles desventajas**:
  - El CSS proporcionado por el framework podría entrar en conflicto con tu CSS personalizado.
  - Tu sitio web podría verse similar a otros sitios web que utilizan el mismo framework.
  - Los frameworks grandes podrían causar problemas de rendimiento.

## Dos Tipos de Frameworks CSS

- **Frameworks CSS orientados a utilidades**: Estos frameworks tienen clases pequeñas con propósitos específicos, como establecer el margen, el relleno o el color de fondo. Puedes asignar estas clases pequeñas directamente a los elementos HTML según sea necesario. Tailwind CSS está categorizado como un framework CSS orientado a utilidades.

Aquí tienes un ejemplo de cómo usar Tailwind CSS para estilizar un botón.

```html
<button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700">
  Button
</button>
```

- **Frameworks CSS basados en componentes**: Estos frameworks tienen componentes preconstruidos con estilos predefinidos que puedes añadir a tu sitio web. Los componentes están disponibles en la documentación oficial del framework CSS, y puedes copiarlos y pegarlos en tu proyecto. Bootstrap está categorizado como un framework CSS basado en componentes.

Aquí tienes un ejemplo de cómo usar Bootstrap para crear un grupo de listas. En lugar de aplicar clases pequeñas a tus elementos HTML, añadirás todo el componente, incluida la estructura HTML.

```html
<div class="card" style="width: 25rem;">
  <ul class="list-group list-group-flush">
    <li class="list-group-item">HTML</li>
    <li class="list-group-item">CSS</li>
    <li class="list-group-item">JavaScript</li>
  </ul>
</div>
```

## Preprocesadores CSS

- **Preprocesador CSS**: Un preprocesador CSS es una herramienta que extiende el CSS estándar. Compila el código con sintaxis extendida en un archivo CSS nativo. Puede ser útil para escribir CSS más limpio, reutilizable, menos repetitivo y escalable para proyectos complejos.
- **Características**: Algunas de las características que pueden proporcionar los preprocesadores CSS son variables, mixins, anidamiento, y herencia de selectores.
- **Preprocesadores CSS populares**: Algunos de los preprocesadores CSS populares son Sass, Less, y Stylus.
- **Posibles desventajas**:
  - Compilar las reglas CSS en CSS estándar podría causar sobrecarga.
  - El código compilado puede ser difícil de depurar.

## Sass

- **Sass**: Es uno de los preprocesadores CSS más populares. Sass significa "Style Sheets Asombrosamente Sintácticos."
- **Características soportadas por Sass**: Sass soporta características como variables, reglas CSS anidadas, módulos, mixins, herencia y operadores para operaciones matemáticas básicas.

## Dos Sintaxis Soportadas por Sass

- **Sintaxis SCSS**: El SCSS (CSS estilizado con Sassy) expande la sintaxis básica de CSS. Es la sintaxis más utilizada para Sass. Los archivos SCSS tienen una extensión `.scss`.

Aquí hay un ejemplo de definir y usar una variable en sintaxis SCSS.

```scss
$primary-color: #3498eb;

header {
  background-color: $primary-color;
}
```

- **Sintaxis indentada**: La sintaxis indentada fue la sintaxis original de Sass y también se conoce como la "sintaxis de Sass".

Aquí hay un ejemplo de definir y usar una variable en la sintaxis indentada.

```sass
$primary-color: #3498eb

header
  background-color: $primary-color
```

### Mixins

- **Mixins**: Los mixins te permiten agrupar múltiples propiedades CSS y sus valores bajo un nombre y reutilizar ese bloque de código CSS a lo largo de tu hoja de estilo.

Aquí hay un ejemplo de definir un mixin en sintaxis SCSS. En este caso, el mixin se llama `center-flex`. Tiene tres propiedades CSS para centrar elementos usando flexbox.

```scss
@mixin center-flex {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

Aquí hay un ejemplo de usar el mixin que has definido.

```scss
section {
  @include center-flex;
  height: 500px;
  background-color: #3289a8;
}
```

## Pruebas Manuales y Automatizadas

- **Pruebas Manuales**: En las pruebas manuales, un tester revisará manualmente cada parte de la aplicación y probará diferentes características para asegurarse de que funciona correctamente. Si se descubren errores en el proceso de prueba, el tester reportará esos errores al equipo de software para que puedan ser corregidos.
- **Pruebas Automatizadas**: En las pruebas automatizadas, puedes automatizar tus pruebas escribiendo un programa separado que verifique si tu aplicación se comporta como se espera.

## Pruebas Unitarias

- **Pruebas Unitarias**: En las pruebas unitarias, se prueba cada función para garantizar que todo funciona como se espera. Las pruebas unitarias también pueden servir como una forma de documentación para tu aplicación porque están destinadas a representar el comportamiento esperado para tu código.
- **Principio de Responsabilidad Única**: El principio de responsabilidad única recomienda mantener a cada función pequeña y responsable de una sola cosa.
- **Frameworks de Pruebas Comunes en JavaScript**: Algunos frameworks de pruebas comunes incluyen Jest, Mocha y Vitest. Jest es un framework de pruebas popular para pruebas unitarias.

Aquí hay un ejemplo de pruebas unitarias usando Jest.

Primero, puedes crear una función que sea responsable de devolver una cadena recién formateada:

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

En un archivo separado `getFormattedWord.test.js`, puedes escribir algunas pruebas para verificar que la función está funcionando como se espera. El archivo `getFormattedWord.test.js` se verá así:

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **`expect` Función**: La función `expect` se utiliza para probar un valor.
- **Matcher**: Matcher es una función que verifica si el valor se comporta como se esperaba. En el ejemplo anterior, matcher es `toBe()`. Jest tiene una variedad de matchers.

Para usar Jest, primero debes instalar el paquete `jest` usando `npm i jest`. También necesitarás añadir un script a tu archivo `package.json` como este:

```js
"scripts": {
  "test": "jest"
},
```

Luego, puedes ejecutar el comando `npm run test` para ejecutar tus pruebas.

## Ciclo de Vida del Desarrollo de Software

- **Diferentes Etapas del Ciclo de Vida del Desarrollo de Software**:
  - **Etapa de Planificación**: El equipo de desarrollo recoge requisitos para el trabajo propuesto de los stakeholders.
  - **Etapa de Diseño**: El equipo de software descompone los requisitos y decide los mejores enfoques para las soluciones.
  - **Etapa de Implementación**: El equipo de software descompone los requisitos en tareas manejables y las implementa.
  - **Etapa de Pruebas**: Esto involucra pruebas manuales y automatizadas para el nuevo trabajo. A veces, el equipo prueba la aplicación durante toda la etapa de desarrollo para detectar y arreglar cualquier problema que surja.
  - **Etapa de Despliegue**: El equipo despliega los nuevos cambios a un entorno de compilación o de pruebas.
  - **Etapa de Mantenimiento**: Esto involucra arreglar cualquier problema que surja por parte de los clientes en la aplicación de producción.

- **Diferentes Modelos del Ciclo de Vida del Desarrollo de Software**:
  - **Modelo en Cascada**: El modelo en cascada es aquel donde cada fase del ciclo de vida debe completarse antes de que la siguiente fase pueda comenzar.
  - **Modelo Ágil**: El modelo ágil se enfoca en el desarrollo iterativo descomponiendo el trabajo en sprints.

## BDD y TDD

- **TDD**: El desarrollo dirigido por pruebas es una metodología que enfatiza escribir las pruebas primero. Escribir pruebas antes de construir características proporciona retroalimentación en tiempo real a los desarrolladores durante el proceso de desarrollo.
- **BDD**: El desarrollo dirigido por el comportamiento es el enfoque de alinear una serie de pruebas con objetivos empresariales. Los escenarios de prueba en BDD deben ser escritos en un lenguaje que pueda ser entendido por individuos tanto técnicos como no técnicos. Un ejemplo de tal sintaxis es Gherkin.
- **Frameworks de Pruebas BDD**: Ejemplos de frameworks de pruebas BDD incluyen Cucumber, JBehave, y SpecFlow.

## Aserciones en Pruebas Unitarias

- **Aserción**: Las aserciones se utilizan para probar que el código se comporta como se espera.
- **Librerías de Aserciones**: Chai es una librería de aserciones comúnmente usada. Otras librerías de aserciones comunes en JavaScript son `should.js` y `expect.js`.

Aquí hay un ejemplo de una aserción usando Chai que verifica que el valor devuelto por la `addThreeAndFour` función es igual al número 7:

```js
assert.equal(addThreeAndFour(), 7);
```

- **Best Practices**: Independientemente de qué librería de aserciones utilices, debes escribir mensajes de aserción claros y de error que te ayuden a comprender qué pruebas están fallando y por qué.

## Simulación, Falsificación y Sustitución

- **Simulación**: La simulación es el proceso de reemplazar datos reales con datos falsos que simulan el comportamiento de componentes reales. Por ejemplo, podrías simular la respuesta de la API en pruebas en lugar de hacer llamadas continuas a la API para obtener los datos.
- **Sustitución**: Los stubs son objetos que devuelven respuestas predefinidas o datos ficticios para un comportamiento esperado en una aplicación. Por ejemplo, puedes simular el comportamiento de una conexión a la base de datos en tus pruebas sin tener que depender de una conexión real a la base de datos.
- **Simulaciones**: Las simulaciones son versiones simplificadas de componentes reales sin la complejidad o efectos secundarios. Por ejemplo, puedes simular una base de datos almacenando los datos en memoria en lugar de interactuar con la base de datos real. Esto te permitirá imitar operaciones de base de datos en memoria, lo cual será mucho más rápido que tratar con la base de datos real.

## Pruebas Funcionales

- **Pruebas Funcionales**: Las pruebas funcionales verifican si las características y funciones de la aplicación funcionan como se espera. El objetivo de las pruebas funcionales es probar el sistema como un todo contra múltiples escenarios.
- **Pruebas No Funcionales**: Las pruebas no funcionales se centran en aspectos como rendimiento y fiabilidad.
- **Pruebas de Humo**: Las pruebas de humo son una verificación preliminar del sistema para detectar problemas básicos o críticos antes de comenzar pruebas más extensas.

## Pruebas de Principio a Fin

- **Pruebas de Principio a Fin**: Las pruebas de principio a fin, o E2E, verifican escenarios del mundo real desde la perspectiva del usuario. Las pruebas de principio a fin ayudan a asegurar que tu aplicación se comporte correctamente y sea predecible para los usuarios. Sin embargo, lleva tiempo configurarlas, diseñarlas y mantenerlas.
- **Frameworks para Pruebas de Principio a Fin**: Playwright es un framework para pruebas de principio a fin popular desarrollado por Microsoft. Otros ejemplos de herramientas para pruebas de principio a fin incluyen Cypress, Selenium y Puppeteer.

Aquí hay un ejemplo de pruebas E2E del código de freeCodeCamp usando Playwright. El gancho `beforeEach` se ejecutará antes de cada una de las pruebas. Las pruebas verifican que el donante tenga un enlace de apoyo en la barra de menú, así como un borde especial estilizado alrededor de su avatar:

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## Pruebas de Usabilidad

- **Pruebas de Usabilidad**: Las pruebas de usabilidad son cuando tienes usuarios reales interactuando con la aplicación para descubrir si hay problemas de diseño, experiencia de usuario o funcionalidad en la aplicación. Las pruebas de usabilidad se centran en la intuitividad de la aplicación por parte de los usuarios.
- **Cuatro Tipos Comunes de Pruebas de Usabilidad**:
  - **Explorativa**: Las pruebas de usabilidad explorativa involucran a los usuarios interactuando con las diferentes características de la aplicación para comprender mejor cómo funcionan.
  - **Comparativa**: Las pruebas comparativas consisten en comparar la experiencia de usuario de tu aplicación con aplicaciones similares en el mercado.
  - **Evaluación**: Las pruebas de evaluación son donde estudias cuán intuitiva es la aplicación para usar.
  - **Validación**: Las pruebas de validación son donde identificas cualquier problema importante que impida al usuario utilizar la aplicación de manera efectiva.
- **Herramientas de Pruebas de Usabilidad**: Ejemplos de herramientas para pruebas de usabilidad incluyen Loop11, Maze, Userbrain, UserTesting y UXTweak.

## Pruebas de Compatibilidad

- **Pruebas de Compatibilidad**: El objetivo de las pruebas de compatibilidad es asegurar que tu aplicación funcione en diferentes entornos informáticos.
- **Diferentes Tipos de Pruebas de Compatibilidad**:
  - **Compatibilidad hacia Atrás**: La compatibilidad hacia atrás se refiere a cuando el software es compatible con versiones anteriores.
  - **Compatibilidad hacia Adelante**: La compatibilidad hacia adelante se refiere a cuando el software y los sistemas funcionarán con futuras versiones.
  - **Compatibilidad de Hardware**: La compatibilidad de hardware es la capacidad del software para funcionar correctamente en diferentes configuraciones de hardware.
  - **Compatibilidad con Sistemas Operativos**: La compatibilidad con sistemas operativos es la capacidad del software de funcionar en diferentes sistemas operativos, como macOS, Windows y distribuciones de Linux como Ubuntu y Fedora.
  - **Compatibilidad de Red**: La compatibilidad de red significa que el software puede trabajar en diferentes condiciones de red, como diferentes velocidades de red, protocolos, configuraciones de seguridad, etc.
  - **Compatibilidad con Navegadores**: La compatibilidad con navegadores significa que la aplicación web puede funcionar de manera consistente en diferentes navegadores, como Google Chrome, Safari, Firefox, etc.
  - **Compatibilidad Móvil**: Es importante asegurarse de que sus aplicaciones de software funcionen en una variedad de dispositivos Android e iOS, incluidos teléfonos y tabletas.

## Pruebas de Rendimiento

- **Pruebas de Rendimiento**: En las pruebas de rendimiento, pruebas la velocidad, capacidad de respuesta, escalabilidad y estabilidad de una aplicación bajo diferentes cargas de trabajo. El objetivo es resolver cualquier tipo de cuello de botella de rendimiento.
- **Diferentes Tipos de Pruebas de Rendimiento**:
  - **Pruebas de Carga**: Las pruebas de carga determinan cómo un sistema se comporta durante tiempos de carga normales y máximos.
  - **Pruebas de Estrés**: Las pruebas de estrés son donde pruebas tu aplicación bajo cargas extremas y ves cómo responde tu sistema a la mayor carga.
  - **Pruebas de Inmersión (Pruebas de Resistencia)**: Las pruebas de inmersión o pruebas de resistencia son un tipo de pruebas de carga donde pruebas el sistema con una carga más alta durante un período prolongado.
  - **Pruebas de Picos**: Las pruebas de picos son donde aumentas y disminuyes drásticamente las cargas y analizas las reacciones del sistema a los cambios.
  - **Pruebas de Umbral (Pruebas de Capacidad)**: Las pruebas de umbral o pruebas de capacidad son donde incrementas lentamente la carga con el tiempo hasta el punto donde el sistema comienza a fallar o deteriorarse.

## Pruebas de Seguridad

- **Pruebas de Seguridad**: Las pruebas de seguridad ayudan a identificar vulnerabilidades y debilidades.
- **Principios de Seguridad**:
  - **Confidencialidad**: Esto protege contra la divulgación de información sensible a otros destinatarios que no sean el destinatario previsto.
  - **Integridad**: Esto implica prevenir que usuarios malintencionados modifiquen la información del usuario.
  - **Autenticación**: Esto implica verificar la identidad del usuario para asegurarse de que estén autorizados para usar ese sistema.
  - **Autorización**: Este es el proceso de determinar qué acciones pueden realizar los usuarios autenticados o a qué partes del sistema tienen permitido acceder.
  - **Disponibilidad**: Esto garantiza que la información y los servicios estén disponibles para los usuarios autorizados cuando los necesiten.
  - **No Repudio**: Esto asegura que tanto el remitente como el destinatario tengan prueba de entrega y verificación de la identidad del remitente. Protege contra el remitente negando haber enviado la información.
- **Amenazas Comunes de Seguridad**:
  - **Cross-Site Scripting (XSS)**: Los ataques XSS ocurren cuando un atacante inyecta scripts maliciosos en una página web y luego los ejecuta en el contexto del navegador de la víctima.
  - **SQL Injection**: La inyección SQL permite a usuarios malintencionados inyectar código malicioso en una base de datos.
  - **Ataque de Denegación de Servicio (DoS)**: El ataque DoS es cuando usuarios malintencionados inundan un sitio web con un gran número de solicitudes o tráfico, causando que el servidor se ralentice y posiblemente se colapse, haciendo que el sitio esté inaccesible para los usuarios.
- **Categorías de Herramientas de Pruebas de Seguridad**:
  - **Pruebas de Seguridad de Aplicaciones Estáticas**: Estas herramientas evalúan el código fuente de una aplicación para identificar vulnerabilidades de seguridad.
  - **Pruebas de Seguridad de Aplicaciones Dinámicas**: Estas herramientas interactúan con el frontend de la aplicación para descubrir posibles debilidades de seguridad. Las herramientas DAST no tienen acceso al código fuente.
- **Pruebas de Penetración (pentest)**: Las pruebas de penetración son un tipo de pruebas de seguridad que implican crear ataques cibernéticos simulados en la aplicación para identificar vulnerabilidades en el sistema.

## Pruebas A/B

- **Pruebas A/B**: Las pruebas A/B implican comparar dos versiones de una página o aplicación y estudiar cuál versión se desempeña mejor. También es conocido como prueba de cubo o prueba dividida. Las pruebas A/B te permiten tomar decisiones más impulsadas por datos y mejorar continuamente la experiencia del usuario.
- **Herramientas para Pruebas A/B**: Ejemplos de herramientas para usar en pruebas A/B incluyen GrowthBook y LaunchDarkly.

## Pruebas Alfa y Beta

Una vez que el desarrollo inicial y las pruebas del software están completas, es importante que la aplicación sea probada por testers y usuarios reales. Aquí es donde entran las pruebas alfa y beta.

- **Pruebas Alfa**: Las pruebas alfa son realizadas por un grupo selecto de testers que revisan la aplicación para asegurarse de que no haya errores antes de ser lanzada al mercado. Las pruebas alfa son parte de las pruebas de aceptación y utilizan técnicas de caja blanca y caja negra.
- **Pruebas Beta**: Las pruebas beta son cuando la aplicación se pone a disposición de usuarios reales. Los usuarios pueden interactuar con la aplicación y proporcionar feedback. Las pruebas beta también son una forma de pruebas de aceptación de usuarios.
- **Pruebas de Aceptación**: Las pruebas de aceptación aseguran que la aplicación de software cumpla con los requisitos comerciales y las necesidades de los usuarios antes de su lanzamiento.
- **Pruebas de Caja Negra**: Las pruebas de caja negra solo se centran en el comportamiento esperado de la aplicación.
- **Pruebas de Caja Blanca**: Las pruebas de caja blanca implican que el tester conozca los componentes internos y realice pruebas sobre ellos.

## Pruebas de Regresión

- **Regresión**: La regresión se refiere a situaciones donde nuevos cambios rompen involuntariamente funcionalidades existentes.
- **Pruebas de Regresión**: Las pruebas de regresión ayudan a detectar problemas de regresión. En las pruebas de regresión, vuelves a ejecutar pruebas funcionales contra partes de tu aplicación para asegurar que todo sigue funcionando como se espera.
- **Herramientas para Pruebas de Reversión**: Herramientas que puedes usar para realizar pruebas de reversión incluyen Puppeteer, Playwright, Selenium y Cypress.
- **Técnicas para Pruebas de Regresión**:
  - **Pruebas de Regresión Unitarias**: Aquí es donde tienes una lista de elementos que deben ser probados cada vez que se implementan cambios o correcciones mayores en la aplicación.
  - **Pruebas de Regresión Parciales**: Esto implica enfoques específicos para asegurar que los nuevos cambios no hayan roto aspectos particulares de la aplicación.
  - **Pruebas de Regresión Completas**: Esto ejecuta pruebas contra todas las funcionalidades en el código. Esta es la opción más detallada y que requiere más tiempo.
- **Re-testing**: El re-testing se utiliza para comprobar problemas conocidos y asegurarse de que han sido resueltos. En contraste, las pruebas de regresión buscan problemas desconocidos que podrían haber ocurrido a través de cambios recientes en el código.

## ¿Qué es TypeScript?

- **JavaScript**: JavaScript es un lenguaje de tipado dinámico. Esto significa que las variables pueden recibir cualquier valor en tiempo de ejecución. El desafío de un lenguaje de tipado dinámico es que la falta de seguridad de tipos puede introducir errores.

Por ejemplo, incluso si tu función JavaScript espera un arreglo, aún puedes llamarla con un número:

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

El `output` de consola para el ejemplo arriba será `undefined`.

- **TypeScript**: TypeScript extiende el lenguaje JavaScript para incluir tipado estático, lo que ayuda a capturar errores causados por incompatibilidades de tipo antes de ejecutar tu código.

Por ejemplo, puedes definir un tipo para el parámetro `array` de la siguiente manera:

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Esta definición de tipo le dice a TypeScript que el parámetro `array` debe ser un arreglo de cadenas. Luego, cuando llamas a `getRandomValue` y le pasas un número, recibes un error llamado error de compilador.

- **Compilador**: Primero necesitas compilar el código TypeScript a JavaScript regular. Cuando ejecutas el compilador, TypeScript evaluará tu código y dará un error por cualquier problema donde los tipos no coincidan.

## Tipos de Datos en TypeScript

- **Tipos de Datos Primitivos en TypeScript**: Para los tipos de datos primitivos `string`, `null`, `undefined`, `number`, `boolean` y `bigint`, TypeScript ofrece palabras clave de tipo correspondientes.

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **Arreglo**: Puedes definir un arreglo de un tipo específico con dos sintaxis diferentes.

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **Objetos**: Puedes definir la estructura exacta de un objeto.

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

Si quieres un objeto con cualquier clave, pero donde todos los valores deben ser cadenas, hay dos maneras de definirlo:

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **Otros Tipos Útiles en TypeScript**:
  - **`any`**: `any` indica que un valor puede tener cualquier tipo. Le dice al compilador que deje de preocuparse por el tipo de esa variable.
  - **`unknown`**: `unknown` le dice a TypeScript que _sí_ te importa el tipo del valor, pero en realidad no sabes cuál es. `unknown` es generalmente preferido sobre `any`.
  - **`void`**: Este es un tipo especial que generalmente solo usas al definir funciones. Las funciones que no tienen valor de retorno utilizan un tipo de retorno de `void`.
  - **`never`**: Representa un tipo que nunca existirá.

- **`type` Palabra Clave**: Esta palabra clave es como `const`, pero en lugar de declarar una variable, puedes declarar un tipo.

Es útil para declarar tipos personalizados, como tipos de unión o tipos que incluyen solo valores específicos:

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interface`**: Las interfaces son como clases para tipos. Pueden implementar o extender otras interfaces, son específicamente tipos de objetos y generalmente son preferidas a menos que necesites una característica específica ofrecida por una declaración `type`.

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **Definición de Tipo de Retorno**: También puedes definir el _tipo de retorno_ de la función.

El siguiente ejemplo define el valor de retorno como una cadena. Si intentas devolver cualquier otra cosa, TypeScript te dará un error de compilador.

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## Genéricos

- **Definiendo Tipo Genérico**: Puedes definir un tipo genérico y referenciarlo en tu función. Puede pensarse como un parámetro especial que proporcionas a una función para controlar el comportamiento de la definición de tipo de la función.

Aquí tienes un ejemplo de definir un tipo genérico para una función:

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

La sintaxis `<T>` le dice a TypeScript que estás definiendo un tipo genérico `T` para la función. `T` es un nombre común para tipos genéricos, pero puedes usar cualquier nombre.

Luego, le dices a TypeScript que el parámetro `array` es un arreglo de valores que coinciden con el tipo genérico, y que el valor devuelto es un solo elemento de ese mismo tipo.

- **Especificando el Argumento de Tipo en una Llamada a Función**: Puedes pasar un argumento de tipo a una llamada a función usando corchetes angulares entre el nombre de la función y sus parámetros.

Aquí tienes un ejemplo de pasar un argumento de tipo a una llamada a función:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Esto le dice a TypeScript que el elemento que esperas encontrar será un elemento de entrada.

## Estrechamiento de Tipo

- **Estrechamiento por Veracidad**: En el ejemplo a continuación, obtienes un error al intentar acceder a la propiedad `valor` de `correo` porque `correo` _podría_ ser `null`.

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Puedes usar una declaración condicional para confirmar que `correo` es _verdadero_ antes de acceder a la propiedad:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

Las comprobaciones de veracidad también pueden funcionar en la dirección inversa:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

Lanzar un error termina la ejecución lógica de este código, lo que significa que cuando llegas a la llamada `console.log()`, TypeScript sabe que `correo` _no_ puede ser `null`.

- **Encadenamiento Opcional**: El encadenamiento opcional `?.` también es una forma de estrechamiento de tipo, bajo el mismo principio de que el acceso a la propiedad no puede ocurrir si el valor de `correo` es `null`.

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **Operador `typeof`**: Puedes usar una condición para verificar el tipo de la variable usando el operador `typeof`.

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **Palabra Clave `instanceof`**: Si el objeto proviene de una clase, puedes usar la palabra clave `instanceof` para estrechar el tipo.

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **Conversión**: Cuando TypeScript no puede determinar automáticamente el tipo de un valor, como el resultado del método `request.json()` en el siguiente ejemplo, obtendrás un error de compilador. Una forma de resolver esto es convirtiendo el tipo, pero hacerlo debilita la capacidad de TypeScript para detectar posibles errores.

```typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **Guardián de Tipo**: En lugar de convertir el tipo, puedes escribir un guardián de tipo:

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

La sintaxis `usuario es Usuario` indica que tu función devuelve un valor booleano, que cuando es verdadero significa que el valor del `usuario` cumple con la interfaz `Usuario`.

## Archivo `tsconfig`

- **`tsconfig.json`**: Las configuraciones del compilador TypeScript viven en un archivo `tsconfig.json` en el directorio raíz de tu proyecto.

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

Aquí están las descripciones de las opciones del compilador utilizadas en el ejemplo anterior:

- **`compilerOptions`**: La propiedad `compilerOptions` es donde controlas cómo se comporta el compilador de TypeScript.
- **`rootDir` y `outDir`**: `rootDir` y `outDir` indican a TypeScript qué directorio contiene tus archivos fuente y qué directorio debe contener el código JavaScript transpilado.
- **`lib`**: La propiedad `lib` determina qué definiciones de tipo usa el compilador, y te permite incluir soporte para lanzamientos específicos de ES, el DOM y más.
- **`module` y `moduleResolution`**: `module` y `moduleResolution` trabajan en conjunto para manejar cómo tu paquete usa módulos - ya sea CommonJS o ECMAScript.
- **`esModuleInterop`**: `esModuleInterop` permite una mejor interoperabilidad entre CommonJS y módulos ES al crear automáticamente objetos de espacio de nombres para importaciones.
- **`skipLibCheck`**: La opción `skipLibCheck` omite la validación de archivos `.d.ts` que no son referenciados por importaciones en tu código.
- **`strict`**: La bandera `strict` habilita varias comprobaciones, como asegurar el manejo adecuado de tipos nulos y advertir cuando TypeScript recurre a `any`.
- **`exclude`**: La propiedad `exclude` de nivel superior le dice al compilador que ignore estos archivos TypeScript durante la compilación.


# --assignment--

Revisa los temas y conceptos de Front End Libraries.
