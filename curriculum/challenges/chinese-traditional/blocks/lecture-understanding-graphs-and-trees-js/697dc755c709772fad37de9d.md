---
id: 697dc755c709772fad37de9d
title: 深度優先搜尋和廣度優先搜尋如何運作？
challengeType: 19
dashedName: how-do-depth-first-and-breadth-first-search-work
---

# --description--

當你開始使用資料結構和演算法時，你很快就會發現你需要執行的常見操作之一是訪問每個節點。

這個處理程序稱為「遍歷」資料結構。

遍歷用於對資料結構中的每個節點執行某些操作，例如列印它們的值、尋找特定的值，或對節點執行特定的操作行為。

透過系統性地造訪每個節點，你確保該處理程序不會跳過任何節點。

但是你如何決定應該以什麼順序巡訪資料結構？處理程序應該從哪裡開始，下一個節點又應該如何選擇？

如果沒有明確的方法來巡訪資料結構，遍歷它就像是在沒有特定路徑可循的迷宮中行走。

這就是像 breadth-first search (BFS) 和 depth-first search (DFS) 這類演算法變得非常重要的地方。它們通常用於巡訪圖形以及尋找兩個節點之間的路徑。

當它們用於巡訪資料結構時，它們定義了節點應該被訪問的順序，以確保沒有任何節點被跳過。

讓我們從廣度優先搜尋（BFS）開始。

## 廣度優先搜尋（BFS）

**廣度優先搜尋（BFS）** 是一種演算法，會在移動到圖形的下一個層級之前，先造訪所有相鄰的節點。

它可以用來尋找無權重圖中兩個節點之間的最短路徑，因為它會分析每個層次的所有節點，所以會先找到邊數最少的路徑。

這個演算法通常使用佇列資料結構來追蹤已經被造訪的節點。佇列遵循 FIFO（先進先出）的方法，最先被加入佇列的節點會是第一個被移除的節點。

演算法的運作方式如下：

* 你從特定節點開始。
    
* 該節點已標記為已訪問並添加到佇列中。
    
* 當佇列不為空時，當前節點會從佇列中移除（出佇列）。然後，對於它的每一個鄰居，如果該鄰居尚未被訪問，則將其標記為已訪問並添加到佇列中。
    

一個重要的考量是，由於廣度優先搜尋（BFS）需要在記憶體中儲存佇列，而這個佇列可能包含大量節點，因此這個演算法的空間需求可能相當可觀。對於在同一層級上有大量節點的圖形尤其如此。

讓我們來看一個將 BFS 應用於一種稱為樹的特定圖的範例。

你將在即將到來的課程中學習更多關於樹狀結構的內容，但它們本質上是沒有迴圈的圖形，其中節點以階層體系組織。迴圈是從同一節點開始並結束的路徑。

讓我們將廣度優先搜尋（BFS）演算法應用到這棵樹上：

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-1.png" alt="A tree diagram showing nodes A through G arranged in a hierarchy. Node A is at the root, with children B and C. Node B has children D and E, and node C has children F and G.">

**步驟 1：**

我們從樹的根節點 A 開始。我們將 A 添加到佇列，並立即將它標記為已訪問。

* **佇列：** `[A]`
    
* **已造訪：** `{A}`
    

**步驟 2：**

我們從佇列中取出節點 A。將它未拜訪的子節點（節點 B 然後節點 C）添加到佇列，並將它們標記為已拜訪。

* **佇列：** `[B, C]`
    
* **已造訪：** `{A, B, C}`
    

在相同層次的節點被添加到佇列的順序，是由資料結構的實作以及圖形表述中邊（連接）儲存的順序所定義。

如果實作體是一致的，同一層級節點的巡訪順序不會影響演算法的正確性。它仍然會逐層級訪問每個節點。

**步驟 3：**

我們從佇列中取出節點 B。我們將它未訪問的子節點（節點 D 然後節點 E）添加到佇列中，並將它們標記為已訪問。

* **佇列：** `[C, D, E]`
    
* **已造訪：** `{A, B, C, D, E}`
    

**步驟 4：**

我們從佇列中取出節點 C。我們將它未拜訪的子節點（節點 F 然後節點 G）添加到佇列中，並將它們標記為已拜訪。

* **佇列：** `[D, E, F, G]`
    
* **已造訪：** `{A, B, C, D, E, F, G}`
    

**步驟 5：**

我們從佇列中取出節點 D。此節點沒有任何未造訪的子節點，因此造訪集合不會有任何變化。

* **佇列：** `[E, F, G]`
    
* **已造訪：** `{A, B, C, D, E, F, G}`
    

**步驟 6：**

我們從佇列中取出節點 E。該節點沒有任何未造訪的子節點，因此造訪集合沒有任何變化。

* **佇列：** `[F, G]`
    
* **已造訪：** `{A, B, C, D, E, F, G}`
    

**步驟 7：**

我們從佇列中取出 F。此節點沒有任何未訪問的子節點，因此已訪問集合沒有任何變化。

* **佇列：** `[G]`
    
* **已造訪：** `{A, B, C, D, E, F, G}`
    

**步驟 8：**

我們從佇列中取出 G。此節點沒有任何未拜訪的子節點，因此拜訪集合沒有任何變化。

* **佇列：** `[]`
    
* **已造訪：** `{A, B, C, D, E, F, G}`
    

當佇列為空時，遍歷完成。

節點依照此順序被巡訪：

**A → B → C → D → E → F → G**

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-2.png" alt="The same tree diagram with arrows showing the BFS traversal order: A to B to C to D to E to F to G, demonstrating level-by-level visitation.">

注意演算法如何依照層級拜訪節點。

我們從節點 A 開始，然後移動到下一個層次拜訪節點 B 和 C，再移動到下一個層次拜訪節點 D、E、F 和 G。這就是廣度優先搜尋（BFS）的核心原理。

## 深度優先搜尋（DFS）

當廣度優先搜尋（BFS）會先造訪同一層次的所有鄰近節點時，**深度優先搜尋（DFS）**會沿著每個分支盡可能深入，然後再回溯。

你可以將這個演算法想像成透過選擇特定路徑並沿著它前進，直到你到達死胡同或 `exit`。如果你到達死胡同，你會回頭並選擇不同的路徑。

深度優先搜尋（DFS）通常用於解決具有單一解的謎題、偵測圖中的迴圈，以及尋找連通圖組件。

這個演算法可以使用遞迴或堆疊資料結構來追蹤已訪問的節點。

堆疊遵循 LIFO（後進先出）方法，最後加入堆疊的節點會是第一個從堆疊中移除的節點。

演算法的運作方式如下：

* 從特定節點開始。
    
* 該節點已標記為已訪問並添加到堆疊。
    
* 當堆疊不為空時，當前節點會被彈出（移除）。這時我們會「拜訪」或處理它（例如，列印它的值）。接著，所有未拜訪的鄰居節點會被標記為已拜訪並添加到堆疊中。
    

這個演算法的限制之一是，它並不總是保證能在無權重圖中找到兩個節點之間的最短路徑。

讓我們來看看深度優先搜尋（DFS）應用於我們的樹狀範例的例子。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-3.png" alt="The same tree diagram as before, showing nodes A through G in their hierarchical structure, ready for DFS demonstration.">

**步驟 1：**

我們從根節點 A 開始。我們將它標記為已訪問並將它添加到堆疊。

* **堆疊：** `[A]`
    
* **已造訪：** `{A}`
    

**步驟 2：**

我們從堆疊中彈出節點 A。

然後，我們將其未訪問的子節點，節點 B 和節點 C，添加到堆疊中。我們將以相反的順序添加它們，先 `C` 再 `B`，以便 `B` 位於頂端（後進先出），並將會是下一個被處理的節點。我們也將它們標記為已訪問。

* **堆疊：** `[C, B]`
    
* **已造訪：** `{A, B, C}`
    

**步驟 3：**

我們從堆疊中彈出節點 B。

然後，我們將其未訪問的子節點，節點 D 和節點 E，依反向順序（先 `E` 再 `D``）添加到堆疊中。我們也將它們標記為已訪問。

* **堆疊：** `[C, E, D]`
    
* **已造訪：** `{A, B, C, D, E}`
    

**步驟 4：**

我們從堆疊中彈出節點 D。此節點沒有子節點可添加到堆疊中。

* **堆疊：** `[C, E]`
    
* **已造訪：** `{A, B, C, D, E}`
    

**步驟 5：**

我們從堆疊中彈出節點 E。此節點沒有子節點可添加到堆疊中。

* **堆疊：** `[C]`
    
* **已造訪：** `{A, B, C, D, E}`
    

**步驟 6：**

我們彈出節點 C。

然後，我們將它的子節點 node F 和 node G 以相反順序（先 node G 再 node F）添加到堆疊中，並將它們標記為已訪問。

* **堆疊：** `[G, F]`
    
* **已造訪：** `{A, B, C, D, E, F, G}`
    

**步驟 7：**

我們從堆疊中彈出節點 F。此節點沒有子節點可添加到堆疊中。

* **堆疊：** `[G]`
    
* **已造訪：** `{A, B, C, D, E, F, G}`
    

**步驟 8：**

我們彈出節點 G。此節點沒有子節點可添加到堆疊。

* **堆疊：** `[]`
    
* **已造訪：** `{A, B, C, D, E, F, G}`
    

當 `stack` 為空時，遍歷完成且所有節點皆已被訪問。

演算法依照此順序造訪節點：

**A → B → D → E → C → F → G**

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-4.png" alt="The tree diagram with numbers showing the DFS traversal order: A(1), B(2), D(3), E(4), C(5), F(6), G(7), demonstrating depth-first exploration of branches.">

注意我們如何從節點 A 開始，然後一路向下移動到節點 B，以及節點 D 和 E，接著再向上移動到節點 C，然後是節點 F 和 G。這是深度優先搜尋（DFS）的核心原理，先遍歷完整路徑，再回溯並尋找其他路徑。

在這種情況下，我們使用堆疊解決了這個範例。或者，也可以使用遞迴實作深度優先搜尋（DFS），其中函式處理當前節點，然後對每個未造訪的鄰居呼叫自己。函式呼叫堆疊隱式地管理後進先出（LIFO）順序。

廣度優先搜尋（BFS）和深度優先搜尋（DFS）都是遍歷圖形和樹狀結構的重要演算法。廣度優先搜尋（BFS）逐層探索節點，非常適合在無權重圖中尋找最短路徑。另一方面，深度優先搜尋（DFS）會盡可能深入一個分支後再回溯，非常適合解迷宮和偵測迴圈。了解它們的優缺點有助於為特定問題選擇合適的演算法。

# --questions--

## --text--

下列哪一種資料結構通常用來實作標準的廣度優先搜尋（BFS）演算法？

## --answers--

堆疊

### --feedback--

思考佇列如何處理資料，以及這如何與逐層拜訪節點相關。

---

佇列

---

鏈結串列

### --feedback--

思考佇列如何處理資料，以及這如何與逐層拜訪節點相關。

---

樹

### --feedback--

思考佇列如何處理資料，以及這如何與逐層拜訪節點相關。

## --video-solution--

2

## --text--

以下關於深度優先搜尋（DFS）的敘述中，哪一項是正確的？

## --answers--

深度優先搜尋保證能在無權重圖中找到兩個節點之間的最短路徑。

### --feedback--

思考深度優先搜尋（DFS）用來巡訪資料結構的策略。

---

深度優先搜尋會在移動到下一個層次之前，先造訪目前層次的所有鄰居。

### --feedback--

思考深度優先搜尋（DFS）用來巡訪資料結構的策略。

---

深度優先搜尋總是比 BFS 更高效節省空間。

### --feedback--

思考深度優先搜尋（DFS）用來巡訪資料結構的策略。

---

深度優先搜尋通常使用遞迴或堆疊來實作。

## --video-solution--

4

## --text--

如果你想在無權重圖中找到從起始節點到標的節點的最短路徑，哪種演算法會是最合適的選擇？

## --answers--

廣度優先搜尋（BFS）

---

深度優先搜尋（DFS）

### --feedback--

思考廣度優先搜尋和深度優先搜尋的核心遍歷策略，以及哪一種能保證找到兩個節點之間的最短路徑。

---

二分搜尋法

### --feedback--

思考廣度優先搜尋和深度優先搜尋的核心遍歷策略，以及哪一種能保證找到兩個節點之間的最短路徑。

---

合併排序

### --feedback--

思考廣度優先搜尋和深度優先搜尋的核心遍歷策略，以及哪一種能保證找到兩個節點之間的最短路徑。

## --video-solution--

1
