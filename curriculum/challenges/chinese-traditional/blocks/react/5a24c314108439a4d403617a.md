---
id: 5a24c314108439a4d403617a
title: 將 State 作為 Props 傳遞給子組件
challengeType: 6
forumTopicId: 301403
dashedName: pass-state-as-props-to-child-components
---

# --description--

你在之前的挑戰中看過許多將 props 傳遞給子 JSX 元素和子 React 組件的範例。你可能會想知道那些 props 從哪裡來。一個常見的樣式是擁有一個包含對你的應用程式重要的 `state` 的有狀態組件，然後呈現子組件。你希望這些組件能存取該 `state` 的某些部分，這些部分會作為 props 傳入。

例如，也許你有一個 `App` 組件，它會呈現一個 `Navbar`，以及其他組件。在你的 `App` 中，你有包含大量使用者資訊的 `state`，但 `Navbar` 只需要存取使用者的使用者名稱，以便顯示它。你將那部分 `state` 作為 prop 傳遞給 `Navbar` 組件。

此樣式說明了 React 中一些重要的範例。第一個是*單向資料流*。狀態沿著應用程式組件的樹狀結構單向流動，從有狀態的父組件流向子組件。子組件只接收它們所需的狀態資料。第二個是複雜的有狀態應用程式可以拆解成少數幾個，甚至可能只有一個有狀態組件。其餘的組件僅從父組件以 props 接收狀態，並從該狀態呈現使用者介面。這開始產生一種分離，使狀態管理在程式碼的一部分中控制代碼，而使用者介面呈現在另一部分。將狀態邏輯與使用者介面邏輯分離的原則是 React 的關鍵原則之一。當正確使用時，它使複雜有狀態應用程式的設計更容易管理。

# --instructions--

`MyApp` 組件是有狀態的，並且將 `Navbar` 組件作為子組件呈現。將 `state` 中的 `name` 屬性傳遞給子組件，然後在 `Navbar` 呈現方法中屬於 `h1` 頁籤的部分顯示 `name`。`name` 應該出現在文字 `Hello, my name is:` 之後。

# --hints--

`MyApp` 組件應該要在內部呈現一個 `Navbar` 組件。

```js
assert(
  (function () {
    const mockedComponent = Enzyme.mount(React.createElement(MyApp));
    return (
      mockedComponent.find('MyApp').length === 1 &&
      mockedComponent.find('Navbar').length === 1
    );
  })()
);
```

`Navbar` 組件應該接收 `MyApp` 狀態屬性 `name` 作為 props。

```js
  const waitForIt = (fn) =>
    new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250));
  const mockedComponent = Enzyme.mount(React.createElement(MyApp));
  const setState = () => {
    mockedComponent.setState({ name: 'TestName' });
    return waitForIt(() => mockedComponent.find('Navbar').props());
  };
  const navProps = await setState();
  assert(navProps.name === 'TestName');
```

`Navbar` 中的 `h1` 元素應該呈現 `name` prop。

```js
  const waitForIt = (fn) =>
    new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250));
  const mockedComponent = Enzyme.mount(React.createElement(MyApp));
  const navH1Before = mockedComponent.find('Navbar').find('h1').text();
  const setState = () => {
    mockedComponent.setState({ name: 'TestName' });
    return waitForIt(() => mockedComponent.find('Navbar').find('h1').text());
  };
  const navH1After = await setState();
  assert(new RegExp('TestName').test(navH1After) && navH1After !== navH1Before);
```

# --seed--

## --after-user-code--

```jsx
ReactDOM.render(<MyApp />, document.getElementById('root'))
```

## --seed-contents--

```jsx
class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'CamperBot'
    }
  }
  render() {
    return (
       <div>
         {/* Change code below this line */}
         <Navbar />
         {/* Change code above this line */}
       </div>
    );
  }
};

class Navbar extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
    <div>
      {/* Change code below this line */}
      <h1>Hello, my name is: </h1>
      {/* Change code above this line */}
    </div>
    );
  }
};
```

# --solutions--

```jsx
class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'CamperBot'
    }
  }
  render() {
    return (
       <div>
         <Navbar name={this.state.name}/>
       </div>
    );
  }
};
class Navbar extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
    <div>
      <h1>Hello, my name is: {this.props.name}</h1>
    </div>
    );
  }
};
```
