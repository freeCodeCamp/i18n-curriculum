---
id: 5a23c84252665b21eecc7edf
title: 最小公倍數
challengeType: 1
forumTopicId: 302301
dashedName: least-common-multiple
---

# --description--

12 和 18 的最小公倍數是 36，因為 12 是因數（12 × 3 = 36），18 是因數（18 × 2 = 36），且沒有比 36 小的正整數同時具有這兩個因數。作為特殊情況，如果 $m$ 或 $n$ 為零，則最小公倍數為零。計算最小公倍數的一種方法是迭代所有 $m$ 的倍數，直到找到同時也是 $n$ 的倍數的數字。如果你已經有 <a href="https://rosettacode.org/wiki/Greatest_common_divisor" target="_blank" rel="noopener noreferrer nofollow">最大公因數</a> 的 $gcd$，那麼此公式可計算 $lcm$。 

$$
\\operatorname{lcm}(m, n) = \\frac{|m \\times n|}{\\operatorname{gcd}(m, n)}
$$

# --instructions--

計算整數陣列的最小公倍數。給定 *m* 和 *n*，最小公倍數是同時以 *m* 和 *n* 為因數的最小正整數。

# --hints--

`LCM` 應該是一個函式（程式）。

```js
assert(typeof LCM == 'function');
```

`LCM([2, 4, 8])` 應該傳回一個數字。

```js
assert(typeof LCM([2, 4, 8]) == 'number');
```

`LCM([2, 4, 8])` 應該傳回 `8`。

```js
assert.equal(LCM([2, 4, 8]), 8);
```

`LCM([4, 8, 12])` 應該傳回 `24`。

```js
assert.equal(LCM([4, 8, 12]), 24);
```

`LCM([3, 4, 5, 12, 40])` 應該傳回 `120`。

```js
assert.equal(LCM([3, 4, 5, 12, 40]), 120);
```

`LCM([11, 33, 90])` 應該傳回 `990`。

```js
assert.equal(LCM([11, 33, 90]), 990);
```

`LCM([-50, 25, -45, -18, 90, 447])` 應該傳回 `67050`。

```js
assert.equal(LCM([-50, 25, -45, -18, 90, 447]), 67050);
```

# --seed--

## --seed-contents--

```js
function LCM(A) {

}
```

# --solutions--

```js
function LCM(A) {
  var n = A.length,
    a = Math.abs(A[0]);
  for (var i = 1; i < n; i++) {
    var b = Math.abs(A[i]),
      c = a;
    while (a && b) {
      a > b ? (a %= b) : (b %= a);
    }
    a = Math.abs(c * A[i]) / (a + b);
  }
  return a;
}
```
