---
id: 61abc7ebf3029b56226de5b6
title: 實作二元搜尋
challengeType: 1
forumTopicId: 487618
dashedName: implement-binary-search
---

# --description--

二分搜尋法是一種用於搜尋已排序陣列中元素的 **O(log(n))** 效率演算法。它透過以下步驟運作：

1. 尋找已排序陣列的中間 `value`。如果 `value == target`，傳回 `true`（已找到該值且搜尋完成）。
1. 如果中間的 `value < target`，則在下一次比較中搜尋陣列的右半部。
1. 如果中間的 `value > target`，則在下一次比較中搜尋陣列的左半部。
1. 如果在搜尋整個陣列後該值不存在，傳回 `false`（陣列已被搜尋且該值不在陣列中）。

如你所見，你正在連續將一個陣列對半分割，這使你達到 log(n) 的效率。對於這個挑戰，我們希望你展示你的過程——你如何得到標的值……你所走的路徑！

# --instructions--

撰寫一個函式 `binarySearch`，在陣列上實作二分搜尋法，並傳回你尋找陣列中標的所走過的路徑（每次中間值的比較）。

該函式接收一個已排序的整數陣列和一個標的值作為輸入。它傳回一個陣列，該陣列包含你在每次將原始陣列對半分割時找到的中間值（依序排列），直到找到標的值為止。標的值應該是傳回陣列的最後一個元素。如果未找到該值，則傳回字串 `Value Not Found`。

例如，`binarySearch([1,2,3,4,5,6,7], 5)` 會傳回 `[4,6,5]`。

在這個挑戰中，當進行除以二時，你必須使用 `Math.floor()`：`Math.floor(x/2)`。這將提供一致且可測試的路徑。

**注意：** 以下陣列將用於測試：

```js
const testArray = [
  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 49, 70
];
```

# --hints--

`binarySearch` 應該是一個函式（程式）。

```js
assert.isFunction(binarySearch);
```

`binarySearch(testArray, 0)` 應該傳回 `[13, 5, 2, 0]`。

```js
const _testArray = [
  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 49, 70
];
assert.deepEqual(binarySearch(_testArray, 0), [13, 5, 2, 0]);
```

`binarySearch(testArray, 1)` 應該傳回 `[13, 5, 2, 0, 1]`。

```js
const _testArray = [
  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 49, 70
];
assert.deepEqual(binarySearch(_testArray, 1), [13, 5, 2, 0, 1]);
```


`binarySearch(testArray, 2)` 應該傳回 `[13, 5, 2]`。

```js
const _testArray = [
  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 49, 70
];
assert.deepEqual(binarySearch(_testArray, 2), [13, 5, 2]);
```

`binarySearch(testArray, 6)` 應該傳回字串 `Value Not Found`。

```js
const _testArray = [
  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 49, 70
];
assert.strictEqual(binarySearch(_testArray, 6), 'Value Not Found');
```

`binarySearch(testArray, 11)` 應該傳回 `[13, 5, 10, 11]`。

```js
const _testArray = [
  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 49, 70
];
assert.deepEqual(binarySearch(_testArray, 11), [13, 5, 10, 11])
```

`binarySearch(testArray, 13)` 應該傳回 `[13]`。

```js
const _testArray = [
  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 49, 70
];
assert.deepEqual(binarySearch(_testArray, 13), [13]);
```

`binarySearch(testArray, 70)` 應該傳回 `[13, 19, 22, 49, 70]`。

```js
const _testArray = [
  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 49, 70
];
assert.deepEqual(binarySearch(_testArray, 70), [13, 19, 22, 49, 70]);
```

# --seed--

## --seed-contents--

```js
function binarySearch(searchList, value) {
  let arrayPath = [];
  return arrayPath;
}
```



# --solutions--

```js
let binarySearch = (searchList, value) => {
  let arrayPath = [];

  // set initial L - M - R
  let left = 0;
  let right = searchList.length - 1;
  let middle = Math.floor(right / 2);

  // if first comparison finds value
  if (searchList[middle] == value) {
    arrayPath.push(searchList[middle]);
    return arrayPath;
  }

  while (searchList[middle] !== value) {
    // add to output array
    arrayPath.push(searchList[middle]);

    // not found
    if (right < left) {
      return 'Value Not Found';
    }
    // value is in left or right portion of array
    // update L - M - R
    if (searchList[middle] > value) {
      right = middle - 1;
      middle = left + Math.floor((right - left) / 2);
    } else {
      left = middle + 1;
      middle = left + Math.floor((right - left) / 2);
    }

    // if found update output array and exit
    if (searchList[middle] == value) {
      arrayPath.push(searchList[middle]);

      break;
    }
  }
  return arrayPath;
};
```
