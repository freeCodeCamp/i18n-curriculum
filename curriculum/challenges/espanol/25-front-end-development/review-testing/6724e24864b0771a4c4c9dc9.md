---
id: 6724e24864b0771a4c4c9dc9
title: Revisión de Pruebas
challengeType: 24
dashedName: review-testing
---

# --description--

## Pruebas Manuales y Automatizadas

- **Pruebas Manuales**: En las pruebas manuales, un evaluador realizará de manera manual cada parte de la aplicación y probará diferentes funciones para asegurarse de que funcione correctamente. Si se descubren errores en el proceso de prueba, el evaluador informará esos errores al equipo de software para que puedan ser corregidos.
- **Pruebas Automatizadas**: En las pruebas automatizadas, puedes automatizar tus pruebas escribiendo un programa separado que verifique si tu aplicación se comporta como se espera.

## Pruebas de Unidad

- **Pruebas de Unidad**: En las pruebas de unidad, se prueba cada función para asegurarse de que todo funciona como se espera. Las pruebas de unidad también pueden servir como una forma de documentación para tu aplicación, ya que están destinadas a representar el comportamiento esperado de tu código.
- **Principio de Responsabilidad Única**: El principio de responsabilidad única recomienda mantener cada función pequeña y responsable de una sola cosa.
- **Frameworks Comunes de Pruebas en JavaScript**: Algunos frameworks comunes de pruebas incluyen Jest, Mocha y Vitest. Jest es un framework de pruebas popular para pruebas de unidad.

Aquí hay un ejemplo de pruebas de unidad utilizando Jest.

Primero, puedes crear una función que sea responsable de devolver una cadena recién formateada:

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

En un archivo separado `getFormattedWord.test.js` , puedes escribir algunas pruebas para verificar que la función esté funcionando como se espera. El archivo `getFormattedWord.test.js` se verá así:

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **`expect` Función**: La función `expect` se utiliza para probar un valor.
- **Matcher**: Matcher es una función que verifica si el valor se comporta como se esperaba. En el ejemplo anterior, el matcher es `toBe()`. Jest tiene una variedad de matchers.

Para usar Jest, primero necesitas instalar el paquete `jest` usando `npm i jest`. También necesitarás agregar un script a tu archivo `package.json` así:

```js
"scripts": {
  "test": "jest"
},
```

Luego, puedes ejecutar el comando `npm run test` para ejecutar tus pruebas.

## Ciclo de Vida del Desarrollo de Software

- **Diferentes Etapas del Ciclo de Vida del Desarrollo de Software**:
  - **Etapa de Planificación**: El equipo de desarrollo recopila requisitos para el trabajo propuesto de los interesados.
  - **Etapa de Diseño**: El equipo de software desglosa los requisitos y decide las mejores propuestas para las soluciones.
  - **Etapa de Implementación**: El equipo de software descompone los requisitos en tareas manejables y las implementa.
  - **Etapa de Pruebas**: Esto implica pruebas manuales y automatizadas para el nuevo trabajo. A veces, el equipo prueba la aplicación a lo largo de toda la etapa de desarrollo para detectar y solucionar cualquier problema que surja.
  - **Etapa de Despliegue**: El equipo despliega los nuevos cambios a un entorno de compilación o prueba.
  - **Etapa de Mantenimiento**: Esto implica corregir cualquier problema que surja de los clientes en la aplicación en producción.

- **Diferentes Modelos del Ciclo de Vida del Desarrollo de Software**:
  - **Modelo de Cascada**: El modelo de cascada es donde cada fase del ciclo de vida debe completarse antes de que pueda comenzar la siguiente fase.
  - **Modelo Ágil**: El modelo ágil se centra en el desarrollo iterativo dividiendo el trabajo en sprints.

## BDD y TDD

- **TDD**: El desarrollo impulsado por pruebas es una metodología que enfatiza escribir pruebas primero. Escribir pruebas antes de desarrollar funciones proporciona retroalimentación en tiempo real a los desarrolladores durante el proceso de desarrollo.
- **BDD**: El desarrollo impulsado por el comportamiento es el enfoque de alinear una serie de pruebas con los objetivos comerciales. Los escenarios de prueba en BDD deben escribirse en un lenguaje que pueda ser entendido tanto por personas técnicas como no técnicas. Un ejemplo de tal sintaxis es Gherkin.
- **Frameworks de Prueba BDD**: Ejemplos de frameworks de pruebas BDD incluyen Cucumber, JBehave y SpecFlow.

## Aserciones en Pruebas de Unidad

- **Aserción**: Las aserciones se utilizan para comprobar que el código se comporta como se espera.
- **Bibliotecas de Aserciones**: Chai es una biblioteca de aserciones comúnmente utilizada. Otras bibliotecas comunes de aserciones en JavaScript son `should.js` y `expect.js`.

Aquí hay un ejemplo de una aserción utilizando Chai que comprueba que el valor de retorno de la función `addThreeAndFour` es igual al número 7:

```js
assert.equal(addThreeAndFour(), 7);
```

- **Mejores Prácticas**: Independientemente de qué biblioteca de aserción uses, debes escribir mensajes claros de aserción y falla que te ayuden a entender qué pruebas están fallando y por qué.

## Simulación, Falsificación y Relleno

- **Simulación**: Simular es el proceso de reemplazar datos reales con datos falsos que simulan el comportamiento de componentes reales. Por ejemplo, podrías simular la response de la API en pruebas en lugar de realizar llamadas de API continuas para obtener los datos.
- **Relleno**: Los rellenos son objetos que devuelven respuestas predefinidas o datos simulados para un comportamiento esperado en una aplicación. Por ejemplo, puedes definir el comportamiento para una conexión a la base de datos en tus pruebas sin tener que depender de una conexión a la base de datos real.
- **Falsificación**: Las falsificaciones son versiones simplificadas de componentes reales sin la complejidad o efectos secundarios. Por ejemplo, puedes falsificar una base de datos almacenando los datos en memoria en lugar de interactuar con la base de datos real. Esto te permitirá imitar operaciones de base de datos en memoria, lo cual será mucho más rápido que tratar con la base de datos real.

## Pruebas Funcionales

- **Pruebas Funcionales**: Las pruebas funcionales verifican si las funciones y características de la aplicación funcionan como se espera. El objetivo de las pruebas funcionales es probar el sistema como un todo en múltiples escenarios.
- **Pruebas No Funcionales**: Las pruebas no funcionales se centran en aspectos como el rendimiento y la fiabilidad.
- **Pruebas de Humo**: Las pruebas de humo son una verificación preliminar del sistema para identificar problemas básicos o críticos antes de comenzar pruebas más exhaustivas.

## Pruebas de Extremo a Extremo

- **Pruebas de Extremo a Extremo**: Las pruebas de extremo a extremo, o E2E, prueban escenarios del mundo real desde la perspectiva del usuario. Las pruebas de extremo a extremo ayudan a garantizar que tu aplicación se comporte correctamente y sea predecible para los usuarios. Sin embargo, lleva mucho tiempo configurarlas, diseñarlas y mantenerlas.
- **Frameworks de Pruebas de Extremo a Extremo**: Playwright es un framework popular para pruebas de extremo a extremo desarrollado por Microsoft. Otros ejemplos de herramientas de pruebas de extremo a extremo incluyen Cypress, Selenium y Puppeteer.

Aquí tienes un ejemplo de pruebas E2E del código abierto de freeCodeCamp usando Playwright. El hook `beforeEach` se ejecutará antes de cada una de las pruebas. Las pruebas verifican que el donante tenga un enlace de apoyo en la barra de menú, así como un borde especial estilizado alrededor de su avatar:

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## Pruebas de Usabilidad

- **Pruebas de Usabilidad**: Las pruebas de usabilidad se realizan cuando usuarios reales interactúan con la aplicación para descubrir si hay problemas de diseño, experiencia de usuario o funcionalidad en la aplicación. Las pruebas de usabilidad se centran en la intuición de la aplicación por parte de los usuarios.
- **Cuatro Tipos Comunes de Pruebas de Usabilidad**:
  - **Explorativa**: La prueba de usabilidad explorativa implica que los usuarios interactúen con las diferentes funciones de la aplicación para comprender mejor cómo funcionan.
  - **Comparativa**: La prueba comparativa consiste en comparar la experiencia del usuario de tu aplicación con aplicaciones similares en el mercado.
  - **Evaluación**: En la prueba de evaluación, se estudia cuán intuitiva es la aplicación al usarla.
  - **Validación**: La prueba de validación es donde se identifican los problemas importantes que impedirán al usuario utilizar la aplicación de manera efectiva.
- **Herramientas de Pruebas de Usabilidad**: Ejemplos de herramientas para pruebas de usabilidad incluyen Loop11, Maze, Userbrain, UserTesting y UXTweak.

## Pruebas de Compatibilidad

- **Pruebas de Compatibilidad**: El objetivo de las pruebas de compatibilidad es asegurar que tu aplicación funcione en diferentes entornos de computación.
- **Diferentes Tipos de Pruebas de Compatibilidad**:
  - **Compatibilidad hacia Atrás**: La compatibilidad hacia atrás se refiere a cuando el software es compatible con versiones anteriores.
  - **Compatibilidad hacia Adelante**: La compatibilidad hacia adelante se refiere a cuando los software y sistemas funcionarán con versiones futuras.
  - **Compatibilidad de Hardware**: La compatibilidad de hardware es la capacidad del software para funcionar correctamente en diferentes configuraciones de hardware.
  - **Compatibilidad de Sistemas Operativos**: La compatibilidad de sistemas operativos es la capacidad del software para funcionar en diferentes sistemas operativos, como macOS, Windows y distribuciones de Linux como Ubuntu y Fedora.
  - **Compatibilidad de Redes**: La compatibilidad de redes significa que el software puede funcionar en diferentes condiciones de red, como diferentes velocidades, protocolos, configuraciones de seguridad, etc.
  - **Compatibilidad de Navegadores**: La compatibilidad de navegadores significa que la aplicación web puede funcionar de manera consistente en diferentes navegadores, como Google Chrome, Safari, Firefox, etc.
  - **Compatibilidad Móvil**: Es importante asegurarse de que tus aplicaciones de software funcionen en una variedad de dispositivos Android y iOS, incluidos teléfonos y tabletas.

## Pruebas de Rendimiento

- **Pruebas de Rendimiento**: En las pruebas de rendimiento, se prueba la velocidad, capacidad de respuesta, escalabilidad y estabilidad de una aplicación bajo diferentes cargas de trabajo. El objetivo es resolver cualquier tipo de cuello de botella de rendimiento.
- **Diferentes Tipos de Pruebas de Rendimiento**:
  - **Pruebas de Carga**: Las pruebas de carga determinan cómo un sistema se comporta durante tiempos de carga normales y máximos.
  - **Pruebas de Estrés**: Las pruebas de estrés son donde se prueba tu aplicación bajo cargas extremas y se observa qué tan bien responde tu sistema a la carga más alta.
  - **Pruebas de Soak (Pruebas de Resistencia)**: Las pruebas de soak o pruebas de resistencia son un tipo de pruebas de carga donde se prueba el sistema con una carga más alta durante un período de tiempo prolongado.
  - **Pruebas de Picos**: Las pruebas de picos son donde se aumenta y disminuye drásticamente las cargas y se analiza las reacciones del sistema a los cambios.
  - **Pruebas de Punto de Ruptura (Pruebas de Capacidad)**: Las pruebas de punto de ruptura o pruebas de capacidad son donde se incrementa lentamente la carga a lo largo del tiempo hasta el punto en el que el sistema comienza a fallar o degradarse.

## Pruebas de Seguridad

- **Pruebas de Seguridad**: Las pruebas de seguridad ayudan a identificar vulnerabilidades y debilidades.
- **Principios de Seguridad**:
  - **Confidencialidad**: Esto protege contra la divulgación de información sensible a destinatarios que no son los previstos.
  - **Integridad**: Esto implica prevenir que usuarios malintencionados modifiquen información de usuarios.
  - **Autenticación**: Esto implica verificar la identidad del usuario para asegurar que esté autorizado para usar el sistema.
  - **Autorización**: Este es el proceso de determinar qué acciones pueden realizar los usuarios autenticados o a qué partes del sistema tienen permitido acceder.
  - **Disponibilidad**: Esto asegura que la información y los servicios estén disponibles para usuarios autorizados cuando los necesiten.
  - **No Repudio**: Esto asegura que tanto el remitente como el destinatario tengan pruebas de entrega y verificación de la identidad del remitente. Protege contra el remitente negando haber enviado la información.
- **Amenazas Comunes de Seguridad**:
  - **XSS (Cross-Site Scripting)**: Los ataques XSS ocurren cuando un atacante inyecta scripts maliciosos en una página web y luego los ejecuta en el contexto del navegador de la víctima.
  - **Inyección SQL**: La inyección SQL permite a usuarios malintencionados inyectar código malicioso en una base de datos.
  - **Denegación de Servicio (DoS)**: Un ataque DoS ocurre cuando usuarios malintencionados inundan un sitio web con un alto número de solicitudes o tráfico, haciendo que el servidor se ralentice o colapse y el sitio no esté disponible para los usuarios.
- **Categorías de Herramientas de Pruebas de Seguridad**:
  - **Pruebas de Seguridad de Aplicaciones Estáticas**: Estas herramientas evalúan el código fuente de una aplicación para identificar vulnerabilidades de seguridad.
  - **Pruebas de Seguridad de Aplicaciones Dinámicas**: Estas herramientas interactúan con el frontend de la aplicación para descubrir potenciales debilidades de seguridad. Las herramientas DAST no tienen acceso al código fuente.
- **Pruebas de Penetración (pentest)**: Las pruebas de penetración son un tipo de pruebas de seguridad que implican crear ataques cibernéticos simulados en la aplicación para identificar vulnerabilidades en el sistema.

## Pruebas A/B

- **Pruebas A/B**: Las pruebas A/B implican comparar dos versiones de una página o aplicación y estudiar cuál versión desempeña mejor. También se le conoce como pruebas de cubeta o división. Las pruebas A/B te permiten tomar decisiones más basadas en datos y mejorar continuamente la experiencia del usuario.
- **Herramientas para Pruebas A/B**: Ejemplos de herramientas para usar en pruebas A/B incluyen GrowthBook y LaunchDarkly.

## Pruebas Alfa y Beta

Una vez que se completa el desarrollo inicial y las pruebas de software, es importante que la aplicación sea probada por evaluadores y usuarios reales. Es aquí donde entran las pruebas alfa y beta.

- **Pruebas Alfa**: Las pruebas alfa son realizadas por un grupo selecto de evaluadores que revisan la aplicación para garantizar que no haya errores antes de ser lanzada al mercado. Las pruebas alfa son parte de las pruebas de aceptación e implementan técnicas de caja blanca y caja negra.
- **Pruebas Beta**: Las pruebas beta son donde la aplicación se pone a disposición de usuarios reales. Los usuarios pueden interactuar con la aplicación y proporcionar retroalimentación. Las pruebas beta también son una forma de pruebas de aceptación por parte del usuario.
- **Pruebas de Aceptación**: Las pruebas de aceptación aseguran que la aplicación de software cumpla con los requisitos comerciales y las necesidades de los usuarios antes de su lanzamiento.
- **Pruebas de Caja Negra**: Las pruebas de caja negra solo se centran en el comportamiento esperado de la aplicación.
- **Pruebas de Caja Blanca**: Las pruebas de caja blanca implican que el evaluador conoce los componentes internos y realiza pruebas sobre ellos.

## Pruebas de Regresión

- **Regresión**: La regresión se refiere a situaciones donde cambios nuevos rompen involuntariamente la funcionalidad existente.
- **Pruebas de Regresión**: Las pruebas de regresión ayudan a identificar problemas de regresión. En las pruebas de regresión, vuelves a ejecutar pruebas funcionales en partes de tu aplicación para garantizar que todo sigue funcionando como se esperaba.
- **Herramientas para Pruebas de Regresión**: Las herramientas que puedes usar para realizar pruebas de regresión incluyen Puppeteer, Playwright, Selenium y Cypress.
- **Técnicas para Pruebas de Regresión**:
  - **Pruebas de regresión unitaria**: Esta es una lista de elementos que deben ser probados cada vez que se implementan cambios o correcciones importantes en la aplicación.
  - **Pruebas de regresión parcial**: Esto implica enfoques dirigidos para garantizar que los nuevos cambios no hayan roto aspectos específicos de la aplicación.
  - **Pruebas de regresión completa**: Esto ejecuta pruebas en todas las funcionalidades del código base. Esta es la opción más detallada y consume más tiempo.
- **Repruebas**: Se emplea para verificar problemas conocidos y asegurar que se hayan resuelto. Por el contrario, las pruebas de regresión buscan problemas desconocidos que podrían haber ocurrido debido a cambios recientes en el código base.

# --assignment--

Revise los temas y conceptos de pruebas.
