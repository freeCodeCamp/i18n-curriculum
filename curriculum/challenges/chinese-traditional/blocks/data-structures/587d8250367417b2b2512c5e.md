---
id: 587d8250367417b2b2512c5e
title: 了解堆疊的運作方式
challengeType: 1
forumTopicId: 301705
dashedName: learn-how-a-stack-works
---

# --description--

你大概熟悉桌上那堆書。你很可能用過文字編輯器的復原特性。你也大概習慣按手機上的返回鍵，回到應用程式的上一個畫面。

你知道它們有什麼共同點嗎？它們都以一種方式儲存資料，讓你可以向後巡訪。

堆疊頂端的書是最後放上去的那本。如果你從堆疊頂端移除那本書，你會看到在最後一本書之前放上去的書，依此類推。

如果你仔細想想，在上述所有範例中，你得到的是 <dfn>Last-In-First-Out</dfn> 型別的服務。我們將嘗試用我們的程式碼來模擬這個。

這個資料儲存結構綱目稱為 <dfn>Stack</dfn>。特別是，我們必須實作 `push()` 方法，將 JavaScript 物件推入堆疊頂端；以及 `pop()` 方法，移除目前位於堆疊頂端的 JavaScript 物件。

# --instructions--

這裡我們有一個以陣列表現的作業堆疊：`"BIO12"` 在底部，而 `"PSY44"` 在堆疊頂端。

修改給定的陣列並使用上述 JavaScript 方法將其視為 `stack`。從堆疊中移除頂端元素 `"PSY44"`。然後將 `"CS50"` 添加為堆疊的新頂端元素。

# --hints--

`homeworkStack` 應該只包含 4 個元素。

```js
assert(homeworkStack.length === 4);
```

`homeworkStack` 中的最後一個元素應該是 `"CS50"`。

```js
assert(homeworkStack[3] === 'CS50');
```

`homeworkStack` 不應包含 `"PSY44"`。

```js
assert(homeworkStack.indexOf('PSY44') === -1);
```

`homeworkStack` 的初始宣告不應該被更改。

```js
assert(
  __helpers.removeJSComments(code).match(/=/g).length === 1 &&
    /homeworkStack\s*=\s*\["BIO12"\s*,\s*"HIS80"\s*,\s*"MAT122"\s*,\s*"PSY44"\]/.test(
      __helpers.removeJSComments(code)
    )
);
```

# --seed--

## --seed-contents--

```js
var homeworkStack = ["BIO12","HIS80","MAT122","PSY44"];
// Only change code below this line
```

# --solutions--

```js
// solution required
```
