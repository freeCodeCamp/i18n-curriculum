---
id: 6724e2dbf723fe1c8883cc69
title: 前端库回顾
challengeType: 31
dashedName: review-front-end-libraries
---

# --description--

## JavaScript 库和框架

- JavaScript 库和框架通过提供预构建的代码，为常见问题提供快速方案并加快开发速度。
- 库通常更专注于为特定任务提供方案，例如操作 DOM、处理事件或管理 AJAX 请求。
- 几个 JavaScript 库的例子是 jQuery 和 React。
- 框架则为创建应用提供了更明确的结构。它们通常随附一套开发者需要遵循的规则和约定。
- 框架的例子包括 Angular 和 Next.js，后者是 React 的元框架。
- **单页应用**（SPAs）是装载单个超文本标记语言页面并在用户与应用交互时动态更新该页面而无需重新加载整个页面的网页应用。
- SPA 使用 JavaScript 来管理应用的状态和渲染内容。这通常通过提供构建复杂用户界面强大工具的框架来完成。
- 关于 SPA 的一些问题包括：

  - 屏幕阅读器难以处理动态更新的内容。
  - 当用户在应用内导航时，URL 不会改变，这可能导致难以收藏、回溯或分享特定页面。
  - 如果应用较大，初始装载时间可能较慢，因为所有资源都需要预先装载。

## React

- React 是一个流行的 JavaScript 库，用于创建用户界面和网页应用。
- React 的一个核心概念是创建可重用的 UI 组件，这些组件可以在数据变化时独立更新和渲染。
- React 允许开发者根据应用状态描述 UI 应该如何呈现。当数据或状态发生变化时，React 会更新并渲染正确的组件。

## React 组件

- 组件是 React 应用的创建块，允许开发者将复杂的用户界面拆分成更小、更易管理的部分。
- UI 使用 JSX 描述，JSX 是 JavaScript 语法的扩展名，允许开发者在 JavaScript 中编写类似超文本标记语言的代码。
- 组件基本上是返回一部分 UI 的 JS 函数或类。

下面是一个简单的 React 组件示例，它渲染一个问候消息：

```jsx
function Greeting() {
  const name = 'Anna';
  return <h1>Welcome, {name}!</h1>;
}
```

要使用该组件，你只需调用：
    
```jsx
  <Greeting />
```

## 导入和导出 React 组件

- React 组件可以从一个文件导出并导入到另一个文件。
- 假设你有一个名为 `City` 的组件，位于名为 `City.js` 的文件中。你可以使用 `export` 关键字导出该组件：

```jsx
// City.js
function City() {
  return <p>New York</p>;
}

export default City;
```

- 要将 `City` 组件导入到另一个文件中，你可以使用 `import` 关键字：

```jsx
// App.js
import City from './City';

function App() {
  return (
    <div>
      <h1>My favorite city is:</h1>
      <City />
    </div>
  );
}
```

- `default` 关键字被使用，因为它是来自 `City.js` 文件的默认导出。

- 你也可以选择在组件定义的同一行导出该组件，如下所示：

```jsx
export default function City() {
  return <p>New York</p>;
}
```

## 使用 Vite 设置 React 项目

- 项目设置工具和 CLI 提供了一种快速简便的方式来开始新建项目，使开发者能够专注于编写代码，而不是处理配置。
- Vite 是一个流行的项目搭建工具，可以与 React 一起使用。
- 要使用 Vite 创建一个新建项目，你可以在终端中使用以下命令：

```bash
npm create vite@latest my-react-app -- --template react
```

此命令使用 Vite 的 React 模板创建一个名为 `my-react-app` 的新 React 项目。在项目目录中，你将看到一个包含项目依赖项和命令列表的 `package.json` 文件。

- 要运行项目，请导航到项目目录并运行以下命令：

```bash
cd my-react-app # path to the project directory
npm install # installs the dependencies listed in the package.json file
```

- 依赖安装完成后，你应该会在你的项目中看到一个名为 `node_modules` 的新文件夹。

- `node_modules` 文件夹是存放你的项目所需的所有包和库的地方。

- 要运行你的项目，请使用以下命令：

```bash
npm run dev
```

- 之后，打开你的浏览器并导航到 `http://localhost:5173` 以查看你的 React 应用正在运行。

- 要实际查看启动模板的代码，你可以进入你的项目中的 `src` 文件夹，应该能看到 `App.jsx` 文件。

## 在 React 组件中传递 props

- 在 React 中，props（属性的缩写）是一种将数据从父组件传递到子组件的方式。此机制用于创建可重用且动态的 UI 元素。
- Props 可以是任何 JavaScript 值。要将 props 从父组件传递给子组件，你需要在父组件的 JSX 中使用子组件时，将 props 作为属性添加。下面是一个简单的例子：

```jsx
// Parent component
function Parent() {
  const name = 'Anna';
  return <Child name={name} />;
}

// Child component
function Child(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

你可以在将它们转换为对象后，使用展开操作符 `(...)` 传递多个 props。以下是一个示例：
    
```jsx
// Parent component
function Parent() {
  const person = {
    name: 'Anna',
    age: 25,
    city: 'New York'
  };
  return <Child {...person} />;
}
```

在这段代码中，展开操作符 `{...person}` 将 person 对象转换为传递给 Child 组件的单个属性。

## React 中的条件式渲染

- React 中的条件式渲染允许你创建动态用户界面。它用于根据你的应用中的某些条件或状态显示不同的内容。
- 在 React 中有多种方法可以条件式渲染内容。一种常见的方法是使用三元操作符。下面是一个示例：

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please log in</h1>}
    </div>
  );
}
```

- 另一种条件式渲染内容的方法是使用逻辑 AND (`&&`) 操作符。当你只想在满足某个条件时渲染内容时，这非常有用。下面是一个示例：

```jsx
function Greeting({ user }) {
  return (
    <div>
      {user && <h1>Welcome, {user.name}!</h1>}
    </div>
  );
}
```

在上面的代码中，只有当 `user` 对象为真值时才渲染 `h1` 元素。

你也可以这样使用直接的 `if` 语句：

```js
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  }
  return <h1>Please sign in</h1>;
}
```

## 在 React 中渲染列表

- 在 React 中渲染列表是创建用户界面时的常见任务。
- 列表可以使用 JS 数组的 `map()` 方法来迭代数组项并返回一个新的 JSX 元素数组。
- 例如，如果你有一个名字的数组，想将其渲染为列表，你可以执行以下操作：

```jsx
function NameList({ names }) {
  return (
    <ul>
      {names.map((name, index) => (
        <li key={`${name}-${index}`}>{name}</li>
      ))}
    </ul>
  );
}
```

- 始终记得为每个列表项提供唯一的 `Key`，以帮助 React 管理更新和渲染的职责。通过这些技术，你可以在你的 React 应用中创建灵活、高效且动态的列表。

## React 中的内联样式

- React 中的内联样式允许你使用 JavaScript 对象直接为 JSX 元素应用 CSS 样式。
- 要在 React 中应用内联样式，你可以在 JSX 元素上使用 style 属性。style 属性接受一个对象，其中的密钥是驼峰式大小写的 CSS 属性，值是对应的值。下面是一个示例：

```js
function Greeting() {
  return (
    <h1
      style={{ color: 'blue', fontSize: '24px', backgroundColor: 'lightgray' }}
    >
      Hello, world!
    </h1>
  );
}

export default Greeting;
```

你也可以将样式提取到一个单独的对象中，并以这种方式在 `style` 属性中引用它：

```jsx
function Greeting() {

  const styles = {
    color: 'blue',
    fontSize: '24px',
    backgroundColor: 'lightgray'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- 内联样式通过允许你基于 props 或 state 条件式地应用样式来支持动态样式。以下是如何基于 prop 条件式地应用样式的示例：

```jsx
function Greeting({ isImportant }) {

  const styles = {
    color: isImportant ? 'red' : 'black',
    fontSize: isImportant ? '24px' : '16px'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- 在上面的代码中，`color` 和 `fontSize` 样式根据 `isImportant` 属性有条件地设置。

## 在 React 中使用事件

- **合成事件系统**：这是 React 处理事件的方式。它作为本地事件（如 `click`、`keydown` 和 `submit` 事件）的包装器。React 中的事件处理器使用驼峰命名法。（例如 `onClick`、`onSubmit` 等）

下面是一个在 React 中为 `button` 元素使用 `onClick` 属性的示例：

```jsx
function handleClick() {
  console.log("Button clicked!");
}

<button onClick={handleClick}>Click Me</button>;
```

在 React 中，事件处理器函数通常以前缀 `handle` 开头，以表示它们负责处理事件，例如 `handleClick` 或 `handleSubmit`。

当用户操作触发一个事件时，React 会将一个合成事件对象传递给你的处理器。该对象的行为类似于原生 JavaScript 中的本地事件对象，提供诸如 `type`、`target` 和 `currentTarget` 等属性。

为了防止诸如浏览器刷新之类的默认行为（例如在 `onSubmit` 事件期间），你可以调用 `preventDefault()` 方法：

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("Form submitted!");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>Submit</button>
</form>;
```

你也可以像这样用箭头函数包裹一个处理器函数：

```jsx
function handleDelete(id) {
  console.log("Deleting item:", id);
}

<button onClick={() => handleDelete(1)}>Delete Item</button>;
```

## 使用状态和 `useState` Hook

- **状态的定义**：在 React 中，状态是包含组件数据的对象。当状态更新时，组件将重新渲染。React 将状态视为不可变的，这意味着你不应直接修改它。
- **`useState()` Hook**：`useState` hook 是一个允许你在函数组件中声明状态变量的函数。以下是基本语法：

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

在状态变量中你有以下内容：

- `stateVariable` 保存当前状态值
- `setStateFunction`（设置函数）更新状态变量
- `initialValue` 设置初始状态

这是一个完整的 `Counter` 组件示例：

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

## 渲染和 React 组件

- **定义**：在 React 中，渲染是组件出现在用户界面（UI）中的进程，通常是浏览器。渲染进程包括三个阶段：触发器、渲染和提交。

触发器阶段发生在 React 检测到某些内容已更改且用户界面（UI）可能需要更新时。此更改通常是由于状态或 props 的更新引起的。

一旦触发器发生，React 就进入渲染阶段。在这里，React 会重新评估你的组件并确定要显示的内容。为此，React 使用了一个称为虚拟 DOM 的“真实” DOM 的轻量级拷贝。通过虚拟 DOM，React 可以快速查看组件中需要更改的内容。

提交阶段是 React 从虚拟 DOM 获取准备好的更改并将其应用到真实 DOM 的阶段。换句话说，这个阶段是你在屏幕上看到最终结果的阶段。

## 更新状态中的对象和数组

- **更新状态中的对象**：如果你需要更新状态中的对象，那么你应该先构造一个新对象或拷贝一个已有对象，然后为该新对象设置状态。任何放入状态中的对象都应被视为只读。下面是设置用户的姓名、年龄和城市的示例。`handleChange` 函数用于处理用户信息的更新：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **更新状态中的数组**：在更新状态中的数组时，重要的是不要使用 `push()` 或 `pop()` 等方法直接修改数组。相反，更新状态时应创建一个新数组：

```jsx
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

如果你想从数组中移除项，你应该使用 `filter()` 方法，该方法会在过滤掉你想移除的内容后返回一个新数组：

```jsx
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## 使用 Refs 参考值

- **`ref` 属性**：你可以通过使用 `ref` 属性来访问 React 中的 DOM 节点。下面是一个示例，展示如何使用 `ref` 来聚焦一个 `input` 元素。`current` 属性用于访问该 `ref` 的当前值：

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Focus;
```

## 使用 `useEffect` Hook

- **`useEffect()` Hook**：在 React 中，效果是指发生在组件渲染过程之外的任何事情。也就是说，任何 React 不直接作为渲染 UI 一部分处理的内容。常见的例子包括获取数据、更新浏览器标签（页）的标题、从浏览器的局部存储读取或写入数据、获取用户的位置等等。这些操作与外部世界交互，被称为副作用。React 提供了 `useEffect` hook 来让你处理这些副作用。`useEffect` 允许你在组件渲染或更新后运行一个函数。

```js
import { useEffect } from "react";

useEffect(() => {
 // Your side effect logic (usually a function) goes here
}, [dependencies]);
```

效果函数在组件渲染后运行，而可选的 `dependencies` 参数控制效果的运行时机。

请注意，`dependencies` 可以是一个包含“响应式值”（状态、属性、函数、变量等）的数组、一个空数组，或者完全省略。以下是所有这些选项如何控制 `useEffect` 的工作方式：

- 如果 `dependencies` 是包含一个或多个响应式值的数组，则每当它们变化时，效果将运行。

- 如果 `dependencies` 是一个空数组，`useEffect` 只会在组件首次渲染时运行一次。

- 如果你省略 `dependencies`，该效果将在组件每次渲染或更新时运行。

## 如何创建自定义 Hooks

- **自定义 Hooks**：自定义 hook 允许你从组件中提取可重用的逻辑，例如数据获取、状态管理、切换以及跟踪在线状态等副作用。在 React 中，所有内置 hook 都以 `use` 开头，因此你的自定义 hook 也应遵循相同的命名规范。

下面是创建 `useDebounce` 钩子的示例：

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

## 在 React 中使用 Forms

- **受控输入**：这是指你将输入字段的值保存在状态中，并通过 `onChange` 事件进行更新。这使你能够完全控制形式数据，并允许即时验证和条件式渲染。

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form>
    </>
  );
}

export default App;
```

- **非受控输入**：非通过 `useState` 钩子处理输入，HTML 中的非受控输入借助 DOM 维护其自身的内部状态。由于 DOM 控制输入值，你需要通过 `ref` 获取输入字段的值。

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">Your</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">Submit</button>
   </form>
 );
}

export default App;
```

## 使用 `useActionState` Hook

- **服务器操作**：这些是在服务器上运行的函数，允许直接在服务器上处理形式，而无需 API 端点。以下是来自 Next.js 应用的示例：

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `Hello, ${name}!` };
}
```

`"use server"` 指令将函数标记为服务器操作。

- **`useActionState` Hook**：此 hook 根据表单提交的结果更新状态。以下是 `useActionState` hook 的基本语法：

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` 是动作返回的当前状态。
- `action` 是触发服务器操作的函数。
- `isPending` 是一个布尔值，表示该操作当前是否正在运行。
- `actionFunction` 参数就是服务器操作本身。
- `initialState` 是表现动作运行前状态起点的参数。
- `permalink` 是一个可选的字串，包含该形式修改的唯一页面链接。

## React 中的数据获取

- **获取数据的选项**：在 React 中有许多不同的方法来获取数据。你可以使用本地的 Fetch API，或者第三方工具如 Axios 或 SWR。
- **获取数据时常用的状态变量**：无论你选择哪种方式在 React 中获取你的数据，都需要跟踪一些状态。第一个是数据本身。第二个用于跟踪数据是否仍在被获取。第三个是一个状态变量，用于捕捉在数据获取进程中可能发生的任何误差。

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

由于获取数据是一个副作用，最好在 `useEffect` 钩子内使用 `Fetch API`。

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      
      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

然后，如果数据获取未完成，你可以渲染一个加载消息；如果获取数据时出现误差，你可以渲染一个错误信息；或者渲染结果。

```jsx
if (loading) {
  return <p>Loading...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

如果你想使用 Axios，你需要安装并导入它：

```bash
npm i axios
```

```js
import axios from "axios";
```

然后你可以使用 `axios.get` 获取数据：

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

要使用 `useSWR` 钩子获取数据，你需要先安装并导入它。

```bash
npm i swr
```

```js
import useSWR from "swr";
```

以下是你如何使用该钩子来获取数据的方法：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>Loading...</h2>;
 }
 if (error) {
   return <h2>Error: {error.message}</h2>;
 }

 return (
   <>
     <h2>Todos</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## 使用 `useOptimistic` Hook

- **`useOptimistic` Hook**：此 Hook 用于在等待异步操作在后台完成时保持界面响应。它有助于管理界面中的“乐观更新”，这是一种基于操作预期结果（例如等待服务器响应）立即更新界面的策略。

这是基本语法：

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` 是一种临时状态，会立即更新以提供更好的用户体验。
- `addOptimistic` 是在实际状态更改之前应用乐观更新的函数。
- `actualState` 是来自某个操作结果的真实状态值，比如从服务器获取数据。
- `updateFunction` 是确定在调用时乐观状态应如何更新的函数。

下面是一个在 `TaskList` 组件中使用 `useOptimistic` 钩子的示例：

```js
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**：用于渲染部分 UI 并将状态更新标记为非紧急过渡。这允许 UI 在耗时更新期间保持响应。基本语法如下：

```js
startTransition(action)
```

`action` 执行状态更新或触发某些与转换相关的逻辑。这确保了紧急的 UI 更新（如类型指派或点击）不会被阻塞。

## 使用 `useMemo` Hook

- **记忆化**：这是一种优化技术，其中基于特定参数缓存（记住）昂贵函数调用的结果。当再次提供相同参数时，将返回缓存的结果，而不是重新计算函数。
- **`useMemo` Hook**：此 Hook 用于缓存计算值。以下是缓存排序大型数组结果的示例。只有当 `largeArray` 发生变化时，`expensiveSortFunction` 才会运行：

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## 使用 `useCallback` Hook

- **`useCallback` Hook**：用于缓存函数引用。

```js
const handleClick = useCallback(() => {
 // code goes here
}, [dependency]);
``` 

- **`React.memo`**：用于缓存组件，以防止在其 prop 未改变时发生不必要的重新渲染。

```js
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* Presentation */}
   </>
 )
});
``` 

## 依赖管理工具

- **依赖定义**：在软件中，依赖是指应用中的一个组件或模块依赖另一个组件或模块才能正常运行。依赖在软件应用中很常见，因为它们允许开发者使用他人创建的预构建函数或工具。React 项目所需的两个核心依赖将是 `react` 和 `react-dom` 包：

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **包管理器定义**：要管理项目中的软件依赖，你需要使用包管理器。包管理器是一种用于安装、更新和移除依赖的工具。许多流行的编程语言如 JavaScript、Python、Ruby 和 Java 都使用包管理器。JavaScript 的流行包管理器包括 npm、Yarn 和 pnpm。
- **`package.json` 文件**：这是项目中的一个关键配置文件，包含有关你的项目的元数据，包括其名称、版本和依赖项。它还定义了脚本、许可信息以及帮助管理项目及其依赖项的其他设置。
- **`package-lock.json` 文件**：此文件将锁定你的项目正在使用的所有包的确切版本。当你更新包时，锁定文件中的新版本也会被更新。
- **`node_modules` 文件夹**：此文件夹包含你 `package.json` 文件中列出的依赖项的实际代码，包括你项目的直接依赖项及这些依赖项的任何依赖项。
- **开发依赖**：这些是仅用于开发而非生产环境的包。一个例子是像 Jest 这样的测试库。你会将 Jest 安装为开发依赖，因为它用于在局部测试你的应用，但在生产环境中运行应用时不需要。

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **介绍**：React Router 是一个第三方库，允许你为你的 React 应用添加路由。要开始，你需要在现有的 React 项目中安装 React Router，方法如下：

```bash
npm i react-router
```

然后在 `main.jsx` 或 `index.jsx` 文件中，你需要像这样设置路由结构：

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

`path` 和 `element` 用于将 URL 和 UI 组件绑定在一起。在这个分支中，我们正在为指向 `App` 组件的主页设置路由。 

- **多个视图和路由设置**：在较大的应用中，通常会像这样设置多个视图和路由：

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

这些示例中的 `index` 属性用于表现给定路径段的默认路由。因此，`Home` 组件将在根路径 `/` 显示，而 `ProductsHome` 组件将在 `/products` 路径显示。

- **嵌套路由**：你可以将路由嵌套在其他路由内，这会导致子路由的路径被追加到父路由的路径中。

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

在上面的示例中，热门产品的路径将是 products/trending。

- **动态段**：动态段是指 URL `path` 中的任何部分是动态的。

```jsx
<Route path=":category" element={<Category />} />
```

在此示例中，我们有一个名为 `category` 的动态段。当用户导航到类似 products/brass-instruments 的 URL 时，视图将切换到 `Category` 组件，你可以根据该段动态获取相应的数据。

- **`useParams` Hook**：此 Hook 用于访问 URL 路径中的动态参数。

```js
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
   {/* Accessing the category param: params.category */}
   {/* rest of code goes here */}
}
```

## React 框架

- **介绍**：React 框架提供路由、图像优化、数据获取、认证等特色。这意味着在某些用例中，你可能不需要设置单独的前端和后端应用。React 框架的示例包括 Next.js 和 Remix。
- **Next.js 路由**：该路由系统包括对动态路由、并行路由、路由处理程序、重定向、国际化等的支持。

下面是创建自定义请求处理器的示例：

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Next.js 图像优化**：`Image` 组件扩展了本地的超文本标记语言 `img` 元素，允许更快的页面装载和大小优化。这意味着图像只有在进入视图时才会装载，且 `Image` 组件会自动为每个设备提供正确尺寸的图像。

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
``` 

## 属性传递

- **定义**：Prop drilling 是将 props 从父组件传递到深层嵌套子组件的进程，即使某些子组件不需要这些 props。

## 状态管理

- **Context API**：上下文指的是父组件在不需要通过 props 显式传递的情况下，使信息可用于子组件。`createContext` 用于创建一个上下文对象，该对象表现其他组件将要读取的上下文。`Provider` 用于向子组件提供上下文值。

```js
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**：Redux 通过提供一个中央保存和对状态更新的严格控件来处理状态管理。它使用一个可预测的模式，包括 actions、reducers 和 middleware。Actions 是将数据从你的应用发送到 Redux 保存的信息负载，通常由用户交互触发。Reducers 是指定状态应如何响应这些 actions 变化的函数，确保状态以不可变的方式更新。另一方面，middleware 充当 action 分派和 reducer 之间的桥梁，允许你扩展 Redux 的功能性（例如，记录日志、处理异步操作），而无需修改核心流程。

- **Zustand**：这个状态管理方案非常适合中小型应用。它通过使用 `useStore` 钩子直接在组件和页面中访问状态来工作。这样你可以修改和访问数据，而无需使用 actions、reducers 或 provider。

## 使用 React DevTools 调试 React 组件

- **React Developer Tools**：这是一个浏览器扩展（程序、功能），你可以在 Chrome、Firefox 和 Edge 中使用它来检查 React 组件并识别性能问题。对于 Safari，你需要安装 `react-devtools` npm 包。安装 React DevTools 并在浏览器中打开 React 应用后，打开浏览器开发者工具以访问为调试 React 提供的两个额外标签（页）——Components 和 Profiler。
- **组件标签（页）**：此标签（页）以树状视图格式显示每个组件。你可以在此标签（页）中执行以下操作：
  - 查看应用的组件层次结构
  - 实时查看和修改 props、states 和 context 值
  - 查看每个选定组件的源代码
  - 将组件数据记录到控制台
  - 检查组件的 DOM 元素
- **Profiler 标签（页）**：此标签（页）帮助你分析组件性能。你可以记录组件性能，以便识别不必要的重新渲染，查看提交持续时间，进而优化缓慢的组件。

## React 服务器组件

- **定义**：React 服务器端组件是仅在服务器上渲染的 React 组件，只将最终的 HTML 发送到客户。这意味着这些组件可以直接访问服务器端资源，并大幅减少发送到浏览器的 JavaScript 数量。

## 真实性能与感知性能之间的差异

- **感知性能**：这是用户对网站性能的感知。它是用户根据响应速度和可靠性对网站进行的评估。这是一种主观的衡量标准，因此很难量化，但非常重要，因为用户体验决定了网站的成败。
- **真实性能**：这是网站的客观且可测量的性能。它通过页面装载时间、服务器响应时间和渲染时间等指标来衡量。这些测量受多个与网络和代码本身相关的因素影响。

## 提升感知性能的技术

- **惰性装载**：这种技术通过在后台装载非必要资源，尽可能减少初始装载时间。
- **最小化字体延迟**：如果你的网站有自定义字体，你也应该尽量最小化字体装载延迟，因为这可能导致闪烁或在自定义字体装载时显示备用字体。一个建议是使用与自定义字体相似的备用字体，这样如果发生这种情况，变化会更为细微。
- **加载指示器的使用**：当用户点击一个元素后立即显示长时间运行进程的加载指示器，可以帮助用户感受到与进程的连接和参与，使等待时间感觉更短。

## 核心性能概念

- **源顺序**：这指的是 HTML 元素在文档中的结构方式。这决定了什么先装载，并且会显著影响性能和无障碍。

源顺序的一些最佳实践包括：

- 将关键内容（例如标题、导航或主要文本）放置在 `HTML` 结构的更高位置。
- 推迟非必要的脚本，例如用于分析的脚本或第三方小部件，以免它们阻塞渲染。
- 使用渐进增强，确保核心体验即使在样式和脚本装载之前也能正常工作。渐进增强是一种基于先使页面使用超文本标记语言正常工作的理念来创建网站和应用的方法。

这是一个良好源顺序的示例，使用了我们刚刚讲解的最佳实践：

```html
<h1>Welcome to FastSite!</h1>
<p>Critical information loads first.</p>
<script src="slow-script.js" defer></script>
```

- **关键渲染路径**：这是浏览器将代码转换为屏幕上像素所遵循的序列步骤。
- **延迟**：这是一个 `request` 在浏览器和 `server` 之间传输所需的时间。换句话说，延迟高意味着页面加载缓慢。

减少延迟的一些方法包括：

- 使用 CDN，或内容分发网络，从更近的位置提供文件。
- 使用诸如 Gzip 等工具启用压缩以减小文件大小。
- 优化图像并使用惰性装载。

```html
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
```

## 提升 INP

- **定义**：INP（Interaction to Next Paint）通过测量用户交互（如点击或按键）到浏览器下一次更新显示之间的时间，评估页面的整体响应性。INP 越低表示页面响应越快。

以下是一些提升 INP 的方法：

- 通过拆分长时间的 JavaScript 任务来减少主线程工作量。
- 为非关键脚本使用 `requestIdleCallback()`。这将把一个函数添加到浏览器闲置期间调用的队列中。
- 推迟或惰性装载之前提到的重资产。
- 优化事件处理器。如果这些处理器运行过于频繁或执行繁重的操作，会导致页面变慢并增加 INP。解决方案是防抖。防抖确保函数仅在用户停止输入后经过短暂延迟（例如 300 毫秒）才运行。这可以防止不必要的计算并提升性能。

## 浏览器中渲染的工作原理

- **渲染的工作原理**：首先，浏览器解析 `HTML` 并构建 `DOM`。接着，浏览器处理 `CSS`，构造 `CSS Object Model`，或称 `CSSOM`。这是另一个树结构，用于决定元素应如何被样式化。最后，浏览器将像素绘制到屏幕上，根据计算出的样式和版型渲染每个元素。在复杂页面中，这可能涉及多个图层的合成，以形成最终的视觉输出。

## 性能如何影响可持续性

- **背景简介**：互联网约占全球碳排放的 2％——这与航空业相同！每个传输的字节都需要电力，从数据中心到用户设备。更大的文件和低效的脚本意味着更多的能耗。高性能的网站不仅更快，还能减少不必要的处理和能源使用。

## 减少页面装载时间的方法

- **优化媒体资源**：大型图像和视频是导致加载缓慢的常见原因。通过优化这些资源，你可以显著加快你的网站速度。这包括压缩图像、使用像 WebP 这样的现代形式以及为资源使用惰性装载。
- **杠杆浏览器缓存**：缓存允许浏览器将你网站的部分内容局部地保存，减少回访用户的装载时间。
- **压缩和压缩文件**：减小你的文件大小可以加快下载速度。这包括减小传输文件的大小以及压缩 CSS 和 JavaScript 文件。

## 提升 `"time to usable"`

- **定义**：“time to usable” 是指用户请求页面到他们能够有意义地与之交互之间的时间间隔。为了改善 “time to usable”，你可以惰性装载你的资源或最小化阻塞渲染的资源。

## 用于衡量性能的关键指标

- **首次内容绘制或 FCP**：它衡量第一个内容——文本或图像——在屏幕上出现的速度。良好的 FCP 被认为是在 1.8 秒以下，较差的 FCP 则超过 3 秒。你可以使用 Chrome DevTools 并查看性能标签（页）来查看你的 FCP。
- **总阻塞时间**：这显示主线程被繁重的 JavaScript 任务阻塞了多长时间。如果总阻塞时间（TBT）较高，用户会感受到交互迟缓。为改善 TBT，请拆分长任务并推迟非必要的脚本。
- **弹跳率**：这是指访问者在没有任何互动的情况下离开的百分比。如果你的网站弹跳率很高，可能是因为你的页面太慢。
- **独立用户**：此指标跟踪访问你网站的独立访客数量。要查看 `Bounce Rate` 和 `Unique Users`，你可以使用 Google Analytics。它将允许你监控这些指标并提升参与度。

## 常用性能测量工具

- **Chrome DevTools**：Chrome DevTools 是 Google Chrome 内置的工具，允许你实时分析和调试性能。DevTools 会显示装载时间、CPU 使用率和渲染延迟。它对于测量首次内容绘制（First Contentful Paint，简称 FCP）特别有用，FCP 是用户看到第一个可见内容的速度。如果你的网站感觉缓慢，DevTools 会帮助你发现瓶颈。
- **Lighthouse**：这是一个自动化工具，用于查看性能、SEO 和无障碍。
- **WebPageTest**：该工具允许你测试你的网站从不同地点和设备的装载情况。该工具为你提供你的网站的 Speed Index、Total Blocking Time 及其他关键性能指标的详细分解。如果你想了解真实用户在全球范围内如何体验你的网站，WebPageTest 是适合你的工具。
- **PageSpeed Insights**：该工具分析你的网站，并为移动和桌面提供快速改进建议。它会告诉你是什么拖慢了你的网站，并给出具体建议，如优化图像、移除阻塞渲染的脚本以及减少服务器响应时间。PageSpeed Insights 是查看 Google 如何看待你网站性能的快速简便方法。
- **真实用户监控**：RUM 工具跟踪实际用户行为，展示真实访客如何体验你的网站。流行的 RUM 工具包括 Google Analytics，它跟踪页面装载时间和弹跳率，以及 New Relic 或 Datadog，它们监控实时性能问题。如果你想获得来自实际用户的数据，RUM 工具是必不可少的。

## 使用 Performance Web APIs

- **定义**：性能 Web API 让开发者能够直接在代码中跟踪网页装载和响应的高效性。这些 API 允许你测量页面装载时间、跟踪渲染和交互延迟以及分析 JavaScript 执行时间。
- **`performance.now()`**：此 API 为你提供高查准率的时间戳（以毫秒为单位），用于测量你网站不同部分的装载时间。

```js
const start = performance.now();  
// Run some code here  
const end = performance.now();  

console.log(`Execution time: ${end - start}ms`);
```

- **性能 Timing API**：此 API 为你提供页面装载每个阶段的详细信息，从 DNS 查询到 `DOMContentLoaded`。

```js
const timing = performance.timing;  

const pageLoadTime = timing.loadEventEnd - timing.navigationStart;  
console.log(`Page load time: ${pageLoadTime}ms`);
```

- **`PerformanceObserver`**：此 API 监听诸如版型移动、长任务和用户交互等性能事件。

```js
const observer = new PerformanceObserver((list) => {  
  list.getEntries().forEach((entry) => {  
    console.log(`Long task detected: ${entry.duration}ms`);  
  });  
});  

observer.observe({ type: "longtask", buffered: true });
```

## 提升 CSS 性能的技术

- **CSS 动画**：对某些 CSS 属性（例如维度、位置和版型）进行动画处理会触发一个称为“reflow”的进程，在此过程中浏览器会重新计算页面上某些元素的位置和几何形状。这需要重绘，计算开销很大。因此，建议尽可能减少 CSS 动画的数量，或者至少为用户提供一个选项来切换它们的开关。

## 提升 JavaScript 性能的技术

- **代码拆分**：将你的 JavaScript 代码拆分成执行关键任务和非关键任务的模块也很有帮助。这样，你就能尽快预装载关键模块，并推迟非关键模块，以尽可能快地渲染页面。
- **DOM 操作**：请记住，DOM 操作是指通过与文档对象模型（DOM）交互，使用 JavaScript 动态更改页面内容的过程。操作 DOM 的计算开销很大。通过减少你的 JavaScript 代码中的 DOM 操作量，将提升性能。

## CSS 框架

- **CSS 框架**：CSS 框架可以加快你的工作流程，为整个网站创建统一的视觉风格，使你的设计在多个浏览器中保持一致，并使你的 CSS 代码更加有序。
- **流行的 CSS 框架**：一些流行的 CSS 框架有 Tailwind CSS、Bootstrap、Materialize 和 Foundation。
- **潜在缺点**：
  - 框架提供的 CSS 可能与你的自定义 CSS 冲突。
  - 你的网站可能看起来与使用相同框架的其他网站相似。
  - 大型框架可能导致性能问题。

## 两种类型的 CSS 框架

- **以实用为先的 CSS 框架**：这些框架具有具有特定用途的小类，例如设置边距、内边距或背景颜色。你可以根据需要将这些小类直接赋值给 `HTML` 元素。Tailwind CSS 被归类为以实用为先的 CSS 框架。

这是一个使用 Tailwind CSS 为按钮设置样式的示例。

```html
<button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700">
  Button
</button>
```

- **基于组件的 CSS 框架**：这些框架具有预构建的组件和预定义的样式，你可以将它们添加到你的网站中。组件可在 CSS 框架的官方文档中找到，你可以将它们拷贝并粘贴到你的项目中。Bootstrap 被归类为基于组件的 CSS 框架。

这是使用 Bootstrap 创建列表组的示例。你将为你的超文本标记语言元素添加整个组件，包括超文本标记语言结构，而不是应用小的类。

```html
<div class="card" style="width: 25rem;">
  <ul class="list-group list-group-flush">
    <li class="list-group-item">HTML</li>
    <li class="list-group-item">CSS</li>
    <li class="list-group-item">JavaScript</li>
  </ul>
</div>
```

## Tailwind CSS

Tailwind 是一个以实用工具为先的 CSS 框架。你无需编写自定义 CSS 规则，而是通过直接在你的 HTML 中组合小型实用类来构建设计。

### 响应式设计实用函数

Tailwind 使用诸如 `sm:`、`md:` 和 `lg:` 之类的前缀，在不同的屏幕尺寸上应用样式。

```html
<div class="w-full md:w-1/2 lg:flex-row">
  Responsive layout
</div>
```

### Flexbox 实用函数

像 `flex`、`flex-col`、`justify-around` 和 `items-center` 这样的类使创建灵活的版型变得容易。

```html
<div class="flex flex-col md:flex-row justify-around items-center">
  <p>Column on small screens</p>
  <p>Row on medium and larger screens</p>
</div>
```

### 网格实用函数

Tailwind 包含用于 CSS 网格 的实用函数，比如 `grid`、`grid-cols-1` 和 `md:grid-cols-3`。

```html
<div class="grid grid-cols-1 md:grid-cols-3 gap-8">
  <div class="bg-gray-100 p-4">Column 1</div>
  <div class="bg-gray-100 p-4">Column 2</div>
  <div class="bg-gray-100 p-4">Column 3</div>
</div>
```

### 间距实用函数

实用函数如 `mt-8`、`mx-auto`、`p-4` 和 `gap-4` 帮助创建一致的间距，无需编写 CSS。

```html
<div class="mt-8 p-4 bg-indigo-600 text-white">
  Spaced content
</div>
```

### 排版实用函数

实用函数如 `uppercase`、`font-bold`、`font-semibold` 和 `text-4xl` 控制文本外观。

你可以设置在断点处调整的字体大小，例如 `text-3xl` 和 `md:text-5xl`。

```html
<h1 class="text-3xl md:text-5xl font-semibold text-center">
  Responsive Heading
</h1>
```

### 颜色和悬停状态

Tailwind 提供了丰富的颜色调色板，例如 `text-red-700`、`bg-indigo-600` 和 `bg-gray-100`。

像 `hover:bg-pink-600` 这样的类使交互效果变得简单。

```html
<a href="#" class="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-md">
  Hover Me
</a>
```

### 边框、环和效果

- **边框**：`border-2 border-red-300` 添加具有指定厚度和颜色的边框。
- **Rings**：`ring-1 ring-gray-300` 创建类似轮廓的效果，常用于焦点或卡片。
- **圆角和缩放**：像 `rounded-md`、`rounded-xl` 和 `scale-105` 这样的类添加了精致感。

```html
<div class="p-6 rounded-xl ring-2 ring-fuchsia-500 scale-105">
  Highlighted card
</div>
```

### 梯度

Tailwind 支持像 `bg-gradient-to-r from-fuchsia-500 to-indigo-600` 这样的渐变实用函数。

```html
<div class="p-4 text-white bg-gradient-to-r from-fuchsia-500 to-indigo-600">
  Gradient background
</div>
```

## CSS 预处理器

- **CSS 预处理器**：CSS 预处理器是一种扩展标准 CSS 的工具。它将带有扩展语法的代码编译成本地的 CSS 文件。它有助于为复杂项目编写更简洁、可重用、重复性更少且可扩展的 CSS。
- **特色**：CSS 预处理器可以提供的一些特色包括变量、混入、嵌套和选择器继承。
- **流行的 CSS 预处理器**：一些流行的 CSS 预处理器有 Sass、Less 和 Stylus。
- **潜在缺点**：
  - 将 CSS 规则编译成标准 CSS 可能会导致额外开销。
  - 编译后的代码可能难以调试。

## Sass

- **Sass**：它是最流行的 CSS 预处理器之一。Sass 代表“Syntactically Awesome Style Sheets”。
- **Sass 支持的特色**：Sass 支持变量、嵌套 CSS 规则、模块、混入、继承以及用于基本数学操作的操作符等特色

## Sass 支持的两种语法

- **SCSS 语法**：SCSS（Sassy CSS）扩展了 CSS 的基本语法。它是 Sass 中使用最广泛的语法。SCSS 文件具有 `.scss` 扩展名。

下面是定义和使用 `variable` 在 SCSS 中的示例。

```scss
$primary-color: #3498eb;

header {
  background-color: $primary-color;
}
```

- **缩排语法**：缩排语法是 Sass 的原始语法，也称为“Sass 语法”。

下面是一个在缩排语法中定义和使用变量的示例。

```sass
$primary-color: #3498eb

header
  background-color: $primary-color
```

### 混入（Mixins）

- **Mixins**：Mixins 允许你将多个 CSS 属性及其值组合在一个名称下，并在整个样式表中重用该块 CSS 代码。

下面是使用 SCSS 语法定义 mixin 的示例。在这个分支中，mixin 被称为 `center-flex`。它有三个 CSS 属性，用于使用 flexbox 居中元素。

```scss
@mixin center-flex {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

这是使用你定义的 mixin 的示例。

```scss
section {
  @include center-flex;
  height: 500px;
  background-color: #3289a8;
}
```

## 手动和自动化测试

- **手动测试**：在手动测试中，测试人员将手动检查应用的每个部分并测试不同的特色，以确保其正常工作。如果在测试过程中发现任何错误，测试人员将向软件团队报告这些错误，以便修复。
- **自动化测试**：在自动化测试中，你可以通过编写一个单独的程序来自动化你的测试，以查看你的应用是否按预期运行。

## 单元测试

- **单元测试**：在单元测试中，你测试每个函数以确保一切按预期工作。单元测试也可以作为你的应用的文档形式，因为它们旨在表现你的代码的预期行为。
- **单一职责原则**：单一职责原则建议保持每个函数小且只负责一件事。
- **常见的 JavaScript 测试框架**：一些常见的测试框架包括 Jest、Mocha 和 Vitest。Jest 是一个流行的单元测试框架。

这是使用 Jest 的单元测试示例。

首先，你可以创建一个负责返回新格式化字串的函数：

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

在单独的 `getFormattedWord.test.js` 文件中，你可以编写一些测试来验证该函数是否按预期工作。`getFormattedWord.test.js` 文件将如下所示：

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **`expect` 函数**：`expect` 函数用于测试一个值。
- **Matcher**：Matcher 是一个函数，用于查看值是否符合预期。在上述示例中，matcher 是 `toBe()`。Jest 有多种 matcher。

要使用 Jest，首先需要通过 `npm i jest` 安装 `jest` 包。你还需要为你的 `package.json` 文件添加一个脚本，如下所示：

```js
"scripts": {
  "test": "jest"
},
```

然后，你可以运行命令 `npm run test` 来运行你的测试。

## 软件开发生命周期

- **软件开发生命周期的不同阶段**：
  - **计划阶段**：开发团队从利益相关者处收集拟议工作的需求。
  - **设计阶段**：软件团队分解需求并决定最佳的方案方法。
  - **实现阶段**：软件团队将需求分解为可管理的任务并实现它们。
  - **测试阶段**：这包括对新建工作的手动和自动测试。有时，团队会在整个开发阶段测试应用，以发现并修复出现的任何问题。
  - **部署阶段**：团队将新建的更改部署到构建或测试环境。
  - **维护阶段**：这涉及修复生产应用中客户出现的任何问题。

- **软件开发生命周期的不同模型**：
  - **瀑布模型**：瀑布模型是指生命周期的每个阶段都需要完成后，才能开始下一个阶段。
  - **敏捷模型**：敏捷模型专注于通过将工作分解为冲刺来进行迭代的开发。

## BDD 和 TDD

- **TDD**：测试驱动开发是一种强调先编写测试的开发方法。在创建特色之前编写测试，为开发者在开发进程中提供实时反馈。
- **BDD**：行为驱动开发是一种将一系列测试与业务目标对齐的方法。BDD 中的测试场景应使用技术人员和非技术人员都能理解的语言编写。此类语法的一个示例是 Gherkin。
- **BDD 测试框架**：BDD 测试框架的示例包括 Cucumber、JBehave 和 SpecFlow。

## 单元测试中的断言

- **断言**：断言用于测试代码是否按预期运行。
- **断言库**：Chai 是一个常用的断言库。其他常见的 JavaScript 断言库有 `should.js` 和 `expect.js`。

下面是一个使用 Chai 的断言示例，用于查看 `addThreeAndFour` 函数的返回值是否相等于数字 7：

```js
assert.equal(addThreeAndFour(), 7);
```

- **最佳实践**：无论你使用哪个断言库，都应编写清晰的断言和失败消息，以帮助你了解哪些测试失败以及原因。

## 模拟、伪造和存根

- **模拟**：模拟是用模拟真实组件行为的虚假数据替换真实数据的过程。例如，你可以在测试中模拟 API `Response`，而不是持续调用 API 来获取数据。
- **存根**：存根是返回预定义响应或虚拟数据的对象，用于模拟应用中的预期行为。例如，你可以在测试中为数据库连接存根行为，而无需依赖实际的数据库连接。
- **伪造**：伪造是简化版本的真实组件，没有复杂度或副作用。例如，你可以通过将数据存储在内存中而不是与真实数据库交互来伪造数据库。这将允许你在内存中模拟数据库操作，这比处理真实数据库要快得多。

## 功能测试

- **功能测试**：功能测试检查应用的特色和函数是否按预期工作。功能测试的目标是针对多个场景对系统整体进行测试。
- **非功能测试**：非功能测试关注性能和可靠性等方面。
- **冒烟测试**：冒烟测试是在开始更广泛的测试之前，对系统进行的基本或关键问题的初步查看。

## 端到端测试

- **端到端测试**：端到端测试，或称 E2E，从用户的角度测试真实场景。端到端测试有助于确保你的应用表现正确且对用户可预测。然而，设置、设计和维护耗时。
- **端到端测试框架**：Playwright 是微软开发的流行端到端测试框架。其他端到端测试工具的例子包括 Cypress、Selenium 和 Puppeteer。

这是一个使用 Playwright 的 freeCodeCamp 代码库中的端到端测试示例。`beforeEach` 钩子将在每个测试之前运行。测试查看捐赠者在菜单栏中是否有支持者链接，以及他们的头像周围是否有特殊样式的边框：

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## 可用性测试

- **可用性测试**：可用性测试是指让真实用户与应用交互，以发现应用中是否存在任何设计、用户体验或功能性问题。可用性测试侧重于用户对应用的直观感受。
- **四种常见的可用性测试类型**：
  - **探索性**：探索性可用性测试涉及用户与应用的不同特色交互，以更好地理解它们的工作原理。
  - **比较**：比较测试是指将你的应用的用户体验与市场上类似应用进行比较。
  - **评估**：评估测试是研究应用的使用直观性的过程。
  - **验证**：验证测试是识别任何会阻止用户有效使用该应用的重大问题的过程。
- **可用性测试工具**：可用性测试的工具示例包括 Loop11、Maze、Userbrain、UserTesting 和 UXTweak。

## 兼容性测试

- **兼容性测试**：兼容性测试的目标是确保你的应用在不同的计算环境中正常运行。
- **不同类型的兼容性测试**：
  - **向后兼容性**：向后兼容性是指软件与早期版本兼容。
  - **向前兼容性**：向前兼容性是指软件和系统能够与未来版本一起工作。
  - **硬件兼容性**：硬件兼容性是软件在不同硬件配置中正常工作的能力。
  - **操作系统兼容性**：操作系统兼容性是指软件在不同操作系统上运行的能力，例如 macOS、Windows 以及像 Ubuntu 和 Fedora 这样的 Linux 发行（版本）。
  - **网络兼容性**：网络兼容性意味着软件能够在不同的网络条件下工作，例如不同的网络速度、协议、安全性设置等。
  - **浏览器兼容性**：浏览器兼容性意味着网页应用可以在不同浏览器（例如 Google Chrome、Safari、Firefox 等）中一致地工作。
  - **移动兼容性**：确保你的软件应用能在各种 Android 和 iOS 设备上运行，包括手机和平板电脑，这一点非常重要。

## 性能测试

- **性能测试**：在性能测试中，你测试一个应用的速度、响应性、可扩展性和在不同工作负载下的稳定性。目标是解析任何类型的性能瓶颈。
- **不同类型的性能测试**：
  - **装载测试**：装载测试确定系统在正常和峰值装载时间的行为。
  - **压力测试**：压力测试是指在极端负载下测试你的 `application`，观察你的系统对更高负载的响应能力。
  - **浸泡测试（耐力测试）**：浸泡测试或耐力测试是一种装载测试，你用较高的装载对系统进行长时间测试。
  - **突发测试**：突发测试是指你剧烈增加和减少负载，并分析系统对这些变化的反应。
  - **断点测试（容量测试）**：断点测试或容量测试是指你随着时间缓慢增加 `load`，直到系统开始失败或性能下降。

## 安全性测试

- **安全性测试**：安全性测试有助于识别漏洞和弱点。
- **安全性原则**：
  - **保密性**：这可以防止敏感信息泄露给非预期的接收者。
  - **完整性**：这涉及防止恶意用户修改用户信息。
  - **认证**：这涉及验证用户的同一性，以确保他们被允许使用该系统。
  - **授权**：这是确定经过身份验证的用户被允许执行哪些操作或被允许访问系统哪些部分的进程。
  - **可用性**：这确保信息和服务在授权用户需要时可用。
  - **不可否认性**：这确保发送方和接收方都拥有交付证明和发送方身份的验证。它防止发送方否认已发送该信息。
- **常见安全性威胁**：
  - **跨站脚本攻击（XSS）**：当攻击者将恶意脚本注入网页并在受害者浏览器的上下文中执行时，就会发生 XSS 攻击。
  - **SQL 注入**：SQL 注入允许恶意用户将恶意代码注入到数据库中。
  - **拒绝服务（DoS）攻击**：DoS 攻击是指恶意用户向网站发送大量请求或流量，导致服务器变慢甚至崩溃，使网站对用户不可用。
- **安全性测试工具的类别**：
  - **静态应用安全性测试**：这些工具评估应用的源代码以识别安全漏洞。
  - **动态应用安全性测试**：这些工具与应用的前端接口，以发现潜在的安全性弱点。DAST 工具无法访问源代码。
- **渗透测试 (pentest)**：渗透测试是一种安全性测试，涉及对应用进行模拟网络攻击，以识别系统中的任何漏洞。

## A/B 测试

- **A/B 测试**：A/B 测试涉及比较页面或应用的两个版本，并研究哪个版本执行得更好。它也被称为桶测试或分割测试。A/B 测试使你能够做出更多数据驱动的决策，并持续改进用户体验。
- **A/B 测试工具**：用于 A/B 测试的工具示例包括 GrowthBook 和 LaunchDarkly。

## Alpha 和 Beta 测试

一旦初步开发和软件测试完成，重要的是让测试人员和真实用户对应用进行测试。这就是 alpha 测试和 beta 测试的作用。

- **Alpha 测试**：Alpha 测试由一组精选的测试人员进行，他们通过应用程序以确保在发布到市场之前没有错误。Alpha 测试是验收测试的一部分，采用白盒和黑盒测试技术。
- **Beta 测试**：Beta 测试是将应用提供给真实用户的阶段。用户可以与应用交互并提供反馈。Beta 测试也是一种用户验收测试的形式。
- **验收测试**：验收测试确保软件应用在发布前满足业务需求和用户需求。
- **黑盒测试**：黑盒测试只关注应用的预期行为。
- **白盒测试**：白盒测试涉及测试者了解内部组件并对其执行测试。

## 回归测试

- **回归**：回归指的是新更改无意中破坏现有功能性的情况。
- **回归测试**：回归测试有助于捕捉回归问题。在回归测试中，你会对应用的部分功能重新运行功能测试，以确保一切仍按预期工作。
- **回归测试工具**：你可以使用的回归测试工具包括 Puppeteer、Playwright、Selenium 和 Cypress。
- **回归测试的技术**：
  - **单元回归测试**：这是指你有一个需要在每次对应用程序实现重大更改或修复时进行测试的项列表。
  - **部分回归测试**：这涉及有针对性的方法，以确保新建更改未破坏应用的特定方面。
  - **完整回归测试**：这会针对代码库中的所有功能运行测试。这是最耗时且最详细的选项。
- **重新测试**：重新测试用于查看已知问题并确保它们已被解析。相比之下，回归测试查找可能因代码库最近更改而产生的未知问题。

## 什么是 TypeScript

- **JavaScript**：JavaScript 是一种动态类型语言。这意味着变量可以在运行时接收任何值。动态类型语言的挑战在于缺乏类型安全可能会引入误差。

例如，即使你的 JavaScript 函数期望一个数组，你仍然可以用一个数字来调用它：

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

上面示例的 `console` 输出将是 `undefined`。

- **TypeScript**：TypeScript 扩展了 JavaScript 语言，包含静态类型指派，这有助于在你运行代码之前捕获由类型不匹配引起的误差。

例如，你可以为 `array` 参数定义一个类型，如下所示：

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

此类型定义告诉 TypeScript，`array` 参数必须是一个字串数组。然后，当你调用 `getRandomValue` 并传入一个数字时，你会得到一个称为编译器误差的误差。

- **编译器**：你首先需要将 TypeScript 代码编译成普通的 JavaScript。当你运行编译器时，TypeScript 会评估你的代码，并在任何类型不匹配的问题上抛出误差。

## TypeScript 中的数据类型

- **TypeScript 中的原语数据类型**：对于原语数据类型 `string`、`null`、`undefined`、`number`、`boolean` 和 `bigint`，TypeScript 提供了相应的类型关键字。

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **数组**：你可以用两种不同的语法定义特定类型的数组。

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **对象**：你可以定义对象的精确结构。

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

如果你想要一个具有任意密钥，但所有值必须是字串的对象，有两种方法可以定义它：

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **TypeScript 中的其他有用类型**：
  - **`any`**：`any` 表示一个值可以具有任何类型。它告诉编译器不再关心该变量的类型。
  - **`unknown`**：`unknown` 告诉 TypeScript 你*确实*关心该值的类型，但你实际上不知道它是什么。通常推荐使用 `unknown` 而不是 `any`。
  - **`void`**：这是一种特殊的类型，通常只在定义函数时使用。没有返回值的函数使用返回类型为 `void`。
  - **`never`**：它表现为一种永远不会存在的类型。

- **`type` 关键字**：这个关键字类似于 `const`，但不是声明变量，而是声明类型。

它对于声明自定义类型非常有用，例如并集类型或仅包含特定值的类型：

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interface`**：接口就像类型的类。它们可以实现或扩展其他接口，专门是对象类型，通常优先使用，除非你需要 `type` 声明提供的特定特色。

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **定义返回类型**：你也可以定义函数的*返回类型*。

下面的示例将返回值定义为字串。如果你尝试返回其他任何内容，TypeScript 将给出编译器误差。

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## 泛型

- **定义通用的类型**：你可以定义一个通用的类型并在你的函数中参考它。它可以被视为你提供给函数的一个特殊参数，用于控制函数类型定义的行为。

下面是为函数定义通用的类型的示例：

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

`<T>` 语法告诉 TypeScript 你正在为函数定义一个通用的类型 `T`。`T` 是通用类型的常用名称，但你可以使用任何名称。

然后，你告诉 TypeScript `array` 参数是一个匹配通用类型的值数组，并且返回值是同一类型的单个元素。

- **在函数调用中指定类型参数**：你可以在函数名和其参数之间使用尖括弧传递类型参数。

下面是将类型参数传递给函数调用的示例：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

这告诉 TypeScript 你期望查找的元素将是一个输入元素。

## 类型缩小

- **通过真值缩小类型**：在下面的示例中，你尝试访问 `email` 的 `value` 属性时会得到编译器误差，因为 `email` *可能* 是 `null`。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

你可以使用条件式语句来确认 `email` 是 *truthy*，然后再访问该属性：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

真值检查也可以反向工作：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

抛出误差会结束此代码的逻辑执行，这意味着当你达到 `console.log()` 调用时，TypeScript 知道 `email` *不可能* 是 `null`。

- **可选链**：可选链 `?.` 也是一种类型缩小的形式，前提是如果 `email` 值为 `null`，则属性访问不会发生。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **`typeof` 操作符**：你可以使用条件式通过 `typeof` 操作符查看变量的类型。

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **`instanceof` 关键字**：如果对象来自某个类，你可以使用 `instanceof` 关键字来缩小类型。

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **类型转换**：当 TypeScript 无法自动确定一个值的类型时，例如下面示例中 `request.json()` 方法的结果，你会遇到编译器误差。解决此问题的一种方法是进行类型转换，但这样会削弱 TypeScript 捕捉潜在误差的能力。

```typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **类型保护**：你可以编写类型保护，而不是进行类型转换：

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

`user is User` 语法表示你的函数返回一个布尔值，当为 true 时表示 `user` 值满足 `User` 接口。

## `tsconfig` 文件

- **`tsconfig.json`**：TypeScript 的编译器设置存放在你项目根目录下的 `tsconfig.json` 文件中。

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

以下是上述示例中使用的编译器选项的描述：

- **`compilerOptions`**：`compilerOptions` 属性是你控制 TypeScript 编译器行为的地方。
- **`rootDir` 和 `outDir`**：`rootDir` 和 `outDir` 告诉 TypeScript 哪个目录包含你的源文件，哪个目录应包含转译后的 JavaScript 代码。
- **`lib`**：`lib` 属性决定编译器使用哪些类型定义，并允许你包含对特定 ES 版本、DOM 等的支持。
- **`module` 和 `moduleResolution`**：`module` 和 `moduleResolution` 协同工作以管理你的包如何使用模块——无论是 CommonJS 还是 ECMAScript。
- **`esModuleInterop`**：`esModuleInterop` 通过自动为导入创建命名空间对象，实现 CommonJS 和 ES 模块之间更顺畅的互操作性。
- **`skipLibCheck`**：`skipLibCheck` 选项跳过验证未被你的代码中的导入引用的 `.d.ts` 文件。
- **`strict`**：`strict` 标记启用多项查看，例如确保正确处理可空类型以及当 TypeScript 回退到 `any` 时发出警告。
- **`exclude`**：顶层的 `exclude` 属性告诉编译器在编译期间忽略这些 TypeScript 文件。


# --assignment--

复习 Frontend Libraries 主题和概念。
