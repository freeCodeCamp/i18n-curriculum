---
id: 68c1a929005bf54d342aa8d5
title: "Desafío 58: Semana del Espacio Día 4: Lugar de Aterrizaje"
challengeType: 28
dashedName: challenge-58
---

# --description--

En el cuarto día de la Semana Espacial, te dan una matriz de números (un arreglo de arreglos), que representa posibles lugares de aterrizaje para tu rover. Encuentra el lugar de aterrizaje más seguro basado en las siguientes reglas:

- Cada posición en la matriz contendrá un número de `0-9`, inclusive.
- Cualquier `0` representa un posible punto de aterrizaje.
- Cualquier número distinto de `0` es demasiado peligroso para aterrizar. Cuanto mayor sea el número, más peligroso.
- El lugar más seguro se define como la celda `0` cuyas celdas circundantes (hasta 4 vecinas, sin contar diagonales) tienen el menor peligro total.
- Ignora vecinos fuera de los límites (las esquinas y bordes simplemente tienen menos vecinos).
- Devuelve los índices del lugar de aterrizaje más seguro. Siempre habrá un único lugar más seguro.

Por ejemplo, dado:

```js
[
  [1, 0],
  [2, 0]
]
```

Devuelve `[0, 1]`, los índices para el `0` en el primer arreglo.

# --hints--

`findLandingSpot([[1, 0], [2, 0]])` debería devolver `[0, 1]`.

```js
assert.deepEqual(findLandingSpot([[1, 0], [2, 0]]), [0, 1]);
```

`findLandingSpot([[9, 0, 3], [7, 0, 4], [8, 0, 5]])` debería devolver `[1, 1]`.

```js
assert.deepEqual(findLandingSpot([[9, 0, 3], [7, 0, 4], [8, 0, 5]]), [1, 1]);
```

`findLandingSpot([[1, 2, 1], [0, 0, 2], [3, 0, 0]])` debería devolver `[2, 2]`.

```js
assert.deepEqual(findLandingSpot([[1, 2, 1], [0, 0, 2], [3, 0, 0]]), [2, 2]);
```

`findLandingSpot([[9, 6, 0, 8], [7, 1, 1, 0], [3, 0, 3, 9], [8, 6, 0, 9]])` debería devolver `[2, 1]`.

```js
assert.deepEqual(findLandingSpot([[9, 6, 0, 8], [7, 1, 1, 0], [3, 0, 3, 9], [8, 6, 0, 9]]), [2, 1]);
```

# --seed--

## --seed-contents--

```js
function findLandingSpot(matrix) {

  return matrix;
}
```

# --solutions--

```js
function findLandingSpot(matrix) {
  let bestSpot = null;
  let lowestNeighborSum = Infinity;

  for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {

      if (matrix[i][j] === 0) {
        let currentNeighborSum = 0;

        if (i > 0) currentNeighborSum += matrix[i - 1][j];
        if (j < matrix[i].length - 1) currentNeighborSum += matrix[i][j + 1];
        if (i < matrix.length - 1) currentNeighborSum += matrix[i + 1][j];
        if (j > 0) currentNeighborSum += matrix[i][j - 1];

        if (currentNeighborSum < lowestNeighborSum) {
          lowestNeighborSum = currentNeighborSum;
          bestSpot = [i, j];
        }
      }
    }
  }

  return bestSpot;
}
```
