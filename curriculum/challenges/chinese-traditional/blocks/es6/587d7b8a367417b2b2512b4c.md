---
id: 587d7b8a367417b2b2512b4c
title: >-
  透過剩餘元素進行解構賦值
challengeType: 1
forumTopicId: 301218
dashedName: >-
  use-destructuring-assignment-with-the-rest-parameter-to-reassign-array-elements
---

# --description--

在某些涉及陣列解構的情況下，我們可能想將其餘的元素收集到一個獨立的陣列中。

結果類似於 `Array.prototype.slice()`，如下所示：

```js
const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];
console.log(a, b);
console.log(arr);
```

主控台會顯示數值 `1, 2` 和 `[3, 4, 5, 7]`。

變數 `a` 和 `b` 取得陣列中的第一個和第二個值。之後，因為存在剩餘語法，`arr` 會以陣列的形式取得剩餘的值。剩餘元素只有在列表中的最後一個變數時才能正確運作。也就是說，你不能使用剩餘語法來捕捉一個排除原始陣列最後一個元素的子陣列。

# --instructions--

使用解構指派搭配剩餘語法來模擬 `Array.prototype.slice()` 的行為。`removeFirstTwo()` 應該傳回原始陣列 `list` 中省略前兩個元素的子陣列。

# --hints--

`removeFirstTwo([1, 2, 3, 4, 5])` 應該是 `[3, 4, 5]`

```js
assert.deepEqual(removeFirstTwo([1, 2, 3, 4, 5]), [3, 4, 5]);
```

`removeFirstTwo()` 不應該修改 `list`

```js
const _testArr = [1, 2, 3, 4, 5];
removeFirstTwo(_testArr);
assert.deepEqual(_testArr, [1, 2, 3, 4, 5])
```

不應該使用 `Array.slice()`。

```js
assert(!__helpers.removeJSComments(code).match(/\.\s*slice\s*\(/));
```

你應該使用剩餘語法。

```js
assert.match(code, /\.\.\./);
```

# --seed--

## --seed-contents--

```js
function removeFirstTwo(list) {
  return list;
}

const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const sourceWithoutFirstTwo = removeFirstTwo(source);
```

# --solutions--

```js
function removeFirstTwo(list) {
  // comment with 'slice' to check comments are removed in tests
  const [, , ...shorterList] = list;
  return shorterList;
}

const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const sourceWithoutFirstTwo = removeFirstTwo(source);
```
