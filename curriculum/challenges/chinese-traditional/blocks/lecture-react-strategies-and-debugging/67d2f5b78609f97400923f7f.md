---
id: 67d2f5b78609f97400923f7f
title: 什麼是狀態管理函式庫，以及你應該何時使用它們？
challengeType: 19
dashedName: what-are-state-management-libraries-and-when-should-you-use-them
---

# --description--

隨著你的應用程式成長，管理資料在組件之間的流動可能會變得複雜。

剛開始時，React 的 `useState` 掛鉤可能已足夠，但當你添加特性時，可能會遇到以下問題：

- 將 props 傳遞給不需要它們的組件，也稱為 prop drilling
- 保持你的應用程式中不同零件的資料同步
- 處理同時影響多個組件的複雜更新

這些和其他挑戰可能會出現，導致程式碼庫更難維護、偵錯和測試。這就是狀態管理函式庫的用武之地－它們提供一個集中化的位置，讓組件可以取得或更新它們所需的資料。

讓我們來看看你擁有的幾種不同狀態管理選項，可選方案以及何時使用它們。

Context API 是內建於 React 的狀態管理器，讓你能在組件之間共享狀態，而無需使用第三方函式庫。它是 `useState` 掛鉤的成熟升級版，因此非常適合用於主題切換或使用者身份驗證狀態等情況。

然而，Context API 無法良好控制頻繁的更新，且可能導致不必要的重新呈現，使其不太適合像電子商務和社交媒體平台這類具有複雜狀態需求的應用程式。 

這是一個計數器組件，示範了 Context API 的基本用法：

```jsx
import { useState, createContext } from 'react';

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

這段程式碼創建了一個背景關係和一個提供者，以便在整個應用程式中共享 `count` 狀態。

`CounterProvider` 使用 `useState` 掛鉤來初始化並管理 `count` 狀態及其設值函式。兩者隨後透過 `Provider` 傳遞給子組件。

因此，當你用 `CounterProvider` 包裹整個應用程式時，`count` 狀態在你的應用程式中隨處可用。

以下是你如何將 `CounterProvider` 包裹在你的應用程式周圍的方法：

```jsx
import { CounterProvider } from './context/CounterContext';

function App() {
  return (
    <CounterProvider>
        {/* App components */}
    </CounterProvider>
  );
}

export default App;
```

以下是你如何使用 `count` 狀態的方法：

```jsx
import React, { useContext } from 'react';
import { CounterContext } from '../context/CounterContext';

const Counter = () => {
  const { count, setCount } = useContext(CounterContext);

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Context API Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => setCount(count - 1)}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => setCount(count + 1)}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

如你所見，`count` 及其設值函式 `setCount` 是透過 `useContext` 函式初始化的。 

接著會顯示目前的 `count` 狀態，並且當使用者分別點擊遞減和遞增按鈕時，會使用 `setCount` 來增加和減少 `count` 狀態。

另一個受歡迎的狀態管理程式庫是 Redux，它是與 React 一起使用的最受歡迎的狀態管理程式庫之一。它已經存在很長時間，非常適合較大型的應用程式，例如電子商務和社交媒體平台、論壇等等。

Redux 透過提供一個中央儲存庫和對狀態更新的嚴格控制元件來處理狀態管理。它使用包含 actions、reducers 和 middleware 的可預測樣式。

動作是資訊的有效負載，將資料從你的應用程式傳送到 Redux 儲存庫，通常由使用者互動觸發。

Reducers 是指定狀態應如何回應那些動作而改變的函式，確保狀態以不可變的方式更新。

另一方面，中介層充當動作分派與 reducer 之間的橋樑，讓你能在不修改核心流程的情況下擴充 Redux 的功能（例如，記錄、處理非同步操作）。

關於 Redux 最常見的抱怨是你需要大量樣板程式碼才能開始。為此，Redux 團隊介紹了「Redux Toolkit」和「RTK Query」，這些大幅簡化了設定流程。

你通常會在單一檔案中使用 `createSlice()` 函式（程式）定義動作和 reducers。檔案名稱通常會以字 `Slice` 結尾，例如 `productSlice`、`userSlice`、`counterSlice` 等等。

這裡有一個 `counterSlice` 檔案，向你展示基礎知識：

```jsx
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',

  initialState: { count: 0 },

  reducers: {
    increment: (state) => {
      state.count += 1;
    },
    decrement: (state) => {
      state.count -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;

export default counterSlice.reducer;
```

從這裡開始，你需要用 `Provider` 包裹整個應用程式，使用 `useSelector()` 從 slice 中選取一部分狀態，然後使用 `useDispatch()` 來使狀態處於作用中。

另一個可考慮的選項是 Zustand。

Zustand 是一個輕量級的狀態管理程式庫，具有簡單的 API。它是基於掛鉤，因此與 Redux 相比，樣板程式碼較少，使設定更簡單且更快速。

Zustand 非常適合小型到中型應用程式。它透過使用 `useStore` 掛鉤直接在組件和頁面中存取狀態來運作。這讓你可以在不需要 actions、reducers 或 provider 的情況下修改和存取資料。

這裡有一個實作另一個計數器功能的 `useCounterStore`：

```jsx
import { create } from 'zustand';

const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

export default useCounterStore;
```

以下是如何在你的應用程式中初始化和使用狀態的方法：

```jsx
// Import the useCounterStore (it's just a hook)
import useCounterStore from '../useCounterStore';

const Counter = () => {
  // Initialize the states with the useCounterStore hook
  const { count, increment, decrement } = useCounterStore();

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Zustand Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => decrement()}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => increment()}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

即使前端生態系統不斷演進且新的狀態管理函式庫經常出現，我們討論過的那些仍然在業界廣泛使用。

# --questions--

## --text--

使用狀態管理函式庫的原因有哪些？

## --answers--

為了避免在你的應用程式中撰寫任何狀態邏輯。

### --feedback--

思考跨多個組件和頁面管理複雜狀態的利益。

---

自動更新 UI 而不重新呈現。

### --feedback--

思考跨多個組件和頁面管理複雜狀態的利益。

---

為了創建一致且可預測的資料流程。

---

完全消除對 props 的需求。

### --feedback--

思考跨多個組件和頁面管理複雜狀態的利益。

## --video-solution--

3

## --text--

以下哪一項不是狀態管理函式庫？

## --answers--

Context API

### --feedback--

思考哪一個是專門用於 API 請求的。

---

Redux

### --feedback--

思考哪一個是專門用於 API 請求的。

---

Zustand

### --feedback--

思考哪一個是專門用於 API 請求的。

---

Axios

## --video-solution--

4

## --text--

關於 Redux 的常見抱怨是什麼，以及它是如何被解決的？

## --answers--

它的瀏覽器支援有限，這個問題透過建立 polyfills 得以解決。

### --feedback--

思考為了降低設定複雜度所做的改進。

---

它有效率問題，這些問題透過優化其中介層來解決。

### --feedback--

思考為了降低設定複雜度所做的改進。

---

這需要大量複雜的樣板程式碼，Redux Toolkit 和 RTK Query 解決了這個問題。

---

文件不足，已透過添加更多範例來解決。

### --feedback--

思考為了降低設定複雜度所做的改進。

## --video-solution--

3
