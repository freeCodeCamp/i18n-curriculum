---
id: 6724e417419c2f211bb41bfc
title: Revisión de scripting Bash
challengeType: 31
dashedName: review-bash-scripting
---

# --description--

## Conceptos Básicos de Scripting en Bash

- **Scripting en Bash**: Escribir una secuencia de comandos Bash en un archivo, que luego puedes ejecutar con Bash para correr el contenido del archivo.
- **Shebang**: La línea comentada al inicio de un script (por ejemplo, `#!/bin/bash`) que indica qué intérprete debe usarse para el script.

- **Asignación de variables**: Instancia variables usando la sintaxis `variable_name=value`.

- **Reglas para la creación de variables**: Crea variables con la sintaxis `VARIABLE_NAME=VALUE`. No se permiten espacios alrededor del signo igual (`=`). Usa comillas dobles si el valor contiene espacios.

- **Uso de variables**: Accede a los valores de las variables colocando `$` delante del nombre de la variable.

- **Interpolación de variables**: Usa `$variable_name` para acceder al valor de una variable dentro de cadenas y comandos.

- **Ámbito de variable**: Los scripts de Shell se ejecutan de arriba hacia abajo, por lo que las variables solo pueden usarse debajo del lugar donde se crean.

- **Entrada del usuario**: Usa `read` para aceptar entrada de los usuarios y almacenarla en una variable.

- **Comments**: Add comments to your scripts using `#` followed by your comment text.
  - Los comentarios de una sola línea comienzan con `#` y continúan hasta el final de la línea
  - Los comentarios son ignorados por el shell y no afectan la ejecución del script

  ```bash
  # This is a single-line comment
  NAME="John"  # Comment at end of line
  ```

- **Comentarios multilínea**: Comenta bloques de código usando dos puntos y comillas.

- **Built-in commands and help**: 
  - Usa `help` para ver una lista de comandos bash integrados
  - Usa `help <command>` para obtener información sobre comandos integrados específicos
  - Algunos comandos (como `if`) son incorporados y no tienen páginas man
  - Los comandos integrados se ejecutan directamente por el shell en lugar de como programas externos
  - Usa `help function` para ver información sobre cómo crear funciones

  ```bash
  help
  help if
  help function
  ```

- **Finding command locations**: Use `which` to locate where executables are installed.
  - Muestra la ruta completa a los archivos ejecutables
  - Útil para encontrar ubicaciones del intérprete (como bash)
  - Ayuda a verificar qué versión de un comando se ejecutará

  ```bash
  which bash
  which python
  which ls
  ```

- **Manual pages**: Use `man` to access detailed documentation for commands.
  - Proporciona información completa sobre el uso de comandos
  - Muestra todas las opciones y ejemplos disponibles
  - Usa las teclas de flecha para navegar, 'q' para salir
  - No todos los comandos tienen páginas de manual (los integrados usan `help` en su lugar)

  ```bash
  man echo
  man ls
  man bash
  ```

- **Help flags**: Many commands support `--help` for quick help information.
  - Alternativa a las páginas de manual para referencia rápida
  - Muestra la sintaxis del comando y las opciones comunes
  - No todos los comandos soportan esta bandera (algunos pueden mostrar error)

  ```bash
  ls --help
  chmod --help
  mv --help
  ```

- **Echo command options**: The `echo` command supports various options:
  - La opción `-e` habilita la interpretación de secuencias de escape con barra invertida
  - `\n` crea una nueva línea
  - Las líneas vacías solo se imprimen cuando los valores están entre comillas
  - Útil para crear salida formateada y títulos de programas

  ```bash
  echo -e "Line 1\nLine 2"
  echo ""
  echo -e "\n~~ Program Title ~~\n"
  echo "Line 1\nLine 2"
  ```

- **Script arguments**: Programs can accept arguments that are accessible using `$` variables.
  - `$*` imprime todos los argumentos pasados al script
  - `$@` imprime todos los argumentos pasados al script como cadenas separadas entre comillas
  - `$<number>` accede a argumentos específicos por posición (por ejemplo, `$1`, `$2`, `$3`)

  ```bash
  echo $*
  echo $@
  echo $1
  echo $2
  ```

## Expresiones de Doble Corchete `[[ ]]`

- **Double bracket syntax**: Use `[[ ]]` for conditional testing and pattern matching.
  - Debe haber espacios dentro de los corchetes y alrededor de los operadores
  - Devuelve el estado de salida 0 (true) o 1 (false) según el resultado de la prueba

  ```bash
  [[ $variable == "value" ]]
  [[ $number -gt 10 ]]
  [[ -f filename.txt ]]
  ```

- **String comparison operators**: Compare strings using various operators within `[[ ]]`.
  - `==` (equal): Prueba si dos cadenas son idénticas
  - `!=` (no es igual): Prueba si dos cadenas son diferentes
  - `<` (menos lexicográficamente): comparación de cadenas en orden alfabético
  - `>` (lexicográficamente mayor): comparación de cadenas en orden alfabético

  ```bash
  [[ "apple" == "apple" ]]
  [[ "apple" != "orange" ]]
  [[ "apple" < "banana" ]]
  [[ "zebra" > "apple" ]]
  ```

- **Numeric comparison operators**: Compare numbers using specific numeric operators.
  - `-eq` (equal): comparación de igualdad numérica
  - `-ne` (not equal): comparación de desigualdad numérica
  - `-lt` (less than): comparación numérica de menor que
  - `-le` (less than or equal): comparación numérica de menor o igual
  - `-gt` (greater than): comparación numérica de mayor que
  - `-ge` (greater than or equal): comparación numérica de mayor o igual que

  ```bash
  [[ $number -eq 5 ]]
  [[ $count -ne 0 ]]
  [[ $age -ge 18 ]]
  [[ $score -lt 100 ]]
  ```

- **Logical operators**: Combine multiple conditions using logical operators.
  - `&&` (y): Ambas condiciones deben ser verdaderas
  - `||` (o): Al menos una condición debe ser verdadera
  - `!` (not): Niega la condición (convierte true en false, false en true)

  ```bash
  [[ $age -ge 18 && $age -le 65 ]]
  [[ $name == "John" || $name == "Jane" ]]
  [[ ! -f missing_file.txt ]]
  ```

- **File test operators**: Test file properties and existence.
  - `-e file`: Verdadero si el archivo existe
  - `-f file`: Verdadero si el archivo existe y es un archivo regular
  - `-d file`: Verdadero si el archivo existe y es un directorio
  - `-r file`: Verdadero si el archivo existe y es legible
  - `-w file`: Verdadero si el archivo existe y es escribible
  - `-x file`: Verdadero si el archivo existe y es ejecutable
  - `-s file`: Verdadero si el archivo existe y tiene un tamaño mayor que cero

  ```bash
  [[ -e /path/to/file ]]
  [[ -f script.sh ]]
  [[ -d /home/user ]]
  [[ -x program ]]
  ```

- **Pattern matching with `=~`**: Use regular expressions for advanced pattern matching.
  - El operador `=~` permite la coincidencia de patrones regex
  - El patrón no debe ir entre comillas cuando uses metacaracteres de regex
  - Soporta la sintaxis completa de expresiones regulares
  - Sensible a mayúsculas y minúsculas por defecto

  ```bash
  [[ "hello123" =~ [0-9]+ ]]
  [[ "email@domain.com" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
  [[ "filename.txt" =~ \.txt$ ]]
  ```

- **Variable existence testing**: Check if variables are set or empty.
  - Prueba si la variable está vacía: `[[ ! $variable ]]`

  ```bash
  [[ ! $undefined_var ]]
  ```

## Expresiones de Doble Paréntesis `(( ))`

- **Arithmetic evaluation**: Use `(( ))` for mathematical calculations and numeric comparisons.
  - Evalúa expresiones aritméticas usando sintaxis estilo C
  - Las variables no necesitan el prefijo `$` dentro de los paréntesis dobles
  - Devuelve el estado de salida 0 si el resultado es distinto de cero, 1 si el resultado es cero
  - Soporta todos los operadores aritméticos estándar

  ```bash
  (( result = 10 + 5 ))
  (( count++ ))
  (( total += value ))
  ```

- **Arithmetic operators**: Mathematical operators available in `(( ))`.
  - `+` (adición): Suma dos números
  - `-` (subtraction): Resta el segundo número del primero
  - `*` (multiplicación): Multiplica dos números
  - `/` (división): Divide el primer número por el segundo (división entera)
  - `%` (módulo): Residuo después de la división
  - `**` (exponenciación): Eleva el primer número a la potencia del segundo

  ```bash
  (( sum = a + b ))
  (( diff = x - y ))
  (( product = width * height ))
  (( remainder = num % 10 ))
  (( power = base ** exponent ))
  ```

- **Assignment operators**: Modify variables using arithmetic assignment operators.
  - `=` (asignación): Asigna un valor a la variable
  - `+=` (sumar y asignar): Añade un valor a la variable
  - `-=` (restar y asignar): Resta un valor a la variable
  - `*=` (multiplicar y asignar): Multiplica la variable por el valor
  - `/=` (divide y asigna): Divide la variable por el valor
  - `%=` (módulo y asignar): Establece la variable al resto

  ```bash
  (( counter = 0 ))
  (( counter += 5 ))
  (( total -= cost ))
  (( area *= 2 ))
  (( value /= 3 ))
  ```

- **Increment and decrement operators**: Modify variables by one.
  - `++variable` (pre-incremento): Incrementa antes de usar
  - `variable++` (post-incremento): Incrementa después de usarlo
  - `--variable` (pre-decremento): Decrementa antes de usar
  - `variable--` (post-decremento): Decrementa después de usar

  ```bash
  (( ++counter ))
  (( index++ ))
  (( --remaining ))
  (( attempts-- ))
  ```

- **Comparison operators**: Compare numbers using arithmetic comparison.
  - `==` (equal): Los números son iguales
  - `!=` (no es igual): Los números no son iguales
  - `<` (menos que): El primer número es menor que el segundo
  - `<=` (menor o igual): El primer número es menor o igual que el segundo
  - `>` (mayor que): El primer número es mayor que el segundo
  - `>=` (mayor o igual que): El primer número es mayor o igual que el segundo

  ```bash
  (( age >= 18 ))
  (( score < 100 ))
  (( count == 0 ))
  (( temperature > freezing ))
  ```

- **Logical operators**: Combine arithmetic conditions.
  - `&&` (and): Ambas condiciones deben ser verdaderas
  - `||` (o): Al menos una condición debe ser verdadera
  - `!` (not): Niega la condición

  ```bash
  (( age >= 18 && age <= 65 ))
  (( score >= 90 || extra_credit > 0 ))
  (( !(count == 0) ))
  ```

- **Bitwise operators**: Perform bit-level operations on integers.
  - `&` (AND a nivel de bits): operación AND en cada bit
  - `|` (bitwise OR): operación OR en cada bit
  - `^` (bitwise XOR): operación XOR en cada bit
  - `~` (bitwise NOT): Invierte todos los bits
  - `<<` (left shift): Desplaza bits hacia la izquierda
  - `>>` (right shift): Desplaza bits hacia la derecha

  ```bash
  (( result = a & b ))
  (( flags |= new_flag ))
  (( shifted = value << 2 ))
  ```

- **Conditional (ternary) operator**: Use `condition ? true_value : false_value` syntax.
  - Proporciona una forma concisa de asignar valores basados en condiciones
  - Similar al operador ternario en lenguajes estilo C
  - Evalúa la condición y devuelve uno de dos valores

  ```bash
  (( result = (score >= 60) ? 1 : 0 ))
  (( max = (a > b) ? a : b ))
  (( sign = (num >= 0) ? 1 : -1 ))
  ```

- **Command substitution with arithmetic**: Use `$(( ))` to capture arithmetic results.
  - Devuelve el resultado de la expresión aritmética como una cadena
  - Puede usarse en asignaciones o argumentos de comando
  - Útil para cálculos que necesitan ser usados en otro lugar

  ```bash
  result=$(( 10 + 5 ))
  echo "The answer is $(( a * b ))"
  array_index=$(( RANDOM % array_length ))
  ```

## Flujo de Control y Condicionales

- **Conditional statements**: Use `if` statements to execute code based on conditions.
  - Sintaxis básica: `if [[ CONDITION ]] then STATEMENTS fi`
  - Sintaxis completa: `if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`
  - Puedes usar tanto las expresiones `[[ ]]` como `(( ))` para diferentes tipos de condiciones
  - **elif (else if)**: Opcional, puede repetirse varias veces para probar condiciones adicionales en secuencia
  - **else**: Opcional, se ejecuta cuando todas las condiciones anteriores son falsas
  - Puedes mezclar dobles paréntesis `(( ... ))` y dobles corchetes `[[ ... ]]` en la misma cadena condicional

  ```bash
  if (( NUMBER <= 15 ))
  then
      echo "B:$NUMBER"
  elif [[ $NUMBER -le 30 ]]
  then
      echo "I:$NUMBER"
  elif (( NUMBER < 46 ))
  then
      echo "N:$NUMBER"
  elif [[ $NUMBER -lt 61 ]]
  then
      echo "G:$NUMBER"
  else
      echo "O:$NUMBER"
  fi
  ```

## Ejecución de Comandos y Control de Procesos

- **Command separation**: Use semicolon (`;`) to run multiple commands on a single line.
  - Los comandos se ejecutan secuencialmente de izquierda a derecha
  - El estado de salida de cada comando puede verificarse individualmente

  ```bash
  [[ 4 -ge 5 ]]; echo $?
  ls -l; echo "Done"
  ```

- **Exit status**: Every command has an exit status that indicates success or failure.
  - Accede al estado de salida del último comando con `$?`
  - El estado de salida `0` significa éxito (verdadero/sin errores)
  - Cualquier estado de salida distinto de cero significa fallo (ocurrieron errores/falso)
  - Códigos de error comunes: `127` (comando no encontrado), `1` (error general)

  ```bash
  echo $?
  [[ 4 -le 5 ]]; echo $?
  ls; echo $?
  bad_command; echo $?
  ```

- **Subshells and command substitution**: Different uses of parentheses for execution contexts.
  - Los paréntesis simples `( ... )` crean una subshell
  - `$( ... )` realiza la sustitución de comandos
  - Las subshells se ejecutan en entornos separados y no afectan las variables del shell padre

  ```bash
  ( cd /tmp; echo "Current dir: $(pwd)" )
  current_date=$(date)
  file_count=$(ls | wc -l)
  echo "Today is $current_date"
  echo "Found $file_count files"
  ```

- **Sleep command**: Pause script execution for a specified number of seconds.
  - Útil para crear retrasos en scripts
  - Puede usarse con valores decimales para retrasos de subsegundos

  ```bash
  sleep 3
  sleep 0.5
  sleep 1
  ```

## Loops

- **While loops**: Execute code repeatedly while a condition is true.
  - Sintaxis: `while [[ CONDITION ]] do STATEMENTS done`

  ```bash
  I=5
  while [[ $I -ge 0 ]]
  do
      echo $I
      (( I-- ))
      sleep 1
  done
  ```

- **Until loops**: Execute code repeatedly until a condition becomes true.
  - Sintaxis: `until [[ CONDITION ]] do STATEMENTS done`

  ```bash
  until [[ $QUESTION =~ \?$ ]]
  do
      echo "Please enter a question ending with ?"
      read QUESTION
  done
  until [[ $QUESTION =~ \?$ ]]
  do
      GET_FORTUNE again
  done
  ```

- **Bucles for**: Itera a través de arreglos o listas usando bucles `for` con `do` y `done` para definir el bloque lógico del bucle.

## Arreglos

- **Arrays**: Store multiple values in a single variable.
  - Crea arreglos con paréntesis: `ARRAY=("value1" "value2" "value3")`
  - Accede a elementos por índice: `${ARRAY[0]}`, `${ARRAY[1]}`
  - Accede a todos los elementos: `${ARRAY[@]}` o `${ARRAY[*]}`
  - El índice de un array comienza en 0

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Ask again later")
  echo ${RESPONSES[0]}     # Yes          
  echo ${RESPONSES[1]}     # No         
  echo ${RESPONSES[5]}     # Index 5 doesn't exist; empty string              
  echo ${RESPONSES[@]}     # Yes No Maybe Ask again later   
  echo ${RESPONSES[*]}     # Yes No Maybe Ask again later 
  ```

- **Array inspection with declare**: Use `declare -p` to view array details.
  - Muestra el tipo de arreglo con la bandera `-a`
  - Muestra todos los elementos del array y su estructura

  ```bash
  ARR=("a" "b" "c")
  declare -p ARR # ARR=([0]="a" [1]="b" [2]="c")
  ```

- **Expansión de arrays**: Usa la sintaxis `"${array_name[@]}"` para expandir un array en elementos individuales.

```bash
for server in "${servers[@]}"
```

## Funciones

- **Functions**: Create reusable blocks of code.
  - Define con `FUNCTION_NAME() { STATEMENTS }`
  - Llama usando el nombre de la función
  - Puede aceptar argumentos accesibles como `$1`, `$2`, etc.

  ```bash
  GET_FORTUNE() {
      echo "Ask a question:"
      read QUESTION
  }
  GET_FORTUNE
  ```

- **Function arguments**: Functions can accept arguments just like scripts.
  - Los argumentos se pasan al llamar a la función
  - Accede a los argumentos dentro de la función usando `$1`, `$2`, etc.
  - Usa lógica condicional para manejar diferentes argumentos

  ```bash
  GET_FORTUNE() {
      if [[ ! $1 ]]
      then
          echo "Ask a yes or no question:"
      else
          echo "Try again. Make sure it ends with a question mark:"
      fi
      read QUESTION
  }
  GET_FORTUNE
  GET_FORTUNE again
  ```

## Números aleatorios y operaciones matemáticas

- **Random numbers**: Generate random values using the `$RANDOM` variable.
  - `$RANDOM` genera números entre 0 y 32767
  - Usa el operador módulo para limitar el rango: `$RANDOM % 75`
  - Suma 1 para evitar cero: `$(( RANDOM % 75 + 1 ))`
  - Debes usar la sintaxis `$(( ... ))` para cálculos con `$RANDOM`

  ```bash
  NUMBER=$(( RANDOM % 6 ))
  DICE=$(( RANDOM % 6 + 1 ))
  BINGO=$(( RANDOM % 75 + 1 ))
  echo $(( RANDOM % 10 ))
  ```

- **Random array access**: Use random numbers to access array elements randomly.
  - Genera un índice aleatorio dentro de los límites del array
  - Usa un índice aleatorio para acceder a los elementos del arreglo
  - Útil para selecciones aleatorias de opciones predefinidas

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Outlook good" "Don't count on it" "Ask again later")
  N=$(( RANDOM % 6 ))
  echo ${RESPONSES[$N]}
  ```

- **Modulus operator**: Use `%` to get the remainder of division operations.
  - Esencial para limitar rangos de números aleatorios
  - Funciona con `$RANDOM` para crear valores aleatorios limitados
  - `RANDOM % n` da números desde 0 hasta n-1

  ```bash
  echo $(( 15 % 4 ))
  echo $(( RANDOM % 100 ))
  echo $(( RANDOM % 10 + 1 ))
  ```

## Información del entorno y del sistema

- **Environment variables**: Predefined variables available in the shell environment.
  - `$RANDOM`: Genera números aleatorios entre 0 y 32767
  - `$LANG`: configuración del idioma del sistema
  - `$HOME`: ruta del directorio personal del usuario
  - `$PATH`: Directorios donde se buscan los comandos ejecutables
  - Ve todo con `printenv` o `declare -p`

  ```bash
  echo $RANDOM
  echo $HOME
  echo $LANG
  printenv
  ```

- **Variable inspection**: Use `declare` to view and work with variables.
  - `declare -p`: Imprime todas las variables y sus valores
  - `declare -p VARIABLE`: Imprime detalles específicos de la variable
  - Muestra el tipo de variable (string, array, etc.) y los atributos

  ```bash
  declare -p
  declare -p RANDOM
  declare -p MY_ARRAY
  ```

- **Command types**: Different categories of commands available in bash.
  - **Comandos integrados**: Ejecutados directamente por el shell (por ejemplo, `echo`, `read`, `if`)
  - **Comandos externos**: Archivos binarios en directorios del sistema (por ejemplo, `ls`, `sleep`, `bash`)
  - **Palabras clave de Shell**: Estructuras del lenguaje (por ejemplo, `then`, `do`, `done`)
  - Usa `type <command>` para ver qué tipo es un comando

  ```bash
  type echo
  type ls
  type if
  type ./script.sh
  ```

## Creación y gestión de archivos

- **File creation**: Use `touch` to create new empty files.
  - Crea un archivo nuevo si no existe
  - Actualiza la marca de tiempo si el archivo ya existe
  - Comúnmente usado para crear archivos de script antes de editar

  ```bash
  touch script.sh
  touch bingo.sh
  touch filename.txt
  ```

## Creando y Ejecutando Scripts Bash

- **Script execution methods**: Multiple ways to run bash scripts:
  - **`sh scriptname.sh`**: Ejecuta con el intérprete de shell sh.
  - **`bash scriptname.sh`**: Ejecuta con el intérprete de la shell bash.
  - **`./scriptname.sh`**: Ejecuta directamente (requiere permisos de ejecución).

```bash
sh questionnaire.sh
bash questionnaire.sh
./questionnaire.sh
```

## Permisos de Archivos y Ejecución de Scripts

- **Error de permiso denegado**: Al usar `./scriptname.sh`, puedes recibir "permission denied" si el archivo no tiene permisos de ejecución.
- **Comprobando permisos**: Usa `ls -l` para ver los permisos de archivos.

- **Permission format**: The output shows permissions as `-rw-r--r--` where:
  - Primer carácter (`-`): Tipo de archivo (- para archivo regular, d para directorio)
  - Los siguientes 9 caracteres: Permisos para propietario, grupo y otros
  - `r` = leer, `w` = escribir, `x` = ejecutar
  
- **Agregar permisos de ejecución**: Usa `chmod +x` para dar permisos de ejecución a todos.

- **Script organization**: Best practices for structuring bash scripts.
  - Comienza con shebang (`#!/bin/bash`)
  - Agrega comentarios descriptivos sobre el propósito del script
  - Define variables en la parte superior
  - Agrupa funciones relacionadas juntas
  - Lógica principal del script al final

  ```bash
  #!/bin/bash
  NAME="value"
  ARRAY=("item1" "item2")
  my_function() {
      echo "Function code here"
  }
  my_function
  echo "Script complete"
  ```

- **Sequential script execution**: Create master scripts that run multiple programs in sequence.
  - Útil para automatizar flujos de trabajo que involucran múltiples scripts
  - Cada script se ejecuta hasta completarse antes de que comience el siguiente
  - Puedes combinar diferentes programas en un solo flujo de ejecución
  - Los argumentos pueden pasarse a scripts individuales según sea necesario
  - Puede incluir diferentes tipos de programas (interactivos, automatizados, etc.)

  ```bash
  #!/bin/bash
  ./setup.sh
  ./interactive.sh
  ./processing.sh
  ./cleanup.sh
  ```

# --assignment--

Revise los temas y conceptos de scripting Bash.
