---
id: 68816f386bc30d36f59e9563
title: 什麼是 SQL 中的正規化？
challengeType: 19
dashedName: what-is-normalization-in-sql
---

# --description--

正規化是使用既定的正規形式來組織關聯式資料庫的過程，以減少資料冗餘並提升資料完整性。

要正規化資料庫，你需要分析表格結構中的屬性和關係，以根據正規化規則找出簡化的機會。然後，你將資料拆分成更小且更專注的表格，並使用主鍵和外鍵建立它們之間的關係。這些較小的表格將儲存你原本擁有的所有資料，但與較大的表格相比，它們更容易管理、組織和操作。

透過最小化資料冗餘，正規化減少儲存空間並防止不一致性。 例如，如果客戶的位址變更，你只需要在一個客戶資料表中更新，而不是在每筆訂單記錄中更新。 

它還有助於透過確保依賴關係由主鍵和外鍵條件強制執行來維護資料完整性。這降低了插入、更新和刪除異常的可能性。

正規化的資料庫較容易理解和維護，有助於建立良好設計的資料庫系統。

你應該遵循來組織你的資料表的一組規則稱為正規化形式。每個正規化形式都是建立在前一個形式之上，隨著你移動到更高的正規化形式，規則會變得更嚴格。第一正規化形式（1NF）是基礎形式，具有最基本的規則。

如果一個資料表符合第一正規化形式（1NF）：

- 每個儲存格應該只包含一個值。<dfn>例如</dfn>，如果你有一個 `students` 表格，你可能會有一個學生擁有多個電話號碼。你應該建立一個獨立的 `phone_numbers` 表格，並用外鍵指向 `students` 表格，而不是將它們以逗號分隔的列表形式存放在同一個儲存格中，且每個儲存格只存放一個值。這樣可以保持每個值為不可分割的，並且設計符合正規化。
- 每個記錄（列）必須是唯一的。雖然主鍵強制執行此要求，但 1NF 明確規定表中不得存在重複的列。
- 列和行的順序不應該有影響。資料不應該依賴其實體的位置。

基本上，第一正規化形式（1NF）著重於使值簡單且不可分割的。

第二正規化形式（2NF）是在 1NF 的基礎上建置，要求符合所有 1NF 的條件，並且加上額外的條件。

理解 2NF 需要熟悉兩個關鍵概念：超鍵和候選鍵。超鍵是任何能唯一識別資料表中每一列的屬性集合，這表示沒有兩列能在超鍵的所有行中擁有相同的值。

例如，如果我們有一個包含三個行的 `customers` 資料表：

```sql
customer_id | name | email
```

假設 `customer_id` 和 `email` 必須對每個記錄唯一。此資料表的一些超鍵範例如下：

- `customer_id`
- `{ customer_id, name }`，這組合唯一識別列，因為單獨的 `customer_id` 就是唯一的，無論 `name` 是否唯一。
- `{ customer_id, name, email }`
- `email`，由於我們也將唯一條件添加到這個行，每個記錄都可以透過 email 唯一識別。

任何一組屬性，只要能一起識別每一列，就可以是超鍵。

候選鍵類似但又有些不同。它是一組一個或多個行，能夠唯一識別每個記錄。資料表可以有多個候選鍵，但你需要選擇一個作為主鍵。

它們聽起來相當相似，對吧？它們的差別在於超鍵還可以包含不必要用來唯一識別每一列的額外屬性，而候選鍵只包含用來唯一識別該列的屬性。

在我們的 `customers` 範例中，我們提到 `customer_id`、`{ customer_id, name }`、`{ customer_id, name, email }` 和 `email` 都可以是超鍵。在這種情況下，只有 `customer_id` 和 `email` 可以是候選鍵，因為候選鍵不能包含無法唯一識別該列的屬性，例如 `name`。這說明了區分候選鍵與超鍵的最小性原則。

既然你已經熟悉這些概念，讓我們回到第二正規化形式（2NF）。

第二正規化形式（2NF）是基於解決部分相依性。當一個不屬於主鍵的屬性僅依賴於複合主鍵的一部分時（複合主鍵是由多個行組成的主鍵），表格中就會發生部分相依性。這可能導致資料冗餘和更新異常。

例如，假設我們有一個 `orders` 資料表，裡面有這些行：

```sql
order_id | item_id | order_date | quantity | order_shipping_city
```

在此表格中，主鍵是 `order_id` 和 `item_id` 的組合，因為相同的項目 ID 可以出現在不同的訂單中，但它們的組合將是唯一的。你可以看到 `order_id` 和 `order_shipping_city` 之間存在部分相依性。`order_id` 是主鍵的一部分。`order_shipping_city` 依賴於 `order_id`，因為每個具有相同 ID 的訂單都會有相同的運送城市。然而，運送城市不依賴於 `item_id`，但這也是主鍵的一部分。因此，`order_shipping_city` 不依賴於整個主鍵。

為了解決這個問題，你可以將資料表拆分成兩個較小的資料表，例如 `order_header` 和 `order_items`。在 `order_header` 資料表中，你可以儲存關於訂單的頂層資訊： 

```sql
order_id | order_date | order_shipping_city
```

在 `order_items` 資料表中，你可以儲存關於已提交不同訂單中項目的資訊：

```sql
order_id | item_id | quantity
```

有了這些變更，兩個資料表都將處於第二正規化形式（2NF）。

這就引出了第三正規化形式（3NF）。這個正規化形式是在第二正規化形式的基礎上構築的。

要使資料表符合第三正規形式，必須：

- 符合第二正規形式。
- 讓所有非鍵屬性直接依賴於主鍵，意即不應該有非鍵屬性依賴於其他非鍵屬性。

要理解第三正規化形式（3NF），你需要了解遞移相依性。當一個不屬於主鍵的屬性依賴於另一個不屬於主鍵的屬性，而該屬性又依賴於主鍵時，就會發生遞移相依性。

例如，讓我們修改 `orders` 資料表，使其具有這些行：

```sql
order_id | customer_id | customer_city | city_postal_code | order_date | quantity
```

這個新資料表中的主鍵是 `order_id`，因為它能唯一識別每一列。

此表中存在傳遞相依性：

```sql
order_id > customer_id > customer_city > city_postal_code
```

城市的郵遞區號由客戶的城市決定，而客戶的城市由客戶的 ID 決定，客戶的 ID 則由訂單的 ID 決定。`city_postal_code` 是一個不屬於主鍵的屬性，由同樣不屬於主鍵的 `customer_city` 決定，但 `customer_city` 是透過 `customer_id` 由 `order_id` 決定。這表示同一城市的客戶所下的每筆訂單都會重複該城市的郵遞區號。這將導致資料冗餘。此外，任何對城市郵遞區號的更改都需要更新多筆記錄。

為了解決傳遞相依性，你需要將資料表拆分成多個資料表。首先，一個 `orders` 資料表：

```sql
order_id | customer_id | order_date | quantity
```

接著，一個 `customers` 資料表：

```sql
customer_id | city_name
```

還有一個 `cities` 表格：

```sql
city_name | city_postal_code
```

這會從資料表中移除傳遞相依性。

最後，我們有 Boyce-Codd 正規形（BCNF）。這也被稱為正規形 3.5，因為它解決了第三正規形可能無法處理的一些異常。要使一個資料表符合 Boyce-Codd 正規形（BCNF），它必須：

- 符合第三正規化形式。
- 讓每個函式相依性的左側都是超鍵。

這個正規形態的目標是確保每個決定另一個屬性的屬性或屬性集合都是超鍵，超鍵是候選鍵或其超集合。

理解並應用正規化表單對於設計強固且高效的關聯式資料庫至關重要。透過消除資料冗餘並確保邏輯資料依賴性，正規化可提升資料完整性、減少儲存需求，並簡化資料庫維護。你通常應該以達到第三正規化表單（3NF）為目標。

# --questions--

## --text--

哪一種正規化形式主要關注將單一列中的資料群組替換為單一值？

## --answers--

第一正規化形式（1NF）

---

第二正規化形式（2NF）

### --feedback--

思考表格中最基本的組織層級以及構成單一、不可分割的資料單元的要素。

---

第三正規化形式（3NF）

### --feedback--

思考表格中最基本的組織層級以及構成單一、不可分割的資料單元的要素。

---

Boyce-Codd 正規形態（BCNF）

### --feedback--

思考表格中最基本的組織層級以及構成單一、不可分割的資料單元的要素。

## --video-solution--

1

## --text--

如果一個資料表符合第一正規化形式（1NF），且以下條件為真，則該資料表屬於第二正規化形式（2NF）？

## --answers--

所有非鍵屬性都傳遞相依於主鍵。

### --feedback--

思考當資料表具有複合主鍵時，第二正規化形式（2NF）所解決的問題。

---

所有非鍵屬性皆完全函式依賴於整個主鍵。

---

每個決定因素都是候選鍵。

### --feedback--

思考當資料表具有複合主鍵時，第二正規化形式（2NF）所解決的問題。

---

沒有重複的資料群組。

### --feedback--

思考當資料表具有複合主鍵時，第二正規化形式（2NF）所解決的問題。

## --video-solution--

2

## --text--

哪一種正規化表單處理傳遞相依性，即非鍵屬性依賴於另一個非鍵屬性？

## --answers--

第一正規化形式（1NF）

### --feedback--

思考這個正規形式旨在消除非鍵屬性與主鍵之間的間接關係。

---

第二正規化形式（2NF）

### --feedback--

思考這個正規形式旨在消除非鍵屬性與主鍵之間的間接關係。

---

第三正規化形式（3NF）

---

Boyce-Codd 正規形態（BCNF）

### --feedback--

思考這個正規形式旨在消除非鍵屬性與主鍵之間的間接關係。

## --video-solution--

3
