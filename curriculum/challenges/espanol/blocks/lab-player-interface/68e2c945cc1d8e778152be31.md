---
id: 68e2c945cc1d8e778152be31
title: Construye una Interfaz de Player
challengeType: 27
dashedName: build-a-player-interface
---

# --description--

**Objetivo:** Cumplir con las historias de usuario a continuación y pasar todas las pruebas para completar el laboratorio.

**Historias de usuario:**

1. Debes definir una clase abstracta llamada `Player` que herede de la clase `abc.ABC`.
1. The `Player` class should have an `__init__` method that sets:

   - El atributo `moves` a una lista vacía.
   - El atributo `position` a `(0, 0)`.
   - El atributo `path` a una lista que contiene la posición inicial.

1. The `Player` class should have a method named `make_move` that:

   - Usa `random.choice` para obtener un movimiento aleatorio del atributo `moves` (definido en la clase concreta).
   - Suma los valores del movimiento seleccionado a la posición actual y actualiza el atributo `position`.
   - Agrega la nueva tupla `position` al atributo `path`.
   - Devuelve la nueva `position`.

1. La clase `Player` debe tener un método abstracto llamado `level_up` que debe ser implementado en clases concretas.
1. Debes definir una clase `Pawn` que herede de la clase `Player`.
1. La clase `Pawn` debe usar `super()` para llamar al método `__init__` del padre y luego establecer el atributo `moves` como una lista de tuplas que representan las coordenadas `x, y`.
1. Cada tupla de coordenadas debe representar un movimiento de `1` unidad en las siguientes direcciones: arriba, abajo, izquierda, derecha.
1. La clase `Pawn` debe implementar un método concreto `level_up` agregando más movimientos al atributo `moves`. Los movimientos añadidos deben representar los cuatro movimientos diagonales (por ejemplo, `1` unidad hacia abajo más `1` unidad hacia la izquierda).

**Nota:** Los módulos de la biblioteca estándar deben importarse sin usar alias. Las pruebas relacionadas con la clase `Player` fallarán hasta que la clase `Pawn` pueda ser instanciada.

# --hints--

Debes tener una clase llamada `Player`.

```js
({ test: () => runPython(`assert _Node(_code).has_class("Player")`) })
```

La clase `Player` debe heredar de la clase `ABC` del módulo `abc`.

```js
({ test: () => runPython(`
from abc import ABC
import ast
cls = _Node(_code).find_class("Player")
assert cls.inherits_from("ABC") or cls.inherits_from("abc.ABC")
`) })
```

La clase `Player` debe tener un método `__init__`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("__init__")`) })
```

El método `__init__` de `Player` debe tener un solo parámetro `self`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("__init__").has_args("self")`) })
```

El método `__init__` de `Player` debe establecer `self.moves` como una lista vacía.

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.moves = []") or init.has_stmt("self.moves = list()")
`) })
```

El método `__init__` de `Player` debe establecer `self.position` en `(0, 0)`.

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.position = (0, 0)")
`) })
```

El método `__init__` de `Player` debe establecer `self.path` como una lista que contenga la posición inicial.

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.path = [self.position]")
`) })
```

La clase `Player` debe tener un método `make_move`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("make_move")`) })
```

El método `make_move` del `Player` debe tener un solo parámetro `self`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("make_move").has_args("self")`) })
```

El método `make_move` del `Player` debe usar `random.choice` para obtener un movimiento aleatorio del atributo `moves`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").block_has_call("choice", "make_move")`) })
```

El método `make_move` del `Player` debería actualizar el atributo `position` sumándole las coordenadas del movimiento seleccionado aleatoriamente.

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "Unable to instantiate Pawn"

  p.make_move()
  assert p.position == (1, 2)
  p.make_move()
  assert p.position == (2, 4)

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "missing import"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

El método `make_move` del `Player` debe agregar la nueva tupla `position` al atributo `path`.

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "Unable to instantiate Pawn"

  p.make_move()
  assert p.path == [(0, 0), (1, 2)]
  p.make_move()
  assert p.path == [(0, 0), (1, 2), (2, 4)]

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "missing import"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

El método `make_move` del `Player` debería devolver el atributo `position` actualizado.

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "Unable to instantiate Pawn"

  assert p.make_move() == (1, 2)

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "missing import"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

La clase `Player` debe tener un método `level_up`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("level_up")`) })
```

El método `level_up` de `Player` debe tener un solo parámetro `self`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("level_up").has_args("self")`) })
```

El método `level_up` del `Player` debería ser un método abstracto.

```js
({ test: () => runPython(`
target = _Node(_code).find_class("Player").find_function("level_up")
assert target.has_decorators("abstractmethod") or target.has_decorators("abc.abstractmethod")
`) })
```

La clase `Player` debería ser una clase abstracta.

```js
({ test: () => runPython(`
try:
  Player()
except TypeError as e:
  assert str(e) == "Can't instantiate abstract class Player with abstract method level_up"
else:
  assert False, "Player class should not be instantiable"
`) })
```

Debes tener una clase llamada `Pawn`.

```js
({ test: () => runPython(`assert _Node(_code).has_class("Pawn")`) })
```

La clase `Pawn` debe heredar de la clase `Player`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").inherits_from("Player")`) })
```

La clase `Pawn` debe tener un método `__init__`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").has_function("__init__")`) })
```

El método `__init__` de `Pawn` debe tener un solo parámetro `self`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").find_function("__init__").has_args("self")`) })
```

El método `__init__` de `Pawn` debe llamar al `__init__` del padre usando la función `super`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").find_function("__init__").has_stmt("super().__init__()")`) })
```

El método `__init__` de `Pawn` debe establecer el atributo `moves` como una lista de tuplas que representan coordenadas `x, y`, donde cada tupla de coordenadas representa un movimiento de `1` unidad en las siguientes direcciones: arriba, abajo, izquierda, derecha.

```js
({ test: () => runPython(`
p = Pawn()
moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]
assert isinstance(p.moves, list)
assert len(p.moves) == 4
assert all(move in p.moves for move in moves)
`) })
```

La clase `Pawn` debe tener un método `level_up`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").has_function("level_up")`) })
```

El método `level_up` de `Pawn` debería agregar el movimiento diagonal de `1` unidad a cada uno de los cuatro lados al atributo `moves`.

```js
({ test: () => runPython(`
p = Pawn()
moves = [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
p.level_up()
assert isinstance(p.moves, list)
assert len(p.moves) == 8
assert all(move in p.moves for move in moves)
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
from abc import ABC, abstractmethod
from random import choice


class Player(ABC):
    def __init__(self):
        self.moves = []
        self.position = (0, 0)
        self.path = [self.position]

    def make_move(self):
        x, y = self.position
        move = choice(self.moves)
        new_x = move[0] + x
        new_y = move[1] + y
        self.position = (new_x, new_y)
        self.path.append(self.position)
        return self.position

    @abstractmethod
    def level_up(self):
        pass


class Pawn(Player):
    def __init__(self):
        super().__init__()
        self.moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]

    def level_up(self):
        self.moves.extend([(1, 1), (1, -1), (-1, 1), (-1, -1)])
```
