---
id: 6723cdfa4ae237bf6b7e32eb
title: Revisión de Expresiones Regulares en JavaScript
challengeType: 31
dashedName: review-javascript-regular-expressions
---

# --description--

## Expresiones Regulares y Métodos Comunes

- **Definición**: Las expresiones regulares, o regex, se utilizan para crear un "patrón", que luego puedes usar para verificar una cadena, extraer texto y más.

```js
const regex = /freeCodeCamp/;
```

- **`test()` Método**: Este método acepta una cadena, que es la cadena para probar coincidencias con la expresión regular. Este método devolverá un booleano si la cadena coincide con el regex.

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test); // false
```

- **`match()` Método**: Este método acepta una expresión regular, aunque también puede pasar una cadena que se convertirá en una expresión regular. El método `match` devuelve la matriz de coincidencias para la cadena.

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match); // ["freeCodeCamp"]
```

- **`replace()` Método**: Este método acepta dos argumentos: la expresión regular para coincidir (o una cadena), y la cadena para reemplazar la coincidencia con (o una función para ejecutar contra cada coincidencia).

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced); // "freeCodeCamp is rly kewl"
```

- **`replaceAll` Método**: Este método se usa para reemplazar todas las ocurrencias de un patrón especificado con una nueva cadena. Este método lanzará un error si le da una expresión regular sin el modificador global.

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

- **`matchAll` Método**: Este método se utiliza para recuperar todas las coincidencias de una expresión regular dada en una cadena, incluidos los grupos de captura, y los devuelve como un iterador. Un iterador es un objeto que le permite recorrer (o "recorrer" en iterar) una colección de elementos.

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

## Modificadores de Expresiones Regulares

- **Definición**: Los modificadores, a menudo denominados "banderas", modifican el comportamiento de una expresión regular.
- **`i` Bandera**: Este indicador hace que un regex ignore el caso.

```js
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
```

- **`g` Bandera**: Este indicador, o el modificador global, permite que su expresión regular coincida con un patrón más de una vez.

```js
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
```

- **Definición de ancla **: El ancla `^`, al principio de la expresión regular, indica "coincidir con el inicio de la cadena". El ancla `$`, al final de la expresión regular, indica "coincidir con el final de la cadena".

```js
const start = /^freeCodeCamp/i;
const end = /freeCodeCamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
```

- **`m` Bandera**: Los anclajes buscan el principio y el final de toda la cadena. Pero puede hacer que un regex maneje múltiples líneas con el indicador `m`, o el modificador de múltiples líneas.

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const str = `I love 
freecodecamp
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true

```

- **`d` Bandera**: Este indicador amplía la información que recibe en un objeto de coincidencia.

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

- **`u` Bandera**: Esto expande la funcionalidad de una expresión regular para permitir que coincida con caracteres unicode especiales. El indicador `u` le da acceso a clases especiales como `Extended_Pictographic` para coincidir con la mayoría de los emojis. También hay un indicador `v`, que amplía aún más la funcionalidad de la coincidencia unicode.
- **`y` Bandera**: El modificador pegajoso se comporta de manera muy similar al modificador global, pero con algunas excepciones. La mayor es que una expresión regular global comenzará desde lastIndex y buscará en todo el resto de la cadena por otra coincidencia, pero una expresión regular pegajosa devolverá null y restablecerá el lastIndex a 0 si no hay inmediatamente una coincidencia en el último índice anterior.
- **`s` Bandera**: El modificador de una sola línea permite que un carácter comodín, representado por un `.` en regex, coincida con saltos de línea, tratando efectivamente la cadena como una sola línea de texto.

## Clases de Caracteres

- **Comodín `.`**: Las clases de caracteres son una sintaxis especial que puede usar para coincidir con conjuntos o subconjuntos de caracteres. La primera clase de caracteres que debes aprender es la clase de comodines. El comodín está representado por un punto o punto, y coincide con CUALQUIER solo carácter EXCEPTO los saltos de línea. Para permitir que la clase comodín coincida con saltos de línea, recuerda que necesitarías usar el indicador `s`.

```js
const regex = /a./;
```

- **`\d`**: Esto coincidirá con todos los dígitos (`0-9`) en una cadena.

```js
const regex = /\d/;
```

- **`\w`**: Esto se usa para coincidir con cualquier carácter de palabra (`a-z0-9_`) en una cadena. Un carácter de palabra se define como cualquier letra, de la a a la z, o un número del 0 al 9, o el carácter de subrayado.

```js
const regex = /\w/;
```

- **`\s`**: La clase de espacios en blanco `\s`, representada por una barra diagonal seguida de una `s`. Esta clase de caracteres coincidirá con cualquier espacio en blanco, incluidos los nuevos saltos de línea, espacios, tabulaciones y caracteres de espacio unicode especiales.
- **Negando Clases de Caracteres Especiales**: Para negar una de estas clases de caracteres, en lugar de usar una letra minúscula después de la barra diagonal, use el equivalente en mayúscula. El siguiente ejemplo no coincide con un carácter numérico. En cambio, coincide con cualquier único carácter que NO sea un carácter numérico.

```js
const regex = /\D/;
```

- **Clases de Caracteres Personalizadas**: Puede crear clases de caracteres personalizadas colocando el carácter que desea coincidir dentro de un conjunto de corchetes.

```js
const regex = /[abcdf]/;
```

## Afirmaciones de Anticipación y Retroceso

- **Definición**: Las afirmaciones de anticipación y retroceso le permiten coincidir con patrones específicos basados en la presencia o falta de patrones circundantes.
- **Afirmación de Anticipación Positiva**: Esta afirmación coincidirá con un patrón cuando el patrón sea seguido por otro patrón. Para construir una anticipación positiva, debe comenzar con el patrón que desea coincidir. Luego, use paréntesis para envolver el patrón que desea usar como su condición. Después del paréntesis de apertura, use `?=` para definir ese patrón como una anticipación positiva.

```js
const regex = /free(?=code)/i;
```

- **Afirmación de Anticipación Negativa**: Este es un tipo de condición utilizada en expresiones regulares para verificar que un cierto patrón no ocurra adelante en la cadena.

```js
const regex = /free(?!code)/i;
```

- **Afirmación de Retroceso Positiva**: Esta afirmación coincidirá con un patrón solo si es precedida por otro patrón específico, sin incluir el patrón precedente en la coincidencia.

```js
const regex = /(?<=free)code/i;
```

- **Afirmación de Retroceso Negativa**: Esta afirmación asegura que un patrón no es precedido por otro patrón específico. Coincide solo si el patrón especificado no es precedido inmediatamente por la secuencia dada, sin incluir la secuencia precedente en la coincidencia.

```js
const regex = /(?<!free)code/i;
```

## Cantidades de Regex

- **Definición**: Los cuantificadores en expresiones regulares especifican cuántas veces debe aparecer un patrón (o parte de un patrón). Ayudan a controlar el número de ocurrencias de caracteres o grupos en una coincidencia. El siguiente ejemplo se utiliza para coincidir el carácter anterior exactamente cuatro veces.

```js
const regex = /^\d{4}$/;
```

- **`*`** : Coincide con 0 o más ocurrencias del elemento precedente.
- **`+`**: Coincide con 1 o más ocurrencias del elemento precedente.
- **`?`**: Coincide con 0 o 1 ocurrencia del elemento anterior.
- **`{n}`**: Coincide exactamente con n ocurrencias del elemento anterior.
- **`{n,}`**: Coincide con n o más ocurrencias del elemento anterior.
- **`{n,m}`**: Coincide entre n y m ocurrencias del elemento anterior.

## Grupos de Captura y Retroreferencias

- **Grupos de captura**: Un grupo de captura te permite "capturar" una parte de la cadena coincidente para usarla según necesites. Los grupos de captura se definen por paréntesis que contienen el patrón a capturar, sin caracteres iniciales como una búsqueda anticipada.

```js
const regex = /free(code)camp/i;
```

- **Grupos No Captura**: Un grupo no captura es similar a un grupo de captura, pero no almacena la porción coincidente de la cadena para su uso posterior. Los grupos no captura se definen por `(?:...)`.

```js
const regex = /free(?:code)camp/i;
```

- **Retroreferencias**: Una retroreferencia en expresiones regulares se refiere a una forma de reutilizar una parte del patrón que se coincidió anteriormente en la misma expresión. Le permite referirse a un grupo de captura (una parte del patrón entre paréntesis) por su número. Por ejemplo, `$1` se refiere al primer grupo de captura.

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

- Puede usar retroreferencias dentro del propio regex para coincidir con el mismo texto capturado por un grupo anterior con una barra invertida y el número del grupo de captura. Por ejemplo:

```js
const regex = /(hello) \1/i;
console.log(regex.test("hello hello"));  // true
console.log(regex.test("hello world"));  // false
```

# --assignment--

Revise los temas y conceptos de Expresiones Regulares en JavaScript.
