---
id: 68829162a7f96d73c8505d3d
title: 什么是合并冲突，以及你如何解析它们？
challengeType: 19
dashedName: what-are-merge-conflicts-and-how-can-you-resolve-them
---

# --description--

如果你曾经接触过有经验的开发者，无论是在 `online` 社区还是面对面，你可能听说过“可怕的 merge conflicts”。但它们到底是什么？

好吧，当你使用像我们在之前课程中讨论的那样的正确分支策略时，你可能会同时在两个不同的分支上开发两个不同的特色。或者你正在做某件事，而同事正在另一个分支上工作。无论哪种情况，你都有两个独立的更改在进行。但有时，这两个分支都会编辑同一个文件。如果另一个分支先合并到 `main`，你的分支的更改就落后了。

大多数情况下，这可以通过将 `main` 合并回你的特色分支来修复。但当另一个分支的更改与你的分支发生冲突时，Git 无法在合并过程中判断你想保留哪些更改。这称为“合并冲突”。

但是你如何修复它？对于较小且较简单的冲突，GitHub 会为你提供一个网页 UI 来修复它。如果存在冲突，PR 底部会显示一个 `"Resolve conflicts"` 按钮。如果你点击它，你将看到包含你的代码和冲突代码的冲突文件。Git 会在你的代码和冲突代码周围添加“合并冲突标记”以帮助识别问题。它看起来像这样：

```sh
1 <<<<<<< feat/conflict
2 Here's some code from my first PR :)
3 =======
4 Here's some code that was merged to main that conflicts with the code on my PR
5 >>>>>>> main
```

起始标记是 `<<<<<<< feat/conflict`，表示当前分支所做更改的开始。然后我们看到 `Here's some code from my first PR :)`。接下来是 `=======` 标记，表示我们更改的结束和 `main` 分支更改的开始。我们可以看到 `main` 上的更改是 `Here's some code that was merged to main that conflicts with the code on my PR` 这一行。之后是结束冲突的关闭标记 `>>>>>> main`。

但是我们该如何修复它？你需要决定哪些更改要作为合并冲突的一部分保留。如果你想保留两个更改，可以只删除冲突标记而保持更改不变。或者，如果你只想保留某个分支的更改，你需要删除冲突标记和另一个分支的更改（即你不想保留的那些）。最后，如果你完全不喜欢任何更改，可以删除从起始标记到结束标记（包括标记本身）之间的所有内容。

让我们移除 `main` 分支的更改，但保留我们的更改。以下是我们现在的内容：

```sh
1 Here's some code from my first PR :)
```

点击 "Mark as resolved" 按钮，这表示你对你的解析感到满意。如果有其他文件，GitHub 会切换到下一个文件。但由于这是我们唯一有冲突的文件，你会看到一个 "Commit merge" 按钮出现。点击该按钮，GitHub 会为你创建一个合并提交。你将被带回拉取请求页面，在那里你会看到你的新合并提交和已解析的冲突。全部完成！

但是如果你不能直接在 GitHub 上编辑冲突，因为它们太复杂了，该怎么办？

如果你的分支有少量提交，或者只有几个提交修改了该文件，你可能能够将 `main` 合并到你的分支中：

```sh
git checkout feat/conflict
git fetch origin
git merge origin/main
```

当 Git 处理此合并时，你将遇到需要手动解析的冲突。Git 会通知你哪些文件需要修复。当我们在编辑器中打开有冲突的文件时，会看到相同的冲突标记，并且由于 VSCode 的帮助，界面还有一些有用的补充。继续以相同的方式修复文件中的冲突。但这一次，我们需要手动创建提交。它与创建任何其他提交相同：

```sh
git add .
git commit -m "chore: resolve conflicts"
```

运行这些命令后，我们可以看到 Git 已接受我们的方案。

有时，当你有许多提交或冲突时，变基会很有帮助。变基不是合并更改，而是将你分支上的所有提交重新应用，使它们位于 `main` 上的最新更改之后。在 Git 术语中，这实际上是将你的分支的基底“重置”到 `main` 上的最新提交。

为了进行实验，我们需要一个新建分支：

```sh
git checkout main
git pull
git checkout -b feat/rebase
```

让我们继续为我们的分支生成一堆提交，这样我们就可以练习变基：

```sh
echo "change one" > README.md
git add .
git commit -m "change one"
echo "change two" > README.md
git add .
git commit -m "change two"
echo "change three" > README.md
git add .
git commit -m "change three"
```

现在，让我们在 `main` 上再做一次更改以创建冲突：

```sh
git checkout main
echo "change four" > README.md
git add .
git commit -m "change four"
```

并且查看我们的 rebase 分支：

```sh
git checkout feat/rebase
```

接下来，运行 `git rebase -i main`。它会将我们的分支变基到当前 `main` 分支的状态。`-i` 标记告诉 Git 以交互模式执行变基。你会看到你的提交旁边有 `pick` 一词。`pick` 告诉 Git 在变基时按原样使用该提交。储存并关闭文件后，我们会收到一条告诉我们存在冲突的错误信息。

我们的 `change one` 提交与 `change four` 提交发生冲突，我们需要解析它。用你的编辑器打开文件，你会看到与之前冲突时相同的界面。让我们保留 `change one` 的更改。然后，你需要运行 `git add .` 来添加更改，运行 `git rebase --continue` 告诉 Git 我们准备继续变基。由于我们已经解析了第一个提交中的冲突，Git 可以自动处理剩余提交的变基。

现在，作为最后一点清理，让我们将三个变更提交碰撞成一个提交，以获得更清晰的历史。再次运行 `git rebase -i main` 进入编辑器。然后，保留第一个命令为 `pick`，但将接下来的两个改为 `squash`。你可能会再次遇到相同的冲突。如果遇到，请像之前一样解析它。一旦你解析并继续了变基（或者如果没有冲突，则立即），你将看到一个新的提交消息编辑器弹出。这个消息将是你的新提交，包含我们碰撞的三个提交的更改。让我们将其命名为 `change three complete`。储存并关闭编辑器，Git 将完成变基。

如果我们现在查看你的提交历史，可以看到我们现在只有一个 `change three complete` 提交，并且它正确地基于 `change four` 提交。这意味着你已经成功完成了带有碰撞提交的变基！现在你拥有了成为合并冲突冠军所需的工具！

# --questions--

## --text--

Git 添加的用于帮助识别冲突更改的合并冲突标记是什么？

## --answers--

`<<< current 分支`、`=== separator`、`>>> other 分支`

### --feedback--

考虑 Git 用于标记冲突开始、中间和结束的特定语法。

---

`[[ current 分支`, `|| separator`, `]] other 分支`

### --feedback--

考虑 Git 用于标记冲突开始、中间和结束的特定语法。

---

`<<<<<<< current 分支`，`======= separator`，`>>>>>>> other 分支`

---

`--- 当前分支`、`+++ 分隔符`、`--- 其他分支`

### --feedback--

考虑 Git 用于标记冲突开始、中间和结束的特定语法。

## --video-solution--

3

## --text--

在你的局部仓库中手动解决合并冲突后，你需要运行哪些命令来完成合并？

## --answers--

`git push origin main` 和 `git rebase -i origin/main`

### --feedback--

解决冲突后，你需要像处理任何其他提交一样暂存并提交已解析的更改。

---

`git add` 和 `git commit`

---

`git merge --abort` 和 `git commit`

### --feedback--

解决冲突后，你需要像处理任何其他提交一样暂存并提交已解析的更改。

---

`git reset --hard` 和 `git push -f`

### --feedback--

解决冲突后，你需要像处理任何其他提交一样暂存并提交已解析的更改。

## --video-solution--

2

## --text--

处理分支冲突时，合并和变基的主要区别是什么？

## --answers--

合并会创建一个新的提交，而变基会重写历史，将你的提交放在另一个分支的提交之后。

---

变基比合并更快。

### --feedback--

考虑每个 `operation` 如何影响 `commit` 历史。

---

合并只能在 GitHub 上完成，变基必须在本地完成。

### --feedback--

考虑每个 `operation` 如何影响 `commit` 历史。

---

没有区别，它们是相同的操作。

### --feedback--

考虑每个 `operation` 如何影响 `commit` 历史。

## --video-solution--

1
