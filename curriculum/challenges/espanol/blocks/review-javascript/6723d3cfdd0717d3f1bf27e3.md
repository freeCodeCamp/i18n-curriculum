---
id: 6723d3cfdd0717d3f1bf27e3
title: Revisión de JavaScript
challengeType: 31
dashedName: review-javascript
---

# --description--

Revise los conceptos a continuación para prepararse para el próximo examen de preparación.


## Trabajando con HTML, CSS y JavaScript

Mientras que HTML y CSS proporcionan la estructura del sitio web, JavaScript aporta interactividad a los sitios web, habilitando funciones complejas como el manejo de entrada de usuario, animación de elementos y construcción de aplicaciones web completas.

## Tipos de datos en JavaScript

Los tipos de datos ayudan al programa a entender el tipo de datos con los que está trabajando, ya sea un número, texto, o algo más.

- **Número**: Un número representa tanto valores enteros como de punto flotante. Los ejemplos de enteros incluyen 7, 19 y 90.
- **Punto flotante**: Un número de punto flotante es un número con punto decimal. Los ejemplos incluyen 3.14, 0.5 y 0.0001.
- **String**: Una string es una secuencia de caracteres, o texto, encerrada entre comillas. `"I like coding"` y `'JavaScript is fun'` son ejemplos de strings.
- **Booleano**: Un booleano representa uno de dos posibles valores: `true` o `false`. Puedes usar un booleano para representar una condición, como `isLoggedIn = true`.
- **Undefined y Null**: Un valor undefined es una variable que ha sido declarada pero no ha sido asignada un valor. Un valor null es un valor vacío o una variable a la que se le ha asignado intencionadamente el valor `null`.
- **Objeto**: Un objeto es una colección de pares clave-valor. La clave es el nombre de la propiedad y el valor es el valor de la propiedad.

Aquí, el objeto `pet` tiene tres propiedades o claves: `name`, `age` y `type`. Los valores son `Fluffy`, `3` y `dog`, respectivamente.

```js
let pet = {
  name: 'Fluffy',
  age: 3,
  type: 'dog'
};
```

- **Símbolo**: El tipo de dato Symbol es un valor único e inmutable que puede usarse como un identificador para propiedades de objetos.

En el ejemplo a continuación, se crean dos símbolos con la misma descripción, pero no son iguales.

```js
const crypticKey1= Symbol('saltNpepper');
const crypticKey2= Symbol('saltNpepper');
console.log(crypticKey1 === crypticKey2); // false
```

- **BigInt**: Cuando el número es demasiado grande para el tipo de dato `Number`, se puede usar el tipo de dato BigInt para representar enteros de longitud arbitraria.

Al agregar una `n` al final del número, puedes crear un BigInt.

```js
const veryBigNumber = 1234567890123456789012345678901234567890n;
```

## Variables en JavaScript

- Las variables pueden ser declaradas usando la palabra clave `let`.

```js
let cityName;
```

- Para asignar un valor a una variable, se puede usar el operador de asignación `=`.

```js
cityName = 'New York';
```

- Las variables declaradas usando `let` pueden ser reasignadas a un nuevo valor.

```js
cityName = 'Los Angeles';
console.log(cityName); // Los Angeles
```

- Además de `let`, se puede usar `const` para declarar una variable. Sin embargo, una variable `const` no puede ser reasignada a un nuevo valor.

```js
const cityName = 'New York';
cityName = 'Los Angeles'; // TypeError: Assignment to constant variable.
```

- Las variables declaradas usando `const` se utilizan para declarar constantes que no se permiten cambiar a lo largo del código, como `PI` o `MAX_SIZE`.

## Convenciones para la denominación de variables

- Los nombres de las variables deben ser descriptivos y significativos.
- Los nombres de variables deben ser camelCase como `cityName`, `isLoggedIn` y `veryBigNumber`.
- Los nombres de las variables no deben comenzar con un número. Deben comenzar con una letra, `_` o `$`.
- Los nombres de las variables no deben contener espacios ni caracteres especiales, excepto por `_` y `$`.
- Los nombres de las variables no deben ser palabras reservadas.
- Los nombres de variables distinguen entre mayúsculas y minúsculas. `age` y `Age` son variables diferentes.

## Cadenas e inmutabilidad de cadenas en JavaScript

- Las cadenas son secuencias de caracteres encerradas entre comillas. Se pueden crear usando comillas simples y comillas dobles.

```js
let correctWay = 'This is a string';
let alsoCorrect = "This is also a string";
```

- Las cadenas son inmutables en JavaScript. Esto significa que una vez creada una cadena, no se pueden cambiar los caracteres de la cadena. Sin embargo, aún se pueden reasignar cadenas a un nuevo valor.

```js
let firstName = 'John';
firstName = 'Jane'; // Reassigning the string to a new value
```

## Concatenación de Cadenas en JavaScript

- La concatenación es el proceso de unir múltiples cadenas o combinar cadenas con variables que contienen texto. El operador `+` es uno de los métodos más simples y frecuentemente utilizados para concatenar cadenas.

```js
let studentName = 'Asad';
let studentAge = 25;
let studentInfo = studentName + ' is ' + studentAge + ' years old.';
console.log(studentInfo); // Asad is 25 years old.
```

- Si necesitas agregar o adjuntar a una cadena existente, entonces puedes usar el operador `+=`. Esto es útil cuando deseas construir una cadena agregando más texto con el tiempo.

```js
let message = 'Welcome to programming, ';
message += 'Asad!';
console.log(message); // Welcome to programming, Asad!
```

- Otra forma de concatenar cadenas es usar el método `concat()`. Este método une dos o más cadenas.

```js
let firstName = 'John';
let lastName = 'Doe';
let fullName = firstName.concat(' ', lastName);
console.log(fullName); // John Doe
```

## Registro de Mensajes con `console.log()`

- El método `console.log()` se usa para registrar mensajes en la consola. Es una herramienta útil para depurar y probar tu código.

```js
console.log('Hello, World!');
// Output: Hello, World!
```

## Punto y Coma en JavaScript

- Los puntos y comas se usan principalmente para marcar el final de una sentencia. Esto ayuda al motor de JavaScript a entender la separación de instrucciones individuales, lo cual es crucial para una ejecución correcta.

```js
let message = 'Hello, World!'; // first statement ends here
let number = 42; // second statement starts here
```

- Los puntos y comas ayudan a prevenir ambigüedades en la ejecución del código y aseguran que las sentencias se terminen correctamente.

## Comentarios en JavaScript

- Cualquier línea de código que está comentada es ignorada por el motor de JavaScript. Los comentarios se usan para explicar el código, hacer notas o desactivar temporalmente el código.
- Los comentarios de una sola línea se crean utilizando `//`.

```js
// This is a single-line comment and will be ignored by the JavaScript engine
```

- Los comentarios de varias líneas se crean usando `/*` para iniciar el comentario y `*/` para finalizar el comentario.

```js
/*
This is a multi-line comment.
It can span multiple lines.
*/
```

## JavaScript como un Lenguaje de Tipado Dinámico

- JavaScript es un lenguaje de tipado dinámico, lo que significa que no necesitas especificar el tipo de dato de una variable cuando la declaras. El motor de JavaScript determina automáticamente el tipo de dato basado en el valor asignado a la variable.

```js
let error = 404; // JavaScript treats error as a number
error = "Not Found"; // JavaScript now treats error as a string
```

- Otros lenguajes, como C#, que no son de tipado dinámico, resultarían en un error:

```csharp
int error = 404; // value must always be an integer
error = "Not Found"; // This would cause an error in C#
```

## Uso del Operador `typeof`

- El operador `typeof` se usa para verificar el tipo de dato de una variable. Devuelve una cadena que indica el tipo de la variable.

```js
let age = 25;
console.log(typeof age); // number

let isLoggedIn = true;
console.log(typeof isLoggedIn); // boolean
```

- Sin embargo, hay una peculiaridad bien conocida en JavaScript cuando se trata de null. El operador `typeof` devuelve `object` para valores nulos.

```js
let user = null;
console.log(typeof user); // object
```

## Conceptos Básicos de Cadenas

- **Definición**: Una cadena es una secuencia de caracteres envuelta en comillas simples, dobles o acentos graves. Las cadenas son tipos de datos primitivos y son inmutables. La inmutabilidad significa que una vez creada una cadena, no se puede cambiar.
- **Accediendo a los Caracteres de una Cadena**: Para acceder a un carácter de una cadena puedes usar la notación de corchetes e introducir el número de índice. Un índice es la posición de un carácter dentro de una cadena, y es basado en cero.

```js
const developer = "Jessica";
developer[0] // J
```

- **`\n` (Carácter de Nueva Línea)**: Puedes crear una nueva línea en una cadena usando el carácter de nueva línea `\n`.

```js
const poem = "Roses are red,\nViolets are blue,\nJavaScript is fun,\nAnd so are you.";
console.log(poem);
```

- **Escapando Cadenas**: Puedes escapar caracteres en una cadena colocando barras invertidas (`\`) delante de las comillas.

```js
const statement = "She said, \"Hello!\"";
console.log(statement); // She said, "Hello!"
```
  
## Literales de Plantilla (Cadenas de Plantilla) e Interpolación de Cadenas

- **Definición**: Los literales de plantilla se definen con acentos graves (`). Permiten una manipulación de cadenas más sencilla, incluido el incrustar variables directamente dentro de una cadena, una característica conocida como interpolación de strings.

```js
const name = "Jessica";
const greeting = `Hello, ${name}!`; // "Hello, Jessica!"
```

## ASCII, el Método `charCodeAt()` y el Método `fromCharCode()`

- **ASCII**: ASCII, abreviatura de American Standard Code for Information Interchange, es un estándar de codificación de caracteres utilizado en computadoras para representar texto. Asigna un valor numérico a cada carácter, lo cual es reconocido universalmente por las máquinas.
- **El Método `charCodeAt()`**: Este método se llama en una cadena y devuelve el código ASCII del carácter en un índice especificado.

```js
const letter = "A";
console.log(letter.charCodeAt(0));  // 65
```

- **El Método `fromCharCode()`**: Este método convierte un código ASCII en su carácter correspondiente.

```js
const char = String.fromCharCode(65);
console.log(char);  // A
```

## Otros Métodos Comunes de Cadenas

- **El Método `indexOf`**: Este método se utiliza para buscar una subcadena dentro de una cadena. Si se encuentra la subcadena, `indexOf` devuelve el índice (o posición) de la primera aparición de esa subcadena. Si no se encuentra la subcadena, `indexOf` devuelve -1, lo que indica que la búsqueda no tuvo éxito.

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.indexOf("fox")); // 16
console.log(text.indexOf("cat")); // -1
```
  
- **El Método `includes()`**: Este método se utiliza para verificar si una cadena contiene una subcadena específica. Si se encuentra la subcadena dentro de la cadena, el método devuelve verdadero. De lo contrario, devuelve falso.

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.includes("fox")); // true
console.log(text.includes("cat")); // false
```

- El **método `slice()`**: Este método devuelve un nuevo arreglo que contiene una copia superficial de una porción del arreglo original, especificada por los índices de inicio y fin. El nuevo arreglo contiene referencias a los mismos elementos que el arreglo original (no duplicados). Esto significa que si los elementos son primitivos (como números o cadenas), los valores se copian; pero si los elementos son objetos o arreglos, se copian las referencias, no los objetos en sí.

```js
const text = "freeCodeCamp";
console.log(text.slice(0, 4));  // "free"
console.log(text.slice(4, 8));  // "Code"
console.log(text.slice(8, 12)); // "Camp"
```

- **El Método `toUpperCase()`**: Este método convierte todos los caracteres a letras mayúsculas y devuelve una nueva cadena con todos los caracteres en mayúscula.

```js
const text = "Hello, world!";
console.log(text.toUpperCase()); // "HELLO, WORLD!"
```

- **El Método `toLowerCase()`**: Este método convierte todos los caracteres de una cadena a minúsculas.

```js
const text = "HELLO, WORLD!"
console.log(text.toLowerCase()); // "hello, world!"
```

- **El método `replace()`**: Este método te permite encontrar un valor especificado (como una palabra o carácter) en una cadena y reemplazarlo con otro valor. El método devuelve una nueva cadena con el reemplazo y deja la original sin cambios porque las cadenas en JavaScript son inmutables.

```js
const text = "I like cats";
console.log(text.replace("cats", "dogs")); // "I like dogs"
```
 
- **El Método `repeat()`**: Este método se utiliza para repetir una cadena un número especificado de veces.

```js
const text = "Hello";
console.log(text.repeat(3)); // "HelloHelloHello"
```

- **El Método `trim()`**: Este método se utiliza para eliminar espacios en blanco tanto del principio como del final de una cadena.

```js
const text = "  Hello, world!  ";
console.log(text.trim()); // "Hello, world!"
```

- **El Método `trimStart()`**: Este método elimina los espacios en blanco del inicio (o "comienzo") de la cadena.

```js
const text = "  Hello, world!  ";
console.log(text.trimStart()); // "Hello, world!  "
```

- **El Método `trimEnd()`**: Este método elimina los espacios en blanco del final de la cadena.

```js
const text = " Hello, world! ";
console.log(text.trimEnd()); // "  Hello, world!"
```

- **El Método `prompt()`**: Este método del `window` se utiliza para obtener información de un usuario a través de un cuadro de diálogo. Este método toma dos argumentos. El primer argumento es el mensaje que aparecerá dentro del cuadro de diálogo, típicamente pidiendo al usuario que ingrese información. El segundo es un valor predeterminado que es opcional y llenará el campo de entrada inicialmente.

```js
const answer = window.prompt("What's your favorite animal?"); // This will change depending on what the user answers
```

## Trabajando con el Tipo de Dato Número

- **Definición**: El tipo `Number` de JavaScript incluye enteros, números de coma flotante, `Infinity` y `NaN`. Los números de coma flotante son números con un punto decimal.  Positive `Infinity` is a number greater than any other number while `-Infinity` is a number smaller than any other number. `NaN` (`Not a Number`) represents an invalid numeric value like the string `"Jessica"`.

## Operaciones Aritméticas Comunes

- **Operador de Suma**: Este operador (`+`) se utiliza para calcular la suma de dos o más números.
- **Operador de Resta**: Este operador (`-`) se utiliza para calcular la diferencia entre dos números.
- **Operador de Multiplicación**: Este operador (`*`) se utiliza para calcular el producto de dos o más números.
- **Operador de División**: Este operador (`/`) se utiliza para calcular el cociente entre dos números.
- **División por Cero**: Si intentas dividir por cero, JavaScript devolverá `Infinity`.
- **Operador de Resto**: Este operador (`%`) devuelve el resto de una división.
- **Operador de Exponenciación**: Este operador (`**`) eleva un número a la potencia de otro.

## Cálculos con Números y Cadenas

- **Explicación**: Cuando usas el operador `+` con un número y una cadena, JavaScript convertirá el número en una cadena y concatenará los dos valores. Cuando usas los operadores `-`, `*` o `/` con una cadena y un número, JavaScript convertirá la cadena en un número y el resultado será un número. Para `null` y `undefined`, JavaScript trata `null` como 0 y `undefined` como `NaN` en operaciones matemáticas.

```js
const result = 5 + '10';

console.log(result); // 510
console.log(typeof result); // string

const subtractionResult = '10' - 5;
console.log(subtractionResult); // 5
console.log(typeof subtractionResult); // number

const multiplicationResult = '10' * 2;
console.log(multiplicationResult); // 20
console.log(typeof multiplicationResult); // number

const divisionResult = '20' / 2;
console.log(divisionResult); // 10
console.log(typeof divisionResult); // number

const result1 = null + 5;
console.log(result1); // 5
console.log(typeof result1); // number

const result2 = undefined + 5;
console.log(result2); // NaN
console.log(typeof result2); // number
```

## Precedencia de Operadores

- **Definición**: La precedencia de operadores determina el orden en el que las operaciones se evalúan en una expresión. Los operadores con mayor precedencia se evalúan antes que los de menor precedencia. Los valores dentro del paréntesis se evaluarán primero y la multiplicación/división tendrá mayor precedencia que la suma/resta. Si los operadores tienen la misma precedencia, entonces JavaScript utilizará la asociatividad. La asociatividad es lo que le dice a JavaScript si debe evaluar operadores de izquierda a derecha o de derecha a izquierda. Por ejemplo, el operador de exponenciación también es asociado de derecha a izquierda:

```js
const result = (2 + 3) * 4;

console.log(result); // 20

const result2 = 10 - 2 + 3;

console.log(result2); // 11

const result3 = 2 ** 3 ** 2;

console.log(result3); // 512
```

## Operadores de Incremento y Decremento

- **Operador de Incremento**: Este operador se utiliza para aumentar el valor en uno. La notación prefija `++num` incrementa el valor de la variable primero, luego devuelve un nuevo valor. La notación postfija `num++` devuelve el valor actual de la variable primero, luego la incrementa.

```js
let x = 5;

console.log(++x); // 6
console.log(x); // 6


let y = 5;

console.log(y++); // 5
console.log(y); // 6
```

- **Operador de Decremento**: Este operador se utiliza para disminuir el valor en uno. La notación de prefijo y sufijo funciona de la misma manera que antes con el operador de incremento.

```js
let num = 5;

console.log(--num); // 4
console.log(num--); // 4
console.log(num); // 3
```

## Operadores de Asignación Compuesta

- **Operador de Asignación de Suma (`+=`)**: Este operador realiza la suma sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de Resta (`-=`)**: Este operador realiza la resta sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de Multiplicación (`*=`)**: Este operador realiza la multiplicación sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de División (`/=`)**: Este operador realiza la división sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de Resto (`%=`)**: Este operador divide una variable por el número especificado y asigna el resto a la variable.
- **Operador de Asignación de Exponenciación (`**=`)**: Este operador eleva una variable a la potencia del número especificado y reasigna el resultado a la variable.

## Booleanos y Igualdad

- **Definición de Booleano**: Un booleano es un tipo de dato que solo puede tener dos valores: `true` o `false`.
- **Operador de Igualdad (`==`)**: Este operador utiliza la coerción de tipo antes de verificar si los valores son iguales.

```js
console.log(5 == '5'); // true
```

- **Operador de Estricta Igualdad (`===`)**: Este operador no realiza coerción de tipos y verifica si ambos, tanto los tipo como los valores, son iguales.

```js
console.log(5 === '5'); // false
```

- **Operador de Desigualdad (`!=`)**: Este operador utiliza la coerción de tipo antes de verificar si los valores no son iguales.
- **Operador de Desigualdad Estricta (`!==`)**: Este operador no realiza la coerción de tipos y verifica si tanto los tipos como los valores no son iguales.

## Operadores de Comparación

- **Operador Mayor Que (`>`)**: Este operador verifica si el valor a la izquierda es mayor que el de la derecha.
- **Operador Mayor o Igual (`>=`)**: Este operador verifica si el valor a la izquierda es mayor o igual que el de la derecha.
- **Operador Menor Que (`<`)**: Este operador verifica si el valor a la izquierda es menor que el de la derecha.
- **Operador Menor Que (`<=`) o Igual**: Este operador verifica si el valor a la izquierda es menor o igual que el de la derecha.

## Operadores Unarios

- **Operador Más Unario**: Este operador convierte a su operando en un número. Si el operando ya es un número, permanece sin cambios.

```js
const str = '42';
const num = +str;

console.log(num); // 42
console.log(typeof num); // number
```

- **Operador Negación Unaria (`-`)**: Este operador niega el operando.

```js
const num = 4;
console.log(-num); // -4
```

- **Operador Lógico NO (`!`)**: Este operador invierte el valor booleano de su operando. Por lo tanto, si el operando es `true`, se convierte en `false`, y si es `false`, se convierte en `true`.

## Operadores Bit a Bit

- **Operador AND a nivel de bits (`&`)**: Este operador devuelve un 1 en cada posición de bit para la cual los bits correspondientes de ambos operandos son 1.
- **Operador de Asignación AND a Nivel de Bits (`&=`)**: Este operador realiza una operación de `bitwise AND` con el número especificado y reasigna el resultado a la variable.
- **Operador O Bit a Bit (`|`)**: Este operador devuelve un 1 en cada posición de bit para la cual los bits correspondientes de cualquiera o ambos operandos son 1.
- **Asignación OR a Nivel de Bit (Operador `|=`)**: Este operador realiza una operación `OR a nivel de bit` con el número especificado y reasigna el resultado a la variable.
- **Operador XOR a Nivel de Bit (`^`)**: Este operador devuelve un 1 en cada posición de bit para la cual los bits correspondientes de cualquiera de los operandos son 1, pero no ambos.
- **Operador NOT a Nivel de Bit (`~`)**: Este operador invierte la representación binaria de un número.
- **Operador de desplazamiento a la izquierda (`<<`)**: Este operador desplaza todos los bits hacia la izquierda un número especificado de posiciones.
- **Operador de desplazamiento a la derecha (`>>`)**: Este operador desplaza todos los bits hacia la derecha.

## Condicionales, Valores Verídicos, Valores Falsos y el Operador Ternario

- **`if/else if/else`**: Una declaración `if` toma una condición y ejecuta un bloque de código si esa condición es `verdadera`. Si la condición es `false`, entonces se mueve al bloque `else if`.  If none of those conditions are `true`, then it will execute the `else` clause. `Truthy` values are any values that result in `true` when evaluated in a Boolean context like an `if` statement. `Falsy` values are values that evaluate to `false` in a Boolean context.

```js
const score = 87;

if (score >= 90) {
 console.log('You got an A'); 
} else if (score >= 80) {
 console.log('You got a B'); // You got an B
} else if (score >= 70) {
 console.log('You got a C');
} else {
 console.log('You failed! You need to study more!');
}
```

- **Operador Ternario**: Este operador se utiliza frecuentemente como una manera más corta de escribir declaraciones `if else`.

```js
const temperature = 30;
const weather = temperature > 25 ? 'sunny' : 'cool';

console.log(`It's a ${weather} day!`); // It's a sunny day!
```

## Operadores Lógicos Binarios

- **Logical AND (`&&`) Operator**: This operator checks if both operands are truthy. Si el primer valor es truthy, entonces devolverá el segundo valor. Si el primer valor es falsy, entonces devolverá el primer valor.

```js
const result = true && 'hello';

console.log(result); // hello
```

- **Operador OR lógico (`||`)**: Este operador verifica si al menos uno de los operandos es verdadero. Si el primer valor es verdadero, entonces se devuelve. Si el primer valor es falso, entonces se devuelve el segundo valor.
- **Operador de Coalescencia Nula (`??`)**: Este operador devolverá un valor solo si el primero es `null` o `undefined`.

```js
const userSettings = {
 theme: null,
 volume: 0,
 notifications: false,
};

let theme = userSettings.theme ?? 'light';
console.log(theme); // light
```

## El Objeto `Math`

- **El Método `Math.random()`**: Este método genera un número flotante aleatorio entre 0 (inclusivo) y 1 (exclusivo). Esto significa que el resultado posible puede ser 0, pero nunca llegará a 1.
- **El método `Math.max()`**: Este método toma un conjunto de números y devuelve el valor máximo.
- **El método `Math.min()`**: Este método toma un conjunto de números y devuelve el valor mínimo.
- **El Método `Math.ceil()`**: Este método redondea un valor hacia arriba al número entero más cercano.
- **El Método `Math.floor()`**: Este método redondea un valor hacia abajo hasta el número entero más cercano.
- **El Método `Math.round()`**: Este método redondea un valor al número entero más cercano.

```js
console.log(Math.round(2.3)); // 2
console.log(Math.round(4.5)); // 5
console.log(Math.round(4.8)); // 5
```

- **El Método `Math.trunc()`**: Este método elimina la parte decimal de un número, devolviendo solo la parte entera, sin redondear.
- **El Método `Math.sqrt()`**: Este método devolverá la raíz cuadrada de un número.
- **El Método `Math.cbrt()`**: Este método devolverá la raíz cúbica de un número.
- **El Método `Math.abs()`**: Este método devolverá el valor absoluto de un número.
- **El Método `Math.pow()`**: Este método toma dos números y eleva el primero a la potencia del segundo.

## Métodos Comunes para Números

- **`isNaN()`**: `NaN` significa "No-es-un-Número". Es un valor especial que representa un resultado numérico que no es representable o está indefinido.  The `isNaN()` function property is used to determine whether a value is `NaN` or not.  `Number.isNaN()` provides a more reliable way to check for `NaN` values, especially in cases where type coercion might lead to unexpected results with the global `isNaN()` function.

```js
console.log(isNaN(NaN));       // true
console.log(isNaN(undefined)); // true
console.log(isNaN({}));        // true

console.log(isNaN(true));      // false
console.log(isNaN(null));      // false
console.log(isNaN(37));        // false


console.log(Number.isNaN(NaN));        // true
console.log(Number.isNaN(Number.NaN)); // true
console.log(Number.isNaN(0 / 0));      // true

console.log(Number.isNaN("NaN"));      // false
console.log(Number.isNaN(undefined));  // false
```

- **El Método `parseFloat()`**: Este método analiza una cadena y devuelve un número de punto flotante. Está diseñado para extraer un número del comienzo de una cadena, incluso si la cadena contiene caracteres no numéricos más adelante.
- **The `parseInt()` Method**: This method parses a string argument and returns an integer. `parseInt()` stops parsing at the first non-digit it encounters. Para números de punto flotante, solo devuelve la parte entera. Si no puede encontrar un entero válido al inicio de la cadena, devuelve `NaN`.
- **El Método `toFixed()`**: Este método se llama en un número y toma un argumento opcional, que es el número de dígitos que aparecerán después del punto decimal. Devuelve una representación en cadena del número con el número especificado de decimales.

## Comparaciones y los Tipos de Datos `null` y `undefined`

- **Comparaciones y `undefined`**: Una variable es `undefined` cuando ha sido declarada pero no se le ha asignado un valor. Es el valor predeterminado de variables no inicializadas y parámetros de función a los que no se les proporcionó un argumento. `undefined` se convierte en `NaN` en contextos numéricos, lo que hace que todas las comparaciones numéricas con `undefined` devuelvan `false`.

```js
console.log(undefined < 0); // false (NaN < 0 is false)
console.log(undefined >= 0); // false (NaN >= 0 is false)
```

- **Comparaciones y `null`**: El tipo `null` representa la ausencia intencional de un valor. `null` se convierte en `0` en contextos numéricos, lo que puede resultar en un comportamiento inesperado en comparaciones numéricas:

```js
console.log(null < 0); // false (0 < 0 is false)
console.log(null >= 0); // true (0 >= 0 is true)
```

- Al usar el operador de igualdad (`==`), `null` y `undefined` solo son iguales entre sí y a sí mismos:

```js
console.log(null == undefined); // true
console.log(null == 0); // false
console.log(undefined == NaN); // false
```

- Sin embargo, al usar el operador de igualdad estricta (`===`), que verifica tanto el valor como el tipo sin realizar coerción de tipos, `null` y `undefined` no son iguales:

```js
console.log(null === undefined); // false
```

## Instrucciones `switch`

- **Definición**: Una instrucción `switch` evalúa una expresión y compara su valor con una serie de cláusulas `case`. Cuando se encuentra una coincidencia, se ejecuta el bloque de código asociado con ese caso.

```js
const dayOfWeek = 3; 

switch (dayOfWeek) {
  case 1:
    console.log("It's Monday! Time to start the week strong.");
    break;
  case 2:
    console.log("It's Tuesday! Keep the momentum going.");
    break;
  case 3:
    console.log("It's Wednesday! We're halfway there.");
    break;
  case 4:
    console.log("It's Thursday! Almost the weekend.");
    break;
  case 5:
    console.log("It's Friday! The weekend is near.");
    break;
  case 6:
    console.log("It's Saturday! Enjoy your weekend.");
    break;
  case 7:
    console.log("It's Sunday! Rest and recharge.");
    break;
  default:
    console.log("Invalid day! Please enter a number between 1 and 7.");
}
```

## Funciones de JavaScript

- Las funciones son bloques de código reutilizables que realizan una tarea específica.
- Las funciones se pueden definir usando la palabra clave `function` seguida de un nombre, una lista de parámetros y un bloque de código que realiza la tarea.
- Los argumentos son valores pasados a una función cuando es llamada.
- Cuando una función termina su ejecución, siempre devolverá un valor.
- Por defecto, el valor de retorno de una función es `undefined`.
- La palabra clave `return` se usa para especificar el valor que se devolverá de la función y finaliza la ejecución de la función.

## Funciones de flecha

- Las funciones de flecha son una forma más concisa de escribir funciones en JavaScript.
- Las funciones flecha se definen usando la sintaxis `=>` entre los parámetros y el cuerpo de la función.
- Al definir una función de flecha, no necesitas la palabra clave `function`.
- Si estás usando un solo parámetro, puedes omitir los paréntesis alrededor de la lista de parámetros.
- Si el cuerpo de la función consiste en una sola expresión, puedes omitir las llaves y la palabra clave `return`.

## Alcance en Programación

- **Ámbito global**: Este es el alcance más externo en JavaScript. Las variables declaradas en el ámbito global son accesibles desde cualquier parte del código y se conocen como variables globales.
- **Ámbito local**: Esto refiere a variables declaradas dentro de una función. Estas variables son accesibles solo dentro de la función donde se declaran y se conocen como variables locales.
- **Ámbito de bloque**: Un bloque es un conjunto de declaraciones encerradas entre llaves `{}`, como en sentencias `if` o bucles.
- El alcance de bloque con `let` y `const` proporciona un control aún más fino sobre la accesibilidad de las variables, ayudando a prevenir errores y haciendo que su código sea más predecible.

## Conceptos básicos de arreglos de JavaScript

- **Definición**: Un arreglo en JavaScript es una colección ordenada de valores, cada uno identificado por un índice numérico. Los valores en un array de JavaScript pueden ser de diferentes tipos de datos, incluidos números, cadenas, booleanos, objetos e incluso otros arrays. Los arreglos son continuos en memoria, lo que significa que todos los elementos se almacenan en un único bloque continuo de ubicaciones de memoria, lo que permite una indexación eficiente y un acceso rápido a los elementos por su índice.

```js
const developers = ["Jessica", "Naomi", "Tom"];
```

- **Accediendo a Elementos de Arreglos**: Para acceder a elementos de un arreglo, necesitarás hacer referencia al arreglo seguido de su número de índice dentro de corchetes. Los arreglos de JavaScript están indexados desde cero, lo que significa que el primer elemento está en el índice 0, el segundo elemento está en el índice 1, etc. Si intentas acceder a un índice que no existe para el arreglo, JavaScript devolverá `undefined`.

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers[0] // "Jessica"
developers[1] // "Naomi"

developers[10] // undefined
```

- **Propiedad `length`**: Esta propiedad se utiliza para devolver el número de elementos en un arreglo.

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers.length // 3
```

- **Actualizando Elementos en un Arreglo**: Para actualizar un elemento en un arreglo, utilizas el operador de asignación (`=`) para asignar un nuevo valor al elemento en un índice específico.

```js
const fruits = ['apple', 'banana', 'cherry'];
fruits[1] = 'blueberry';

console.log(fruits); // ['apple', 'blueberry', 'cherry']
```

## Arreglos bidimensionales

- **Definición**: Un arreglo bidimensional es esencialmente un arreglo de arreglos. Se usa para representar datos que tienen una estructura natural en forma de cuadrícula, como un tablero de ajedrez, una hoja de cálculo o los píxeles de una imagen. Para acceder a un elemento en un arreglo bidimensional, necesitas dos índices: uno para la fila y otro para la columna.

```js
const chessboard = [
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']
];

console.log(chessboard[0][3]); // "Q"
```

## Desestructuración de Arreglos

- **Definición**: La desestructuración de arreglos es una característica en JavaScript que te permite extraer valores de arreglos y asignarlos a variables de una manera más concisa y legible. Proporciona una sintaxis conveniente para desempaquetar elementos de un arreglo en variables distintas.

```js
const fruits = ["apple", "banana", "orange"];

const [first, second, third] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(third); // "orange"
```

- **Sintaxis de propagación**: Esto te permite capturar los elementos restantes de un arreglo que no han sido desestructurados en un nuevo arreglo.

```js
const fruits = ["apple", "banana", "orange", "mango", "kiwi"];
const [first, second, ...rest] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(rest); // ["orange", "mango", "kiwi"]
```

## Métodos Comunes de Arreglos

- **Método `push()`**: Este método se utiliza para agregar elementos al final del arreglo y devolverá la nueva longitud.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.push("ice cream");

console.log(desserts); // ["cake", "cookies", "pie", "ice cream"];
```

- **Método `pop()`**: Este método se utiliza para eliminar el último elemento de un arreglo y devolverá ese elemento eliminado. Si el arreglo está vacío, entonces el valor devuelto será `undefined`.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.pop();

console.log(desserts); // ["cake", "cookies"];
```

- **Método `shift()`**: Este método se utiliza para eliminar el primer elemento de un arreglo y devolver ese elemento eliminado. Si el arreglo está vacío, entonces el valor devuelto será `undefined`.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.shift();

console.log(desserts); // ["cookies", "pie"];
```

- **Método `unshift()`**: Este método se utiliza para agregar elementos al inicio del arreglo y devolverá la nueva longitud.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.unshift("ice cream");

console.log(desserts); // ["ice cream", "cake", "cookies", "pie"];
```

- **Método `indexOf()`**: Este método es útil para encontrar el primer índice de un elemento específico dentro de un arreglo. Si no se puede encontrar el elemento, entonces devolverá `-1`.

```js
const fruits = ["apple", "banana", "orange", "banana"];
const index = fruits.indexOf("banana");

console.log(index); // 1
console.log(fruits.indexOf("not found")); // -1
```

- **Método `splice()`**: Este método se utiliza para agregar o eliminar elementos desde cualquier posición en un arreglo. El valor de retorno para el método `splice()` será un arreglo de los elementos eliminados del arreglo. Si no se eliminó nada, entonces se devolverá un arreglo vacío. Este método modificará el arreglo original, alterándolo en su lugar en vez de crear uno nuevo. El primer argumento especifica el índice en el que se comenzará a modificar el arreglo. El segundo argumento es el número de elementos que deseas eliminar. Los siguientes argumentos son los elementos que deseas agregar.

```js
const colors = ["red", "green", "blue"];
colors.splice(1, 0, "yellow", "purple");

console.log(colors); // ["red", "yellow", "purple", "green", "blue"]
```

- **Método `includes()`**: Este método se utiliza para verificar si un arreglo contiene un valor específico. Este método devuelve `true` si el arreglo contiene el elemento especificado, y `false` de lo contrario.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];

console.log(programmingLanguages.includes("Python")); // true
console.log(programmingLanguages.includes("Perl")); // false
```

- **Método `concat()`**: Este método crea un nuevo arreglo fusionando dos o más arreglos.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.concat("Perl");

console.log(newList); // ["JavaScript", "Python", "C++", "Perl"]
```

- **Método `slice()`**: Este método devuelve una copia superficial de una porción del arreglo, comenzando desde un índice especificado o del arreglo completo. Una copia superficial copiará la referencia al arreglo en lugar de duplicarlo.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.slice(1);

console.log(newList); // ["Python", "C++"]
```

- **Sintaxis de Propagación**: La sintaxis de propagación se utiliza para crear copias superficiales de un arreglo.

```js
const originalArray = [1, 2, 3];
const shallowCopiedArray = [...originalArray];

shallowCopiedArray.push(4);

console.log(originalArray); // [1, 2, 3]
console.log(shallowCopiedArray); // [1, 2, 3, 4]
```

- **Método `split()`**: Este método divide una cadena en un arreglo de subcadenas y especifica dónde debe ocurrir cada división según un separador dado. Si no se proporciona un separador, el método devuelve un arreglo que contiene la cadena original como un único elemento.

```js
const str = "hello";
const charArray = str.split("");

console.log(charArray); // ["h", "e", "l", "l", "o"]
```

- **Método `reverse()`**: Este método invierte un arreglo en su lugar.

```js
const desserts = ["cake", "cookies", "pie"];
console.log(desserts.reverse()); // ["pie", "cookies", "cake"]
```

- **Método `join()`**: Este método concatena todos los elementos de un arreglo en una sola cadena, con cada elemento separado por un separador especificado. Si no se proporciona un separador, o se usa una cadena vacía (`""`), los elementos se unirán sin ningún separador.

```js
const reversedArray = ["o", "l", "l", "e", "h"];
const reversedString = reversedArray.join("");

console.log(reversedString); // "olleh"
```

## Aspectos básicos del objeto

- **Definición**: Un objeto es una estructura de datos compuesta por propiedades. Una propiedad consta de una clave y un valor. Para acceder a los datos de un objeto, puedes usar notación de puntos o notación de corchetes.

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};

console.log(person.name);  // Alice
console.log(person["name"]); // Alice
```

Para establecer una propiedad de un objeto existente, puedes usar notación de puntos o notación de corchetes junto con el operador de asignación.

```js
const person = {
  name: "Alice",
  age: 30
};

person.job = "Engineer"
person["hobby"] = "Knitting"
console.log(person);  // {name: 'Alice', age: 30, job: 'Engineer', hobby: 'Knitting'}
```

## Eliminar propiedades de un objeto

- **`Operador delete`**: Este operador se utiliza para eliminar una propiedad de un objeto.

```js
const person = {
  name: "Alice",
  age: 30,
  job: "Engineer"
};

delete person.job;

console.log(person.job); // undefined
```

## Comprobar si un objeto tiene una propiedad

- **`Método hasOwnProperty()`**: Este método devuelve un booleano que indica si el objeto tiene la propiedad especificada como su propia propiedad.

```js
const person = {
  name: "Alice",
  age: 30
};

console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("job")); // false
```

- **`Operador in`**: Este operador devolverá `true` si la propiedad existe en el objeto.

```js
const person = {
  name: "Bob",
  age: 25
};

console.log("name" in person);  // true
```

## Acceder a propiedades de objetos anidados

- **Acceso a datos**: Acceder a propiedades de objetos anidados implica usar la notación de puntos o la notación de corchetes, similar a acceder a propiedades de objetos simples. Sin embargo, necesitarás encadenar estos accesos para descender a la estructura anidada.

```js
const person = {
  name: "Alice",
  age: 30,
  contact: {
    email: "alice@example.com",
    phone: {
      home: "123-456-7890",
      work: "098-765-4321"
    }
  }
};

console.log(person.contact.phone.work); // "098-765-4321"
```

## Tipos de datos primitivos y no primitivos

- **Tipos de datos primitivos**: Estos tipos de datos incluyen números, cadenas, booleanos, `null`, `undefined` y símbolos. Estos tipos se llaman "primitivos" porque representan valores únicos y no son objetos. Los valores primitivos son inmutables, lo que significa que una vez creados, su valor no puede cambiarse.
- **Tipos de datos no primitivos**: En JavaScript, estos son objetos, que incluyen objetos regulares, arreglos y funciones. A diferencia de los primitivos, los tipos no primitivos pueden contener múltiples valores como propiedades o elementos.

## Métodos de objeto

- **Definición**: Los métodos de objeto son funciones que están asociadas con un objeto. Se definen como propiedades de un objeto y pueden acceder y manipular los datos del objeto. La palabra clave `this` dentro del método se refiere al propio objeto, permitiendo acceder a sus propiedades.

```js
const person = {
  name: "Bob",
  age: 30,
  sayHello: function() {
    return "Hello, my name is " + this.name;
  }
};

console.log(person.sayHello()); // "Hello, my name is Bob"
```

## Constructor de objeto

- **Definición**: En JavaScript, un constructor es un tipo especial de función que se utiliza para crear e inicializar objetos. Se invoca con la palabra clave `new` y puede inicializar propiedades y métodos en el objeto recién creado. El constructor `Object()` crea un nuevo objeto vacío.

```js
new Object()
```

## Trabajar con el operador de encadenamiento opcional (`?.`)

- **Definición**: Este operador te permite acceder de manera segura a las propiedades de un objeto o llamar métodos sin preocuparte si existen.

```js
const user = {
  name: "John",
  profile: {
    email: "john@example.com",
    address: {
      street: "123 Main St",
      city: "Somewhere"
    }
  }
};

console.log(user.profile?.address?.street); // "123 Main St"
console.log(user.profile?.phone?.number);   // undefined
```

## Desestructuración de objetos

- **Definición**: La desestructuración de objetos permite extraer valores de objetos y asignarlos a variables de una manera más concisa y legible.

```js
const person = { name: "Alice", age: 30, city: "New York" };

const { name, age } = person;

console.log(name); // Alice
console.log(age);  // 30
```

## Trabajando con JSON

- **Definición**: JSON significa Notación de Objetos de JavaScript. Es un formato de datos ligero, basado en texto, que se usa comúnmente para intercambiar datos entre un servidor y una aplicación web.

```js
{
  "name": "Alice",
  "age": 30,
  "isStudent": false,
  "list of courses": ["Mathematics", "Physics", "Computer Science"]
}
```

- **`JSON.stringify()`**: Este método se utiliza para convertir un objeto de JavaScript en una cadena JSON. Esto es útil cuando deseas almacenar o transmitir datos en un formato que pueda compartirse o transferirse fácilmente entre sistemas.

```js
const user = {
  name: "John",
  age: 30,
  isAdmin: true
};

const jsonString = JSON.stringify(user);
console.log(jsonString); // '{"name":"John","age":30,"isAdmin":true}'
```

- **`JSON.parse()`**: Este método convierte una cadena JSON de nuevo en un objeto de JavaScript. Esto es útil cuando recuperas datos JSON de un servidor web o localStorage y necesitas manipular los datos en tu aplicación.

```js
const jsonString = '{"name":"John","age":30,"isAdmin":true}';
const userObject = JSON.parse(jsonString);

// result: { name: 'John', age: 30, isAdmin: true }
console.log(userObject);
```


## Trabajando con Bucles

- **`for` Bucle**: Este tipo de bucle se utiliza para repetir un bloque de código un cierto número de veces. Este bucle se divide en tres partes: la declaración de inicialización, la condición y la declaración de incremento/decremento. La declaración de inicialización se ejecuta antes de que comience el bucle. Se utiliza típicamente para inicializar una variable contador. La condición se evalúa antes de cada iteración del bucle. Una iteración es un único paso a través del bucle. Si la condición es `true`, se ejecuta el bloque de código dentro del bucle. Si la condición es `false`, el bucle se detiene y se procede al siguiente bloque de código. La declaración de incremento/decremento se ejecuta después de cada iteración del bucle. Se utiliza típicamente para incrementar o decrementar la variable contador.

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

- **`for...of` Bucle**: Este tipo de bucle se utiliza cuando necesitas iterar sobre valores de un iterable. Ejemplos de iterables son arreglos y cadenas de texto.

```js
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num);
}
```

- **`for...in` Bucle**: Este tipo de bucle se usa mejor cuando necesitas iterar sobre las propiedades de un objeto. Este bucle iterará sobre todas las propiedades enumerables de un objeto, incluidas las propiedades heredadas y no numéricas.

```js
const fruit = {
  name: 'apple',
  color: 'red',
  price: 0.99
};

for (const prop in fruit) {
  console.log(fruit[prop]);
}
```

- **`while` Bucle**: Este tipo de bucle ejecutará un bloque de código siempre que la condición sea `true`.

```js
let i = 5;

while (i > 0) {
  console.log(i);
  i--;
}
```

- **`do...while` Bucle**: Este tipo de bucle ejecutará el bloque de código al menos una vez antes de verificar la condición.

```js
let userInput;

do {
  userInput = prompt("Please enter a number between 1 and 10");
} while (Number(userInput) < 1 || Number(userInput) > 10);

alert("You entered a valid number!");
```

## Sentencias `break` y `continue`

- **Definición**: Una sentencia `break` se utiliza para salir de un bucle antes de tiempo, mientras que una sentencia `continue` se utiliza para omitir la iteración actual de un bucle y pasar a la siguiente.

```js
// Example of break statement
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, and 4

// Example of continue statement 
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    continue;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, 4, 6, 7, 8, and 9
```

## Constructor de Cadenas y Método `toString()`

- **Definición**: Un objeto cadena se utiliza para representar una secuencia de caracteres. Los objetos cadena se crean utilizando la función constructora `String`, que envuelve el valor primitivo en un objeto.

```js
const greetingObject = new String("Hello, world!");

console.log(typeof greetingObject); // "object"
```

- **Método `toString()`**: Este método convierte un valor a su representación en cadena. Es un método que se puede utilizar para números, booleanos, arreglos y objetos.

```js
const num = 10;
console.log(num.toString()); // "10"

const arr = [1, 2, 3];
console.log(arr.toString()); // "1,2,3"
```

Este método acepta un radix opcional, que es un número de 2 a 36. Este radix representa la base, como la base 2 para binario o base 8 para octal. Si no se especifica el radix, por defecto será base 10, que es decimal.


```js
const num = 10;
console.log(num.toString(2)); // "1010"(binary)
```

## Constructor de Números

- **Definición**: El constructor `Number` se utiliza para crear un objeto número. El objeto número contiene algunas propiedades y métodos útiles como los métodos `isNaN` y `toFixed`. La mayor parte del tiempo, utilizarás el constructor `Number` para convertir otros tipos de datos al tipo de datos número.

```js
const myNum = new Number("34");
console.log(typeof myNum); // "object"

const num = Number('100');
console.log(num); // 100

console.log(typeof num); // number
```

## Mejores Prácticas para Nombrar Variables y Funciones

- **camelCasing**: Por convención, los desarrolladores de JavaScript usarán camel case para nombrar variables y funciones. El camel casing es donde la primera palabra está en minúsculas y las siguientes palabras comienzan con mayúscula.  Ex. `isLoading`.

- **Nombrar Booleanos**: Para variables booleanas, es una práctica común usar prefijos como "is", "has" o "can".

```js
let isLoading = true;
let hasPermission = false;
let canEdit = true;
```

- **Nombrar Funciones**: Para las funciones, el nombre debe indicar claramente qué hace la función. Para las funciones que devuelven un valor booleano (a menudo llamadas predicados), puedes usar los mismos prefijos "is", "has" o "can". Cuando tengas funciones que recuperan datos, es común comenzar con la palabra "get". Cuando tienes funciones que establecen datos, es común comenzar con la palabra "establecer". Para funciones manejadoras de eventos, podrías usar prefijos como "handle" o sufijos como "Handler".

```js
function getUserData() { /* ... */ }

function isValidEmail(email) { /* ... */ }

function getProductDetails(productId) { /* ... */ }

function setUserPreferences(preferences) { /* ... */ }

function handleClick() { /* ... */ }
```

- **Nombrar Variables Dentro de Bucles**: Al nombrar variables iteradoras en bucles, es común usar letras simples como `i`, `j` o `k`.

```js
for (let i = 0; i < array.length; i++) { /* ... */ }
```

## Trabajar con Arreglos Dispersos

- **Definición**: Es posible tener arreglos con espacios vacíos. Los espacios vacíos se definen como espacios sin nada dentro. Esto es diferente de los espacios de arreglos con el valor de `undefined`. Estos tipos de matrices se conocen como matrices dispersas.

```js
const sparseArray = [1, , , 4];
console.log(sparseArray.length); // 4
```
  
## Linters y Formateadores

- **Linters**: Un linter es una herramienta de análisis estático de código que señala errores de programación, errores estilísticos y estructuras sospechosas. Un ejemplo de linter común sería ESLint.
- **Formateadores**: Los formateadores son herramientas que formatean automáticamente tu código para adherirse a un guía de estilo específico. Un ejemplo de un formateador común es Prettier.

## Gestión de Memoria

- **Definición**: La gestión de memoria es el proceso de controlar la memoria, asignándola cuando se necesita y liberándola cuando ya no se necesita. JavaScript utiliza gestión automática de memoria.  This means that JavaScript (more specifically, the JavaScript engine in your web browser) takes care of memory allocation and deallocation for you.  You don't have to explicitly free up memory in your code. Este proceso automático a menudo se llama "recolección de basura".

## Clausuras

- **Definición**: Una clausura es una función que tiene acceso a variables en su ámbito léxico exterior (cercano), incluso después de que la función exterior haya retornado.

```js
function outerFunction(x) {
  let y = 10;
  function innerFunction() {
    console.log(x + y);
  }
  return innerFunction;
}

let closure = outerFunction(5);
closure(); // 15
```

## Palabra Clave `var` y Elevación

- **Definición**: `var` fue la forma original de declarar variables antes de 2015. Pero hubo algunos problemas que vinieron con `var` en términos de ámbito, redeclaración y más. Por eso, la programación moderna de JavaScript usa `let` y `const` en su lugar.
- **Redeclaring Variables with `var`**: Si intentas redeclarar una variable usando `let`, recibirías un `SyntaxError`. Pero con `var`, puedes redeclarar una variable.

```js
// Uncaught SyntaxError: Identifier 'num' has already been declared 
let num = 19;
let num = 18;

var myNum = 5;
var myNum = 10; // This is allowed and doesn't throw an error

console.log(myNum) // 10
```

- **`var` y Ámbito**: Las variables declaradas con `var` dentro de un bloque (como una declaración `if` o un bucle `for`) aún son accesibles fuera de ese bloque.

```js
if (true) {
  var num = 5;
}
console.log(num); // 5
```

- **Elevación**: Este es el comportamiento predeterminado de JavaScript de mover declaraciones al principio de sus respectivos ámbitos durante la fase de compilación antes de que el código se ejecute. Cuando declaras una variable usando la palabra clave `var`, JavaScript eleva la declaración a la cima de su ámbito.

```js
console.log(num); // undefined
var num = 5;
console.log(num); // 5
```

Cuando declaras una función usando la sintaxis de declaración de función, tanto el nombre de la función como el cuerpo de la función se elevan. Esto significa que puedes llamar a una función antes de haberla declarado en tu código.

```js
sayHello(); // "Hello, World!"

function sayHello() {
  console.log("Hello, World!");
}
```

Las declaraciones de variables hechas con `let` o `const` se elevan, pero no se inicializan, y no puedes acceder a ellas antes de la declaración real en tu código. Este comportamiento a menudo se refiere como la "zona temporalmente muerta".

```js
console.log(num); // Throws a ReferenceError
let num = 10;
```

## Trabajar con Importaciones, Exportaciones y Módulos

- **Módulo**: Este es una unidad de código autónoma que encapsula funciones, clases o variables relacionadas. Para crear un módulo, escribes tu código JavaScript en un archivo separado.
- **Exportaciones**: Cualquier variable, función o clase que deseas poner a disposición de otras partes de tu aplicación necesitas exportarla explícitamente usando la palabra clave `export`. Hay dos tipos de exportación: exportación nombrada y exportación por defecto.
- **Importaciones**: Para utilizar los elementos exportados en otra parte de tu aplicación, necesitas importarlos usando la palabra clave `import`. Los tipos pueden ser importación nombrada, importación por defecto e importación de espacio de nombres.

```js
// Within a file called math.js, we export the following functions:

// Named export
export function add(num1, num2) {
  return num1 + num2;
}

// Default export
export default function subtract(num1, num2) {
  return num1 - num2;
}

// Within another file, we can import the functions from math.js.

// Named import - This line imports the add function.
// The name of the function must exactly match the one exported from math.js.
import { add } from './math.js';

// Default import - This line imports the subtract function.
// The name of the function can be anything.
import subtractFunc from './math.js';

// Namespace import - This line imports everything from the file.
import * as Math from './math.js';

console.log(add(5, 3)); // 8
console.log(subtractFunc(5, 3)); // 2
console.log(Math.add(5, 3)); // 8
console.log(Math.subtract(5, 3)); // 2
```

## Funciones de devolución de llamada y el método `forEach`

- **Definición**: En JavaScript, una función callback es una función que se pasa como argumento a otra función para ser invocada en algún momento desde la primera función.
- **Método `forEach()`**: Este método se usa para iterar sobre cada elemento en un arreglo y realizar una operación en cada elemento. La función de devolución de llamada en `forEach` puede aceptar hasta tres argumentos: el elemento actual, el índice del elemento actual y el arreglo sobre el que se llamó `forEach`.

```js
const numbers = [1, 2, 3, 4, 5];

// Result: 2 4 6 8 10
numbers.forEach((number) => {
  console.log(number * 2);
});
```

## Funciones de Orden Superior

- **Definición**: Una función de orden superior toma una o más funciones como argumentos y devuelve una función o valor como resultado.

```js
function operateOnArray(arr, operation) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(operation(arr[i]));
  }
  return result;
}

function double(x) {
  return x * 2;
}

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = operateOnArray(numbers, double);
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
```

- **Método `map()`**: Este método se utiliza para crear un nuevo arreglo aplicando una función dada a cada elemento del arreglo original. La función de devolución de llamada puede aceptar hasta tres argumentos: el elemento actual, el índice del elemento actual y el arreglo sobre el que se llamó `map`.

```js
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);

console.log(numbers); // [1, 2, 3, 4, 5]
console.log(doubled); // [2, 4, 6, 8, 10]
```

- **Método `filter()`**: Este método se utiliza para crear un nuevo arreglo con elementos que pasan una prueba específica, lo que lo hace útil para extraer elementos selectivamente según criterios. Al igual que el método `map`, la función de callback para el método `filter` acepta los mismos tres argumentos: el elemento actual que se está procesando, el índice y el array.

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter((num) => num % 2 === 0);

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

- **Método `reduce()`**: Este método se utiliza para procesar un arreglo y condensarlo en un solo valor. Este valor único puede ser un número, una cadena, un objeto o incluso otro array. El método `reduce()` funciona aplicando una función a cada elemento en el arreglo, en orden, pasando el resultado de cada cálculo al siguiente. Esta función a menudo se denomina función reductora. La función reductora toma dos parámetros principales: un acumulador y el valor actual. El acumulador es donde almacenas el resultado en curso de tus operaciones y el valor actual es el elemento del array que se está procesando.

```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0
);

console.log(sum); // 15
```

## Encadenamiento de Métodos

- **Definición**: El encadenamiento de métodos es una técnica de programación que te permite llamar a varios métodos sobre el mismo objeto en una sola línea de código. Esta técnica puede hacer que tu código sea más legible y conciso, especialmente al realizar una serie de operaciones sobre el mismo objeto.

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

## Trabajando con el Método `sort`

- **Definición**: El método `sort` se usa para ordenar los elementos de un arreglo y devolver una referencia al arreglo ordenado. No se hace ninguna copia en este caso porque los elementos se ordenan in situ.

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();

console.log(fruits); // ["Apple", "Banana", "Mango", "Orange"]
```

Si necesitas ordenar números, deberás pasar una función de comparación. El método `sort` convierte los elementos en cadenas y luego compara sus secuencias de valores de unidades de código UTF-16. Las unidades de código UTF-16 son los valores numéricos que representan los caracteres en la cadena. Ejemplos de unidades de código UTF-16 son los números 65, 66 y 67, que representan los caracteres "A", "B" y "C" respectivamente. Entonces, el número 200 aparece antes del número 3 en un arreglo, porque la cadena "200" viene antes de la cadena "3" cuando se comparan sus unidades de código UTF-16.

```js
const numbers = [414, 200, 5, 10, 3];

numbers.sort((a, b) => a - b);

console.log(numbers); // [3, 5, 10, 200, 414]
```

Los parámetros `a` y `b` son los dos elementos que se están comparando. La función de comparación debe devolver un valor negativo si `a` debe ir antes que `b`, un valor positivo si `a` debe ir después de `b`, y cero si `a` y `b` son iguales.

## Trabajando con los Métodos `every` y `some`

- **Método `every()`**: Este método prueba si todos los elementos de un arreglo pasan una prueba implementada por una función proporcionada. El método `every()` devuelve `true` si la función proporcionada devuelve `true` para todos los elementos del arreglo. Si algún elemento falla la prueba, el método devuelve inmediatamente `false` y deja de verificar los elementos restantes.

```js
const numbers = [2, 4, 6, 8, 10];
const hasAllEvenNumbers = numbers.every((num) => num % 2 === 0);

console.log(hasAllEvenNumbers); // true
```

- **Método `some()`**: Este método verifica si al menos un elemento pasa la prueba. El método `some()` devuelve `true` tan pronto como encuentra un elemento que pasa la prueba. Si ningún elemento pasa la prueba, devuelve `false`.

```js
const numbers = [1, 3, 5, 7, 8, 9];
const hasSomeEvenNumbers = numbers.some((num) => num % 2 === 0);

console.log(hasSomeEvenNumbers); // true
```

## Trabajar con el DOM y Web APIs

- **API**: Una API (Interfaz de Programación de Aplicaciones) es un conjunto de reglas y protocolos que permite a las aplicaciones de software comunicarse entre sí e intercambiar datos de forma eficiente.
- **Web API**: Las Web APIs están específicamente diseñadas para aplicaciones web. Estos tipos de API a menudo se dividen en dos categorías principales: API del navegador y API de terceros.
- **API del navegador**: Estas API exponen datos del navegador. Como desarrollador web, puedes acceder y manipular estos datos utilizando JavaScript.
- **APIs de terceros**: Estas no están incorporadas en el navegador por defecto. Tienes que recuperar su código de alguna manera. Por lo general, tendrán documentación detallada que explica cómo usar sus servicios. Un ejemplo es la API de Google Maps, que puedes usar para mostrar mapas interactivos en tu página web.
- **DOM**: El DOM significa Modelo de Objeto Documental. Es una interfaz de programación que te permite interactuar con documentos HTML. Con el DOM, puedes añadir, modificar o eliminar elementos en una página web. La raíz del árbol DOM es el elemento `html`. Es el contenedor de nivel superior para todo el contenido de un documento HTML. Todos los demás nodos son descendientes de este nodo raíz. Luego, debajo del nodo raíz, encontramos otros nodos en la jerarquía. Un nodo padre es un elemento que contiene otros elementos. Un nodo hijo es un elemento que está contenido dentro de otro elemento.
- **`navegador` Interfaz**: Esta proporciona información sobre el entorno del navegador, como la cadena del agente de usuario, la plataforma y la versión del navegador. Una cadena del agente de usuario es una cadena de texto que identifica el navegador y el sistema operativo que se está utilizando.
- **`ventana` Interfaz**: Esta representa la ventana del navegador que contiene el documento DOM. Proporciona métodos y propiedades para interactuar con la ventana del navegador, como cambiar el tamaño de la ventana, abrir nuevas ventanas y navegar a diferentes URLs.

## Trabajando con los métodos `querySelector()`, `querySelectorAll()` y `getElementById()`

- **`getElementById()` Método**: Este método se usa para obtener un objeto que representa el elemento HTML con el `id` especificado. Recuerda que los ID deben ser únicos en cada documento HTML, por lo que este método solo devolverá un objeto Element.

```html
<div id="container"></div>
```

```js
const container = document.getElementById("container");
```

- **Método `querySelector()`**: Este método se utiliza para obtener el primer elemento en el documento HTML que coincide con el selector CSS pasado como argumento.

```html
<section class="section"></section>
```

```js
const section = document.querySelector(".section");
```

- **`querySelectorAll()` Método**: Puedes usar este método para obtener una lista de todos los elementos del DOM que coinciden con un selector CSS específico.

```html
<ul class="ingredients">
  <li>Sugar</li>
  <li>Milk</li>
  <li>Eggs</li>
</ul>
```

```js
const ingredients = document.querySelectorAll('ul.ingredients li');
```

## Trabajando con los métodos `innerText()`, `innerHTML()`, `createElement()` y `textContent()`

- **`innerHTML` Propiedad**: Esta es una propiedad del `Elemento` que se utiliza para establecer o actualizar partes del marcado HTML.

```html
<div id="container">
  <!-- Add new elements here -->
</div>
```

```js
const container = document.getElementById("container");
container.innerHTML = '<ul><li>Cheese</li><li>Tomato</li></ul>';
```

- **`createElement` Método **: Este se utiliza para crear un elemento HTML.

```js
const img = document.createElement("img");
```

- **`innerText`**: Este representa el contenido de texto visible del elemento HTML y sus descendientes.

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.innerText);
```

- **`textContent`**: Este devuelve el contenido de texto plano de un elemento, incluyendo todo el texto dentro de sus descendientes.

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.textContent);
```

## Trabajando con los métodos `appendChild()` y `removeChild()`

- **`appendChild()` Método**: Este método se utiliza para agregar un nodo al final de la lista de hijos de un nodo padre específico.

```html
<ul id="desserts">
  <li>Cake</li>
  <li>Pie</li>
</ul>
```

```js
const dessertsList = document.getElementById("desserts");
const listItem = document.createElement("li");

listItem.textContent = "Cookies";
dessertsList.appendChild(listItem);
```

- **`removeChild()` Método**: Este método se utiliza para eliminar un nodo del DOM.

```html
<section id="example-section">
  <h2>Example sub heading</h2>
  <p>first paragraph</p>
  <p>second paragraph</p>
</section>
```

```js
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");

sectionEl.removeChild(lastParagraph);
```

## Trabajar con el Método `setAttribute`

- **Definición**: Este método se utiliza para establecer el atributo para un determinado elemento. Si el atributo ya existe, entonces el valor es actualizado. De lo contrario, se añade un nuevo atributo con un valor.

```html
<p id="para">I am a paragraph</p>
```

```js
const para = document.getElementById("para");
para.setAttribute("class", "my-class");
```

## Objeto Evento

- **Definición**: El objeto `Evento` es un payload que se desencadena cuando un usuario interactúa con tu página web de alguna manera. Estas interacciones pueden ser cualquier cosa desde hacer clic en un botón o enfocar un input hasta sacudir su dispositivo móvil. Todos los objetos `Evento` tendrán la propiedad `tipo`. Esta propiedad revela el tipo de evento que desencadenó el payload, como presionar una tecla o hacer clic. Estos valores corresponderán a los mismos valores que puede pasar a `addEventListener()`, donde puede capturar y utilizar el objeto `Event`.

## Métodos `addEventListener()` y `removeEventListener()`

- **`addEventListener` Método**: Este método se utiliza para escuchar eventos. Toma dos argumentos: el evento que deseas escuchar y una función que se llamará cuando ocurra el evento. Algunos ejemplos comunes de eventos serían eventos de clic, eventos de entrada y eventos de cambio.

```js
const btn = document.getElementById("btn");

btn.addEventListener("click", () => alert("You clicked the button"));
```

- **Método `removeEventListener`**: Este método se usa para eliminar un escuchador de eventos que fue previamente añadido a un elemento utilizando el método `addEventListener`. Esto es útil cuando deseas dejar de escuchar un evento en particular en un elemento.

```js
const bodyEl = document.querySelector("body");
const para = document.getElementById("para");
const btn = document.getElementById("btn");

let isBgColorGrey = true;

function toggleBgColor() {
  bodyEl.style.backgroundColor = isBgColorGrey ? "blue" : "grey";
  isBgColorGrey = !isBgColorGrey;
}

btn.addEventListener("click", toggleBgColor);

para.addEventListener("mouseover", () => {
  btn.removeEventListener("click", toggleBgColor);
});
```

- **Manejadores de Eventos Inline**: Los manejadores de eventos inline son atributos especiales en un elemento HTML que se utilizan para ejecutar código JavaScript cuando ocurre un evento. No se considera una buena práctica usar manejadores de eventos inline en JavaScript moderno. Se prefiere usar el método `addEventListener` en su lugar.

```html
<button onclick="alert('Hello World!')">Show alert</button>
```

## DOMContentLoaded

- **Definición**: El evento `DOMContentLoaded` se dispara cuando todo en el documento HTML ha sido cargado y analizado. Si tienes hojas de estilo o imágenes externas, el evento `DOMContentLoaded` no esperará a que se carguen. Solo esperará a que se cargue el HTML.

## Trabajando con el `style` y `classList`

- **Propiedad `Element.style`**: Esta propiedad es una propiedad de solo lectura que representa el estilo en línea de un elemento. Puedes usar esta propiedad para obtener o establecer el estilo de un elemento.

```js
const paraEl = document.getElementById("para");
paraEl.style.color = "red";
```

- **Propiedad `Element.classList`**: Esta propiedad es una propiedad de solo lectura que se puede usar para agregar, quitar o alternar clases en un elemento.

```js
// Example adding a class
const paraEl = document.getElementById("para");
paraEl.classList.add("highlight");

// Example removing a class
paraEl.classList.remove("blue-background");

// Example toggling a class
const menu = document.getElementById("menu");
const toggleBtn = document.getElementById("toggle-btn");

toggleBtn.addEventListener("click", () => menu.classList.toggle("show"));
```


## Trabajando con los Métodos `setTimeout` y `setInterval`

- **`setTimeout()` Método**: Este método te permite retrasar una acción por un tiempo especificado.

```js
setTimeout(() => {
 console.log('This runs after 3 seconds'); 
}, 3000);
```

- **Método `setInterval()`**: Este método sigue ejecutando un bloque de código repetidamente a un intervalo establecido. Como `setInterval()` sigue ejecutando la función proporcionada al intervalo especificado, es posible que desees detenerlo. Para esto, tienes que usar el método `clearInterval()`.

```js
setInterval(() => {
 console.log('This runs every 2 seconds');
}, 2000);

// Example using clearInterval
const intervalID = setInterval(() => {
 console.log('This will stop after 5 seconds');
}, 1000);

setTimeout(() => {
 clearInterval(intervalID);
}, 5000);
```

## El Método `requestAnimationFrame()`

- **Definición**: Este método te permite programar el siguiente paso de tu animación antes del próximo repintado de pantalla, resultando en una experiencia fluida y visualmente atractiva. El siguiente repintado de pantalla se refiere al momento en que el navegador refresca la visualización de la página web. Esto ocurre múltiples veces por segundo, típicamente alrededor de 60 veces (o 60 cuadros por segundo) en la mayoría de las pantallas.

```js
function animate() {
 // Update the animation...
 // for example, move an element, change a style, and more.
 update();
 // Request the next frame
 requestAnimationFrame(animate);
}
```

## API de Animaciones Web

- **Definición**: La API de Web Animations te permite crear y controlar animaciones directamente dentro de JavaScript.

```js
const square = document.querySelector('#square');

const animation = square.animate(
 [{ transform: 'translateX(0px)' }, { transform: 'translateX(100px)' }],
 {
   duration: 2000, // makes animation lasts 2 seconds
   iterations: Infinity, // loops indefinitely
   direction: 'alternate', // moves back and forth
   easing: 'ease-in-out', // smooth easing
 }
);
```

## La API del Canvas

- **Definición**: La API del Canvas es una herramienta poderosa que te permite manipular gráficos directamente dentro de tu archivo JavaScript. Para trabajar con la API de Canvas, primero necesitas proporcionar un elemento `canvas` en HTML. Este elemento actúa como una superficie de dibujo que puedes manipular con los métodos y propiedades de las interfaces dentro de la API del Canvas. Esta API tiene interfaces como `HTMLCanvasElement`, `CanvasRenderingContext2D`, `CanvasGradient`, `CanvasPattern` y `TextMetrics` que contienen métodos y propiedades que puedes usar para crear gráficos en tu archivo JavaScript.

```html
<canvas id="my-canvas" width="400" height="400"></canvas>
```

```js
const canvas = document.getElementById('my-canvas');

// Access the drawing context of the canvas. 
// "2d" allows you to draw in two dimensions 
const ctx = canvas.getContext('2d');

// Set the background color
ctx.fillStyle = 'crimson';

// Draw a rectangle
ctx.fillRect(1, 1, 150, 100);
```

## Abrir y cerrar diálogos y modales con JavaScript

- **Modal y Definiciones de Diálogo**: Los diálogos te permiten mostrar información importante o acciones a los usuarios. Con el elemento diálogo incorporado en HTML, puedes crear fácilmente estos diálogos (tanto diálogos modales como no modales) en tus aplicaciones web. Un diálogo modal es un tipo de diálogo que obliga al usuario a interactuar con él antes de poder acceder al resto de la aplicación o página web. En contraste, un diálogo no modal permite al usuario seguir interactuando con otras partes de la página o aplicación incluso cuando el diálogo está abierto. No impide el acceso al resto del contenido.
- **`showModal()` Método**: Este método se utiliza para abrir un modal.

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');

openButton.addEventListener('click', () => {
  dialog.showModal();
});
```

- **`close()` Método**: Este método se utiliza para cerrar el modal.

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
   <button id="close-modal">Close Modal</button>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');
const closeButton = document.getElementById('close-modal');

openButton.addEventListener('click', () => {
  dialog.show();
});

closeButton.addEventListener('click', () => {
  dialog.close();
});
```

## El Evento de Cambio

- **Definición**: El evento de cambio es un evento especial que se activa cuando el usuario modifica el valor de ciertos elementos de entrada. Los ejemplos incluirían cuando se marca una casilla de verificación o un botón de opción. O cuando el usuario hace una selección de algo como un selector de fechas o un menú desplegable.

```html
<label>
  Choose a programming language:
  <select class="language" name="language">
    <option value="">---Select One---</option>
    <option value="JavaScript">JavaScript</option>
    <option value="Python">Python</option>
    <option value="C++">C++</option>
  </select>
</label>

<p class="result"></p>
```

```js 
const selectEl = document.querySelector(".language");
const result = document.querySelector(".result");

selectEl.addEventListener("change", (e) => {
  result.textContent = `You enjoy programming in ${e.target.value}.`;
});
```

## Propagación de Eventos

- **Definición**: La burbuja de eventos, o propagación, se refiere a cómo un evento "sube" hacia los objetos padre cuando se activa.

## Delegación de Eventos

- **Definición**: La delegación de eventos es el proceso de escuchar eventos que se han propagado a un elemento padre, en lugar de manejarlos directamente en el elemento que los activó.

## JavaScript y Accesibilidad

### Atributos comunes de accesibilidad ARIA

- **`aria-expanded` atributo**: Se utiliza para comunicar el estado de una función de alternancia o divulgación a los usuarios de lectores de pantalla.
- **`aria-haspopup` atributo**: Este estado se utiliza para indicar que un elemento interactivo activará un elemento emergente cuando se active. Sólo puedes utilizar el atributo `aria-haspopup` cuando el elemento emergente tiene uno de los siguientes roles: `menu`, `listbox`, `tree`, `grid` o `dialog`. El valor de `aria-haspopup` debe ser uno de estos roles o `true`, que es lo mismo que `menu`.
- **`aria-checked` atributo**: Este atributo se utiliza para indicar si un elemento está en el estado marcado. Se utiliza más comúnmente al crear casillas de verificación personalizadas, botones de opción, interruptores y cuadros de lista.
- **`aria-disabled` atributo**: Este estado se utiliza para indicar que un elemento está deshabilitado sólo para personas que utilizan tecnologías asistivas, como lectores de pantalla.
- **`aria-selected` atributo**: Este estado se utiliza para indicar que un elemento está seleccionado. Puedes usar este estado en controles personalizados como una interfaz con pestañas, un cuadro de lista o una cuadrícula.
- **`aria-controls` atributo**: Se utiliza para asociar un elemento con otro elemento que controla. Esto ayuda a las personas que utilizan tecnologías asistivas a comprender la relación entre los elementos.
- **Atributo `hidden`**: Oculta los paneles inactivos tanto para usuarios visuales como para tecnologías de asistencia.

### Trabajando con Live Regions y Contenido Dinámico

- **Atributo `aria-live`**: Convierte una parte de una página web en una región activa, lo que significa que cualquier actualización dentro de esa área será anunciada por un lector de pantalla para que los usuarios no se pierdan cambios importantes.
- **Valor `polite`**: La mayoría de las regiones en vivo usan este valor. Este valor significa que la actualización no es urgente, por lo que el lector de pantalla puede esperar hasta que termine cualquier anuncio actual o que el usuario complete su acción actual antes de anunciar la actualización.

Aquí tienes un ejemplo de una región en vivo que se actualiza dinámicamente mediante JavaScript:

```html
<div aria-live="polite" id="status"></div>
```

```js
const statusEl = document.getElementById("status");
statusEl.textContent = "Your file has been successfully uploaded.";
```

- **Atributo `contenteditable`**: Convierte el elemento en un editor en vivo, permitiendo que los usuarios actualicen su contenido como si fuera un campo de texto. Cuando no haya una etiqueta o encabezado visible para una región `contenteditable`, agrega un nombre accesible usando el atributo `aria-label` para ayudar a los usuarios de lectores de pantalla a entender el propósito del área editable.

```html
<div contenteditable="true" aria-label="Note editor">
  Editable content goes here
</div>
```

## Eventos `focus` y `blur`

- **Evento `blur`**: Se activa cuando un elemento pierde el foco.

```js
element.addEventListener("blur", () => {
  // Handle when user leaves the element
});
```

- **Evento `focus`**: Se activa cuando un elemento recibe el foco.

```js
element.addEventListener("focus", () => {
  // Handle when user enters the element
});
```

## Tipos Comunes de Mensajes de Error

- **SyntaxError**: Estos errores ocurren cuando escribes algo incorrectamente en tu código, como faltar un paréntesis o un corchete. Piénsalo como un error gramatical en una oración.

```js
const arr = ["Beau", "Quincy" "Tom"]
```

- **ReferenceError**: Hay varios tipos de Errores de Referencia, desencadenados de diferentes maneras. El primer tipo de error de referencia sería variables no definidas. Otro ejemplo de un ReferenceError es intentar acceder a una variable, declarada con `let` o `const`, antes de que haya sido definida.

```js
console.log(num);
const num = 50;
```

- **TypeError**: Estos errores ocurren cuando tratas de realizar una operación en el tipo equivocado.

```js
const developerObj = {
  name: "Jessica",
  country: "USA",
  isEmployed: true
};

developerObj.map()
```

- **RangeError**: Estos errores ocurren cuando tu código intenta usar un valor que está fuera del rango que JavaScript puede manejar.

```js
const arr = [];
arr.length = -1; 
```

## La Declaración `throw`

- **Definición**: La declaración `throw` en JavaScript se usa para lanzar una excepción definida por el usuario. Una excepción en programación es cuando ocurre un evento inesperado y altera el flujo normal del programa.

```js
function validateNumber(input) {
  if (typeof input !== "number") {
    throw new TypeError("Expected a number, but received " + typeof input);
  }
  return input * 2;
}
```

## `try...catch...finally`

- **Definición**: El bloque `try` se usa para envolver código que podría arrojar un error. Actúa como un espacio seguro para intentar algo que podría fallar. El bloque `catch` captura y maneja errores que ocurren en el bloque try. Puedes usar el objeto error dentro de catch para inspeccionar qué salió mal. El bloque `finally` se ejecuta después de los bloques try y catch, independientemente de si ocurrió un error. Se usa comúnmente para tareas de limpieza, como cerrar archivos o liberar recursos.

```js
function processInput(input) {
  if (typeof input !== "string") {
    throw new TypeError("Input must be a string.");
  }

  return input.toUpperCase();
}

try {
  console.log("Starting to process input...");
  const result = processInput(9);
  console.log("Processed result:", result);
} catch (error) {
  console.error("Error occurred:", error.message);
} 
```

## Técnicas de Depuración

- **`Sentencia debugger`**: Esta sentencia te permite pausar tu código en una línea específica para investigar qué está sucediendo en el programa.

```js
let firstNumber = 5;
let secondNumber = 10;

debugger; // Code execution pauses here
let sum = firstNumber + secondNumber;

console.log(sum);
```

- **Puntos de interrupción**: Los puntos de interrupción te permiten pausar la ejecución de tu código en una línea específica de tu elección. Después de la pausa, puedes inspeccionar variables, evaluar expresiones y examinar la pila de llamadas.
- **Observadores**: Observa expresiones te permite monitorear los valores de variables o expresiones mientras el código se ejecuta, incluso si están fuera del ámbito actual.
- **Perfilado**: El perfilado te ayuda a identificar cuellos de botella de rendimiento permitiéndote capturar capturas de pantalla y registrar el uso del CPU, llamadas de funciones y tiempo de ejecución.
- **`console.dir()`**: Este método se usa para mostrar una lista interactiva de las propiedades de un objeto de JavaScript especificado. Muestra una lista jerárquica que se puede expandir para ver todas las propiedades anidadas.

```js
console.dir(document);
```

- **`console.table()`**: Este método muestra datos tabulares como una tabla en la consola. Toma un argumento obligatorio, que debe ser un arreglo u objeto, y un argumento opcional para especificar qué propiedades (columnas) mostrar.

## Expresiones Regulares y Métodos Comunes

- **Definición**: Las expresiones regulares, o regex, se utilizan para crear un "patrón", que luego puedes usar para verificar una cadena, extraer texto y más.

```js
const regex = /freeCodeCamp/;
```

- **`test()` Método**: Este método acepta una cadena, que es la cadena para probar coincidencias con la expresión regular. Este método devolverá un booleano si la cadena coincide con el regex.

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test); // false
```

- **`match()` Método**: Este método acepta una expresión regular, aunque también puede pasar una cadena que se convertirá en una expresión regular. El método `match` devuelve la matriz de coincidencias para la cadena.

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match); // ["freeCodeCamp"]
```

- **`replace()` Método**: Este método acepta dos argumentos: la expresión regular para coincidir (o una cadena), y la cadena para reemplazar la coincidencia con (o una función para ejecutar contra cada coincidencia).

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced); // "freeCodeCamp is rly kewl"
```

- **`replaceAll` Método**: Este método se usa para reemplazar todas las ocurrencias de un patrón especificado con una nueva cadena. Este método lanzará un error si le da una expresión regular sin el modificador global.

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

- **`matchAll` Método**: Este método se utiliza para recuperar todas las coincidencias de una expresión regular dada en una cadena, incluidos los grupos de captura, y los devuelve como un iterador. Un iterador es un objeto que le permite recorrer (o "recorrer" en iterar) una colección de elementos.

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

## Modificadores de Expresiones Regulares

- **Definición**: Los modificadores, a menudo denominados "banderas", modifican el comportamiento de una expresión regular.
- **`i` Bandera**: Este indicador hace que un regex ignore el caso.

```js
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
```

- **`g` Bandera**: Este indicador, o el modificador global, permite que su expresión regular coincida con un patrón más de una vez.

```js
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
```

- **Definición de ancla **: El ancla `^`, al principio de la expresión regular, indica "coincidir con el inicio de la cadena". El ancla `$`, al final de la expresión regular, indica "coincidir con el final de la cadena".

```js
const start = /^freeCodeCamp/i;
const end = /freeCodeCamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
```

- **`m` Bandera**: Los anclajes buscan el principio y el final de toda la cadena. Pero puede hacer que un regex maneje múltiples líneas con el indicador `m`, o el modificador de múltiples líneas.

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const str = `I love 
freecodecamp
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true

```

- **`d` Bandera**: Este indicador amplía la información que recibe en un objeto de coincidencia.

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

- **`u` Bandera**: Esto expande la funcionalidad de una expresión regular para permitir que coincida con caracteres unicode especiales. El indicador `u` le da acceso a clases especiales como `Extended_Pictographic` para coincidir con la mayoría de los emojis. También hay un indicador `v`, que amplía aún más la funcionalidad de la coincidencia unicode.
- **`y` Bandera**: El modificador pegajoso se comporta de manera muy similar al modificador global, pero con algunas excepciones. La mayor es que una expresión regular global comenzará desde lastIndex y buscará en todo el resto de la cadena por otra coincidencia, pero una expresión regular pegajosa devolverá null y restablecerá el lastIndex a 0 si no hay inmediatamente una coincidencia en el último índice anterior.
- **`s` Bandera**: El modificador de una sola línea permite que un carácter comodín, representado por un `.` en regex, coincida con saltos de línea, tratando efectivamente la cadena como una sola línea de texto.

## Clases de Caracteres

- **Comodín `.`**: Las clases de caracteres son una sintaxis especial que puede usar para coincidir con conjuntos o subconjuntos de caracteres. La primera clase de caracteres que debes aprender es la clase de comodines. El comodín está representado por un punto o punto, y coincide con CUALQUIER solo carácter EXCEPTO los saltos de línea. Para permitir que la clase comodín coincida con saltos de línea, recuerda que necesitarías usar el indicador `s`.

```js
const regex = /a./;
```

- **`\d`**: Esto coincidirá con todos los dígitos (`0-9`) en una cadena.

```js
const regex = /\d/;
```

- **`\w`**: Esto se usa para coincidir con cualquier carácter de palabra (`a-z0-9_`) en una cadena. Un carácter de palabra se define como cualquier letra, de la a a la z, o un número del 0 al 9, o el carácter de subrayado.

```js
const regex = /\w/;
```

- **`\s`**: La clase de espacios en blanco `\s`, representada por una barra diagonal seguida de una `s`. Esta clase de caracteres coincidirá con cualquier espacio en blanco, incluidos los nuevos saltos de línea, espacios, tabulaciones y caracteres de espacio unicode especiales.
- **Negando Clases de Caracteres Especiales**: Para negar una de estas clases de caracteres, en lugar de usar una letra minúscula después de la barra diagonal, use el equivalente en mayúscula. El siguiente ejemplo no coincide con un carácter numérico. En cambio, coincide con cualquier único carácter que NO sea un carácter numérico.

```js
const regex = /\D/;
```

- **Clases de Caracteres Personalizadas**: Puede crear clases de caracteres personalizadas colocando el carácter que desea coincidir dentro de un conjunto de corchetes.

```js
const regex = /[abcdf]/;
```

## Afirmaciones de Anticipación y Retroceso

- **Definición**: Las afirmaciones de anticipación y retroceso le permiten coincidir con patrones específicos basados en la presencia o falta de patrones circundantes.
- **Afirmación de Anticipación Positiva**: Esta afirmación coincidirá con un patrón cuando el patrón sea seguido por otro patrón. Para construir una anticipación positiva, debe comenzar con el patrón que desea coincidir. Luego, use paréntesis para envolver el patrón que desea usar como su condición. Después del paréntesis de apertura, use `?=` para definir ese patrón como una anticipación positiva.

```js
const regex = /free(?=code)/i;
```

- **Afirmación de Anticipación Negativa**: Este es un tipo de condición utilizada en expresiones regulares para verificar que un cierto patrón no ocurra adelante en la cadena.

```js
const regex = /free(?!code)/i;
```

- **Afirmación de Retroceso Positiva**: Esta afirmación coincidirá con un patrón solo si es precedida por otro patrón específico, sin incluir el patrón precedente en la coincidencia.

```js
const regex = /(?<=free)code/i;
```

- **Afirmación de Retroceso Negativa**: Esta afirmación asegura que un patrón no es precedido por otro patrón específico. Coincide solo si el patrón especificado no es precedido inmediatamente por la secuencia dada, sin incluir la secuencia precedente en la coincidencia.

```js
const regex = /(?<!free)code/i;
```

## Cantidades de Regex

- **Definición**: Los cuantificadores en expresiones regulares especifican cuántas veces debe aparecer un patrón (o parte de un patrón). Ayudan a controlar el número de ocurrencias de caracteres o grupos en una coincidencia. El siguiente ejemplo se utiliza para coincidir el carácter anterior exactamente cuatro veces.

```js
const regex = /^\d{4}$/;
```

- **`*`** : Coincide con 0 o más ocurrencias del elemento precedente.
- **`+`**: Coincide con 1 o más ocurrencias del elemento precedente.
- **`?`**: Coincide con 0 o 1 ocurrencia del elemento anterior.
- **`{n}`**: Coincide exactamente con n ocurrencias del elemento anterior.
- **`{n,}`**: Coincide con n o más ocurrencias del elemento anterior.
- **`{n,m}`**: Coincide entre n y m ocurrencias del elemento anterior.

## Grupos de Captura y Retroreferencias

- **Grupos de captura**: Un grupo de captura te permite "capturar" una parte de la cadena coincidente para usarla según necesites. Los grupos de captura se definen por paréntesis que contienen el patrón a capturar, sin caracteres iniciales como una búsqueda anticipada.

```js
const regex = /free(code)camp/i;
```

- **Retroreferencias**: Una retroreferencia en expresiones regulares se refiere a una forma de reutilizar una parte del patrón que se coincidió anteriormente en la misma expresión. Le permite referirse a un grupo de captura (una parte del patrón entre paréntesis) por su número. Por ejemplo, `$1` se refiere al primer grupo de captura.

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

## Validación de Formularios con JavaScript

- **API de Validación de Restricciones**: Ciertos elementos HTML, como los elementos `textarea` y `input`, exponen una API de validación de restricciones. Esta API te permite afirmar que el valor proporcionado por el usuario para ese elemento cumpla con cualquier validación a nivel HTML que hayas escrito, como longitud mínima o coincidencia de patrones.
- **`checkValidity()` método**: Este método devuelve `true` si el elemento cumple con todas las validaciones HTML (basadas en sus atributos), y `false` si falla.

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.setCustomValidity("You must use a .com email.")
  }
})
```

- **`reportValidity()` Método**: Este método informa al navegador que la `entrada` es inválida.

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.reportValidity();
  }
})
```

- **Propiedad `validity`**: Esta propiedad se usa para obtener o establecer el estado de validez de los controles de formulario (como `<input>`, `<select>`, etc.) y proporciona información sobre si la entrada del usuario cumple con las restricciones definidas para ese elemento (por ejemplo, campos `required`, restricciones de patrón, longitud máxima, etc.).

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.validity);
})
```

- **`patternMismatch` Propiedad**: Será `true` si el valor no coincide con el patrón de expresión regular especificado.

## `preventDefault()` Método

- **Definición**: Cada evento que se activa en el DOM tiene algún tipo de comportamiento predeterminado. El evento de clic en un checkbox alterna el estado de ese checkbox, por defecto. Presionar la barra espaciadora en un botón enfocado activa el botón. El método `preventDefault()` en estos objetos `Event` detiene ese comportamiento de ocurrir.

```js
button.addEventListener('click', (event) => {
  // Prevent the default button click behavior  
  event.preventDefault(); 
  alert('Button click prevented!');
});
```

## Enviar Formularios

- **Definición**: Hay tres formas en que se puede enviar un formulario. La primera es cuando el usuario hace clic en un botón en el formulario que tiene el atributo `type` configurado como `submit`. La segunda es cuando el usuario presiona la tecla `Enter` en cualquier campo `input` editable en el formulario. La tercera es a través de una llamada JavaScript a los métodos `requestSubmit()` o `submit()` del elemento `form`.
- **`action` Atributo**: El atributo `action` debe contener una URL o una ruta relativa para el dominio actual. Este valor determina a dónde intenta enviar los datos el formulario; si no estableces un atributo `action`, el formulario enviará datos a la URL de la página actual.

```html
<form action="https://freecodecamp.org">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`method` Atributo**: Este atributo acepta un método `HTTP` estándar, como `GET` o `POST`, y usa ese método al hacer la solicitud a la URL de acción. Cuando un método no está configurado, el formulario usará por defecto una solicitud `GET`. Los datos en el formulario se codificarán en la URL como pares `name=value` y se agregarán a la URL de acción como parámetros de consulta.

```html
<form action="/data" method="POST">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`enctype` Atributo**: El elemento `form` acepta un atributo `enctype`, que representa el tipo de codificación a usar para los datos. Este atributo solo acepta tres valores: `application/x-www-form-urlencoded` (que es el valor por defecto, enviando los datos como un cuerpo de formulario codificado en URL), `text/plain` (que envía los datos en formato de texto sin formato, en pares `name=value` separados por nuevas líneas), o `multipart/form-data`, que es específicamente para manejar formularios con una carga de archivo.

## El Objeto `date()` y Métodos Comunes

- **Definición:** El objeto `date()` se utiliza para crear, manipular y formatear fechas y horas en JavaScript. En el siguiente ejemplo, la palabra clave `new` se utiliza para crear una nueva instancia del objeto `Date`, y el objeto `Date` se asigna luego a la variable `now`. Si registraras el valor de `now` en la consola, verías la fecha y la hora actual basada en el reloj del sistema de la computadora que ejecuta el código.

```js
const now = new Date();
```

- **`Date.now()` Method**: This method is used to get the current date and time. `Date.now()` returns the number of milliseconds since January 1, 1970, 00:00:00 UTC. Esto se conoce como tiempo épico de Unix. El tiempo épico de Unix es una forma común de representar fechas y horas en los sistemas informáticos porque es un entero que se puede almacenar y manipular fácilmente. UTC significa Tiempo Universal Coordinado, que es el estándar de tiempo primario por el cual se regulan los relojes y el tiempo en el mundo.
- **Método `getDate()`**: Este método se usa para obtener un día del mes basado en la fecha actual. `getDate()` devolverá un valor entero entre 1 y 31, dependiendo del día del mes. Si la fecha es inválida, devolverá `NaN` (Not a Number).

```js
const now = new Date();
const date = now.getDate();
console.log(date); // 15
```

- **`getMonth()` Método**: Este método se utiliza para obtener el mes. El mes es basado en cero, así que enero es 0, febrero es 1, y así sucesivamente. En este ejemplo, la salida es 2, lo que corresponde a marzo. Si el mes es inválido, devolverá `NaN`.

```js
const now = new Date();
const month = now.getMonth();
console.log(month); // 2
```

- **`getFullYear()` Método**: Este método se utiliza para obtener el año completo. Si el año es inválido, devolverá `NaN`.

```js
const now = new Date();
const year = now.getFullYear();
console.log(year); // 2024
```

## Diferentes Formas de Formatear Fechas

- **El método `toISOString()`**: Este método se usa para formatear la fecha en un formato extendido `ISO` (ISO 8601). ISO 8601 es un estándar internacional para representar fechas y horas. El formato es `YYYY-MM-DDTHH:mm:ss.sssZ`.

```js
const date = new Date();
console.log(date.toISOString());
```

- **`toLocaleDateString()` Método**: Este método se utiliza para formatear la fecha según la configuración regional del usuario.

```js
const date = new Date();
console.log(date.toLocaleDateString());  // 11/23/2024
```

El método `toLocaleDateString()` acepta dos parámetros opcionales: locales y opciones.

El parámetro locales es una cadena que representa la configuración regional a utilizar. Por ejemplo, puedes pasar `"en-US"` para inglés (Estados Unidos) o `"fr-FR"` para francés (Francia). Si no pases un parámetro locales, se utiliza la configuración regional predeterminada. El segundo parámetro opcional es el parámetro de opciones. Este parámetro es un objeto que te permite especificar el formato de la cadena de fecha.

```js
const date = new Date();
const options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(date.toLocaleDateString("en-GB", options)); // Saturday, November 23, 2024
```

## `Audio` Constructor y Métodos Comunes

- **Definición**: El constructor `Audio`, como otros constructores, es una función especial llamada con la palabra clave `new`. Devuelve un `HTMLAudioElement`, que luego puedes usar para reproducir audio para el usuario, o agregar al DOM para que el usuario lo controle. Cuando llamas al constructor, puedes opcionalmente pasar una URL como el (único) argumento. Esta URL debe apuntar a la fuente del archivo de audio que deseas reproducir. O, si necesitas cambiar la fuente dinámicamente, puedes asignar la URL a la propiedad `src` del elemento de audio devuelto.
- **Método `play()`**: Este método se usa con los elementos `audio` o `video` para comenzar la reproducción del medio.

```js
const audio = document.getElementById('audio');

// Starts playing the audio
audio.play();  
```

- **Método `pause()`**: Este método se usa con los elementos `audio` o `video` para pausar la reproducción del medio.

```js
function pauseAudio() {
  const audio = document.getElementById('myAudio');
  audio.pause();  // Pauses the audio playback
}
```

- **`addTextTrack()` Método**: Este método permite especificar una pista de texto para asociarla con el elemento de medios, lo cual es especialmente útil para agregar subtítulos a un video.
- **`fastSeek()` Método**: Este método permite mover la posición de reproducción a un tiempo específico dentro del medio.

## Diferentes Formatos de Audio y Video

- **Tipo MIME**: Un tipo MIME, que significa Extensiones de Correo de Internet Multipropósito, es una manera estandarizada de indicar programáticamente un tipo de archivo. El tipo MIME le puede decir a una aplicación, como tu navegador, cómo manejar un archivo específico. En el caso de audio y video, el tipo MIME indica que es un formato multimedia que se puede incrustar en la página web.
- **`source` Elemento**: Esto se usa para especificar un tipo de archivo y fuente, y puede incluir varios tipos diferentes utilizando múltiples elementos source. Cuando haces esto, el navegador determinará el mejor formato para usar en el entorno actual del usuario.
- **MP3**: Este es un tipo de formato de archivo digital utilizado para almacenar música, audio o sonido. Es una versión comprimida de una grabación de sonido que hace que el tamaño del archivo sea más pequeño, por lo que es más fácil de almacenar y compartir.  An MP3 file has the MIME type `audio/mpeg`.
- **MP4**: Un MP4 es un tipo de formato de archivo digital utilizado para almacenar video y audio. Sirve como un contenedor que contiene tanto el video (imágenes) como el sonido (música o habla) en un solo archivo. Un MP4, puede tener el tipo MIME `audio/mp4` O `video/mp4`, dependiendo de si es un archivo de video o solo de audio.

## códecs

- **Definición**: Un códec, abreviatura de "codificador/decodificador", es un algoritmo o software que puede convertir audio y video entre formatos analógicos y digitales. Los códecs pueden estar especificados como parte del tipo MIME. La sintaxis básica para definir un códec es agregar un punto y coma después del tipo de medios, luego `codecs=` y el códec.

## API HTMLMediaElement

- **Definición**: La API `HTMLMediaElement` se utiliza para controlar el comportamiento de los elementos de audio y video en tu página. Extiende la interfaz base `HTMLElement`, por lo que tienes acceso a las propiedades base así como a estos métodos útiles. Ejemplos de estos métodos incluyen `play()`, `fastSeek()`, y `pause()`.

## Captura de Medios y API de Streams

- **Definición**: La API de Captura de Medios y Streams, o la API MediaStream, se utiliza para capturar audio y video desde tu dispositivo. Para utilizar la API, necesitas crear el objeto `MediaStream`. Podrías hacer esto con el constructor, pero no estaría vinculado al hardware del usuario. En su lugar, la propiedad `mediaDevices` del objeto `global` del navegador tiene un método `getUserMedia()` para que puedas usarla.

```js
window.navigator.mediaDevices.getUserMedia({
  audio: true,
  video: {
    width: {
      min: 1280,
      ideal: 1920,
      max: 3840
    },
    height: {
      min: 720,
      ideal: 1080,
      max: 2160
    }
  }
});
```

## API de Captura de Pantalla

- **Definición**: La API de captura de pantalla se utiliza para grabar la pantalla de un usuario. Esta API se expone llamando al método `getDisplayMedia()` del objeto `mediaDevices` y usando el flujo de medios devuelto.

## API de Grabación MediaStream

- **Definición**: La API de Grabación MediaStream funciona en conjunto con las APIs de MediaStreams, permitiéndote grabar un MediaStream (o incluso un `HTMLMediaElement` directamente).

## Extensiones de Fuente de Medios API

- **Tema**: La API de extensiones de fuente de medios es lo que te permite pasar directamente la transmisión de la cámara web de un usuario a un elemento de video con la propiedad `srcObject`.

## API de Audio en la Web

- **Definición**: La API de Audio en la Web que impulsa todo lo audible en la web. Este API incluye objetos importantes como un `AudioBuffer` (que representa un Búfer específicamente que contiene datos de audio) o el `AudioContext`.

## Conjuntos en JavaScript

- Un `Set` es una opción integrada para gestionar la colección de datos.
- Los conjuntos aseguran que cada valor en él aparezca solo una vez, lo que lo hace útil para eliminar duplicados de un array o manejar colecciones de valores distintos.
- Puedes crear un `Set` usando el constructor `Set()`:

```js
const set = new Set([1, 2, 3, 4, 5]);
console.log(set); // Set { 1, 2, 3, 4, 5 }
```

- Los conjuntos pueden manipularse usando estos métodos:
  
  - `add()`: Añade un nuevo elemento al `Set`.
  - `delete()`: Elimina un elemento del `Set`.
  - `has()`: Verifica si un elemento existe en el `Set`.
  - `clear()`: Elimina todos los elementos del `Set`.

## Weaksets en JavaScript

- `WeakSet` es una colección de objetos que le permite almacenar objetos retenidos débilmente.

## Conjuntos vs WeakSets

- A diferencia de los Conjuntos, un `WeakSet` no admite primitivos como números o cadenas.
- Un `WeakSet` solo almacena objetos, y las referencias a esos objetos son "débiles", lo que significa que si el objeto no se está utilizando en otra parte de su código, se elimina automáticamente para liberar memoria.

## Mapas en JavaScript

- Un `Map` es un objeto incorporado que mantiene pares clave-valor como un objeto.
- Los mapas difieren de los objetos estándar de JavaScript con su capacidad para permitir claves de cualquier tipo, incluidos objetos y funciones.
- Un `Map` proporciona mejor rendimiento sobre el objeto estándar cuando se trata de la adición y eliminación frecuente de pares clave-valor.
- Puedes crear un `Map` usando el constructor `Map()`:

```js
const map = new Map([
  ['flower', 'rose'],
  ['fruit', 'apple'],
  ['vegetable', 'carrot']
]);
console.log(map); // Map(3) { 'flower' => 'rose', 'fruit' => 'apple', 'vegetable' => 'carrot' }
```

- Los mapas pueden manipularse usando estos métodos:

  - `set()`: Añade un nuevo par clave-valor al `Map`.
  - `get()`: Recupera el valor de una clave del `Map`.
  - `delete()`: Elimina un par clave-valor del `Map`.
  - `has()`: Verifica si una clave existe en el `Map`.
  - `clear()`: Elimina todos los pares clave-valor del `Map`.

## WeakMaps en JavaScript

- Un `WeakMap` es una colección de pares clave-valor como `Map`, pero con referencias débiles a las claves. Las claves deben ser un objeto y los valores pueden ser lo que desee.

## Mapas vs WeakMaps

- Los WeakMaps son similares a los WeakSets en que solo almacenan objetos y las referencias a esos objetos son "débiles".

## Almacenamiento Persistente

- **Definición**: El almacenamiento persistente se refiere a una forma de guardar datos de manera que permanezcan disponibles incluso después de que se apague el dispositivo o se reinicie.

## Crear, Leer, Actualizar, Eliminar (CRUD)

- **Crear**: Se refiere al proceso de crear nuevos datos. Por ejemplo, en una aplicación web, esto podría ser cuando un usuario agrega una nueva publicación a un blog.
- **Leer**: Esta es la operación donde se recuperan los datos de una base de datos. Por ejemplo, cuando visitas una publicación de blog o ves tu perfil en un sitio web, estás realizando una operación de lectura para obtener y mostrar datos almacenados en la base de datos.
- **Actualizar**: Esto implica modificar datos existentes en la base de datos. Un ejemplo sería editar una publicación del blog o actualizar la información de tu perfil.
- **Eliminar**: Esta es la operación que elimina datos de una base de datos. Por ejemplo, cuando eliminas una publicación de blog o una cuenta, estás realizando una operación de eliminación.

## Métodos HTTP

- **Definición**: HTTP significa Protocolo de Transferencia de Hipertexto y es la base para la comunicación de datos en la web. Existen métodos HTTP que definen las acciones que se pueden realizar sobre los recursos a través de la web. Los métodos comunes son GET, POST, PUT, PATCH, DELETE.
- **`GET` Método**: Se utiliza para obtener datos de un servidor.
- **`POST` Método**: Se utiliza para enviar datos a un servidor lo cual crea un nuevo recurso.
- **`PUT` Método**: Se utiliza para actualizar un recurso reemplazándolo por completo.
- **`PATCH` Método**: Se utiliza para actualizar parcialmente un recurso.
- **`DELETE` Método**: Se utiliza para remover registros de una base de datos.

## Propiedades `localStorage` y `sessionStorage`

- **API de Almacenamiento Web**: Esta API proporciona un mecanismo para que los navegadores almacenen pares clave-valor directamente en el navegador, lo que permite a los desarrolladores guardar información que puede usarse a través de diferentes recargas de página y sesiones. Los dos componentes principales de la API de Almacenamiento Web son las propiedades `localStorage` y `sessionStorage`.
- **`localStorage` Propiedad**: `localStorage` es la parte de la API de Almacenamiento Web que permite que los datos persistan incluso después de que se cierre la ventana del navegador o se refresque la página. Estos datos permanecen disponibles hasta que sean eliminados explícitamente por la aplicación o el usuario.
- **`localStorage.setItem()` Método**: Este método se utiliza para almacenar un par clave-valor en `localStorage`.

```js
localStorage.setItem('username', 'Jessica');
```

- **`localStorage.getItem()` Método**: Este método se utiliza para recuperar el valor de una clave determinada de `localStorage`.

```js
localStorage.setItem('username', 'codingRules');

let username = localStorage.getItem('username');
console.log(username); // codingRules
```

- **`localStorage.removeItem()` Método**: Este método se utiliza para eliminar un elemento específico de `localStorage` usando su clave.

```js
localStorage.removeItem('username');
```

- **`localStorage.clear()` Método**: Este método se utiliza para eliminar todos los datos almacenados en `localStorage`.

```js
localStorage.clear();
```

- **`sessionStorage` Propiedad**: Almacena datos que solo duran para la sesión actual y se eliminan cuando se cierra la pestaña del navegador o la ventana.
- **`sessionStorage.setItem()` Método**: Este método se utiliza para almacenar un par clave-valor en `sessionStorage`.

```js
sessionStorage.setItem('cart', '3 items');
```

- **`sessionStorage.getItem()` Método**: Este método se utiliza para recuperar el valor de una clave dada de `sessionStorage`.

```js
sessionStorage.setItem('cart', '3 items');

let cart = sessionStorage.getItem('cart');
console.log(cart); // '3 items'
```

- **`sessionStorage.removeItem()` Método**: Este método se utiliza para eliminar un elemento específico de `sessionStorage` usando su clave.

```js
sessionStorage.removeItem('cart');
```

- **`sessionStorage.clear()` Método**: Este método se utiliza para eliminar todos los datos almacenados en `sessionStorage`.

```js
sessionStorage.clear();
```

## Trabajando con Cookies

- **Definición**: Las cookies, también conocidas como web cookies o cookies del navegador, son pequeños fragmentos de datos que un servidor envía a un navegador web de un usuario. Estas cookies se almacenan en el dispositivo del usuario y se envían de nuevo al servidor con solicitudes posteriores. Las cookies son esenciales para ayudar a las aplicaciones web a mantener el estado y recordar la información del usuario, lo cual es especialmente importante ya que HTTP es un protocolo sin estado.
- **Cookies de Sesión**: Estas cookies solo duran por la duración de la sesión del usuario en el sitio web. Una vez que el usuario cierra el navegador o la pestaña, la cookie de sesión se elimina. Estas cookies se usan típicamente para tareas como mantener a un usuario registrado durante su visita.
- **Cookies Seguras**: Estas cookies solo se envían a través de HTTPS, asegurando que no puedan ser interceptadas por un atacante en tránsito.
- **Cookies HttpOnly**: Estas cookies no pueden ser accedidas ni modificadas por JavaScript que se ejecute en el navegador, lo que las hace más seguras contra ataques de cross-site scripting (XSS).
- **Encabezado Set-Cookie**: Cuando visita un sitio web, el servidor puede enviar un encabezado Set-Cookie en la respuesta HTTP. Este encabezado le dice a su navegador que guarde una cookie con información específica. Por ejemplo, puede almacenar una ID única que ayude al sitio a reconocerle la próxima vez que visite. Puede establecer manualmente una cookie en JavaScript usando `document.cookie`:

```js
document.cookie = "organization=freeCodeCamp; expires=Fri, 31 Dec 2021 23:59:59 GMT; path=/";
```

Para eliminar una cookie, puede establecer su fecha de expiración en un tiempo pasado.

```js
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
```

## API de Caché

- **Definition**: Caching is the process of storing copies of files in a temporary storage location, so that they can be accessed more quickly.  The Cache API is used to store network requests and responses, making web applications work more efficiently and even function offline. Es parte de la API del Service Worker y es crucial para crear Aplicaciones Web Progresivas (PWAs) que puedan funcionar bajo condiciones de red poco fiables o lentas. La API de caché es un mecanismo de almacenamiento que almacena objetos de Request y Response. Cuando se hace una solicitud a un servidor, la aplicación puede almacenar la respuesta y luego recuperarla de la caché en lugar de hacer una nueva solicitud de red. Esto reduce los tiempos de carga, ahorra ancho de banda y mejora la experiencia general del usuario.
- **Almacenamiento en Caché**: Se utiliza para almacenar pares clave-valor de solicitudes HTTP y sus respuestas correspondientes. Esto permite la recuperación eficiente de recursos solicitados previamente, reduciendo la necesidad de obtenerlos de la red en visitas posteriores y mejorando el rendimiento.
- **Control de Caché**: Los desarrolladores pueden definir cuánto tiempo debe mantenerse un recurso en caché, y si debe ser revalidado o servido directamente desde la caché.
- **Soporte Sin Conexión**: Usando la API de Caché, se pueden crear aplicaciones web que prioricen el acceso sin conexión. Por ejemplo, una PWA puede servir recursos en caché cuando el usuario está desconectado de la red.

## Patrones Negativos y Almacenamiento del Lado del Cliente

- **Rastreo Excesivo**: Se refiere a la práctica de recopilar y almacenar un exceso de datos del usuario en el almacenamiento del lado del cliente (como cookies, almacenamiento local o almacenamiento de sesión) sin un consentimiento claro, informado o una necesidad legítima. Esto a menudo implica el rastreo de comportamiento del usuario, preferencias e interacciones a través de múltiples sitios o sesiones, lo que puede infringir la privacidad del usuario.
- **Huella Digital del Navegador**: Una técnica utilizada para rastrear e identificar usuarios individuales basada en características únicas de su dispositivo y navegador, en lugar de confiar en cookies u otros métodos de seguimiento tradicionales. A diferencia de las cookies, que se almacenan localmente en el dispositivo del usuario, la huella digital implica recopilar una variedad de información que se puede usar para crear una "huella" distintiva de la sesión del navegador de un usuario.
- **Estableciendo Contraseñas en LocalStorage**: Incluso si parece un patrón negativo más obvio, establecer cualquier dato sensible como contraseñas en almacenamiento local representa un riesgo de seguridad. El Almacenamiento Local no está encriptado y se puede acceder fácilmente. Por lo tanto, nunca debes almacenar ningún tipo de datos sensibles allí.

## IndexedDB

- **Definición**: IndexedDB se usa para almacenar datos estructurados en el navegador. Esto está incorporado en los navegadores web modernos, permitiendo que las aplicaciones web almacenen y recuperen objetos de JavaScript de manera eficiente.

## Caché/Service Workers

- **Definición**: Un Service Worker es un script que se ejecuta en segundo plano y que está separado de la página web. Puede interceptar solicitudes de red, acceder a la caché y hacer que la aplicación web funcione sin conexión. Este es un componente clave de las aplicaciones web progresivas.

## Conceptos Básicos para Trabajar con Clases

- **Definición**: Las clases en JavaScript se utilizan para definir planos para crear objetos y encapsular datos. Las clases incluyen un constructor que es un método especial que se llama automáticamente cuando se crea un nuevo objeto a partir de la clase. Se usa para inicializar las propiedades del objeto. La palabra clave `this` se utiliza aquí para referirse a la instancia actual de la clase. Debajo del constructor, puedes tener lo que se llaman métodos. Los métodos son funciones definidas dentro de una clase que realizan acciones u operaciones sobre los datos o el estado de la clase. Se utilizan para definir comportamientos que pueden realizar las instancias de la clase.

```js
class Dog {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
}
```

Para crear una nueva instancia de la clase, se utiliza la palabra clave `new` seguida del nombre de la clase:

```js
const dog = new Dog("Gino");
```

También puedes crear clases como expresiones de clase. Aquí es donde la clase es anónima y se asigna a una variable. 

```js
const Dog = class {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
};
```

## Herencia de Clases

- **Definición**: En programación, la herencia te permite definir clases que heredan propiedades y métodos de clases padres. Esto fomenta la reutilización del código y establece una relación jerárquica entre las clases. Una clase padre es una clase que actúa como un plano para otras clases. Define propiedades y métodos que son heredados por otras clases. Una clase hija es una clase que hereda las propiedades y métodos de otra clase. Las clases hija también pueden extender la funcionalidad de sus clases padre agregando nuevas propiedades y métodos. En JavaScript, usamos la palabra clave `extends` para implementar herencia. Esta palabra clave indica que una clase es la clase hija de otra clase.

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

La palabra clave `super` se usa para acceder a los métodos, constructores y campos de la clase padre.


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

## Trabajando con Métodos Estáticos y Propiedades Estáticas

- **Métodos estáticos**: Estos métodos se usan a menudo para funciones de utilidad que no necesitan acceso al estado específico de un objeto. Se definen en las clases para encapsular funcionalidad relacionada. Los métodos estáticos también son útiles para implementar métodos "factory". Un método factory es un método que defines además del constructor para crear objetos basados en criterios específicos.

```js
class Movie {
  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }
}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);

Movie.compareMovies(movieA, movieB);
```

- **Propiedades estáticas**: Estas propiedades se utilizan para definir valores o atributos que están asociados con la clase en sí, en lugar de con las instancias de la clase. Las propiedades estáticas se comparten en todas las instancias de la clase y se pueden acceder sin crear una instancia de la clase.

```js
class Car {
  // Static property
  static numberOfWheels = 4;

  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  // Instance method
  getCarInfo() {
    return `${this.make} ${this.model}`;
  }

  // Static method
  static getNumberOfWheels() {
    return Car.numberOfWheels;
  }
}

// Accessing static property directly from the class
console.log(Car.numberOfWheels); 
```

## Recursión

- La recursión es un concepto de programación que te permite llamar a una función repetidamente hasta alcanzar un caso base.

Aquí tienes un ejemplo de una función recursiva que calcula el factorial de un número:

```js
function findFactorial(n) {
  if (n === 0) {
    return 1;
  }
  return n * findFactorial(n - 1);
}
```

En el ejemplo anterior, la función `findFactorial` se llama recursivamente hasta que `n` alcanza `0`. Cuando `n` es `0`, se llega al caso base y la función devuelve `1`. La función entonces devuelve el producto de `n` y el resultado de la llamada recursiva a `findFactorial(n - 1)`.

- La recursión permite manejar algo con una profundidad desconocida, como objetos/arreglos anidados profundamente o un árbol de archivos.
- Se utiliza una pila de llamadas para realizar un seguimiento de las llamadas a funciones en una función recursiva. Cada vez que se llama a una función, se agrega a la pila de llamadas. Cuando se alcanza el caso base, las llamadas de función se eliminan del stack.
- Debes definir cuidadosamente el caso base ya que llamarlo indefinidamente puede hacer que tu Código deje de funcionar. Esto se debe a que la recursión sigue acumulando más y más llamadas a funciones hasta que el sistema se queda sin memoria.
- Las recursiones encuentran su uso en la resolución de problemas matemáticos como factorial y Fibonacci, recorrer árboles y grafos, generar permutaciones y combinaciones y mucho más.

## Funciones Puras vs Impuras

- Una función pura es aquella que siempre produce la misma salida para la misma entrada y no tiene efectos secundarios. Su salida depende únicamente de su entrada y no modifica ningún estado externo.
- Las funciones impuras tienen efectos secundarios, que son cambios en el estado del programa observables fuera de la función.

## Programación funcional

- La Programación Funcional es un enfoque del desarrollo de software que enfatiza el uso de funciones para resolver problemas, centrándose en lo que se debe hacer en lugar de cómo hacerlo.
- La programación funcional fomenta el uso de técnicas que ayudan a evitar efectos secundarios, como el uso de estructuras de datos inmutables y funciones de orden superior.
- Cuando se utiliza correctamente, los principios de la programación funcional conducen a un código más limpio y mantenible

## Currying

- El currying es una técnica de programación funcional que transforma una función con múltiples argumentos en una secuencia de funciones, cada una con un solo argumento.

Aquí tienes un ejemplo de una función regular vs una función curried:

```js
// Regular function

function average(a, b, c) {
  return (a + b + c) / 3;
}

// Curried function

function curriedAverage(a) {
  return function(b) {
    return function(c) {
      return (a + b + c) / 3;
    };
  };
}

// Usage of curried function

const avg = curriedAverage(2)(3)(4);
```

- El currying puede ser particularmente poderoso al trabajar con funciones que toman muchos argumentos.
- El currying hace que tu código sea más flexible y fácil de reutilizar.
- Puedes usar funciones flecha para crear funciones curry de manera más concisa:

```js
const curriedAverage = a => b => c => (a + b + c) / 3;
```

- Aunque el currying puede llevar a un código más flexible y reutilizable, también puede hacer que el código sea más difícil de leer si se abusa de él.

## JavaScript asíncrono

- **JavaScript Síncrono** se ejecuta secuencialmente y espera a que la operación anterior termine antes de pasar a la siguiente.
- **JavaScript Asíncrono** permite que varias operaciones se ejecuten en segundo plano sin bloquear el hilo principal.
- **Hilo** es una secuencia de instrucciones que pueden ejecutarse independientemente del flujo principal del programa.
- **Funciones de devolución de llamada** son funciones que se pasan como argumentos a otras funciones y se ejecutan después de que la operación se complete o como resultado de un evento.

## El motor de JavaScript y el entorno de ejecución de JavaScript

- El **motor de JavaScript** es un programa que ejecuta código JavaScript en un navegador web. Funciona como un convertidor que toma tu código, lo transforma en instrucciones que la computadora puede entender y procede en consecuencia.
- V8 es un ejemplo de un motor de JavaScript desarrollado por Google.
- El **tiempo de ejecución de JavaScript** es el entorno en el que se ejecuta el código JavaScript. Incluye el motor de JavaScript que procesa y ejecuta el código, y características adicionales como un navegador web o Node.js.

## La API Fetch

- La API Fetch permite a las aplicaciones web hacer solicitudes de red, típicamente para recuperar o enviar datos al servidor. Proporciona un método `fetch()` que puedes usar para realizar estas requests.
- Puedes recuperar texto, imágenes, audio, JSON y otros tipos de datos usando la API Fetch.

## Métodos HTTP para la API Fetch

La API Fetch soporta varios métodos HTTP para interactuar con el servidor. Los métodos más comunes son:

- **GET**: Se utiliza para recuperar datos del servidor. Por defecto, la API Fetch usa el método `GET` para recuperar datos.

```js
fetch('https://api.example.com/data')
```

Para utilizar los datos obtenidos, es necesario convertirlos al formato JSON usando el método `.json()`:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

En este código, la respuesta que viene de la API Fetch es una promesa y el manejador `.then` está convirtiendo la respuesta a un formato JSON.

- **POST**: Se utiliza para enviar datos al servidor. El método `POST` se utiliza para crear nuevos recursos en el servidor.

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

En este ejemplo, estamos enviando una solicitud ` POST ` para crear un nuevo usuario. Hemos especificado el método como `POST`, establecido los encabezados apropiados y hemos incluido un cuerpo con los datos que queremos enviar. El cuerpo debe ser una cadena, por lo que utilizamos ` JSON.stringify() ` para convertir nuestro objeto en una cadena JSON.

- **PUT**: Se utiliza para actualizar datos en el servidor. El método `PUT` se usa para actualizar recursos existentes en el servidor.

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

En este ejemplo, estamos actualizando el ID `45` que se especifica al final del URL. Hemos usado el método `PUT` en el código y también hemos especificado los datos como el cuerpo que se usará para actualizar los datos identificados. 

- **DELETE**: Se usa para eliminar datos en el servidor. El método `DELETE` se utiliza para eliminar recursos en el servidor.

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

En este ejemplo, estamos enviando una request `DELETE` para eliminar un usuario con el ID `45`.

## Promesa y encadenamiento de promesas

- Las **promesas** son objetos que representan la finalización o el fallo eventual de una operación asincrónica y su valor resultante. El valor de la promesa es conocido solo cuando la operación `async` se completa.
- Aquí tienes un ejemplo para crear una promesa simple:

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- El método `.then()` se utiliza en una promesa para especificar qué debería suceder cuando la promesa se cumple, mientras que `.catch()` se usa para manejar cualquier error que ocurra.
- Aquí hay un ejemplo del uso de `.then()` y `.catch()` con una promesa:

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

En el ejemplo anterior, el método `.then()` se usa para imprimir los datos recibidos de la promesa, mientras que el método `.catch()` se usa para imprimir cualquier error que ocurra.

- **Encadenamiento de promesas**: Una de las características poderosas de las promesas es que podemos encadenar múltiples operaciones asincrónicas juntas. Cada `.then()` puede devolver una nueva promesa, lo que te permite realizar una secuencia de operaciones asincrónicas una tras otra.
- Aquí tienes un ejemplo de encadenamiento de promesas:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

En el ejemplo anterior, primero obtenemos datos de una URL, luego obtenemos datos de otra URL en base a la primera respuesta, y finalmente imprimimos los segundos datos recibidos. 

El método `catch` manejaría cualquier error que ocurra durante el proceso. Esto significa que no necesita agregar manejo de errores a cada paso individual, lo que puede simplificar enormemente su código.

## Uso de `async/await` para manejar promesas

Async/await facilita escribir y leer código asíncrono que está construido sobre Promises.

- **async**: La palabra clave `async` se usa para definir una función asincrónica. Una función `async` devuelve una promesa, la cual se resuelve con el valor devuelto por la función `async`.
- **await**: La palabra clave `await` se utiliza dentro de una función `async` para pausar la ejecución de la función hasta que la promesa se resuelva. Solo puede usarse dentro de una función `async`.
- Aquí tienes un ejemplo de uso de `async/await`:

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

En el ejemplo anterior, la función `delayedGreeting` es una función `async` que se pausa durante 2 segundos antes de imprimir el mensaje de saludo. La palabra clave `await` se usa para pausar la ejecución de la función hasta que la `Promise` se resuelva.

- Una de las mayores ventajas de `async/await` es el manejo de errores a través de bloques `try/catch`. Aquí tienes un ejemplo:

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

En el ejemplo anterior, el bloque `try` contiene el código que podría generar un error, y el bloque `catch` maneja el error si ocurre. Esto hace que el manejo de errores sea más simple y legible.

## El atributo `async`

- El atributo `async` le dice al navegador que descargue el archivo de script de manera asíncrona mientras continúa analizando el documento HTML.
- Una vez que el script se descarga, el análisis HTML se pausa, el script se ejecuta y luego se reanuda el análisis HTML.
- Deberías usar `async` para scripts independientes donde el orden de ejecución no importe.

## El atributo `defer`

- El atributo `defer` también descarga el script de forma asíncrona, pero difiere la ejecución del script hasta que el documento HTML haya sido completamente analizado.
- Los scripts diferidos mantienen el orden de ejecución como aparecen en el documento HTML.

- Es importante observar que tanto los atributos `async` como `defer` se ignoran para scripts internos y solo funcionan para archivos de script externos.

- Cuando ambos atributos, `async` y `defer`, están presentes, el atributo `async` tiene precedencia.

## API de Geolocalización

- La API de Geolocalización proporciona una forma para que los sitios web soliciten la ubicación del usuario.

- El ejemplo de abajo demuestra el uso del método `getCurrentPosition()` de la API, el cual se utiliza para obtener la ubicación actual del usuario.

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

En este código, estamos llamando a `getCurrentPosition` y pasándole una función que se llamará cuando la posición se obtenga exitosamente. 

El objeto `position` contiene una variedad de información, pero aquí hemos seleccionado solo `latitud` y `longitud`.

Si hay un problema al obtener la `posición`, entonces el error se registrará en la consola. Es importante respetar la privacidad del usuario y solicitar su ubicación solo cuando sea necesario.


# --assignment--

Revise los temas y conceptos de JavaScript.
