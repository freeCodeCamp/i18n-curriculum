---
id: 587d8252367417b2b2512c67
title: 在鏈結串列的特定索引處添加元素
challengeType: 1
forumTopicId: 301619
dashedName: add-elements-at-a-specific-index-in-a-linked-list
---

# --description--

讓我們創建一個 `addAt(index,element)` 方法，在指定的索引處添加一個元素。就像我們在指定索引處移除元素一樣，我們需要在巡訪鏈結串列時追蹤 `currentIndex`。當 `currentIndex` 與給定的索引相符時，我們需要重新指定前一個節點的 `next` 屬性以引用新添加的節點。而新節點應該引用 `currentIndex` 中的下一個節點。回到排隊的例子，一個新的人想加入隊伍，但他想加入中間。你正好在隊伍中間，所以你放開了前面那個人的手。新的人走過來，將他的手放在你之前握著的那個人身上，而你現在握著新的人。

# --instructions--

創建一個 `addAt(index,element)` 方法，將元素添加到指定的索引。若無法添加元素，則傳回 false。**注意：** 請記得檢查給定的索引是否為負數或超過鏈結串列的長度。

# --hints--

當給定的索引為 0 時，你的 `addAt` 方法應該將 `head` 重新指定為新節點。

```js
assert(
  (function () {
    var test = new LinkedList();
    test.add('cat');
    test.add('dog');
    test.addAt(0, 'fish');
    return test.head().element === 'fish' && test.head().next.element === 'cat';
  })()
);
```

你的 `addAt` 方法應該在每次將新節點添加到鏈結串列時，使鏈結串列的長度增加一。

```js
assert(
  (function () {
    var test = new LinkedList();
    test.add('cat');
    test.add('dog');
    test.addAt(0, 'cat');
    return test.size() === 3;
  })()
);
```

如果節點無法被添加，你的 `addAt` 方法應該傳回 `false`。

```js
assert(
  (function () {
    var test = new LinkedList();
    test.add('cat');
    test.add('dog');
    return test.addAt(4, 'cat') === false;
  })()
);
```

# --seed--

## --seed-contents--

```js
function LinkedList() {
  var length = 0;
  var head = null;

  var Node = function(element) {
    this.element = element;
    this.next = null;
  };

  this.size = function() {
    return length;
  };

  this.head = function() {
    return head;
  };

  this.add = function(element) {
    var node = new Node(element);
    if (head === null) {
      head = node;
    } else {
      var currentNode = head;

      while (currentNode.next) {
        currentNode = currentNode.next;
      }

      currentNode.next = node;
    }
    length++;
  };

  // Only change code below this line

  // Only change code above this line
}
```

# --solutions--

```js
function LinkedList() {
  var length = 0;
  var head = null;

  var Node = function(element){
    this.element = element;
    this.next = null;
  };

  this.size = function(){
    return length;
  };

  this.head = function(){
    return head;
  };

  this.add = function(element){
    var node = new Node(element);
    if (head === null){
        head = node;
    } else {
      var currentNode = head;

      while (currentNode.next) {
        currentNode = currentNode.next;
      }

      currentNode.next = node;
    }
    length++;
  };
  this.addAt = function (index, element) {
    if (index > length || index < 0) {
      return false;
    }
    var newNode = new Node(element);
    var currentNode = head;
    if (index === 0) {
      head = newNode;
    } else {
      var previousNode = null;
      var i = 0;
      while (currentNode && i < index) {
        previousNode = currentNode;
        currentNode = currentNode.next;
        i++;
      }
      previousNode.next = newNode;
    }
    newNode.next = currentNode;
    length++;
  }
}
```
