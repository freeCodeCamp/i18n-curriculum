---
id: 68cabc534d2e741f33a3fe1d
title: 构建一个游戏字符属性追踪器
challengeType: 27
dashedName: lab-game-character-stats
---

# --description--

在本实验中，你将创建一个游戏字符属性追踪器。该程序将允许你创建具有特定属性的字符，更新这些属性，并检索该字符的当前状态。

**目标：**实现以下用户需求并通过所有测试以完成实验。

**用户故事：**

1. 创建一个名为 `GameCharacter` 的类，用于表现游戏中的字符并管理字符属性。
2. 实例化时，新的 `GameCharacter` 对象应具有以下属性：
    - `_name` 设置为实例化时给定的字串。
    - `_health` 设置为 `100`。
    - `_mana` 设置为 `50`。
    - `_level` 设置为 `1`。
3. 为角色的名称创建一个只读访问的 `name` 属性。
4. 对于 `health` 属性：
     - 定义一个返回当前生命值的 getter。
     - 定义一个 setter，防止将健康值设置为低于 `0`，并将健康值限制在 `100`。
5. 对于 `mana` 属性：
     - 定义一个返回当前法力值的 getter。
     - 定义一个 setter，防止将 `mana` 设置为低于 `0`，并将 `mana` 限制在 `50`。
6. 为 `level` 创建一个 getter，以返回该字符的当前等级。
7. 定义一个名为 `level_up` 的方法，该方法：
    - 将 `character` 的等级提升 1。
    - 将生命值重置为 `100`，将法力值重置为 `50`，使用它们对应的属性设置器。
    - 以 `<name> leveled up to <level>!` 形式打印一条消息（其中 `<name>` 和 `<level>` 应分别替换为字符的名字和新建等级）。
8. 定义一个 `__str__` 方法，返回包含以下内容的格式化字串：
    - 该字符的名称。
    - 该字符的等级。
    - 该字符的当前生命值。
    - 该字符当前的法力值。  
例如，名为 `Kratos` 的字符，在实例化后，应表现为以下内容：

   ```md
   Name: Kratos
   Level: 1
   Health: 100
   Mana: 50
   ```

## 使用示例

```python
hero = GameCharacter('Kratos') # Creates a new character named Kratos
print(hero)  # Displays the character's stats

hero.health -= 30  # Decreases health by 30
hero.mana -= 10    # Decreases mana by 10
print(hero)  # Displays the updated stats

hero.level_up()  # Levels up the character
print(hero)  # Displays the stats after leveling up
```

# --hints--

你应该有一个 `GameCharacter` 类。

```js
({ test: () => assert(runPython(`_Node(_code).has_class("GameCharacter")`)) })
```

你应该在 `GameCharacter` 类中有一个 `__init__` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("__init__")`) 
})
```

`__init__` 方法应有两个参数，第一个参数为 `self`。

```js
({ 
    test: () => runPython(`
    import inspect
    params = list(inspect.signature(GameCharacter.__init__).parameters)
    assert params[0] == "self"
    assert len(params) == 2
    `) 
})
```

你应该在 `__init__` 方法内将 `self._name` 设置为实例化时给定的字串。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._name == "Kratos"
    `) 
})
```

你应该在 `__init__` 方法内将 `100` 赋值给 `self._health`。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._health == 100
    `) 
})
```

你应该在 `__init__` 方法内将 `50` 赋值给 `self._mana`。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._mana == 50
    `) 
})
```

你应该在 `__init__` 方法内将 `1` 赋值给 `self._level`。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._level == 1
    `) 
})
```

你应该在 `GameCharacter` 类中有一个 `name` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("name")`) 
})
```

`name` 方法应该只有一个参数，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("name").has_args("self")`) 
})
```

你应该在 `name` 方法中返回 `self._name`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("name").has_return("self._name")`)
})
```

`name` 方法应具有 `@property` 装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("name").has_decorators("property")`) 
})
```

你应该在 `GameCharacter` 类中有一个 `health` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("health")`) 
})
```

`health` 方法应该只有一个参数，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("health").has_args("self")`) 
})
```

你应该在 `health` 方法中返回 `self._health`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("health").has_return("self._health")`)
})
```

`health` 方法应具有 `@property` 装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("health").has_decorators("property")`) 
})
```

你应该创建一个 `health` setter 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("health")[1]`) 
})
```

`health` 的 setter 方法 应该有一个 `@health.setter` 装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("health")[1].has_decorators("health.setter")`) 
})
```

`health` 设置方法应有两个参数，第一个为 `self`。

```js
({ 
    test: () => runPython(`
    import inspect
    params = list(inspect.signature(GameCharacter.health.fset).parameters)
    assert params[0] == "self"
    assert len(params) == 2`) 
})
```

如果传递给 `health` setter 的值小于 `0`，你应该将 `self._health` 设置为 `0`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.health = -1
    assert char.health == 0
    char.health = -10
    assert char.health == 0
`)})
```

如果传递给 `health` setter 的值大于 `100`，你应该将 `self._health` 设置为 `100`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.health = 101
    assert char.health == 100
    char.health = 200
    assert char.health == 100
`)})
```

当值在 `0` 和 `100` 之间时，你应将 `self._health` 设置为传递给 `health` setter 的值。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.health = 95
    assert char.health == 95
    char.health = 1
    assert char.health == 1
    char.health = 0
    assert char.health == 0
    char.health = 100
    assert char.health == 100
`)})
```

你应该在 `GameCharacter` 类中有一个 `mana` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("mana")`) 
})
```

`mana` 方法应该只有一个参数，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("mana").has_args("self")`) 
})
```

你应该在 `mana` 方法中返回 `self._mana`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("mana").has_return("self._mana")`)
})
```

`mana` 方法应具有 `@property` 装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("mana").has_decorators("property")`) 
})
```

你应该创建一个 `mana` setter 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("mana")[1]`) 
})
```

`mana` 的 setter 方法应有一个 `@mana.setter` 装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("mana")[1].has_decorators("mana.setter")`) 
})
```

`mana` 的 setter 方法应有两个参数，第一个是 `self`。

```js
({ 
    test: () => runPython(`
    import inspect
    params = list(inspect.signature(GameCharacter.mana.fset).parameters)
    assert params[0] == "self"
    assert len(params) == 2`) 
})
```

如果传递给 `mana` setter 的值小于 `0`，你应该将 `self._mana` 设置为 `0`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.mana = -1
    assert char.mana == 0
    char.mana = -10
    assert char.mana == 0
`)})
```

如果传递给 `mana` setter 的值大于 `50`，你应该将 `self._mana` 设置为 `50`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.mana = 51
    assert char.mana == 50
    char.mana = 100
    assert char.mana == 50
`)})
```

如果值在 `0` 和 `50` 之间，你应该将 `self._mana` 设置为传递给 `mana` setter 的值。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.mana = 25
    assert char.mana == 25
    char.mana = 0
    assert char.mana == 0
    char.mana = 50
    assert char.mana == 50
`)})
```

你应该在 `GameCharacter` 类中有一个 `level` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("level")`) 
})
```

`level` 方法应该只有一个参数，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level").has_args("self")`) 
})
```

你应该在 `level` 方法中返回 `self._level`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level").has_return("self._level")`)
})
```

`level` 方法应具有 `@property` 装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level").has_decorators("property")`) 
})
```

你应该在 `GameCharacter` 类中有一个 `level_up` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("level_up")`) 
})
```

`level_up` 方法应该只有一个参数，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level_up").has_args("self")`) 
})
```

你应该在 `level_up` 方法中将 `self._level` 增加 `1`。

```js
({ 
  test: () => runPython(`
    node = _Node(_code).find_class("GameCharacter").find_function("level_up")
    assert (
        node.has_stmt("self._level += 1") or
        node.has_stmt("self._level = self._level + 1")
    )
`)
})
```

你应该在 `level_up` 方法中将 `self.health` 设置为 `100`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level_up").has_stmt("self.health = 100")`) 
})
```

你应该在 `level_up` 方法中将 `self.mana` 设置为 `50`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level_up").has_stmt("self.mana = 50")`) 
})
```

`level_up` 方法应打印 `<name> leveled up to <level>!`（其中 `<name>` 和 `<level>` 应分别替换为字符的名字和新等级）。

```js
({
  test: () => runPython(`
    import io
    import sys
            
    captured_output = io.StringIO()
    sys.stdout = captured_output
            
    gc = GameCharacter("test")
    gc.level_up()
            
    sys.stdout = sys.__stdout__
    output = captured_output.getvalue()
            
    assert "test leveled up to 2!" in output
`)
})
```

你应该在 `GameCharacter` 类中有一个 `__str__` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("__str__")`) 
})
```

`__str__` 方法应只有一个参数，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("__str__").has_args("self")`) 
})
```

你的 `__str__` 方法应返回一个使用提供格式的包含该字符属性的字串。

```js
({ 
  test: () => runPython(`
    import io
    import sys
            
    captured_output = io.StringIO()
    sys.stdout = captured_output
            
    gc = GameCharacter("test")
    gc.mana = 15
    gc.health = 77
    print(gc)
            
    sys.stdout = sys.__stdout__
    output = captured_output.getvalue()
    expected = """Name: test
    Level: 1
    Health: 77
    Mana: 15"""
    assert expected in output
`)
})
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
class GameCharacter:
    def __init__(self, name):
        self._name = name
        self._health = 100
        self._mana = 50
        self._level = 1

    @property
    def name(self):
        return self._name

    @property
    def health(self):
        return self._health

    @health.setter
    def health(self, value):
        if value < 0:
            self._health = 0
        elif value > 100:
            self._health = 100
        else:
            self._health = value

    @property
    def mana(self):
        return self._mana

    @mana.setter
    def mana(self, value):
        if value < 0:
            self._mana = 0
        elif value > 50:
            self._mana = 50
        else:
            self._mana = value

    @property
    def level(self):
        return self._level

    def level_up(self):
        self._level += 1
        self.health = 100
        self.mana = 50
        print(f"{self._name} leveled up to {self._level}!")

    def __str__(self):
        return (
            f"Name: {self._name}\n"
            f"Level: {self._level}\n"
            f"Health: {self._health}\n"
            f"Mana: {self._mana}"
        )
```
