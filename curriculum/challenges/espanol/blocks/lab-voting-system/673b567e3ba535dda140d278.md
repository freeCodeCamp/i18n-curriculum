---
id: 673b567e3ba535dda140d278
title: Construir un sistema de votación
challengeType: 26
dashedName: build-a-voting-system
saveSubmissionToDB: true
---

# --description--

En este laboratorio, construirás un sistema de votación que usa `Map` para crear una encuesta y `Set` para evitar votos duplicados.

**Objetivo:** Cumplir con las historias de usuario a continuación y pasar todas las pruebas para completar el laboratorio.

**Historias de usuario:**

1. Deberías inicializar una variable `poll` a un nuevo objeto `Map`.

2. Deberías tener una función `addOption` que acepte un parámetro `option`.

3. En la función `addOption`:

   - Si el `option` no existe ya en la encuesta, debe añadirse a la encuesta con un `Set` vacío como su valor para rastrear a los votantes. También debes devolver el mensaje `Option "<option>" added to the poll.`

   - Si el `option` ya existe, debe devolver el mensaje `Option "<option>" already exists.`

   - Si intentas agregar una opción vacía, la función debe devolver el mensaje `Option cannot be empty.`

4. Deberías tener una función `vote` que acepte dos parámetros, `option` (la opción para votar) y `voterId` (un ID único para el votante).

5. En la función `vote`:

   - Si la `option` no existe en la encuesta, la función debe devolver el mensaje `Option "<option>" does not exist.`

   - Si la `option` existe, la función debería verificar si el `voterId` ya ha votado por esta `option`.

   - Si el votante ya ha votado, la función debería devolver el mensaje `Voter <voterId> has already voted for "<option>".`

   - Si el votante no ha votado, `voterId` debe añadirse al `Set` de `voters` para esta opción. La función debe devolver el mensaje `Voter <voterId> voted for "<option>".`

6. Deberías tener al menos tres opciones en tu `poll`.

7. Tu `poll` debería tener al menos tres votos.

8. Deberías tener una función `displayResults` que devuelva los resultados de la encuesta en el siguiente formato:

```js
Poll Results:
OptionA: N votes
OptionB: N votes
.
.

/*
sample output

Poll Results:
Turkey: 2 votes
Morocco: 1 votes
*/
```

# --hints--

Deberías tener una variable `poll` inicializada a un nuevo objeto `Map`.

```js
assert.exists(poll);
assert.instanceOf(poll, Map);
```

Deberías definir una función `addOption` que acepte un parámetro `option`.

```js
assert.isFunction(addOption);
assert.match(
  addOption.toString(),
  /^function\s+addOption\s*\(\s*option\s*\)\s*\{|\(?\s*option\s*\)?\s*=>/
);
```

Deberías definir una función `vote` que acepte dos parámetros, `option` y `voterId`.

```js
assert.isFunction(vote);
assert.match(vote.toString(), /\(\s*option\s*,\s*voterId\s*\)/);
```

Deberías definir una función `displayResults` para mostrar los resultados de la encuesta.

```js
assert.isFunction(displayResults);
```

Deberías tener al menos tres opciones en tu `poll`.

```js
assert.isAtLeast(poll.size, 3);
```

Tu `poll` debería tener al menos tres votos.

```js
let totalVotes = 0;
for (let voters of poll.values()) {
  totalVotes += voters.size;
}
assert.isAtLeast(totalVotes, 3);
```

Deberías asegurar que cada opción de votación mapee a un objeto `Set`.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();

  addOption('Turkey');
  assert.instanceOf(poll.get('Turkey'), Set);
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

`addOption("Egipto")` debería devolver `Opción "Egipto" añadida a la encuesta.`.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  assert.equal(addOption('Egypt'), 'Option "Egypt" added to the poll.');
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

Añadir una opción vacía debería devolver `"La opción no puede estar vacía."`.

```js
assert.equal(addOption(''), 'Option cannot be empty.');
```

Cuando `Turkey` ya está añadida, `addOption("Turkey")` debería devolver `Opción "Turkey" ya existe.`.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Turkey');
  addOption('Turkey');
  assert.equal(addOption('Turkey'), 'Option "Turkey" already exists.');
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

Cuando `Malaysia` existe en las opciones de votación, `vote("Malaysia", "traveler1")` debería devolver `El votante traveler1 votó por "Malaysia".`.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Malaysia');
  assert.equal(
    vote('Malaysia', 'traveler1'),
    'Voter traveler1 voted for "Malaysia".'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

`vote` debería actualizar el `Set` de votantes para una opción.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Alaska');
  vote('Alaska', 'seal');
  assert.isTrue(poll.get('Alaska').has('seal'));
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

Cuando `traveler1` intenta votar por `Algeria` de nuevo, `vote("Algeria", "traveler1")` debería devolver `El votante traveler1 ya ha votado por "Algeria".`.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Algeria');
  vote('Algeria', 'traveler1');
  assert.equal(
    vote('Algeria', 'traveler1'),
    'Voter traveler1 has already voted for "Algeria".'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

Los votos duplicados no deberían aumentar el tamaño del `Set`.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Turkey');
  vote('Turkey', 'traveler1');
  const voterSet = poll.get('Turkey');
  const initialSize = voterSet.size;

  vote('Turkey', 'traveler1');
  assert.equal(voterSet.size, initialSize);
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

Cuando `Nigeria` no está en las opciones de votación, `vote("Nigeria", "traveler2")` debería devolver `Opción "Nigeria" no existe.`.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  assert.equal(
    vote('Nigeria', 'traveler2'),
    'Option "Nigeria" does not exist.'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

Una opción única debería ser capaz de recibir múltiples votos.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Bali');
  assert.equal(vote('Bali', 'traveler1'), 'Voter traveler1 voted for "Bali".');
  assert.equal(vote('Bali', 'traveler2'), 'Voter traveler2 voted for "Bali".');
  assert.equal(poll.get('Bali').size, 2);
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

Cuando la opción `Turkey` recibe dos votos, la opción `Morocco` recibe un voto, y la opción `Spain` no recibe ningún voto, `displayResults()` debería devolver `"Poll Results:\nTurkey: 2 votes\nMorocco: 1 votes\nSpain: 0 votes"`.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Turkey');
  addOption('Morocco');
  addOption('Spain');

  vote('Turkey', 'traveler1');
  vote('Turkey', 'traveler2');
  vote('Morocco', 'traveler3');

  assert.equal(
    displayResults(),
    'Poll Results:\nTurkey: 2 votes\nMorocco: 1 votes\nSpain: 0 votes'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

`displayResults()` debería devolver los resultados en el formato correcto.

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Turkey');
  addOption('Morocco');

  vote('Turkey', 'traveler1');
  vote('Turkey', 'traveler2');
  vote('Morocco', 'traveler3');

  assert.equal(
    displayResults(),
    'Poll Results:\nTurkey: 2 votes\nMorocco: 1 votes'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
const poll = new Map();

function addOption(option) {
  if (!option || option.trim() === '') {
    return 'Option cannot be empty.';
  }
  if (!poll.has(option)) {
    poll.set(option, new Set());
    return `Option "${option}" added to the poll.`;
  } else {
    return `Option "${option}" already exists.`;
  }
}

function vote(option, voterId) {
  if (!poll.has(option)) {
    return `Option "${option}" does not exist.`;
  }
  const voters = poll.get(option);
  if (voters.has(voterId)) {
    return `Voter ${voterId} has already voted for "${option}".`;
  } else {
    voters.add(voterId);
    return `Voter ${voterId} voted for "${option}".`;
  }
}

function displayResults() {
  let results = 'Poll Results:\n';
  for (let [option, voters] of poll.entries()) {
    results += `${option}: ${voters.size} votes\n`;
  }
  return results.trim();
}

addOption('Turkey');
addOption('Morocco');
addOption('Spain');

vote('Turkey', 'traveler1');
vote('Turkey', 'traveler2');
vote('Morocco', 'traveler3');
```
