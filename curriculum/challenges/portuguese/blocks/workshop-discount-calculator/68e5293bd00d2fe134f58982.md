---
id: 68e5293bd00d2fe134f58982
title: Passo 9
challengeType: 20
dashedName: step-9
---

# --description--

Como discutido na lição anterior, métodos abstratos são métodos que devem ser implementados por qualquer classe que herde da classe base abstrata. Eles servem como um contrato, garantindo que todas as estratégias de desconto terão certos métodos obrigatórios.

Dentro da sua classe `DiscountStrategy`, defina um método chamado `is_applicable`. Use o decorador `@abstractmethod` acima da definição do método. O método deve ter os seguintes parâmetros: `self`, `product` e `user_tier`. Use a instrução `pass` no corpo do método.

Adicione dicas de tipo para deixar a assinatura do método clara: `product` deve ser do tipo `Product` e `user_tier` deve ser do tipo `str`.


# --hints--

Sua classe `DiscountStrategy` deve ter um método chamado `is_applicable`.

```js
({
  test: () => runPython(`assert _Node(_code).find_class("DiscountStrategy").has_function("is_applicable")`)
})
```

Seu método `is_applicable` deve ter o decorador `@abstractmethod`.

```js
({
  test: () => runPython(`assert _Node(_code).find_class("DiscountStrategy").find_function("is_applicable").has_decorators("abstractmethod")`)
})
```

Seu método `is_applicable` deve ter os parâmetros `self`, `product: Product` e `user_tier: str`.

```js
({
  test: () => runPython(`assert _Node(_code).find_class("DiscountStrategy").find_function("is_applicable").has_args("self,product:Product,user_tier:str")`)
})
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod

class Product:
    def __init__(self, name: str, price: float) -> None:
        self.name = name
        self.price = price

    def __str__(self) -> str:
        return f'{self.name} - ${self.price}'

--fcc-editable-region--
class DiscountStrategy(ABC):
    pass
--fcc-editable-region--
product = Product('Wireless Mouse', 50.0)
print(product)
```
