---
id: 695cc8f280fef0cc3bed02c8
title: 什么是 Crypto 模块及其工作原理？
challengeType: 19
dashedName: what-is-the-crypto-module-and-how-does-it-work
---

# --description--

Crypto 是另一个内置于 Node.js 的核心模块。它包含用于哈希、加密、解密和创建数字签名等功能的工具，这些功能都用于保护敏感信息并保持你的应用安全。

话虽如此，`crypto` 为你提供的是低级创建块，而不是即插即用的安全性。如果你不小心，编写自己的加密或认证代码可能是不安全的。在大多数情况下，最好使用经过充分测试的库，比如用于密码哈希的 `bcrypt` 或用于处理登录和令牌的 `jsonwebtoken`（JWT）。

话虽如此，了解 `crypto` 模块中某些方法的工作原理仍然很有用。

要使用这些方法，你需要导入 `crypto` 模块：

```js
const crypto = require("crypto");
```

有些方法用于数据转换目的，例如用于哈希和加密数据的方法，另一些则用于密钥和安全性管理，例如用于生成随机值和创建密钥的方法。

我们先来看用于哈希和加密数据的 `methods`。

`createHash()` 方法通过接收诸如 `sha256`、`sha512` 或 `md5` 之类的算法来创建哈希对象。这是一个单向操作，因此你无法逆转它。

`createHash()` 对于哈希密码和文件指纹识别非常有用。要使用它，你需要传入你的算法，使用 `update()` 方法输入数据，最后使用带编码的 `digest()` 来获取哈希值：

```js
const crypto = require("crypto");

const hashedPassword = crypto
  .createHash("sha256")
  .update("myStrongPassword")
  .digest("hex");

console.log("createHash result:", hashedPassword);
// createHash result: f92c9cfa0ead1bcec05ca75888a4074ba994ad237e5e2a8c7cc6a620378c061d
```

`createHmac()` 的功能几乎与 `createHash()` 相同，但它更进一步，接受一个密钥，因此只有拥有该密钥的人才能验证哈希。它非常适合认证和验证数据完整性：

```js
const crypto = require("crypto");

const hashedMessage = crypto
  .createHmac("sha256", "secretkey")
  .update("important-secret-message")
  .digest("hex");

console.log("createHmac result:", hashedMessage);
// createHmac result: da48d6f026b6036286b1fb872c63264130d5cc4271f3a213bb6ddca5a023e77e
```

`createCipheriv()` 和 `createDecipheriv()` 方法用于加密和解密数据。它们都接受一个算法、一个密钥和一个 `iv`，`iv` 是在加密过程开始时使用的一块随机或唯一的数据：

```js
createCipheriv(algorithm, key, iv);
createDecipheriv(algorithm, key, iv);
```

要解密数据，密钥必须相同，否则解密将失败，你将得到误差或无法读取的乱码，而不是原始消息。

下面是这两个的实际应用：

```js
const crypto = require("crypto");

// A key must match the algorithm length. Here AES-256 is 32 bytes
const key = Buffer.from("12345678901234567890123456789012");

// A fixed IV, 16 bytes for AES
const iv = Buffer.from("1234567890123456");

const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);

let encrypted = cipher.update("Hello campers!", "utf8", "hex");
encrypted += cipher.final("hex");

console.log("Encrypted data:", encrypted);
// Encrypted data: 4ee93aa398ab44e3540e4a67ca96bc8c

// Decrypt the "Hello campers!" message
const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
let decrypted = decipher.update(encrypted, "hex", "utf8");
decrypted += decipher.final("utf8");

console.log("Decrypted data:", decrypted);
// Decrypted data: Hello campers!
```

另一种用于数据转换的加密方法是 `sign()` 和 `verify()`。 

`sign()` 使用私有密钥从一些数据创建数字签名。该签名证明数据来自私有密钥的持有者且未被篡改。

`verify()` 然后查看该签名，如果数据或签名不匹配则失败。

现在，让我们来看用于生成随机值和创建密钥的加密方法。

`randomBytes()` 接受一个 `size` 并生成加密安全的令牌。这使它非常适合生成 UUID（通用唯一标识符）。此外，它是 `Math.random()` 的一个很好的替代品，后者对于令牌和密钥来说不安全。

```js
console.log("Random Bytes:", crypto.randomBytes(16));
// Random Bytes: <Buffer 01 88 aa 1e 2c 38 48 39 26 e1 6b a9 d8 c5 ed 49>
```

输出默认是一个缓冲区。正如你在关于 Buffer 模块的课程中学到的，你可以使用 `toString()` 方法将该缓冲区转换为字串：

```js
console.log("Random Bytes:", crypto.randomBytes(16).toString("hex"));
// Random Bytes: a6154ef5a296fa176ad0f332bd94d712
```

这里 `toString('hex')` 中的 `'hex'` 参数告诉 Node 将来自缓冲区的二进制数据编码为十六进制字串。

`randomInt()` 方法接受 `min` 和 `max` 值，并生成它们之间的安全随机整数。它对于 OTP 和随机选择非常有用。

```js
console.log("Random Int:", crypto.randomInt(0, 100)); // 89
```

同样，优于 `Math.random()` 和 `Math.floor()` 的地方在于该方法在底层使用了加密安全的随机性，因此攻击者无法预测生成的随机数。

另一种方法是 `createSecretKey()`。它接受一个缓冲区并生成一个封装在 `KeyObject` 中的未经处理的字节：

```js
const crypto = require("crypto");

const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret); // SecretKeyObject [KeyObject] { [Symbol(kKeyType)]: 'secret' }
```

然后你可以使用 `export` 方法导出该 `KeyObject`：

```js
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export());
// <Buffer 53 06 a1 c7 75 69 8b 38 8b a4 b2 f7 1b bc b8
// ae e2 d1 bf 67 af 1a 6a 0a 6e a0 29 62 bb 52 52 32>
```

最后，使用 `toString()` 在缓冲区上查看它的字串表现：

```js
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export().toString('hex'));
// 32dfe5917668580160986f1623bf8152913329c71163be9c3404a110cd78efd6
```

除了这些，还有：

- `createPublicKey()` 和 `createPrivateKey()`，让你可以使用其他地方生成的密钥
- `createDiffieHellman()` 让双方生成共享密钥而无需直接发送密钥
- `Certificate()` 用于处理 HTTPS 中使用的证书，因此你可以解析、导出和验证证书内容

# --questions--

## --text--

以下哪种方式是导入 Node.js `crypto` 模块的正确方法？

## --answers--

`const crypto = require('crypto')`

---

`const crypto = import('crypto')`

### --feedback--

关注 Node.js 用于引入内置模块的语法。

---

`import crypto from 'nodes:crypto'`

### --feedback--

关注 Node.js 用于引入内置模块的语法。

---

`crypto = requireModule('crypto')`

### --feedback--

关注 Node.js 用于引入内置模块的语法。

## --video-solution--

1

## --text--

关于 `sign()` 和 `verify()`，以下哪个语句是正确的？

## --answers--

`sign()` 使用公钥创建签名，`verify()` 使用私钥查看签名。

### --feedback--

请记住，数字签名使用私钥–公钥点对。

---

`sign()` 和 `verify()` 都只需要私有密钥。

### --feedback--

请记住，数字签名使用私钥–公钥点对。

---

`sign()` 使用私有密钥创建数字签名，`verify()` 使用相应的公钥查看它。

---

`verify()` 可以在不需要任何密钥的情况下查看签名。

### --feedback--

请记住，数字签名使用私钥–公钥点对。

## --video-solution--

3

## --text--

crypto 模块中使用 `sha256`、`sha512` 或 `md5` 等算法创建单向哈希对象的是什么方法？

## --answers--

`createCipheriv()`

### --feedback--

此 `method` 通常用于对密码进行哈希处理和对 `file` 进行指纹识别。

---

`createDiffieHellman()`

### --feedback--

此 `method` 通常用于对密码进行哈希处理和对 `file` 进行指纹识别。

---

`createSign()`

### --feedback--

此 `method` 通常用于对密码进行哈希处理和对 `file` 进行指纹识别。

---

`createHash()`

## --video-solution--

4
