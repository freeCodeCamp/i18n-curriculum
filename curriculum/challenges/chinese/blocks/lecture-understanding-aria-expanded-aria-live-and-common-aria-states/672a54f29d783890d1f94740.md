---
id: 672a54f29d783890d1f94740
title: 自定义控件元素上常用的 ARIA 状态有哪些？
challengeType: 19
dashedName: what-are-some-common-aria-states-used-on-custom-control-elements
---

# --interactive--

语义形式控件元素如 `input`、`select`、`textarea`、`button` 和 `fieldset` 具有内置状态，这些状态会传达给辅助技术。

例如，你可以使用 `disabled` 属性来禁用按钮，或使用 `checked` 属性来表示复选框已被选中。

但是如果你正在创建一个自定义控件元素，你需要使用 ARIA 属性向辅助技术传达控件的状态。

在本课中，我们将讨论你可以在自定义控件元素上使用的几个常见 ARIA 状态。

我们将讨论的第一个 ARIA 状态是 `aria-selected`。此状态用于指示元素已被选中。你可以在自定义控件中使用此状态，例如标签（页）接口、列表框或网格。

以下是如何在自定义标签（页）控件上使用 `aria-selected` 的示例：

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<div role="tablist">
  <button role="tab" aria-selected="true">Tab 1</button>
  <button role="tab" aria-selected="false">Tab 2</button>
  <button role="tab" aria-selected="false">Tab 3</button>
</div>
<script src="index.js"></script>
```

```css
[role="tablist"] {
  display: flex;
  border-bottom: 2px solid #ddd;
  gap: 0.25rem;
  font-family: system-ui, sans-serif;
}

[role="tab"] {
  appearance: none;
  border: none;
  background: none;
  padding: 0.5rem 1rem;
  cursor: pointer;
  font-size: 1rem;
  color: #444;
  border-radius: 4px 4px 0 0;
  transition: background-color 0.2s, color 0.2s;
}

[role="tab"]:hover {
  background-color: #f3f3f3;
}

[role="tab"][aria-selected="true"] {
  background-color: #fff;
  color: #0078d4;
  border: 2px solid #0078d4;
  border-bottom: 2px solid #fff; 
  font-weight: 600;
  position: relative;
  z-index: 1;
}

[role="tab"]:focus {
  outline: 2px solid #0078d4;
  outline-offset: 2px;
}

```

```js
document.addEventListener("click", (event) => {
  const clickedTab = event.target.closest('[role="tab"]');
  if (!clickedTab) return;

  const tablist = clickedTab.closest('[role="tablist"]');
  const tabs = tablist.querySelectorAll('[role="tab"]');

  tabs.forEach((tab) => {
    const isSelected = tab === clickedTab;
    tab.setAttribute("aria-selected", isSelected);
    tab.tabIndex = isSelected ? 0 : -1;
  });
});

document.addEventListener("keydown", (event) => {
  const activeTab = document.activeElement;
  if (activeTab.getAttribute("role") !== "tab") return;

  const tablist = activeTab.closest('[role="tablist"]');
  const tabs = Array.from(tablist.querySelectorAll('[role="tab"]'));
  const index = tabs.indexOf(activeTab);

  let newIndex = index;
  if (event.key === "ArrowRight") newIndex = (index + 1) % tabs.length;
  if (event.key === "ArrowLeft") newIndex = (index - 1 + tabs.length) % tabs.length;

  if (newIndex !== index) {
    tabs[newIndex].focus();
    tabs[newIndex].click();
  }
});

```

:::

标签（页）用于在有限空间内显示多个内容窗格。`aria-selected` 状态用于指示当前选中的标签（页）。

当用户选择一个标签（页）时，所选标签（页）的 `aria-selected` 状态被设置为 `true`，其他标签（页）的 `aria-selected` 状态被设置为 `false`。

另一个常见的 ARIA 状态是 `aria-disabled`。此状态用于向使用辅助技术（例如屏幕阅读器）的人指示某个元素已被禁用。需要注意的是，`aria-disabled` 并不会真正禁用该元素。由你，开发者，负责使其看起来并表现得像一个禁用的元素。此属性也常用于本地的超文本标记语言元素，替代 `disabled` 属性。你选择哪一个取决于按钮所使用的上下文。

下面是如何在自定义编辑按钮上使用 `aria-disabled` 的示例：

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<div role="button" tabindex="-1" aria-disabled="true">Edit</div>
```

```css
[role="button"] {
  display: inline-block;
  background-color: #0078d4;
  color: #fff;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-family: system-ui, sans-serif;
  font-size: 1rem;
  text-align: center;
  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s, transform 0.1s, opacity 0.2s;
}

[role="button"]:not([aria-disabled="true"]):hover {
  background-color: #005fa3;
}

[role="button"]:not([aria-disabled="true"]):focus {
  outline: 2px solid #005fa3;
  outline-offset: 2px;
}

[role="button"]:not([aria-disabled="true"]):active {
  transform: scale(0.97);
}

[role="button"][aria-disabled="true"] {
  opacity: 0.5;
  pointer-events: none;
  cursor: not-allowed;
  background-color: #b0b0b0;
  color: #f2f2f2;
}
```

:::

`aria-disabled` 属性用于告诉屏幕阅读器用户编辑按钮已被禁用且无法交互。再次强调，它并不会真正禁用按钮。使用 `aria-disabled` 时，你需要应用样式和 JavaScript 使控件看起来并表现得像一个禁用的按钮。

在大多数分支中，你可能会使用本地的按钮元素，但在某些情况下你可能需要使用自定义控件。因此，了解如何将控件的状态传达给辅助技术非常重要。

下一个我们将讨论的 ARIA 状态是 `aria-haspopup`。此状态用于指示交互式元素在激活时将触发弹出元素。只有当弹出元素具有以下角色之一时，你才能使用 `aria-haspopup` 属性：`menu`、`listbox`、`tree`、`grid` 或 `dialog`。`aria-haspopup` 的值必须是这些角色之一或 `true`，后者默认为 `menu` 角色。 

这是一个使用 `aria-haspopup` 的文件编辑器菜单示例：

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<button id="menubutton" aria-haspopup="menu" aria-controls="filemenu" aria-expanded="false">File</button>
<ul id="filemenu" role="menu" aria-labelledby="menubutton" hidden>
  <li role="menuitem" tabindex="-1">Open</li>
  <li role="menuitem" tabindex="-1">New</li>
  <li role="menuitem" tabindex="-1">Save</li>
  <li role="menuitem" tabindex="-1">Delete</li>
</ul>
```

```css
#menubutton {
  background-color: #0078d4;
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  position: relative;
}

#menubutton:hover,
#menubutton:focus {
  background-color: #005ea2;
  outline: none;
}

#filemenu {
  list-style: none;
  padding: 4px 0;
  margin: 4px 0 0;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: #fff;
  width: 160px;
  position: absolute;
  z-index: 1000;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#filemenu[hidden] {
  display: none;
}

#filemenu [role="menuitem"] {
  display: block;
  padding: 8px 12px;
  font-size: 14px;
  color: #333;
  cursor: pointer;
}

#filemenu [role="menuitem"]:hover,
#filemenu [role="menuitem"]:focus {
  background-color: #e5f1fb;
  outline: none;
}

#filemenu [role="menuitem"]:focus-visible {
  box-shadow: inset 0 0 0 2px #0078d4;
}

```

:::

`aria-haspopup` 状态用于指示 `File` 菜单按钮在激活时将打开弹出菜单。屏幕阅读器用户在导航到该按钮时可能会听到此附加信息。

你需要使用 JavaScript 来显示和隐藏弹出 `menu`，并实现与 `menu` 交互的适当键盘支持。另外，请注意 ARIA `menu` 角色指的是一种非常特定类型的菜单。它通常指用户可以调用的一系列操作，类似于桌面应用程序上的菜单。它不包括我们通常所说的“菜单”的更常见用法，例如导航菜单。实际上，你在网页上创建的大多数“菜单”都不会是 ARIA 菜单，也不会使用 `aria-haspopup`。

下一个我们将讨论的 ARIA 状态是 `aria-required`。`aria-required` 属性用于指示在提交表单之前需要填写某个字段。

这是一个使用 `aria-required` 属性处理自定义形式控件的示例。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<div id="name-label">Full Name*</div>
<div role="textbox" contenteditable aria-labelledby="name-label" aria-required="true" id="name"></div>
```

```css
#name-label {
  font-family: system-ui, sans-serif;
  font-size: 0.95rem;
  font-weight: 600;
  margin-bottom: 0.25rem;
  color: #333;
}

[role="textbox"] {
  display: block;
  width: 100%;
  min-height: 2rem;
  padding: 0.5rem 0.75rem;
  border: 1.5px solid #ccc;
  border-radius: 4px;
  font-family: system-ui, sans-serif;
  font-size: 1rem;
  color: #222;
  background-color: #fff;
  line-height: 1.4;
  transition: border-color 0.2s, box-shadow 0.2s;
}

[role="textbox"]:hover {
  border-color: #999;
}

[role="textbox"]:focus {
  outline: none;
  border-color: #0078d4;
  box-shadow: 0 0 0 3px rgba(0, 120, 212, 0.25);
}

[role="textbox"]:empty::before {
  content: attr(data-placeholder);
  color: #aaa;
  pointer-events: none;
}

[role="textbox"][aria-required="true"] {
  border-left: 3px solid #e81123;
  padding-left: calc(0.75rem - 3px);
}
```

:::

我们需要使用 `contenteditable` 属性，以便用户可以输入他们的内容。我们还使用了设置为 `true` 的 `aria-required` 属性，以表明此自定义形式控件是必填的。

为了使形式控件看起来像普通的形式控件，你需要添加 CSS。你还需要添加 JavaScript 以防止形式在没有内容的情况下提交。

如果标签已经包含单词 `required`，那么你应该省略 `aria-required` 属性。这确保屏幕阅读器只会读取一次单词 required。

在大多数情况下，你可能会使用带有 `required` 属性的本地 `label` 和 `form` 元素。但如果你需要创建自定义表单控件，则在必要时添加 `aria-required` 属性非常重要。

此外，`aria-required` 属性也可以用于本地的表单输入，例如 `input`、`textarea` 和 `select` 元素。通常这比本地的 required 属性更受欢迎，因为 required 属性可能存在潜在的可用性和无障碍问题，特别是浏览器提供的默认误差处理。最终，你需要进行测试以确定哪种属性最适合你的情况。

我们将讨论的最后一个 ARIA 状态是 `aria-checked`。此属性用于指示元素是否处于选中状态。它最常用于创建自定义复选框、单选按钮、开关和列表框时。

以下是如何在自定义复选框控件上使用 `aria-checked` 的示例：

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<div role="checkbox" aria-checked="true" tabindex="0">Checkbox</div>
```

```css
[role="checkbox"] {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-family: system-ui, sans-serif;
  font-size: 1rem;
  cursor: pointer;
  user-select: none;
  color: #222;
}

[role="checkbox"]::before {
  content: "";
  display: inline-block;
  width: 1rem;
  height: 1rem;
  border: 2px solid #666;
  border-radius: 4px;
  background-color: #fff;
  transition: all 0.2s ease;
  box-sizing: border-box;
}

[role="checkbox"]:hover::before {
  border-color: #0078d4;
}

[role="checkbox"]:focus::before {
  outline: 2px solid #0078d4;
  outline-offset: 2px;
}

[role="checkbox"][aria-checked="true"]::before {
  background-color: #0078d4;
  border-color: #0078d4;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'><path fill='white' d='M5.2 10.4L2 7.2l1.1-1.1 2.1 2.1L10.9 2.5 12 3.6z'/></svg>");
  background-repeat: no-repeat;
  background-position: center;
}

[role="checkbox"][aria-disabled="true"] {
  opacity: 0.5;
  pointer-events: none;
  cursor: not-allowed;
}

```

:::

本地的复选框元素具有内置的 `checked` 状态，该状态会传达给辅助技术。但如果你正在创建自定义复选框控件，则需要使用 `aria-checked` 属性来指示其状态。

当用户与自定义复选框控件交互时，你需要使用 `aria-checked` 状态来反映复选框的新状态。当复选框被选中时，`aria-checked` 属性设置为 `true`。当复选框未被选中时，设置为 `false`。

本地的元素通常具有更好的支持和内置无障碍特色。

但是，如果你必须创建自定义控件，使用 ARIA 属性对于有效地向辅助技术传达这些控件的状态是必不可少的。

像往常一样，测试你的工作以确保 ARIA 属性被正确应用，并且自定义控件的功能既可访问又用户友好。

# --questions--

## --text--

你会使用什么 ARIA 状态来表示一个标签（页）当前被选中？

## --answers--

`aria-disabled`

### --feedback--

此状态显示哪个标签（页）处于活动状态。

---

`aria-selected`

---

`aria-haspopup`

### --feedback--

此状态显示哪个标签（页）处于活动状态。

---

`aria-checked`

### --feedback--

此状态显示哪个标签（页）处于活动状态。

## --video-solution--

2

## --text--

在自定义控件的上下文中，使用哪个 ARIA 状态来表示一个元素当前被禁用？

## --answers--

`aria-checked`

### --feedback--

此状态表示该元素无法被交互。

---

`aria-disabled`

---

`aria-selected`

### --feedback--

此状态表示该元素无法被交互。

---

`aria-haspopup`

### --feedback--

此状态表示该元素无法被交互。

## --video-solution--

2

## --text--

当你想表示一个菜单项有子菜单时，应使用哪个 ARIA 状态？

## --answers--

`aria-checked`

### --feedback--

其中一个状态强烈表明存在弹出窗口。

---

`aria-disabled`

### --feedback--

其中一个状态强烈表明存在弹出窗口。

---

`aria-haspopup`

---

`aria-selected`

### --feedback--

其中一个状态强烈表明存在弹出窗口。

## --video-solution--

3
