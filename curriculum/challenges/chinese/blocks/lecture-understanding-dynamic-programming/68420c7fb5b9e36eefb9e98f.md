---
id: 68420c7fb5b9e36eefb9e98f
title: 什么是动态规划以及一些常见的算法？
challengeType: 19
dashedName: what-is-dynamic-programming-and-what-are-some-common-algorithms
---

# --description--
  
动态编程是一种算法技术，通过将复杂问题分解为更简单的子问题并存储结果以避免重复计算来解决问题。这种方法将通常需要指数时间的问题转化为可以在多项式时间内解决的问题。

## 动态规划的核心原则

动态编程在问题中存在两个关键条件时有效。

- **重叠子问题**：在解决较大问题时，相同的较小问题会多次出现。我们不是反复重新计算这些子问题，而是将它们的 `solution` 保存起来。
    
- **最优子结构**：问题的最优 `solution` 包含其子问题的最优 `solution`。这意味着我们可以通过组合较小部分的最优 `solution` 来构建最佳 `solution`。
    

让我们通过经典的“爬楼梯”问题来检验这些概念。

## 朴素递归的问题

考虑爬楼梯问题：你正在爬一个有 `n` 级台阶的楼梯，每次可以爬 1 级或 2 级。你有多少种不同的方法可以到达顶部？

```python
def climb_stairs_recursive(n):
    """Recursive approach"""
    if n <= 2:
        return n  # Base cases: 1 way for 1 step, 2 ways for 2 steps
    # To reach step n, we can come from step (n-1) or step (n-2)
    return climb_stairs_recursive(n-1) + climb_stairs_recursive(n-2)
```

由于大量冗余计算，该实现具有指数时间复杂度。当计算 `climb_stairs(5)` 时，发生了以下情况：

- `climb_stairs(5)` 调用 `climb_stairs(4)` 和 `climb_stairs(3)`
    
- `climb_stairs(4)` 调用 `climb_stairs(3)` 和 `climb_stairs(2)`
    
- 现在 `climb_stairs(3)` 被计算了 **两次**
    
- `climb_stairs(3)` 调用 `climb_stairs(2)` 和 `climb_stairs(1)`
    
- `climb_stairs(2)` 总共计算 **3 次**
    

仅对于 `n=5`，我们进行了 9 次函数调用，而实际上只需要 5 次唯一计算。随着 `n` 的增长，这种冗余呈指数级爆炸——`climb_stairs(30)` 需要超过 10 亿次函数调用！时间复杂度变为 `O(2^n)`，使其对于较大 `n` 值来说既低效又不切实际。

## 动态编程方案

动态编程通过两种主要方法消除这种冗余计算：

### 记忆化（自顶向下方法）

记忆化为昂贵的函数调用保存结果，当相同的输入再次出现时返回缓存的结果：

```python
def climb_stairs_memo(n, memo={}):
    """Dynamic programming with memoization"""
    # Check if we've already calculated this value
    if n in memo:
        return memo[n]  # Return cached result - O(1) lookup!
    
    # Base cases
    if n <= 2:
        return n
    
    # Calculate once and store in memo for future use
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    return memo[n]
```

记忆化非常高效，因为从 `1` 到 `n` 的每个唯一值只计算一次。当我们再次需要 `climb_stairs(3)` 时，不是重新计算它（这会触发更多递归调用），而是直接在我们的备忘录字典中以 `O(1)` 时间查找。

让我们通过自顶向下的方法追踪 `climb_stairs(5)` 的执行，看看记忆化如何消除冗余工作：

```md
Call: climb_stairs_memo(5)
  memo = {} (empty)
  
  Call: climb_stairs_memo(4) 
    memo = {} (empty)
    
    Call: climb_stairs_memo(3)
      memo = {} (empty)
      
      Call: climb_stairs_memo(2) → returns 2 (base case)
      Call: climb_stairs_memo(1) → returns 1 (base case)
      
      Result: 2 + 1 = 3
      memo = {3: 3} (stored!)
    
    Call: climb_stairs_memo(2) → returns 2 (base case)
    
    Result: 3 + 2 = 5
    memo = {3: 3, 4: 5} (stored!)
  
  Call: climb_stairs_memo(3) → returns 3 (FROM MEMO - no recursion!)
  
  Result: 5 + 3 = 8
  memo = {3: 3, 4: 5, 5: 8}
```

**效率比较**

- **朴素递归的**：进行 9 次调用并重复计算
    
- **记忆化**：只进行 5 次唯一计算，然后重用已保存的结果
    
- **时间复杂度**：由于我们只进行 `n` 次唯一计算，复杂度从 `O(2^n)` 降低到 `O(n)`
    
- **空间复杂度**：`O(n)` 用于备忘录存储和调用栈
    
- **实际影响**：`climb_stairs(30)` 从超过 10 亿次调用减少到仅 30 次调用！
    

### 自底向上的制表法

表格法从零开始构建方案，通过填充一个表格来解决子问题：

```python
def climb_stairs_tabulation(n):
    """Dynamic programming with tabulation"""
    if n <= 2:
        return n
    
    # Create array to store results for all steps from 0 to n
    dp = [0] * (n + 1)
    dp[1] = 1  # 1 way to reach step 1
    dp[2] = 2  # 2 ways to reach step 2
    
    # Build up the solution iteratively
    for i in range(3, n + 1):
        # Ways to reach step i = ways to reach (i-1) + ways to reach (i-2)
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

标签（页）通过从最小的子问题迭代地创建方案，完全消除了递归。

让我们通过自底向上的方法来实际演示，看看我们如何系统地构建该方案。以下是 `climb_stairs(5)` 的迭代构造：

```md
Initial state:
dp = [0, 1, 2, 0, 0, 0]
     [0, 1, 2, 3, 4, 5] ← indices (step numbers)

Step by step construction:

i = 3:
  dp[3] = dp[2] + dp[1] = 2 + 1 = 3
  dp = [0, 1, 2, 3, 0, 0]
  
i = 4:
  dp[4] = dp[3] + dp[2] = 3 + 2 = 5
  dp = [0, 1, 2, 3, 5, 0]
  
i = 5:
  dp[5] = dp[4] + dp[3] = 5 + 3 = 8
  dp = [0, 1, 2, 3, 5, 8]

Final result: dp[5] = 8
```

**制表法的主要优势**

- **无递归额外开销**：与记忆化不同，没有递归调用栈。
    
- **可预测的执行**：我们按预定顺序计算值（1、2、3、4、5……）。
    
- **缓存友好**：循序的数组访问优化内存使用。
    
- **易于优化**：可以将空间复杂度降低到 `O(1)`，因为我们只需要最后两个值。
    

```python
def climb_stairs_optimized(n):
    if n <= 2:
        return n
    
    prev2, prev1 = 1, 2  # Only store last two values
    for i in range(3, n + 1):
        current = prev1 + prev2
        prev2, prev1 = prev1, current
    return prev1
```

**效率比较**

- **朴素递归的**：`n=5` 时调用 9 次函数，呈指数增长。
    
- **制表**：`n=5` 时的 3 个简单添加，线性增长。
    
- **时间复杂度**：`O(n)` 而不是 `O(2^n)`。
    
- **空间复杂度**：数组为 `O(n)`，优化后为 `O(1)`。
    
- **可预测的性能**：对于大规模输入，没有栈溢出的风险。
    

这两种方法都将时间复杂度从指数级 `O(2^n)` 降低到线性 `O(n)`，这是一个显著的改进，使得解决问题的时间从几毫秒到对于较大输入等待数年之间产生了巨大差异。

## 现实世界的应用

动态编程在计算机科学及其他领域有广泛的应用：

- **路径优化**：GPS 系统使用动态编程算法来查找位置之间的最短路径。
    
- **文本处理**：拼写检查器和自动完成功能通常依赖动态编程来计算单词之间的编辑距离。
    
- **金融模型**：投资策略和投资组合优化经常采用动态编程技术。
    
- **资源分配**：背包问题及其变体出现在调度、预算和资源管理中。
    

## 实际示例：零钱兑换问题

硬币找零问题是一个经典的编码挑战，当使用动态编程解决时，展示了动态编程的两个关键原则：最优子结构和重叠子问题。

硬币兑换问题问：“制作一个目标金额所需的最少硬币数是多少？”

这是一个使用动态编程的方案：

```python
def min_coins(amount, coins):
    """Find minimum number of coins needed to make the given amount"""
    # Initialize dp array with "infinity" - represents impossible to make
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins needed for amount 0
    
    # For each amount from 1 to target amount
    for i in range(1, amount + 1):
        # Try each coin denomination
        for coin in coins:
            if coin <= i:  # Can only use coin if it doesn't exceed current amount
                # Update minimum: current minimum vs (coins for remaining amount + 1)
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    # Return result if possible, -1 if impossible
    return dp[amount] if dp[amount] != float('inf') else -1

# Example usage:
# coins = [1, 3, 4], amount = 6
# dp[6] = min(dp[5]+1, dp[3]+1, dp[2]+1) = min(3+1, 1+1, 2+1) = 2
# Result: 2 coins (3 + 3)
```

下面是动态规划找零算法针对 `coins = [1, 3, 4]`、`amount = 6` 的逐步工作原理：

```md
Initial state:
dp = [0, ∞, ∞, ∞, ∞, ∞, ∞]
     [0, 1, 2, 3, 4, 5, 6] ← amounts

Building up the solution:

For amount = 1:
  Try coin 1: dp[1] = min(∞, dp[0] + 1) = min(∞, 0 + 1) = 1
  dp = [0, 1, ∞, ∞, ∞, ∞, ∞]

For amount = 2:
  Try coin 1: dp[2] = min(∞, dp[1] + 1) = min(∞, 1 + 1) = 2
  dp = [0, 1, 2, ∞, ∞, ∞, ∞]

For amount = 3:
  Try coin 1: dp[3] = min(∞, dp[2] + 1) = min(∞, 2 + 1) = 3
  Try coin 3: dp[3] = min(3, dp[0] + 1) = min(3, 0 + 1) = 1
  dp = [0, 1, 2, 1, ∞, ∞, ∞]

For amount = 4:
  Try coin 1: dp[4] = min(∞, dp[3] + 1) = min(∞, 1 + 1) = 2
  Try coin 3: dp[4] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2
  Try coin 4: dp[4] = min(2, dp[0] + 1) = min(2, 0 + 1) = 1
  dp = [0, 1, 2, 1, 1, ∞, ∞]

For amount = 5:
  Try coin 1: dp[5] = min(∞, dp[4] + 1) = min(∞, 1 + 1) = 2
  Try coin 3: dp[5] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2
  Try coin 4: dp[5] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2
  dp = [0, 1, 2, 1, 1, 2, ∞]

For amount = 6:
  Try coin 1: dp[6] = min(∞, dp[5] + 1) = min(∞, 2 + 1) = 3
  Try coin 3: dp[6] = min(3, dp[3] + 1) = min(3, 1 + 1) = 2
  Try coin 4: dp[6] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2
  dp = [0, 1, 2, 1, 1, 2, 2]

Final result: dp[6] = 2 (achieved with coins 3 + 3)
```

该方案演示了动态 `programming` 的两个关键原则。它具有重叠子问题，因为查找金额 6 的最小硬币数需要知道金额 5、3 和 2 的方案。这些相同的子问题在计算其他金额时也会出现。它具有最优子结构，因为任何金额的最优方案都包含较小金额的最优方案。如果我们知道金额 3 的最小硬币数是 1，那么构成金额 6 的一种方法是使用该方案加上一个面值为 3 的硬币。

没有 DP，我们需要尝试每一种可能的硬币组合——指数级的可能性。使用 DP，我们系统地构建方案：

- **时间复杂度**：`O(amount × number of coins)`，而非指数级。
    
- **空间复杂度**：`dp` 数组的 `O(amount)`。
    
- **无冗余工作**：每个子问题（查找每个金额的最小硬币数）只解决一次。
    
- **可重用结果**：一旦我们知道金额 3 的最小硬币数，我们就会将此知识用于所有可以从中受益的更大金额。
    

## 何时使用动态规划

动态编程在以下情况下有效：

- 该问题可以分解为重叠子问题。
    
- 该问题表现出最优子结构。
    
- 一个简单的递归的方案将涉及重复计算。
    
- 你需要以空间复杂度为代价优化时间复杂度。
    

常见的动态 `programming` 模式包括优化问题（查找最小/最大值）、计数问题（实现某事的方法数）以及可以分解为更小决策的决策问题。

动态规划通过系统地存储和重用子问题的解决方案，将复杂问题转化为可管理的问题。理解这一技术为高效解决各种计算挑战打开了大门。

# --questions--

## --text--

动态 `programming` 适用必须具备的两个关键条件是什么？

## --answers--

快速执行和低内存使用。

### --feedback--

考虑什么因素使问题适合动态编程优化。

---

重叠子问题和最优子结构。

---

递归的调用和迭代的循环。

### --feedback--

考虑什么因素使问题适合动态编程优化。

---

记忆化和表格法。

### --feedback--

考虑什么因素使问题适合动态编程优化。

## --video-solution--

2

## --text--

动态编程中备忘录法和表格法的主要区别是什么？

## --answers--

记忆化使用的内存比标签（页）法更多。

### --feedback--

考虑每种方法构建方案的方向。

---

表格法总是比记忆化更快。

### --feedback--

考虑每种方法构建方案的方向。

---

记忆化是自顶向下的，而表格法是自底向上的。

---

记忆化仅适用于递归的函数。

### --feedback--

考虑每种方法构建方案的方向。

## --video-solution--

3

## --text--

在天真的递归爬楼梯实现中，时间复杂度是多少，为什么它效率低下？

## --answers--

`O(n)` 因为它只计算每一步一次。

### --feedback--

考虑在递归的树中相同的楼梯计数被计算了多少次。

---

`O(n²)` 因为它使用了嵌套循环。

### --feedback--

考虑在递归的树中相同的楼梯计数被计算了多少次。

---

`O(2^n)` 因为它多次重新计算相同的子问题。

---

`O(log n)` 因为它将问题分成两半。

### --feedback--

考虑在递归的树中相同的楼梯计数被计算了多少次。

## --video-solution--

3
