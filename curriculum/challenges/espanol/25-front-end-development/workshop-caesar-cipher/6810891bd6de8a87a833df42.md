---
id: 6810891bd6de8a87a833df42
title: Paso 10
challengeType: 20
dashedName: step-10
---

# --description--

Como puedes ver en la salida, el mensaje ha sido cifrado. El siguiente paso será hacer que tu código sea reutilizable en caso de que quieras cifrar diferentes mensajes.

Para eso, necesitas crear una función. Como recordatorio, aquí está cómo crear una función llamada `spam` que imprime `Spam!` en la terminal:

```py
def spam():
    print('Spam!')
```

Crea una función llamada `caesar`. Coloca todo tu código existente dentro del cuerpo de la función. Presta atención para mantener el mismo nivel de sangría en todas las líneas dentro del cuerpo de la función.

# --hints--

Debes tener una función llamada `caesar`.

```js
({ test: () => assert(runPython(`_Node(_code).has_function("caesar")`)) })
```

Debes mover todo el código que has escrito hasta ahora dentro del cuerpo de la función `caesar`. Asegúrate de mantener el mismo nivel de sangría en todas las líneas dentro del cuerpo de la función...

```js
({ test: () => assert(runPython(`_Node(_code).find_function("caesar").find_body().is_equivalent("alphabet = 'abcdefghijklmnopqrstuvwxyz'\\nshift = 5\\nshifted_alphabet = alphabet[shift:] + alphabet[:shift]\\ntranslation_table = str.maketrans(alphabet, shifted_alphabet)\\ntext = 'hello world'\\nencrypted_text = text.translate(translation_table)\\nprint(encrypted_text)")`)) })
```

# --seed--

## --seed-contents--

```py
--fcc-editable-region--
alphabet = 'abcdefghijklmnopqrstuvwxyz'
shift = 5
shifted_alphabet = alphabet[shift:] + alphabet[:shift]
translation_table = str.maketrans(alphabet, shifted_alphabet)
text = 'hello world'
encrypted_text = text.translate(translation_table)
print(encrypted_text)
--fcc-editable-region--
```
