---
id: 587d825c367417b2b2512c90
title: 廣度優先搜尋
challengeType: 1
forumTopicId: 301622
dashedName: breadth-first-search
---

# --description--

到目前為止，我們已經學會了不同的圖形表述方式。接下來呢？一個自然的問題是，圖中任意兩個節點之間的距離是多少？這時就引入了<dfn>圖遍歷演算法</dfn>。

<dfn>巡訪演算法</dfn>是用來巡訪或訪問圖中節點的演算法。一種巡訪演算法是廣度優先搜尋演算法。

這個演算法從一個節點開始，並造訪所有與該節點相距一條邊的鄰居。接著，它會繼續造訪每個鄰居的鄰居，如此類推，直到所有節點都被造訪。

一個重要的資料結構，可以幫助實作廣度優先搜尋演算法的是佇列。這是一個陣列，你可以在一端添加元素，並從另一端移除元素。這也被稱為 <dfn>FIFO</dfn> 或 <dfn>先進先出</dfn> 資料結構。

從視覺上來看，這就是演算法正在做的事情：  
<img alt="animation showing the breadth first search algorithm" src='https://cdn.freecodecamp.org/curriculum/coding-interview-prep/breadth-first-search.gif'>

灰色陰影表現節點被加入佇列，黑色陰影表現節點被從佇列中移除。觀察每次節點被從佇列中移除（節點變黑）時，所有相鄰節點都會被加入佇列（節點變灰）。

要實作這個演算法，你需要輸入一個圖形結構體和你想要開始的節點。

首先，你需要知道從起始節點開始的距離，或是距離起始節點有多少條邊。你應該將所有距離初始化為一個很大的數字，例如 `Infinity`。這樣可以避免當某個節點無法從起始節點到達時產生計數問題。接著，你需要從起始節點前往它的鄰居。這些鄰居距離起始節點有一條邊，在這個階段，你應該將你所追蹤的距離加上一個單位。

# --instructions--

撰寫一個函式（程式）`bfs()`，該函式（程式）接受一個鄰接矩陣圖（一個二維陣列）和一個節點標籤 root 作為參數。節點標籤將只是介於 `0` 和 `n - 1` 之間的節點整數值，其中 `n` 是圖中節點的總數。

你的函式（程式）將輸出一個 JavaScript 物件的鍵值配對，包含節點及其與根節點的距離。如果節點無法被到達，距離應為 `Infinity`。

# --hints--

輸入圖形 `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` 且起始節點為 `1` 時，應該傳回 `{0: 1, 1: 0, 2: 1, 3: 2}`。

```js
var graph = [
  [0, 1, 0, 0],
  [1, 0, 1, 0],
  [0, 1, 0, 1],
  [0, 0, 1, 0]
];
var results = bfs(graph, 1);
assert.deepEqual(results, { 0: 1, 1: 0, 2: 1, 3: 2 });
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]` 且起始節點為 `1` 時，應該傳回 `{0: 1, 1: 0, 2: 1, 3: Infinity}`

```js
var graph = [
  [0, 1, 0, 0],
  [1, 0, 1, 0],
  [0, 1, 0, 0],
  [0, 0, 0, 0]
];
var results = bfs(graph, 1);
 assert.deepEqual(results, { 0: 1, 1: 0, 2: 1, 3: Infinity });
```

輸入圖形 `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` 且起始節點為 `0` 時，應該傳回 `{0: 0, 1: 1, 2: 2, 3: 3}`。

```js
var graph = [
  [0, 1, 0, 0],
  [1, 0, 1, 0],
  [0, 1, 0, 1],
  [0, 0, 1, 0]
];
var results = bfs(graph, 0);
 assert.deepEqual(results, { 0: 0, 1: 1, 2: 2, 3: 3 });
```

輸入圖形 `[[0, 1], [1, 0]]` 且起始節點為 `0` 應該傳回 `{0: 0, 1: 1}`

```js
var graph = [
  [0, 1],
  [1, 0]
];
var results = bfs(graph, 0);
assert.deepEqual(results, { 0: 0, 1: 1 });
```

# --seed--

## --seed-contents--

```js
function bfs(graph, root) {
  var nodesLen = {};

  return nodesLen;
};

var exBFSGraph = [
  [0, 1, 0, 0],
  [1, 0, 1, 0],
  [0, 1, 0, 1],
  [0, 0, 1, 0]
];
console.log(bfs(exBFSGraph, 3));
```

# --solutions--

```js
function bfs(graph, root) {
  var nodesLen = {};
  // Set all distances to infinity
  for (var i = 0; i < graph.length; i++) {
    nodesLen[i] = Infinity;
  }
  nodesLen[root] = 0; // ...except root node
  var queue = [root]; // Keep track of nodes to visit
  var current; // Current node traversing
  // Keep on going until no more nodes to traverse
  while (queue.length !== 0) {
    current = queue.shift();
    // Get adjacent nodes from current node
    var curConnected = graph[current]; // Get layer of edges from current
    var neighborIdx = []; // List of nodes with edges
    var idx = curConnected.indexOf(1); // Get first edge connection
    while (idx !== -1) {
      neighborIdx.push(idx); // Add to list of neighbors
      idx = curConnected.indexOf(1, idx + 1); // Keep on searching
    }
    // Loop through neighbors and get lengths
    for (var j = 0; j < neighborIdx.length; j++) {
      // Increment distance for nodes traversed
      if (nodesLen[neighborIdx[j]] === Infinity) {
        nodesLen[neighborIdx[j]] = nodesLen[current] + 1;
        queue.push(neighborIdx[j]); // Add new neighbors to queue
      }
    }
  }
  return nodesLen;
}
```
