---
id: 5cd9a70215d3c4e65518328f
title: Criar uma Contagem Regressiva
challengeType: 26
dashedName: build-a-countdown
---

# --description--

Neste laboratório, você irá construir uma função `countdown` que recebe um número inicial e gera uma lista de contagem regressiva.

Quando você chama `countdown(n)`, ele deve retornar um array que começa em `n` e conta regressivamente de `1` até chegar em `1`.

Por exemplo:

- `countdown(5)` deve retornar `[5, 4, 3, 2, 1]`
- `countdown(1)` deve retornar `[1]`

Se o número inicial for menor que `1`, não há nada para contar regressivamente, então retorne um array vazio:

- `countdown(0)` deve retornar `[]`
- `countdown(-3)` deve retornar `[]`

Para completar o laboratório, você deve construir o resultado usando recursão e não deve usar loops (`for`, `while`) ou métodos de iteração de array (`forEach`, `map`, `filter`, `reduce`). Cada chamada deve produzir seu próprio array de resultado (não use variáveis globais para armazenar a contagem regressiva).

**Objetivo:** Cumprir as user stories abaixo e fazer todos os testes passarem para completar o laboratório.

**Histórias de Usuário:**

1. Você deve criar uma função chamada `countdown`.
2. A função `countdown` deve receber um único argumento `n` (um número).
3. Se `n` for menor que `1`, `countdown` deve retornar um array vazio.
4. Caso contrário, `countdown` deve retornar um array contendo os inteiros de `n` até `1` em ordem decrescente.
5. Você deve usar recursão (a função deve chamar a si mesma) e não deve usar loops de nenhum tipo (`for`, `while` ou métodos de ordem superior como `forEach`, `map`, `filter`, `reduce`).
6. Cada chamada recursiva deve usar um valor menor que a chamada anterior (por exemplo, `n - 1`) para que a função alcance seu caso base.
7. A solução não deve usar variáveis globais para armazenar ou armazenar em cache o array de resultados.
8. Chamar `countdown` várias vezes com entradas diferentes deve sempre retornar o resultado correto e independente.

# --hints--

Você deve ter uma função chamada `countdown`.

```js
assert.isFunction(countdown);
```

`countdown(-1)` deve retornar um array vazio.

```js
assert.isEmpty(countdown(-1));
```

`countdown(10)` deve retornar `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(10), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
```

`countdown(5)` deve retornar `[5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

Seu código não deve depender de nenhum tipo de loop (`for`, `while` ou funções de ordem superior como `forEach`, `map`, `filter` e `reduce`).

```js
assert(
  !__helpers.removeJSComments(code).match(/for|while|forEach|map|filter|reduce/g)
);
```

Você deve usar recursão para resolver o problema.

```js
assert(
  countdown.toString().match(/countdown\s*\(.+\)/)
);
```

As variáveis globais não devem ser usadas para armazenar em cache o array.

```js
countdown(1)
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
function countdown(n) {
  if (n < 1) {
    return [];
  }

  return [n, ...countdown(n - 1)];
}
```
