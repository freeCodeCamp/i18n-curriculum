---
id: 67d1ec87b34cee1d9219f7e9
title: 你如何在 React 中创建自定义 Hooks？
challengeType: 19
dashedName: how-can-you-create-custom-hooks-in-react
---

# --description--

React 提供了许多内置钩子，允许你在你的项目中实现不同的特色。这些包括 `useState`、`useEffect`、`useContext` 和其他。

但有时，你需要添加一个内置钩子都无法帮助的特色。幸运的是，你可以在 React 中创建你自己的自定义钩子。

自定义钩子并不像看起来那么复杂。它们只是可重用的函数，允许你在多个组件之间共享逻辑。这意味着可重用性是你想要构建自己钩子的另一个原因。

通过自定义钩子，你可以将逻辑从使用它们的任何组件中提取出来，比如数据获取、状态管理、切换、以及像查看用户在线或离线状态这样的副作用，等等。 

然后你可以导入该 hook 以在任何组件中使用，这样你就可以专注于这些组件内的渲染和展示。这意味着更少的重复和更少的冗余，也意味着当你想进行任何更新时，需要修改的地方更少。

现在，让我们看看你如何制作你自己的自定义 hook。

在 React 中，所有内置钩子都以单词 `use` 开头，因此你的自定义钩子也应遵循相同的约定。你的自定义钩子名称还应清楚地传达其功能。

所以，如果你的自定义钩子…

- 获取数据，你可以调用 `useFetch`

- 切换某物的开关，你可以调用 `useToggle`

- 或者如果它实现了防抖，`useDebounce` 是一个好名字

假设你想构建一个自定义 hook，为你的应用添加防抖功能。

防抖是一种编程技术，用于限制函数的运行频率。它通过等待用户停止执行某个操作达到指定时间后再执行函数来实现。例如，在搜索框中，防抖不会对每次按键都进行 API 调用，而是等待用户停止输入，比如 500 毫秒后再执行调用。

要创建一个防抖动的自定义钩子，首先需要创建一个 `useDebounce.jsx` 或 `useDebounce.js` 文件。通常，任何你创建的自定义钩子的文件都储存在 `hooks` 文件夹中。

你可以在你自己的自定义 hook 中使用一些内置 hook。对于防抖，你需要 `useState` 和 `useEffect` hook，因此请在你的文件顶部导入它们：

```js
import { useState, useEffect } from "react";
```

接下来，创建一个 `useDebounce` 函数，该函数接受 `value` 和 `delay` 作为参数。`value` 是你想要等待的资源，`delay` 是你想等待的时间段。由于你想等待一段时间，`setTimeout` 和 `clearTimeout` 函数将非常有用：

```js
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

`debouncedValue` 状态保存并返回延迟值，该值仅在指定的超时时间后更新。

`useEffect` 是真正发生魔法的地方。如果你回想起上一课，任何存在于 React 渲染周期之外的东西，比如设置和清除计时器，都是副作用，你应该使用 `useEffect` 钩子来处理它们。

在此处的 `useEffect` 钩子中，你使用 `setTimeout` 来设置 `debouncedValue`。然后你返回一个清理函数，该函数在 `value` 或 `delay` 变化时，或组件卸载时，使用 `clearTimeout` 清除之前的超时。

要使用此钩子，我们准备了一个 `footballers` 数组，通过一个简单的搜索栏进行过滤：

```js
const footballers = [
  'Lionel Messi', 'Cristiano Ronaldo', 'Neymar Jr',
  'Kylian Mbappe', 'Mohamed Salah', 'Sadio Mane',
  'Kevin De Bruyne', 'Robert Lewandowski', 'Harry Kane',
  'Sergio Ramos', 'Virgil van Dijk', 'Alisson Becker', 
  'Joshua Kimmich', 'Manuel Neuer', 'Karim Benzema', 
  'Thibaut Courtois', 'Eden Hazard', 'Raheem Sterling',
  'Bruno Fernandes', 'Trent Alexander-Arnold', 'Son Heung-min',
  'Pierre-Emerick Aubameyang','Sergio Aguero', 'Luis Suarez', 
  'Luka Modric', 'Casemiro', 'Frenkie de Jong', 'Gerard Pique',
  'Marc-Andre ter Stegen', 'Keylor Navas', 'Angel Di Maria', 
  "N'Golo Kante", 'Kai Havertz', 'Timo Werner', 'Hakim Ziyech', 
  'Christian Pulisic', 'Mason Mount', 'Olivier Giroud', 'Tammy Abraham', 
  'Kepa Arrizabalaga', 'Ben Chilwell', 'Thiago Silva', 'Kurt Zouma', 
  'John Terry', 'Didier Drogba', 'Frank Lampard', 'Ashley Cole', 'Petr Cech',
];

export default footballers;
```

这是一个使用 `useDebounce` 钩子，在用户停止类型指派后延迟 1 秒进行查找的 `FootballerSearch` 组件：

```jsx
import { useState, useEffect } from "react";
import { useDebounce } from "./hooks/useDebounce";
import footballers from "./footballers";

const FootballerSearch = () => {
  const [query, setQuery] = useState("");
  const debouncedQuery = useDebounce(query, 1000); // Start searching 1 second after the user stops typing

  useEffect(() => {
    if (debouncedQuery) {
      const results = footballers.filter((footballer) =>
        footballer.toLowerCase().includes(debouncedQuery.toLowerCase()),
      );
      console.log("Search results:", results);
    } else {
      console.log("Search results: []");
    }
  }, [debouncedQuery]);

  return (
    <>
      <h1 style={{ textAlign: "center" }}>Footballer Search App</h1>
      <div style={{ textAlign: "center" }}>
        <input
          style={{ padding: "0.5rem", width: "30%" }}
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search for a footballer..."
        />
      </div>
    </>
  );
};

export default FootballerSearch;
```

如你所见，`debouncedQuery` 变量用于用查询状态（用户输入的内容）和 1,000 毫秒，即 1 秒的延迟来初始化 `useDebounce` 钩子。搜索本身在 `useEffect` 钩子内进行处理，搜索结果会记录到控制台。

# --questions--

## --text--

在 React 中创建自定义 hook 的一个显著好处是什么？

## --answers--

它使组件渲染更快。

### --feedback--

自定义钩子有助于避免在不同组件中重复相同的逻辑。

---

它允许你在多个组件中重用逻辑。

---

它取代了对内置钩子的需求。

### --feedback--

自定义钩子有助于避免在不同组件中重复相同的逻辑。

---

它迫使组件共享相同的状态。

### --feedback--

自定义钩子有助于避免在不同组件中重复相同的逻辑。

## --video-solution--

2

## --text--

React 中自定义钩子的正确命名规范是什么？

## --answers--

它应该以 "`use`" 开头。

---

它可以有任何名称。

### --feedback--

考虑为 hooks 设定一个特定的前缀。

---

它应以 "`Hook`" 结尾。

### --feedback--

考虑为 hooks 设定一个特定的前缀。

---

它必须匹配一个内置钩子名称。

### --feedback--

考虑为 hooks 设定一个特定的前缀。

## --video-solution--

1

## --text--

你会如何调用一个用于切换值开关的自定义 hook？

## --answers--

`useSwitch`

### --feedback--

自定义 hook 应遵循 React 的命名规范，并清晰描述其用途。

---

`useToggle`

---

`toggleHook`

### --feedback--

自定义 hook 应遵循 React 的命名规范，并清晰描述其用途。

---

`useBoolean`

### --feedback--

自定义 hook 应遵循 React 的命名规范，并清晰描述其用途。

## --video-solution--

2
