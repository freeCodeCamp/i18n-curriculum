---
id: 6810891bd6de8a87a833df42
title: Passo 10
challengeType: 20
dashedName: step-10
---

# --description--

Como você pode ver na saída, a mensagem foi criptografada.O próximo passo será tornar seu código reutilizável caso você queira criptografar mensagens diferentes.

Para isso, você precisará criar uma função.Como lembrete, aqui está como criar uma função chamada `spam` que imprime `Spam!` no terminal:

```py
def spam():
    print('Spam!')
```

Crie uma função chamada `caesar`.Coloque todo o seu código existente dentro do corpo da função.Preste atenção para manter o mesmo nível de indentação em todas as linhas dentro do corpo da função.

# --hints--

Você deve ter uma função chamada `caesar`.

```js
({ test: () => assert(runPython(`_Node(_code).has_function("caesar")`)) })
```

Você deve mover todo o código que escreveu até agora para dentro do corpo da função `caesar`.Certifique-se de manter o mesmo nível de indentação para todas as linhas dentro do corpo da função...

```js
({ test: () => assert(runPython(`_Node(_code).find_function("caesar").find_body().is_equivalent("alphabet = 'abcdefghijklmnopqrstuvwxyz'\\nshift = 5\\nshifted_alphabet = alphabet[shift:] + alphabet[:shift]\\ntranslation_table = str.maketrans(alphabet, shifted_alphabet)\\ntext = 'hello world'\\nencrypted_text = text.translate(translation_table)\\nprint(encrypted_text)")`)) })
```

# --seed--

## --seed-contents--

```py
--fcc-editable-region--
alphabet = 'abcdefghijklmnopqrstuvwxyz'
shift = 5
shifted_alphabet = alphabet[shift:] + alphabet[:shift]
translation_table = str.maketrans(alphabet, shifted_alphabet)
text = 'hello world'
encrypted_text = text.translate(translation_table)
print(encrypted_text)
--fcc-editable-region--
```
