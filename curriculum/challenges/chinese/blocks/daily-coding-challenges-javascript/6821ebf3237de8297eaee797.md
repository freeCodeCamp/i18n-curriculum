---
id: 6821ebf3237de8297eaee797
title: "挑战 21：十六进制生成器"
challengeType: 28
dashedName: challenge-21
---

# --description--

给定一个命名的 CSS 颜色字串，生成一个在给定颜色中占主导的随机十六进制（hex）颜色代码。

- 该函数应处理作为输入参数的 `"red"`、`"green"`` 或 `"blue"`。
- 如果 `input` 不是其中之一，`函数` 应该 `return` `"Invalid color"`。
- 该函数应返回一个随机的六字符十六进制颜色代码，其中 `input` 颜色值大于任何 `Others`。
- 给定 `input` 的有效输出示例：

| Input   | Output   |
|---------|----------|
| `"red"`   | `"FF0000"` |
| `"green"` | `"00FF00"` |
| `"blue"`  | `"0000FF"` |

# --hints--

`generateHex("yellow")` 应该返回 `"Invalid color"`。

```js
assert.equal(generateHex("yellow"), "Invalid color");
```

`generateHex("red")` 应返回一个六字符字串。

```js
assert.lengthOf(generateHex("red"), 6);
```

`generateHex("red")` 应该返回一个有效的六字符十六进制颜色代码。

```js
const hex = generateHex("red").toUpperCase();
const isValidHex = /^[0-9A-F]{6}$/.test(hex);
assert.isTrue(isValidHex);
```

`generateHex("red")` 应返回一个有效的十六进制颜色，其红色值高于其他颜色。

```js
const hex = generateHex("red").toUpperCase();
const isValidHex = /^[0-9A-F]{6}$/.test(hex);
assert.isTrue(isValidHex);

const r = parseInt(hex.slice(0, 2), 16);
const g = parseInt(hex.slice(2, 4), 16);
const b = parseInt(hex.slice(4, 6), 16);

assert.isAbove(r, g);
assert.isAbove(r, b);
```

调用 `generateHex("red")` 两次应返回两个不同的以红色为主的十六进制颜色值。

```js
const hex1 = generateHex("red").toUpperCase();
const isValidHex1 = /^[0-9A-F]{6}$/.test(hex1)
assert.isTrue(isValidHex1);

const r1 = parseInt(hex1.slice(0, 2), 16);
const g1 = parseInt(hex1.slice(2, 4), 16);
const b1 = parseInt(hex1.slice(4, 6), 16);

assert.isAbove(r1, g1);
assert.isAbove(r1, b1);

const hex2 = generateHex("red").toUpperCase();
const isValidHex2 = /^[0-9A-F]{6}$/.test(hex2);
assert.isTrue(isValidHex2);

const r2 = parseInt(hex2.slice(0, 2), 16);
const g2 = parseInt(hex2.slice(2, 4), 16);
const b2 = parseInt(hex2.slice(4, 6), 16);

assert.isAbove(r2, g2);
assert.isAbove(r2, b2);
assert.notEqual(hex1, hex2);
```

调用 `generateHex("green")` 两次应返回两个不同的以绿色为主的十六进制颜色值。

```js
const hex1 = generateHex("green").toUpperCase();
const isValidHex1 = /^[0-9A-F]{6}$/.test(hex1)
assert.isTrue(isValidHex1);

const r1 = parseInt(hex1.slice(0, 2), 16);
const g1 = parseInt(hex1.slice(2, 4), 16);
const b1 = parseInt(hex1.slice(4, 6), 16);

assert.isAbove(g1, r1);
assert.isAbove(g1, b1);

const hex2 = generateHex("green").toUpperCase();
const isValidHex2 = /^[0-9A-F]{6}$/.test(hex2);
assert.isTrue(isValidHex2);

const r2 = parseInt(hex2.slice(0, 2), 16);
const g2 = parseInt(hex2.slice(2, 4), 16);
const b2 = parseInt(hex2.slice(4, 6), 16);

assert.isAbove(g2, r2);
assert.isAbove(g2, b2);
assert.notEqual(hex1, hex2);
```

调用 `generateHex("blue")` 两次应返回两个不同的以蓝色为主的十六进制颜色值。

```js
const hex1 = generateHex("blue").toUpperCase();
const isValidHex1 = /^[0-9A-F]{6}$/.test(hex1)
assert.isTrue(isValidHex1);

const r1 = parseInt(hex1.slice(0, 2), 16);
const g1 = parseInt(hex1.slice(2, 4), 16);
const b1 = parseInt(hex1.slice(4, 6), 16);

assert.isAbove(b1, r1);
assert.isAbove(b1, g1);

const hex2 = generateHex("blue").toUpperCase();
const isValidHex2 = /^[0-9A-F]{6}$/.test(hex2);
assert.isTrue(isValidHex2);

const r2 = parseInt(hex2.slice(0, 2), 16);
const g2 = parseInt(hex2.slice(2, 4), 16);
const b2 = parseInt(hex2.slice(4, 6), 16);

assert.isAbove(b2, r2);
assert.isAbove(b2, g2);
assert.notEqual(hex1, hex2);
```

# --seed--

## --seed-contents--

```js
function generateHex(color) {

  return color;
}
```

# --solutions--

```js
function generateHex(color) {
  const toHex = n => n.toString(16).padStart(2, "0").toUpperCase();

  const dominant = Math.floor(Math.random() * 86) + 170;
  const weak1 = Math.floor(Math.random() * 170);
  const weak2 = Math.floor(Math.random() * 170);

  let r, g, b;

  switch (color) {
    case "red":
      r = dominant;
      g = weak1;
      b = weak2;
      break;
    case "green":
      r = weak1;
      g = dominant;
      b = weak2;
      break;
    case "blue":
      r = weak1;
      g = weak2;
      b = dominant;
      break;
    default:
      return "Invalid color";
  }

  return `${toHex(r)}${toHex(g)}${toHex(b)}`;
}
```
