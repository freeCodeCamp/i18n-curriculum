---
id: 69738771fb5a7b8b24cca29f
title: "挑战 173：有效的 `Pawn` 移动"
challengeType: 28
dashedName: challenge-173
---

# --description--

给定你一个兵在棋盘上的位置，返回一个按升序排列的它可以移动到的所有有效格子的数组。

标准棋盘是 8x8，列从左到右标记为 `A` 到 `H`，行从下到上标记为 `1` 到 `8`。它看起来像这样：

|**A8**|**B8**|**C8**|**D8**|**E8**|**F8**|**G8**|**H8**|
|-|-|-|-|-|-|-|-|
|**A7**|**B7**|**C7**|**D7**|**E7**|**F7**|**G7**|**H7**|
|**A6**|**B6**|**C6**|**D6**|**E6**|**F6**|**G6**|**H6**|
|**A5**|**B5**|**C5**|**D5**|**E5**|**F5**|**G5**|**H5**|
|**A4**|**B4**|**C4**|**D4**|**E4**|**F4**|**G4**|**H4**|
|**A3**|**B3**|**C3**|**D3**|**E3**|**F3**|**G3**|**H3**|
|**A2**|**B2**|**C2**|**D2**|**E2**|**F2**|**G2**|**H2**|
|**A1**|**B1**|**C1**|**D1**|**E1**|**F1**|**G1**|**H1**|

对于此挑战：

- 你是棋盘底部的玩家。
- 兵只能向“上”移动一 `square`。
- 除非 `pawn` 在起始行（第 2 行），否则它只能向上移动一格或两格。

例如，给定 `"D4"`，返回 `["D5"]`，这是你的兵唯一可以移动到的格子。  
给定 `"B2"`，返回 `["B3", "B4"]`，因为它在起始行且需要按升序排列。

# --hints--

`findPawnMoves("D4")` 应该返回 `["D5"]`。

```js
assert.deepEqual(findPawnMoves("D4"), ["D5"]);
```

`findPawnMoves("B2")` 应该返回 `["B3", "B4"]`。

```js
assert.deepEqual(findPawnMoves("B2"), ["B3", "B4"]);
```

`findPawnMoves("A7")` 应该返回 `["A8"]`。

```js
assert.deepEqual(findPawnMoves("A7"), ["A8"]);
```

`findPawnMoves("G2")` 应该返回 `["G3", "G4"]`。

```js
assert.deepEqual(findPawnMoves("G2"), ["G3", "G4"]);
```

`findPawnMoves("E3")` 应该返回 `["E4"]`。

```js
assert.deepEqual(findPawnMoves("E3"), ["E4"]);
```

# --seed--

## --seed-contents--

```js
function findPawnMoves(position) {

  return position;
}

```

# --solutions--

```js
function findPawnMoves(position) {
  const column = position[0].toUpperCase();
  const row = parseInt(position[1]);
  const moves = [];

  if (row >= 8) return moves;

  moves.push(`${column}${row + 1}`);

  if (row === 2) moves.push(`${column}${row + 2}`);

  return moves;
}
```
