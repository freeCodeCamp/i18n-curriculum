---
id: 587d7db6367417b2b2512b9b
title: 尋找使用 Lazy Matching 的字元
challengeType: 1
forumTopicId: 301341
dashedName: find-characters-with-lazy-matching
---

# --description--

在正規表達式中，<dfn>貪婪</dfn>配對會尋找符合 regex 樣式的字串中最長的零件，並將其傳回作為配對。另一種則稱為 <dfn>懶惰</dfn>配對，會尋找符合 regex 樣式的字串中最短的零件。

你可以將正則表達式 `/t[a-z]*i/` 套用到字串 `"titanic"`。這個正則表達式基本上是一個樣式，該樣式以 `t` 開頭，以 `i` 結尾，中間有一些字母。

正規表達式預設為貪婪，因此比對會傳回 `["titani"]`。它會尋找符合樣式的最大子字串。

不過，你可以使用 `?` 字元將其改為貪婪匹配。對調整後的正規表達式 `/t[a-z]*?i/` 進行 `"titanic"` 的比對會傳回 `["ti"]`。

**注意：**應避免使用正規表達式解析 HTML，但使用正規表達式對 HTML 字串進行樣式匹配是完全可以的。

# --instructions--

修正正規表達式 `/<.*>/`，使其傳回 HTML 頁籤 `<h1>`，而非文字 `"<h1>Winter is coming</h1>"`。請記得正規表達式中的萬用字元 `.` 會符合任何字元。

# --hints--

`result` 變數應該是一個包含 `<h1>` 的陣列。

```js
assert(result[0] == '<h1>');
```

`myRegex` 應該使用懶惰匹配

```js
assert(/[^\\][\*\+\?]\?/.test(myRegex));
```

`myRegex` 不應包含字串 `h1`

```js
assert(!myRegex.source.match('h1'));
```

# --seed--

## --seed-contents--

```js
let text = "<h1>Winter is coming</h1>";
let myRegex = /<.*>/; // Change this line
let result = text.match(myRegex);
```

# --solutions--

```js
let text = "<h1>Winter is coming</h1>";
let myRegex = /<.*?>/; // Change this line
let result = text.match(myRegex);
```
