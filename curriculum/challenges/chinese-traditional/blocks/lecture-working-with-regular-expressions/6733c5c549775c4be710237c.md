---
id: 6733c5c549775c4be710237c
title: 如何在字串中匹配並取代所有出現的項目？
challengeType: 19
dashedName: how-can-you-match-and-replace-all-occurrences-in-a-string
---

# --description--

讓我們學習如何在字串中比對或取代所有出現的樣式。

你之前已經學過 `replace()` 和 `match()` 方法，以及全域的 `g` 修飾詞。現在你可以結合這些知識來控制字串中的所有樣式。讓我們回顧一下原本的匹配程式碼：

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match);
```

而我們得到的匹配物件：

```js
// [
//   'freeCodeCamp',
//   index: 0,
//   input: 'freeCodeCamp',
//   groups: undefined
// ]
```

但是如果我們有一個包含多個 `freecodecamp` 出現的字串要比對呢？讓我們來看看 `match()` 在這種情況下的行為。我們也會加入之前的 `replace()` 範例，以便比較：

```js
const regex = /freecodecamp/;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

結果如下：

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
// freeCodeCamp is the best we love freecodecamp
```

糟糕！`match()` 只傳回了第一個符合項目，而 `replace()` 只取代了第一個符合項目。這是因為，預設情況下，`match()` 和 `replace()` 只會對第一個樣式出現進行操作。

幸運地，你可以透過在你的正規表達式上使用全域的修飾詞來避免這個問題。讓我們將它添加到我們的正規表達式中：

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

並確認結果：

```js
// [ 'freecodecamp', 'freecodecamp' ]
// freeCodeCamp is the best we love freeCodeCamp
```

成功了！我們的 replace 呼叫取代了所有小寫的 `freecodecamp` 字串，而我們的 `match()` 方法則匹配了它們兩個。

有趣的是，當你在使用 `match()` 時搭配全域的修飾詞，你會失去原本會出現在匹配陣列中的群組捕獲和字串索引的額外資訊。

值得慶幸的是，2019 年的 ECMAScript 更新為我們帶來了兩個新的方法：`matchAll()` 和 `replaceAll()`。像它們的單數對應方法一樣，這些方法接受字串或正規表達式，而 `replaceAll()` 也接受第二個引數作為要替換的字串。 

但與先前的方法不同，若你給 `replaceAll()` 和 `matchAll()` 一個沒有全域修飾詞的正規表達式，它們會丟出錯誤。讓我們更新程式碼以使用這些新方法：

```js
const pattern = "freecodecamp";
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(pattern);
const replaced = str.replaceAll(pattern, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

而我們的結果：

```js
// {}
// freeCodeCamp is the best we love freeCodeCamp
```

好消息！我們的 `replaceAll()` 完全按照預期運作－它將所有小寫的 `freecodecamp` 替換成正確的駝峰式大小寫版本。

但是那個空物件是什麼？其實，`matchAll()` 傳回一種稱為 `Iterator` 的特殊物件型別，而 freeCodeCamp 主控台尚未準備好控制該物件。

如果我們在瀏覽器主控台查看，`Iterator` 有一個 `next()` 方法，我們可以呼叫它來取得下一個值：

```js
// RegExpStringIterator {  }
//  <prototype>: RegExp String Iterator {
//    next: ƒ next(),
//    Symbol(Symbol.toStringTag): "RegExp String Iterator"
//    <prototype>: Object { ... }
//  }
```

讓我們繼續呼叫 `matched.next()`，並記錄結果：

```js
// {
//   "done": false,
//   "value": [
//     0: "freecodecamp"
//     groups: undefined
//     index: 0
//     input: "freecodecamp is the best we love freecodecamp"
//   ]
// }
```

這就是我們的匹配陣列！`next()` 給我們一個包含兩個值的物件：`done`，當迭代器中還有更多元素可用時為 `false`，以及 `value`，它是我們剛剛迭代過的值。所以，如果我們再呼叫一次：

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
const replaced = str.replaceAll(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
console.log(matched.next());
console.log(matched.next());
```

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
```

等等，為什麼它說 `done` 仍然是 `false`？陣列中應該只有兩個匹配項，對吧？讓我們第三次呼叫它，看看會得到什麼：

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": true,
//   "value": undefined
// }
```

`done` 最終是 `true`，但為什麼該值是 `undefined`？事實上，`matchAll()` 迭代器是惰性的。它不會一次找到你所有的匹配項。只有當你透過呼叫 `next()` 告訴它時，它才會找到一個匹配項。

只要找到匹配，它就不會是 `done`。一旦找不到匹配並回傳 `undefined`，它就是 `done`。這看起來可能不方便，但當你的正規表達式計算成本很高時，這會非常有幫助。

如果你的範例較少，像我們的範例一樣，你可以跳過該特性，並透過將其轉換為陣列一次擷取所有符合項目。這是透過呼叫 `Array.from()` 並將你的迭代器作為引數傳入來達成的。

讓我們更新程式碼以使用那個－既然我們知道那個有效，就先清理我們的 `replaceAll` 呼叫：

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
console.log(Array.from(matched));
```

最後我們終於得到我們的匹配陣列：

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
//
// [
//   'freecodecamp',
//   index: 33,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
```

這些強大的方法可以幫助你操作並從字串中擷取資料，而不必犧牲效率或可讀性。

# --questions--

## --text--

應該為正規表達式添加什麼修飾詞，才能匹配字串中樣式的所有出現？

## --answers--

`/i`

### --feedback--

課程提到一個用於全域的匹配的特定修飾詞。

---

`/m`

### --feedback--

課程提到一個用於全域的匹配的特定修飾詞。

---

`/g`

---

`/a`

### --feedback--

課程提到一個用於全域的匹配的特定修飾詞。

## --video-solution--

3

## --text--

當與全域的正規表達式一起使用時，`match()` 和 `matchAll()` 方法之間的主要差異是什麼？

## --answers--

`match()` 傳回一個陣列，而 `matchAll()` 傳回一個迭代器。

---

`matchAll()` 比 `match()` 更快。

### --feedback--

本課程描述由 `matchAll()` 傳回的一種特殊型別物件。

---

`match()` 只能找到第一個出現的項目，而 `matchAll()` 則會找到所有出現的項目。

### --feedback--

本課程描述由 `matchAll()` 傳回的一種特殊型別物件。

---

沒有差別，它們可以互換使用。

### --feedback--

本課程描述由 `matchAll()` 傳回的一種特殊型別物件。

## --video-solution--

1

## --text--

你如何將 `matchAll()` 的結果轉換成包含所有匹配項的陣列？

## --answers--

透過使用 `for...of` 迴圈

### --feedback--

本課程示範將 `Iterator` 轉換為陣列的特定方法。

---

透過對結果呼叫 `toArray()` 方法。

### --feedback--

本課程示範將 `Iterator` 轉換為陣列的特定方法。

---

透過將結果作為引數使用 `Array.from()`。

---

透過展開結果到陣列字面值中。

### --feedback--

本課程示範將 `Iterator` 轉換為陣列的特定方法。

## --video-solution--

3
