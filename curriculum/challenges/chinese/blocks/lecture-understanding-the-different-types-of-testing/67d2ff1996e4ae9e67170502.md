---
id: 67d2ff1996e4ae9e67170502
title: 什么是单元测试？
challengeType: 19
dashedName: what-is-unit-testing
---

# --description--

在你设计你的应用时，你经常会有一系列负责一件事的小函数。这被称为“单一职责原则”。当你有一系列小函数时，最好测试这些函数以确保一切按预期工作。在本课中，我们将了解如何使用流行的 `Jest` 测试框架创建单元测试。

在此示例中，我们将创建一个负责返回新格式化字串的函数：

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

这个 `getFormattedWord` 函数有一个名为 `str` 的参数，首先会查看 `str` 是否为空。如果是，则返回一个空字串。否则，返回一个新字串，其中首字母大写。我们正在导出这个函数，以便在测试文件中使用它。

在单独的 `getFormattedWord.test.js` 文件中，我们可以编写一些测试来验证该函数是否按预期工作。

在 `getFormattedWord.test.js` 文件顶部，我们需要首先像这样导入函数：

```js
import { getFormattedWord } from "./getFormattedWord.js";
```

然后我们需要使用 `npm i jest` 安装 Jest 包。然后我们可以添加一个测试，查看由小写字符组成的单词 `hello` 是否被正确格式化为以大写 `H` 开头的 `Hello`：

```js
test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

`expect` 函数用于测试一个值。它与一个匹配器结合使用，匹配器是一个函数，用于查看该值是否符合预期。在这个分支中，匹配器是 `toBe()`。Jest 有各种匹配器，帮助你测试真值、字串、数字等。

运行测试的一种方法是为你的 `package.json` 文件添加一个 npm 脚本。以下是 Jest 框架的示例脚本：

```js
"scripts": {
  "test": "jest"
},
```

然后只需在终端中运行 `npm run test` 来运行你的测试。如果你的测试通过，你应该会在终端看到类似这样的内容：

```sh
PASS ./getFormattedWord.test.js
  ✓ capitalizes the first letter of a word (1 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.103 s, estimated 1 s
Ran all test suites.
```

要查看失败测试的样子，我们可以通过将函数更新为以下内容来故意破坏测试：

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return "This is incorrect";
}
```

现在当你运行 `npm run test` 命令时，会出现错误信息，因为测试期望的是不同的结果：

```sh
FAIL ./getFormattedWord.test.js
  ✕ capitalizes the first letter of a word (1 ms)

  ● capitalizes the first letter of a word

  expect(received).toBe(expected) // Object.is equality

  Expected: "Hello"
  Received: "This is incorrect"

    2 |
    3 | test('capitalizes the first letter of a word', () => {
    4 |   expect(getFormattedWord('hello')).toBe('Hello');
                                            ^
    5 | });
    6 |

    at Object.toBe (getFormattedWord.test.js:4:37)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        0.121 s, estimated 1 s
Ran all test suites.
```

现在我们可以将我们的函数更新回这里的原始状态：

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

为你的测试添加另一个测试，以查看未向 `getFormattedWord` 提供参数的分支：

```js
test("returns an empty string when no argument is provided", () => {
  expect(getFormattedWord()).toBe("");
});
```

你可以添加其他测试以使事情更加健壮，但这前几个测试是单元测试的良好入门。

在测试 JavaScript 应用时，一些常见的测试框架包括 Jest、Mocha 和 Vitest。

单元测试很重要，因为它将帮助你发现程序中的更多错误，并确保一切按预期工作。它还可以作为你应用的文档形式，因为它旨在表现你代码的预期行为。

# --questions--

## --text--

以下哪项是指一个函数应该只负责一件事的原则？

## --answers--

单一职责原则

---

多重职责原则

### --feedback--

回到课程一开始讨论此内容的地方进行参考。

---

单一请求原则

### --feedback--

回到课程一开始讨论此内容的地方进行参考。

---

多重响应原则

### --feedback--

回到课程一开始讨论此内容的地方进行参考。

## --video-solution--

1

## --text--

以下哪项不是 JavaScript 生态系统中常用的测试框架？

## --answers--

JUnit

---

Jest

### --feedback--

回到课程结束时讨论此内容的部分进行参考。

---

Vitest

### --feedback--

回到课程结束时讨论此内容的部分进行参考。

---

Mocha

### --feedback--

回到课程结束时讨论此内容的部分进行参考。

## --video-solution--

1

## --text--

你可以为 `package.json` 文件添加什么来在终端运行你的测试？

## --answers--

```json
"test": {
  "test": "run test"
},
```

### --feedback--

请记住，你可以在你的 `package.json` 文件中创建自定义脚本。

---

```json
"scriptings": {
  "jest"
},
```

### --feedback--

请记住，你可以在你的 `package.json` 文件中创建自定义脚本。

---

```json
"run": {
  "test"
},
```

### --feedback--

请记住，你可以在你的 `package.json` 文件中创建自定义脚本。

---

```json
"scripts": {
  "test": "jest"
}
```

## --video-solution--

4
