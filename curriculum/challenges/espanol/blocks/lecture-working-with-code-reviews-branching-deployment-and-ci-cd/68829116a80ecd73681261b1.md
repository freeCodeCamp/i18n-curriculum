---
id: 68829116a80ecd73681261b1
title: ¿Cuáles son las buenas prácticas para mantener la sincronización con tus contrapartes remotas?
challengeType: 19
dashedName: what-are-good-practices-for-remaining-in-sync-with-your-remote-counterparts
---

# --description--

Hemos hablado un poco sobre usar ramas para trabajar en cambios aislados y evitar ensuciar tu rama `main`. Pero, ¿qué significa eso y por qué es importante?

Si haces commit de cambios directamente en tu rama `main`, y el repositorio upstream acepta otros cambios que no son tuyos, terminarás con algo llamado "historial divergente". Esto significa que los commits en tu rama `main` ya no están alineados con los commits en la rama `main` del upstream. Y hace que sincronizar los cambios del upstream sea una pesadilla.

Entonces, digamos que has estado siguiendo buenas prácticas de branching, y esto no es un problema. Si seguiste nuestras lecciones anteriores, deberías tener un fork de un repositorio que clonaste localmente, y deberías tener un upstream remote que apunta al repositorio original.

Si no hiciste esto, aquí tienes un recordatorio rápido. Querrás bifurcar un repositorio, clonar tu bifurcación localmente y ejecutar este comando:

```sh
git remote add upstream <url>
```

Reemplaza `<url>` con la URL SSH del repositorio original, NO de tu fork.

Con un upstream configurado correctamente, puedes ejecutar la siguiente serie de comandos para obtener los últimos cambios del upstream:

```sh
git checkout main
git fetch upstream
git merge upstream/main
```

¿Qué hacen estos? Bueno, ya aprendiste sobre `git checkout`, así que el primer comando asegura que estés en tu rama `main` localmente.

El segundo comando, `git fetch upstream`, le indica a Git que obtenga los últimos cambios que están en tu remoto upstream (que es el repositorio original). Sin embargo, a diferencia de un pull, Git no actualizará automáticamente tu rama. Esto es importante, porque tu rama `main` local está conectada a la rama `main` en tu fork, ¡no a la rama `main` en el repositorio original! Ejecutar un git pull puede resultar en un comportamiento inesperado.

El comando final, `git merge upstream/main`, le indica a Git que fusione los últimos cambios de la rama `main` en el remoto upstream en tu rama actual, que es tu rama local `main`, porque eso es lo que revisamos.

¿Pero qué pasa si la fusión falla? ¿Y si accidentalmente has hecho un commit en `main` y Git no puede fusionar los historiales divergentes? Bueno... asumiendo que no has hecho ningún pull request desde tu rama `main`, puedes hacer un hard reset para forzar a Git a actualizar tu rama.

```sh
git reset --hard upstream/main
```

El comando `git reset` te permite restablecer el estado actual de una rama. Pasar la bandera `--hard` le indica a Git que fuerce que los archivos locales coincidan con el estado de la rama. Esto asegura que tengas una base limpia para trabajar. Y pasar `upstream/main` le dice a Git que quieres que tu rama actual (que es `main`) coincida con la rama `main` del remoto upstream. Ten cuidado con este comando: cada vez que actualices forzosamente un historial de Git, pueden ocurrir cosas extrañas y desafortunadas.

Una vez que tengas tu rama local `main` actualizada correctamente, es importante subir ese estado a tu fork remoto (que debería ser `origin`, si has seguido nuestras lecciones). Para hacer esto, puedes ejecutar:

```sh
git push
```

Esto enviará el estado actual a tu fork remoto. Pero si has tenido que hacer un reset duro para limpiar el historial, es posible que tu fork remoto también tenga un historial divergente y el push falle.

Puedes rectificar eso forzando el push:

```sh
git push --force
```

**Ten cuidado con este comando**. Hacer un force push reescribe efectivamente tu historial remoto, y si has hecho algo incorrectamente, entonces un push forzado se vuelve una pesadilla para desenredar.

Subir los cambios sincronizados a tu fork remoto es importante porque te ayuda a asegurarte de que puedes clonar de forma segura el fork con los cambios más recientes si has perdido tu repositorio local existente.

Y una vez que hayas sincronizado tu rama `main`, eres libre de crear una nueva rama desde ese estado para comenzar a trabajar en otra contribución, ¡con la versión más reciente del código original!

# --questions--

## --text--

¿Cuál es la razón principal por la que debes evitar hacer commit de cambios directamente en tu rama `main` cuando trabajas con repositorios bifurcados?

## --answers--

Crea commits duplicados.

### --feedback--

Piensa en lo que sucede cuando tu branch y el repositorio original evolucionan por separado.

---

Esto causa una "historia divergente" que dificulta sincronizar con upstream.

---

Git no permite commits en la rama main.

### --feedback--

Piensa en lo que sucede cuando tu branch y el repositorio original evolucionan por separado.

---

Elimina automáticamente tus cambios locales.

### --feedback--

Piensa en lo que sucede cuando tu branch y el repositorio original evolucionan por separado.

## --video-solution--

2

## --text--

¿Qué serie de comandos actualizará correctamente tu rama local `main` con los cambios del repositorio original?

## --answers--

`git checkout main`; `git pull upstream`

### --feedback--

Considera el proceso paso a paso necesario para obtener cambios upstream sin interrumpir tu fork.

---

`git pull upstream main`

### --feedback--

Considera el proceso paso a paso necesario para obtener cambios upstream sin interrumpir tu fork.

---

`git checkout main`; `git fetch upstream`; `git merge upstream/main`

---

`git fetch upstream/main`; `git merge`

### --feedback--

Considera el proceso paso a paso necesario para obtener cambios upstream sin interrumpir tu fork.

## --video-solution--

3

## --text--

Si accidentalmente hiciste un commit en tu rama `main` y no puedes fusionar los cambios upstream, ¿qué comando puedes usar para restablecer forzosamente tu rama `main` para que coincida con el upstream (asumiendo que no has hecho ningún pull request)?

## --answers--

`git checkout upstream/main`

### --feedback--

¿Qué comando reinicia completamente tu rama para que coincida con el estado de otra rama?

---

`git reset --hard upstream/main`

---

`git rebase upstream/main`

### --feedback--

¿Qué comando restablece completamente tu rama para que coincida con el estado de otra rama?

---

`git clean upstream/main`

### --feedback--

¿Qué comando reinicia completamente tu rama para que coincida con el estado de otra rama?

## --video-solution--

2
