---
id: 67f41341453c2247fb2828f7
title: Cuestionario de estructuras de datos
challengeType: 8
dashedName: quiz-data-structures
---

# --description--

Para aprobar el cuestionario, debe responder correctamente al menos 18 de las 20 preguntas a continuación.

# --quizzes--

## --quiz--

### --question--

#### --text--

¿Qué describe la notación Big O en el análisis de algoritmos?

#### --distractors--

El tiempo de ejecución exacto en segundos para una computadora específica.

---

El porcentaje de líneas de código ejecutadas durante una ejecución.

---

Qué tan legible es el código para otros desarrolladores.

#### --answer--

Cómo crece el tiempo o el espacio en relación con el tamaño de la entrada (un límite superior).

### --question--

#### --text--

Al comenzar un desafío algorítmico, ¿cuál es el mejor primer paso?

#### --distractors--

Comienza a programar inmediatamente para ganar impulso.

---

Optimiza para el rendimiento antes de entender el problema.

---

Escribe pruebas unitarias solo después de terminar la solución.

#### --answer--

Aclara el problema y las restricciones con ejemplos y casos límite.

### --question--

#### --text--

¿Cuál es la diferencia clave entre los arreglos dinámicos y los arreglos estáticos?

#### --distractors--

Los arrays dinámicos almacenan valores de diferentes tipos; los arrays estáticos no pueden.

---

Los arrays estáticos permiten valores duplicados; los arrays dinámicos no.

---

Los arreglos dinámicos son más rápidos que los arreglos estáticos para cada operación.

#### --answer--

Los arreglos dinámicos pueden crecer o reducirse cambiando su tamaño; los arreglos estáticos tienen un tamaño fijo.

### --question--

#### --text--

¿Cuál es la complejidad temporal amortizada de agregar un elemento al final de un arreglo dinámico?

#### --distractors--

`O(n)`

---

`O(log n)`

---

`O(n log n)`

#### --answer--

`O(1)` amortizado.

### --question--

#### --text--

¿Por qué acceder al elemento k-ésimo por índice en una lista enlazada simple toma tiempo `O(n)`?

#### --distractors--

La lista debe redimensionarse antes de cualquier acceso.

---

El índice se convierte en hash y se busca en una tabla.

---

Los nodos se almacenan de forma contigua, por lo que se requiere un desplazamiento.

#### --answer--

Debes recorrer desde el nodo cabeza hasta el nodo k-ésimo uno por uno.

### --question--

#### --text--

¿Qué característica tiene una lista doblemente enlazada que una lista simplemente enlazada no tiene?

#### --distractors--

Acceso aleatorio a cualquier índice en tiempo `O(1)`.

---

Un buffer de array incorporado para una iteración más rápida.

---

Mantenimiento automático de la longitud de la lista como una constante.

#### --answer--

Punteros tanto al siguiente como al nodo anterior que permiten la navegación hacia atrás.

### --question--

#### --text--

¿Cuál de las siguientes opciones describe mejor una pila?

#### --distractors--

Primero en entrar, primero en salir (`FIFO`) con eliminaciones al frente.

---

Una estructura donde cualquier elemento puede ser eliminado en tiempo `O(1)`.

---

Un búfer circular con acceso aleatorio en tiempo constante.

#### --answer--

Último en entrar, primero en salir (`LIFO`) con `push` y `pop` en la parte superior.

### --question--

#### --text--

¿Qué operación elimina el elemento al frente de una cola?

#### --distractors--

`push`

---

`pop`

---

`peek`

#### --answer--

`dequeue`

### --question--

#### --text--

¿Cuál es la complejidad temporal promedio típica en el caso promedio para buscar un valor por clave en un hash map?

#### --distractors--

`O(n)` porque todas las claves deben ser escaneadas secuencialmente.

---

`O(log n)` debido a la búsqueda binaria dentro de los buckets.

---

`O(n log n)` porque las claves se ordenan durante la inserción.

#### --answer--

`O(1)` en promedio con una buena función hash y un factor de carga bajo.

### --question--

#### --text--

¿Qué garantía proporciona una estructura de datos de conjunto?

#### --distractors--

Los elementos se almacenan en orden ordenado por defecto.

---

Los valores duplicados están permitidos y se mantienen juntos.

---

Los elementos están indexados por su posición de inserción.

#### --answer--

Almacena solo elementos únicos (sin duplicados).

### --question--

#### --text--

En un arreglo dinámico, ¿cuál es la complejidad temporal en el peor caso de insertar un elemento en el índice i (no al final)?

#### --distractors--

`O(1)`

---

`O(log n)`

---

`O(1)` amortizado

#### --answer--

`O(n)`

### --question--

#### --text--

¿Cuál es la complejidad temporal de insertar un nuevo nodo al inicio de una lista enlazada simple?

#### --distractors--

`O(n)`

---

`O(log n)`

---

`O(n log n)`

#### --answer--

`O(1)`

### --question--

#### --text--

¿Qué operación devuelve el elemento superior de una pila sin eliminarlo?

#### --distractors--

`push`

---

`pop`

---

Para crear una nueva `structure`, primero define su nombre y luego especifica los campos que contendrá. Cada campo debe tener un tipo de dato y un nombre único dentro de la `structure`. Usa la palabra clave `struct` seguida del nombre de la `structure` y abre llaves `{}` para incluir los campos. Por ejemplo:

```c
struct Persona {
    int edad;
    char nombre[50];
};
```

Esta `structure` llamada `Persona` tiene dos campos: `

#### --answer--

`peek`

### --question--

#### --text--

¿Cuál de las siguientes opciones describe mejor una queue?

#### --distractors--

Último en entrar, primero en salir (`LIFO`) con eliminaciones en la parte superior.

---

Acceso aleatorio a cualquier índice en tiempo `O(1)`.

---

Los elementos siempre se mantienen en orden ordenado automáticamente.

#### --answer--

Primero en entrar, primero en salir (`FIFO`) con `enqueue` en la parte trasera y `dequeue` en la parte delantera.

### --question--

#### --text--

¿Qué es una colisión de hash en un hash map?

#### --distractors--

Cuando una clave se asigna a múltiples valores distintos por diseño.

---

Cuando dos claves idénticas se almacenan en diferentes buckets.

---

Cuando el mapa se queda sin memoria y debe ser redimensionado.

#### --answer--

Cuando dos claves diferentes producen el mismo índice de hash.

### --question--

#### --text--

¿Por qué los mapas hash cambian de tamaño (rehash) a medida que crecen?

#### --distractors--

Para ordenar las claves en orden ascendente para una iteración más rápida.

---

Para comprimir valores y reducir la fragmentación de memoria.

---

Para evitar activar el recolector de basura del lenguaje.

#### --answer--

Para mantener el factor de carga bajo y que las operaciones promedio sigan siendo `O(1)`.

### --question--

#### --text--

¿Qué afirmación sobre conjuntos es verdadera?

#### --distractors--

Los conjuntos preservan el orden de inserción por definición.

---

Los conjuntos permiten elementos duplicados y mantienen conteos.

---

Las pruebas de pertenencia a un conjunto son `O(n log n)` en promedio.

#### --answer--

Las pruebas de pertenencia suelen ser `O(1)` en promedio.

### --question--

#### --text--

¿Qué complejidad temporal crece más rápido que `O(n log n)` cuando n se vuelve grande?

#### --distractors--

`O(n)`

---

`O(log n)`

---

`O(1)`

#### --answer--

`O(n^2)`

### --question--

#### --text--

Después de implementar una solución de fuerza bruta, ¿cuál es un buen siguiente paso?

#### --distractors--

Micro-optimiza factores constantes antes de medir.

---

Descarta las pruebas y reescribe la solución desde cero.

---

Evita considerar casos límite para mantener el código simple.

#### --answer--

Analiza su complejidad de tiempo/espacio y optimiza los cuellos de botella identificados.

### --question--

#### --text--

¿Qué mide la complejidad espacial?

#### --distractors--

Cuántos núcleos de CPU usa un programa.

---

La longitud de un programa en líneas de código.

---

Cuánto tiempo tarda un programa en compilarse.

#### --answer--

Cómo crece el uso de memoria en relación con el tamaño de la entrada.

