---
id: 67d301a5f536d1a9e5df1a8c
title: ¿Qué es la reducción de tipos y cómo funciona?
challengeType: 19
dashedName: what-is-type-narrowing-and-how-does-it-work
---

# --description--

Habrá momentos en que tengas un valor con un tipo amplio y necesites reducirlo a un tipo más específico. Por ejemplo, quizás necesites asegurarte de que un objeto coincida con una interfaz que definiste. O una cadena está dentro de una lista específica de valores. Hay bastantes formas de lograr esto.

La primera es la restricción por veracidad. Considera nuestro ejemplo de la lección anterior:

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Recibimos un error del compilador al intentar acceder a la propiedad `value` de `email`, porque `email` podría ser `null`. Sin embargo, podemos usar una declaración condicional para confirmar que `email` es veraz antes de acceder a la propiedad:

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

En este ejemplo actualizado, debido a que `null` no es un valor veraz, TypeScript puede inferir que `email` DEBE ser un elemento de `input` dentro del bloque condicional. Por lo tanto, ya no lanza un error del compilador.

Los chequéos de veracidad también pueden funcionar en la dirección opuesta:

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

Con este enfoque, lanzamos un error si `email` es falso. `null` es un valor falso. Lanzar un error termina la ejecución lógica de este código, lo que significa que cuando llegamos a la llamada `console.log()`, TypeScript sabe que `email` no puede ser `null`.

El encadenamiento opcional también es una forma de reducción de tipos, bajo el mismo supuesto de que el acceso a la propiedad no puede ocurrir si el valor `email` es `null`.

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

¿Y qué ocurre con otros tipos? Bueno, también puedes reducir tipos utilizando el operador `typeof`. Veamos un ejemplo de una variable que hemos indicado podría ser una cadena O un número:

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
console.log(myVal / 10)
```

En este ejemplo, vemos un error del compilador porque no podemos hacer arithmetic sobre un valor de cadena. Pero podemos usar una condicional para chequear el `typeof` de la variable `myVal`:

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

Debido a que hemos usado la palabra clave `typeof`, TypeScript ahora sabe que `myVal` tiene que ser un número y podemos realizar aritmética de manera segura con ella.

¿Y qué pasa con los tipos de objetos más complejos? Si el objeto en cuestión proviene de una clase, puedes usar la palabra clave `instanceof` para reducir el tipo. Volviendo a nuestro ejemplo de `querySelector()`:

```js
const email = document.querySelector("#email");
```

En lugar de pasar un tipo genérico y decirle a TypeScript qué es el elemento, podemos usar `instanceof` para reducir el tipo y escribir código más seguro:

```js
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

Este enfoque puede parecer el mismo que el nuestro anterior, pero `instanceof` es una validación en tiempo de ejecución - lo que significa que, si de alguna manera nos equivocamos en el tipo de TypeScript, nuestro código JavaScript aún confirmará que `email` es un elemento de `input`.

A continuación, veamos un ejemplo donde obtenemos un objeto `User` de una API e intentamos imprimir la información:

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json();
printAge(myUser);
```

Obtendremos un error del compilador al intentar pasar `myUser` a la función porque, aunque sabemos que la API devuelve el objeto correcto, TypeScript no lo sabe. Y el método `.json()` no toma un tipo genérico.

La manera "fácil" de resolver este problema sería convertir el tipo:

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

Pero cada vez que conviertes el tipo, esencialmente estás debilitando la capacidad de TypeScript para detectar errores potenciales. Así que en lugar de convertir el tipo, puedes escribir una guarda de tipo:

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

El tipo de retorno aquí es el componente clave de esta definición de función. La sintaxis `user is User` indica que nuestra función devuelve un valor booleano, lo que significa que cuando es `true`, el valor `user` satisface la interfaz `User`. Luego hacemos algunas comprobaciones básicas para garantizar que la estructura del objeto `user` coincida; nota el uso de un narrowing de veracidad (`!!user`) y un narrowing de `typeof`. Debemos hacer esto porque `typeof null` devuelve `"object"`:

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
if (isValidUser(myUser)) {
    printAge(myUser);
}
```

Ahora, si combinamos toda nuestra lógica, ya no obtenemos errores del compilador y podemos construir nuestro código con éxito.

La reducción de tipos es una característica poderosa que te ayuda a escribir código más seguro y con menos errores; pero recuerda que los tipos de TypeScript no son completamente rígidos, así que evita prácticas como convertir el tipo de un valor sin reducirlo.

# --questions--

## --text--

¿Cuál de los siguientes NO es un método de estructura de tipos discutido en la lección?

## --answers--

Chequéos de veracidad.

### --feedback--

Aunque todos estos se pueden usar para reducir un tipo, uno de ellos no fue mencionado.

---

Encadenamiento opcional.

### --feedback--

Aunque todos estos se pueden usar para reducir un tipo, uno de ellos no fue mencionado.

---

`typeof` operador.

### --feedback--

Aunque todos estos se pueden usar para reducir un tipo, uno de ellos no fue mencionado.

---

Declaraciones switch.

## --video-solution--

4

## --text--

¿Cuál es el propósito de la sintaxis `user is User` en la función de guarda de tipo?

## --answers--

Convierte el parámetro `user` al tipo `User`.

### --feedback--

Piensa en la palabra `is` y cómo funciona la frase `user is User`.

---

Indica que la función devuelve un valor booleano.

### --feedback--

Piensa en la palabra `is`, y cómo funciona la frase `user is` User.

---

Indica que `user` satisface la interfaz `User`.

---

Crea una nueva instancia de la interfaz `User`.

### --feedback--

Piensa en la palabra `is`, y cómo funciona la frase `user is` User.

## --video-solution--

3

## --text--

¿Cuál de las siguientes afirmaciones es verdadera sobre la conversión de tipos en TypeScript?

## --answers--

Es el método recomendado para resolver problemas de tipo.

### --feedback--

La conversión de tipos debe hacerse como último recurso.

---

Aumenta la capacidad de TypeScript para detectar errores.

### --feedback--

La conversión de tipos debe hacerse como último recurso.

---

Se hace usando la palabra clave `as`.

---

Debería usarse siempre en lugar de las guardas de tipo.

### --feedback--

La conversión de tipos debe hacerse como último recurso.

## --video-solution--

3
