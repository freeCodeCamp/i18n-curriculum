---
id: 67f39e391c9b373069def02c
title: Revisão de Python
challengeType: 31
dashedName: review-python
---

# --description--

## O que é Python?

- **Introdução**: Python é uma linguagem de programação de uso geral conhecida por sua simplicidade e facilidade de uso. Python é usado em muitos campos como ciência de dados e aprendizado de máquina, desenvolvimento web, scripting e automação, sistemas embarcados e IoT e muito mais.
- **Casos de Uso Comuns**: Python é usado em ciência de dados, aprendizado de máquina, desenvolvimento web, cibersegurança, automação e microcomputadores como o Raspberry Pi e placas compatíveis com MicroPython.

## Python no Seu Ambiente Local

- **Instalação**: A melhor forma de instalar Python no Windows, Mac e Linux é baixar o instalador do site oficial do Python (`https://www.python.org/`).

## Variáveis

- **Declarando Variáveis**: Para declarar uma variável, você começa com o nome da variável seguido pelo operador de atribuição (`=`) e então o tipo de dado. Isso pode ser um número, string, boolean, etc. Aqui estão alguns exemplos:

```py
name = 'John Doe'
age = 25
```

- **Convenções de Nomenclatura para Variáveis**: Aqui estão as convenções de nomenclatura que você deve usar para variáveis:

  - Nomes de variáveis só podem começar com uma letra ou um underscore (_), não com um número.
  - Nomes de variáveis só podem conter caracteres alfanuméricos (a-z, A-Z, 0-9) e underscores (_).
  - Nomes de variáveis são sensíveis a maiúsculas e minúsculas — `age`, `Age` e `AGE` são todos considerados únicos.
  - Nomes de variáveis não podem ser uma das palavras reservadas do Python, como `if`, `class` e `def`.
  - Nomes de variáveis com múltiplas palavras são separados por underscores. Ex. `snake_case`.


## Comentários

- **Comentários de Linha Única**: Esses tipos de comentários devem ser usados para notas curtas que você deseja deixar no seu código.

```py
# This is a single line comment
```

- **Strings de Múltiplas Linhas**: Esses tipos de strings podem ser usados para deixar notas maiores ou para comentar seções do código.

```py
"""
This is is a multi-line string.
Here is some code commented out.

name = 'John Doe'
age = 25
"""
```

- **Função `print()`**: Para imprimir dados no console, você pode usar a função `print()` assim:

```py
print('Hello world!') # Hello world!
```

## Tipos Comuns de Dados em Python

- **Introdução**: Python é uma linguagem de tipagem dinâmica como JavaScript, o que significa que você não precisa declarar explicitamente os tipos para variáveis. A linguagem sabe qual é o tipo de uma variável com base no que você atribui à variável. 
- **Integer**: Um número inteiro sem decimais:

```py
my_integer_var = 10
print('Integer:', my_integer_var) # Integer: 10
```

- **Float**: Um número com decimais:

```py
my_float_var = 4.50
print('Float:', my_float_var) # Float: 4.50
```

- **Complexo**: Um número com parte real e imaginária:

```py
my_complex_var = 3 + 4j
print('Complex:', my_complex_var) # Complex: (3+4j)
```

- **String**: Uma sequência de caracteres envolvida por aspas:

```py
my_string_var = 'hello'
print('String:', my_string_var) # String: hello
```

- **Booleano**: Um valor que representa `True` ou `False`:

```py
my_boolean_var = True
print('Boolean:', my_boolean_var) # Boolean: True
```

- **Set**: Uma coleção não ordenada de elementos únicos:

```py
my_set_var = {7, 5, 8}
print('Set:', my_set_var) # Set: {7, 5, 8}
```

- **Dicionário**: Uma coleção de pares chave-valor, delimitada por chaves:

```py
my_dictionary_var = {"name": "Alice", "age": 25}
print('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}
```

- **Tuple**: Uma coleção ordenada imutável, delimitada por parênteses:

```py
my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)
```

- **Range**: Uma sequência de números, frequentemente usada em loops:

```py
my_range_var = range(5)
print(my_range_var) # range(0, 5)
```

- **Lista**: Uma coleção ordenada de elementos que suporta diferentes tipos de dados:

```py
my_list = [22, 'Hello world', 3.14, True]
print(my_list) # [22, 'Hello world', 3.14, True]
```

- **None**: Um valor especial que representa a ausência de um valor:

```py
my_none_var = None
print('None:', my_none_var) # None: None
```

## Tipos Imutáveis e Mutáveis

- **Tipos Imutáveis**: Esses tipos não podem mudar depois de declarados, embora você possa apontar suas variáveis para algo novo, o que é chamado de reatribuição. Eles incluem integer, float, complex, boolean, string, tuple, range e `None`.
- **Tipos Mutáveis**: Esses tipos podem mudar depois de declarados. Você pode adicionar, remover e atualizar seus itens. Eles incluem tipos de coleção como list, set e dictionary.
- **Função `type()`**: Para ver o tipo de uma variável, você pode usar a função `type()` assim:

```py
greeting = 'Hello there!'
age = 21

print(type(greeting)) # <class 'str'>
print(type(age)) # <class 'int'>
```

- **Função `isinstance()`**: Isso é usado para verificar se uma variável corresponde a um tipo de dado específico:

```py
print(isinstance('Hello world', str)) # True
print(isinstance('John Doe', int)) # False
```

## Trabalhando com Strings

- **Definição**: Como você se lembra do JavaScript, strings são imutáveis o que significa que você não pode alterá-las depois que elas foram criadas. Em Python, você pode usar aspas simples ou duplas. É recomendado escolher uma regra e segui-la:

```py
developer = 'Jessica'
city = 'Los Angeles'
```

- **Acessando Caracteres de Strings**: Você pode acessar caracteres de strings usando a notação de colchetes assim:

```py
my_str = "Hello world"

print(my_str[0])  # H
print(my_str[6])  # w

print(my_str[-1])  # d
print(my_str[-2]) # l
```

- **Escapando Strings**: Você pode usar uma barra invertida (`\`) se sua string contiver aspas assim:

```py
msg = 'It\'s a sunny day'
quote = "She said, \"Hello!\""
```

- **Concatenação de Strings**: Para concatenar strings, você pode usar o operador `+` assim:

```py
developer = 'Jessica'
print('My name is ' + developer + '.') # My name is Jessica
```

Outra forma de concatenar strings é usando o operador `+=`. Isto é usado para realizar concatenação e atribuição na mesma etapa assim:

```py
greeting = 'My name is '
developer = 'Jessica.'

greeting += developer
print(greeting) # My name is Jessica.
```

- **`f-strings`**: Isso é a abreviação de formatted string literals. Permite que você faça interpolação e também alguma concatenação com uma sintaxe compacta e legível:

```py
developer = 'Jessica'
greeting = f'My name is {developer}.'
print(greeting) # My name is Jessica.
```

- **Fatiamento de String**: Isso é quando você pode extrair partes de uma string. Aqui está a sintaxe básica:

```py
str[start:stop:step]
```

A posição inicial representa o índice onde a extração deve começar. A posição de parada é onde o slice deve terminar. Esta posição não é inclusiva. A posição do passo representa o intervalo para incrementar no fatiamento. Aqui estão alguns exemplos:

```py
message = 'Python is fun!'

print(message[0:6])  # Python
print(message[7:])  # is fun!
print(message[::2])  # Pto sfn
```

- **Obtendo o Comprimento de uma String**: A função `len()` é usada para retornar o número de caracteres na string:

```py
developer = 'Jessica'

print(len(developer)) # 7
```

## Trabalhando com o operador `in`

- **Operador `in`**: Isso retorna um booleano que especifica se o caractere ou os caracteres existem na string ou não:

```py
my_str = 'Hello world'

print('Hello' in my_str)  # True
print('hey' in my_str)    # False
print('hi' in my_str)    # False
print('e' in my_str)  # True
print('f' in my_str)  # False
```

## Métodos Comuns de String

- **`str.upper()`**: Isso retorna uma nova string com todos os caracteres convertidos para maiúsculas:

```py
developer = 'Jessica'

print(developer.upper()) # JESSICA
```

- **`str.lower()`**: Isso retorna uma nova string com todos os caracteres convertidos para minúsculas:

```py
developer = 'Jessica'

print(developer.lower()) # jessica
```

- **`str.strip()`**: Isso retorna uma cópia da string com os caracteres especificados no início e no fim removidos (se nenhum argumento for passado para o método, ele remove os espaços em branco no início e no fim).

```py
greeting = '  hello world  '

trimmed_my_str = greeting.strip()
print(trimmed_my_str)  # 'hello world'
```

- **`replace()`**: Isso retorna uma nova string com todas as ocorrências da string antiga substituídas por uma nova.

```py
greeting = 'hello world'

replaced_my_str = greeting.replace('hello', 'hi')
print(replaced_my_str)  # 'hi world'
```

- **`split()`**: Isso é usado para dividir uma string em uma lista usando um separador especificado. Um separador é uma string que especifica onde a divisão deve acontecer.

```py
dashed_name = 'example-dashed-name'

split_words = dashed_name.split('-')
print(split_words)  # ['example', 'dashed', 'name']
```

- **`join()`**: Isso é usado para juntar elementos de um iterável em uma string com um separador. Um iterável é uma coleção de elementos que podem ser percorridos como uma lista, string ou uma tupla. 

```py
example_list = ['example', 'dashed', 'name']

joined_str = ' '.join(example_list)
print(joined_str)  # example dashed name
```

- **`str.startswith(prefix)`**: Isso retorna um booleano indicando se uma string começa com o prefixo especificado:

```py
developer = 'Naomi'

result = developer.startswith('N')
print(result)  # True
```

- **`str.endswith(suffix)`**: Isso retorna um booleano indicando se uma string termina com o sufixo especificado:

```py
developer = 'Naomi'

result = developer.endswith('N')
print(result)  # False
```

- **`str.find()`**: Isso retorna o índice da primeira ocorrência de uma substring. Se nenhuma for encontrada, então `-1` é retornado:

```py
developer = 'Naomi'

result = developer.find('N')
print(result)  # 0

city = 'Los Angeles'
print(city.find('New')) # -1
```

- **`str.count(substring)`**: Isso conta quantas vezes uma substring aparece em uma string:

```py
city = 'Los Angeles'
print(city.count('e')) # 2
```

- **`str.capitalize()`**: Isso retorna uma nova string com o primeiro caractere em maiúscula e os outros caracteres em minúscula:

```py
dessert = 'chocolate cake'
print(dessert.capitalize()) # Chocolate cake
```

- **`str.isupper()`**: Isso retorna `True` se todas as letras na string estiverem em maiúsculas e `False` caso contrário:

```py
dessert = 'chocolate cake'
print(dessert.isupper()) # False
```

- **`str.islower()`**: Isso retorna `True` se todas as letras na string estiverem em minúsculas e `False` caso contrário:

```py
dessert = 'chocolate cake'
print(dessert.islower()) # True
```

- **`str.title()`**: Isso retorna uma nova string com a primeira letra de cada palavra em maiúscula:

```py
city = 'los angeles'
print(city.title()) # Los Angeles
```

- **`str.maketrans()`**: Este método é usado para criar uma tabela de mapeamentos de caracteres 1 para 1 para tradução. Ele é frequentemente usado com o método `translate()` que aplica essa tabela a uma string e retorna o resultado traduzido.

```py
trans_table = str.maketrans('abc', '123')
print(trans_table) # {97: 49, 98: 50, 99: 51}

result = 'abcabc'.translate(trans_table)
print(result)  # 123123
```

## Operações Comuns usadas com Integers e Floats

- **Operações Matemáticas Básicas**: Em Python, você pode fazer operações matemáticas básicas com inteiros e floats incluindo adição, subtração, multiplicação e divisão:

```py
int_1 = 56
int_2 = 12
float_1 = 5.4
float_2 = 12.0

# Addition

print('Integer Addition:', int_1 + int_2) # Integer Addition: 68
print('Float Addition:', float_1 + float_2) # Float Addition: 17.4

# Subtraction

print('Int Subtraction:', int_1 - int_2) # Int Subtraction: 44
print('Float Subtraction:',  float_2 - float_1) # Float Subtraction: 6.6

# Multiplication

print('Int Multiplication:', int_1 * int_2) # Int Multiplication: 672
print('Float Multiplication:', float_2 * float_1) # Float Multiplication: 64.80000000000001

# Division

print('Int Division:', int_1 / int_2) # Int Division: 4.666666666666667
print('Float Division:', float_2 / float_1) # Float Division: 2.222222222222222
```

Quando você adiciona um float e um inteiro, o resultado será convertido para um float assim:

```py
int_1 = 56
float_1 = 5.4

print(int_1 + float_1) # 61.4
```

- **Operador Módulo (`%`)**: Isso retorna o resto quando um número é dividido por outro número:

```py
int_1 = 56
int_2 = 12

print(int_1 % int_2) # 8
```

- **Divisão Inteira (`//`)**: Este operador é usado para dividir dois números e arredondar para baixo o resultado para o número inteiro mais próximo:

```py
int_1 = 56
int_2 = 12

print(int_1 // int_2) # 4
```

- **Operador de Exponenciação (`**`)**: Este operador é usado para elevar um número à potência de outro:

```py
int_1 = 4
int_2 = 2

print(int_1 ** int_2) # 16
```

- **Função `float()`**: Você pode usar esta função para converter um inteiro em float.

```py
num = 4

print(float(num)) # 4.0
```

- **Função `int()`**: Você pode usar esta função para converter um float em um inteiro.

```py
num = 4.0

print(int(num)) # 4
```

- **Função `round()`**: Esta é usada para arredondar um número para o inteiro mais próximo:

```py
num_1 = 3.4
num_2 = 7.7

print(round(num_1)) # 3
print(round(num_2)) # 8
```

- **Função `abs()`**: Esta é usada para retornar o valor absoluto de um número:

```py
num = -13

print(abs(num)) # 13
```

- **Função `bin()`**: Esta é usada para converter um inteiro em sua representação binária como uma string:

```py
num = 56

print(bin(num))  # 0b111000
```

- **Função `oct()`**: Esta é usada para converter um inteiro em sua representação octal como uma string:

```py
num = 56

print(oct(num))  # 0o70
```

- **Função `hex()`**: Esta é usada para converter um inteiro em sua representação hexadecimal como uma string:

```py
num = 56

print(hex(num))  # 0x38
```

- **Função `pow()`**: Esta é usada para elevar um número à potência de outro:

```py
result = pow(2, 3) 
print(result)  # 8
```

## Atribuições Aumentadas

- **Definição**: A atribuição aumentada combina uma operação binária com uma atribuição em um único passo. Ela pega uma variável, aplica uma operação nela com outro valor e armazena o resultado de volta na mesma variável.

```py
# Addition assignment 
my_var = 10
my_var += 5

print(my_var) # 15

# Subtraction assignment
count = 14
count -= 3

print(count) # 11

# Multiplication assignment 
product = 65
product *= 7

print(product) # 455

# Division assignment 
price = 100
price /= 4

print(price) # 25.0

# Floor Division assignment 
total_pages = 23
total_pages //= 5

print(total_pages) # 4

# Modulus assignment 
bits = 35
bits %= 2

print(bits) # 1

# Exponentiation assignment 
power = 2
power **= 3

print(power) # 8
```

Existem outros operadores de atribuição aumentada também, como aqueles para operadores bit a bit. Eles incluem `&=`, `^=`, `>>=` e `<<=`.

## Trabalhando com Funções

- **Definição**: Funções são pedaços reutilizáveis de código que recebem entradas (argumentos) e retornam uma saída. Para chamar uma função, você precisa referenciar o nome da função seguido por um conjunto de parênteses:

```py
# Defining a function

def get_sum(num_1, num_2):
    return num_1 + num_2

result = get_sum(3, 4) # function call
print(result) # 7
```

Se uma função não retornar explicitamente um valor, então o valor de retorno padrão é `None`:

```py
def greet():
    print('hello') 

result = greet() # hello
print(result) # None
```

Você também pode fornecer valores padrão para parâmetros assim:

```py
def get_sum(num_1, num_2=2):
    return num_1 + num_2

result = get_sum(3) 
print(result) # 5
```

Se você chamar a função sem o número correto de argumentos, você receberá um `TypeError`:

```py
def calculate_sum(a, b):
    print(a + b)

calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'
```

## Funções Internas Comuns

- **Função `input()`**: Esta é usada para solicitar uma entrada do usuário:

```py
name = input('What is your name?') # User types 'Kolade' and presses Enter  
print('Hello', name) # Hello Kolade
```

- **Função `int()`**: Esta é usada para converter um número, booleano ou uma string numérica em um inteiro:

```py
print(int(3.14)) # 3
print(int('42')) # 42
print(int(True)) # 1
print(int(False)) # 0 
```

## Decorators

- **Definição**: Decorators são um tipo especial de função em Python. Eles são como invólucros para outras funções, então recebem outra função como argumento.

```py
def say_hello():
    name = input('What is your name? ')
    return 'Hello ' + name

def uppercase_decorator(func):
    def wrapper():
        original_func = func()
        modified_func = original_func.upper()
        return modified_func
    return wrapper

say_hello_res = uppercase_decorator(say_hello)

print(say_hello_res())
```

## Escopo em Python

- **Escopo Local**: Isso ocorre quando uma variável declarada dentro de uma função ou classe só pode ser acessada dentro dessa função ou classe.

```py
def my_func():
    num = 10
    print(num)
```

- **Escopo Envolvente**: Isso ocorre quando uma função que está aninhada dentro de outra função pode acessar as variáveis da função na qual está aninhada.

```py
def outer_func():
    msg = 'Hello there!'
    
    def inner_func():
        print(msg)
    inner_func()

print(outer_func()) # Hello there!
```

- **Escopo Global**: Isso se refere a variáveis que são declaradas fora de qualquer função ou classe que podem ser acessadas de qualquer lugar no programa.

```py
tax = 0.70 

def get_total(subtotal):
    total = subtotal + (subtotal * tax)
    return total

print(get_total(100))  # 170.0
```

- **Escopo Embutido**: Nomes reservados em Python para funções, módulos, palavras-chave e objetos pré-definidos.

```py
print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False
```

## Operadores de Comparação

- **Igual (`==`)**: Verifica se dois valores são iguais:

```py
print(3 == 4) # False
```

- **Diferente (`!=`)**: Verifica se dois valores não são iguais:

```py
print(3 != 4) # True
```

- **Estritamente maior que (`>`)**: Verifica se um valor é maior que outro:

```py
print(3 > 4) # False
```

- **Estritamente menor que (`<`)**: Verifica se um valor é menor que outro:

```py
print(3 < 4) # True
```

- **Maior ou igual a (`>=`)**: Verifica se um valor é maior ou igual a outro:

```py
print(3 >= 4) # False
```

- **Menor ou igual(`<=`)**: Verifica se um valor é menor ou igual a outro:

```py
print(3 <= 4) # True
```

## Trabalhando com as declarações `if`, `elif` e `else`

- **`if` Statements**: Estas são condições usadas para determinar se algo é verdadeiro ou não. Se a condição for avaliada como `True`, então aquele bloco de código será executado.

```py
age = 18

if age >= 18:
    print('You are an adult') # You are an adult
```

- **Declaração `elif`**: Estas são condições que vêm depois de uma declaração `if`. Se a condição `elif` for avaliada como `True`, então esse bloco de código será executado.

```py
age = 16

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')  # You are a teenager
```

- **Cláusula `else`**: Isso será executado se nenhuma outra condição for avaliada como `True`.

```py
age = 12

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')
else:
    print('You are a child')  # You are a child
```

Você também pode usar declarações `if` aninhadas assim:

```py
is_citizen = True
age = 25

if is_citizen:
    if age >= 18:
        print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

## Valores Truthy e Falsy

- **Definição**: Em Python, todo valor tem um valor booleano inerente, ou um sentido embutido de se ele deve ser tratado como `True` ou `False` em um contexto lógico. Muitos valores são considerados truthy, isto é, eles avaliam para `True` em um contexto lógico. Outros são falsy, significando que eles avaliam para `False`. Aqui estão alguns exemplos de valores falsy:

```md
None
False
Integer 0
Float 0.0
Empty strings ''
```

Outros valores como números diferentes de zero e strings não vazias são truthy.

## Trabalhando com a Função `bool()`

- **Definição**: Se você quiser verificar se um valor é truthy ou falsy, pode usar a função embutida `bool()`. Ela converte explicitamente um valor para seu equivalente booleano e retorna `True` para valores truthy e `False` para valores falsy. Aqui estão alguns exemplos:

```py
print(bool(False)) # False
print(bool(0))  # False
print(bool('')) # False

print(bool(True)) # True
print(bool(1)) # True
print(bool('Hello')) # True
```

## Operadores Booleanos e Short-circuiting

- **Definição**: Estes são operadores especiais que permitem combinar múltiplas expressões para criar uma lógica de tomada de decisão mais complexa no seu código. Existem três operadores Booleanos em Python: `and`, `or` e `not`.
- **Operador `and`**: Este operador recebe dois operandos e retorna o primeiro operando se ele for falso, caso contrário, retorna o segundo operando. Ambos os operandos devem ser verdadeiros para que uma expressão resulte em um valor verdadeiro.

```py
is_citizen = True
age = 25

print(is_citizen and age) # 25
```

Você também pode usar o operador `and` em condicionais assim:

```py
is_citizen = True
age = 25

if is_citizen and age >= 18:
    print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

- **Operador `or`**: Este operador retorna o primeiro operando se ele for truthy, caso contrário, retorna o segundo operando. Uma expressão or resulta em um valor truthy se pelo menos um operando for truthy. Aqui está um exemplo:

```py
age = 19
is_employed = False

print(age or is_employed) # 19
```

Assim como com o operador `and`, você pode usar o operador `or` em condicionais assim:

```py
age = 19
is_student = True

if age < 18 or is_student:
    print('You are eligible for a student discount') # You are eligible for a student discount
else:
    print('You are not eligible for a student discount')
```

- **Curto-circuito**: Os operadores `and` e `or` são conhecidos como operadores de curto-circuito. Curto-circuito significa que o Python verifica os valores da esquerda para a direita e para assim que determina o resultado final.
- **Operador `not`**: Este operador recebe um único operando e inverte seu valor booleano. Ele converte valores truthy em `False` e valores falsy em `True`. Diferente dos operadores anteriores que vimos, `not` sempre retorna `True` ou `False`. Aqui estão alguns exemplos:

```py
print(not '') # True, because empty string is falsy
print(not 'Hello') # False, because non-empty string is truthy
print(not 0) # True, because 0 is falsy
print(not 1) # False, because 1 is truthy
print(not False) # True, because False is falsy
print(not True) # False, because True is truthy
```

Aqui está um exemplo do operador `not` em uma condicional: 

```py
is_admin = False

if not is_admin:
    print('Access denied for non-administrators.') # Access denied for non-administrators.
else:
    print('Welcome, Administrator!')
```


## Listas em Python

- **Introdução**: Em Python, o tipo de dado list é uma sequência ordenada de elementos que pode ser composta por strings, números ou até outras listas. As listas são mutáveis e indexadas a partir do zero.

```python
cities = ['Los Angeles', 'London', 'Tokyo']
```

- **Acessando Elementos em uma Lista**: Para acessar um elemento da lista `cities`, você pode referenciar seu número de índice na sequência:

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[0] # Los Angeles
```

- **Acessando Elementos Usando Indexação Negativa**: Para acessar o último elemento de qualquer lista, você pode usar `-1` como número do índice:

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[-1] # Tokyo
```

- A indexação negativa é usada para acessar elementos começando do final da lista em vez do início no índice `0`.

- **Criando Listas Usando o construtor `list()`**: Listas também podem ser criadas usando o construtor `list()`. O construtor `list()` é usado para converter um iterável em uma lista:

```python
developer = 'Jessica'

print(list(developer)) 
# Result: ['J', 'e', 's', 's', 'i', 'c', 'a']
```

- **Encontrando o Tamanho de uma Lista**: Você pode usar a função `len()` para obter o tamanho de uma lista:

```python
numbers = [1, 2, 3, 4, 5]
len(numbers) # 5
```

- **Mutabilidade de Listas**: Listas são mutáveis, o que significa que você pode atualizar qualquer elemento na lista desde que forneça um número de índice válido. Para atualizar listas em um índice específico, você pode atribuir um novo valor a esse índice:

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[0] = 'JavaScript'
print(programming_languages) # ['JavaScript', 'Java', 'C++', 'Rust']
```

- **Erro de Índice Fora do Intervalo**: Se você passar um índice (positivo ou negativo) que esteja fora dos limites da lista, você receberá um `IndexError`:

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[10] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
"""
```

- **Removendo Elementos de uma Lista**: Elementos podem ser removidos de uma lista usando a palavra-chave `del`:

```python
developer = ['Jane Doe', 23, 'Python Developer']
del developer[1]
print(developer) # ['Jane Doe', 'Python Developer']
```

- **Verificando se um Elemento Existe em uma Lista**: A palavra-chave `in` pode ser usada para verificar se um elemento existe em uma lista:

```py
programming_languages = ['Python', 'Java', 'C++', 'Rust']

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **Listas Aninhadas**: Listas podem ser aninhadas dentro de outras listas:

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
```

- Para acessar a lista aninhada, você precisará acessá-la usando o índice `2` já que as listas são indexadas a partir do zero.

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2] # ['Python', 'Rust', 'C++']
```

- Para acessar ainda mais a segunda língua daquela lista aninhada, você precisará acessá-la usando o índice `1`:

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2][1] # Rust
```

- **Desempacotando Valores de uma Lista:** Desempacotar valores de uma lista é uma técnica usada para atribuir valores de uma lista a novas variáveis. Aqui está um exemplo para desempacotar a lista `developer` em novas variáveis chamadas `name`, `age` e `job` assim:

```py
developer = ['Alice', 34, 'Rust Developer']
name, age, job = developer
```

- **Coletando Itens Restantes de uma Lista**: Para coletar quaisquer elementos restantes de uma lista, você pode usar o operador asterisco (`*`) assim:

```py
developer = ['Alice', 34, 'Rust Developer']
name, *rest = developer
```

- Se o número de variáveis no lado esquerdo do operador de atribuição não corresponder ao número total de itens na lista, você receberá um `ValueError`.

- **Fatiando Listas**: Fatiar é o conceito de acessar uma porção de uma lista usando o operador de fatia `:`. Para fatiar uma lista que começa no índice `1` e termina no índice `3`, você pode usar a seguinte sintaxe:

```python
desserts = ['Cake', 'Cookies', 'Ice Cream', 'Pie']
desserts[1:3] # ['Cookies', 'Ice Cream']
```

- **Intervalos de Passo**: Também é possível especificar um intervalo de passo que determina o quanto incrementar entre os índices. Aqui está um exemplo se você quiser extrair uma lista apenas com números pares usando slicing:

```python
numbers = [1, 2, 3, 4, 5, 6]
numbers[1::2] # [2, 4, 6]
```

## Métodos de Lista

- **append()**: Usado para adicionar um item ao final da lista. Aqui está um exemplo de uso do método `append()` para adicionar o número `6` a esta lista `numbers`:

```py
numbers = [1, 2, 3, 4, 5]
numbers.append(6)
print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **Concatenando listas**: O método `append()` também pode ser usado para adicionar uma lista ao final de outra:

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.append(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, [6, 8, 10]]
```

- **extend()**: Usado para adicionar múltiplos itens ao final de uma lista. Aqui está um exemplo de como adicionar os números `6`, `8` e `10` ao final da lista `numbers`:

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.extend(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, 6, 8, 10]
```

- **insert()**: Usado para inserir um item em um índice específico na lista. Aqui está um exemplo de uso do método `insert()`:

```py
numbers = [1, 2, 3, 4, 5]
numbers.insert(2, 2.5)

print(numbers) # [1, 2, 2.5, 3, 4, 5]
```

- **remove():** Usado para remover um item da lista. O método `remove()` removerá apenas a primeira ocorrência de um item na lista:

```py
numbers = [1, 2, 3, 4, 5, 5, 5]
numbers.remove(5)

print(numbers) # [1, 2, 3, 4, 5, 5]

```

- **pop()**: Usado para remover um item específico da lista e retorná-lo:

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop(1) # The number 2 is returned
```

- Se você não especificar um elemento para o método `pop`, então o último elemento será removido.

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop() # The number 5 is returned
```

- **clear()**: Usado para remover todos os itens da lista:

```py
numbers = [1, 2, 3, 4, 5]
numbers.clear()

print(numbers) # []
```

- **sort()**: O método `sort()` é usado para ordenar os elementos no local. Aqui está um exemplo de ordenação de uma lista aleatória de `numbers` no local:

```py
numbers = [19, 2, 35, 1, 67, 41]
numbers.sort()

print(numbers) # [1, 2, 19, 35, 41, 67]
```

- **sorted()**: Usado para ordenar os elementos em uma lista e retornar uma nova lista ordenada em vez de modificar a lista original.

- **reverse()**: Usado para inverter a ordem dos elementos em uma lista:

```py
numbers = [6, 5, 4, 3, 2, 1]
numbers.reverse()

print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **index()**: Usado para encontrar o primeiro índice onde um elemento pode ser encontrado em uma lista:

```python
programming_languages = ['Rust', 'Java', 'Python', 'C++']
programming_languages.index('Java') # 1
```

- Se o elemento não puder ser encontrado usando o método `index()`, então o resultado será um `ValueError`.

## Tuplas em Python

- **Definição**: Uma tupla é um tipo de dado Python usado para criar uma sequência ordenada de valores. Tuplas podem conter um conjunto misto de tipos de dados:

```py
developer = ('Alice', 34, 'Rust Developer')
```

- Tuples são imutáveis, o que significa que os elementos na tuple não podem ser alterados depois de criados. Se você tentar atualizar um dos itens na tuple, você receberá um `TypeError`:

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')
programming_languages[0] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object does not support item assignment
"""
```

- **Acessando Elementos de uma Tupla**: Para acessar um elemento de uma tupla, use a notação de colchetes e o número do índice:

```py
developer = ('Alice', 34, 'Rust Developer')
developer[1] # 34
```

- A indexação negativa pode ser usada para acessar elementos começando do final da tupla:

```py
numbers = (1, 2, 3, 4, 5)
numbers[-2] # 4
```

- Se você tentar passar um número de índice que excede ou é igual ao comprimento da tupla, então você receberá um `IndexError`:

```py
numbers = (1, 2, 3, 4, 5)
numbers[7]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: tuple index out of range
"""
```

- Uma tupla também pode ser criada usando o construtor `tuple()`. Dentro do construtor, você pode passar diferentes iteráveis como strings, listas e até outras tuplas.

```python
developer = 'Jessica'

print(tuple(developer)) 
# Result: ('J', 'e', 's', 's', 'i', 'c', 'a')
```

- **Verificando Itens em uma Tupla**: Para verificar se um item está em uma tupla, você pode usar a palavra-chave `in` assim:

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **Desempacotando Tuplas**: Itens podem ser desempacotados de uma tupla assim:

```py
developer = ('Alice', 34, 'Rust Developer')
name, age, job = developer
```

- Se você precisar coletar quaisquer elementos restantes de uma tupla, pode usar o operador asterisco (`*`) assim:

```py
developer = ('Alice', 34, 'Rust Developer')
name, *rest = developer
```

- **Fatiamento de Tuplas**: O fatiamento pode ser usado para extrair uma parte de uma tupla. Por exemplo, os itens `pie` e `cookies` podem ser fatiados em uma tupla separada:

```py
desserts = ('cake', 'pie', 'cookies', 'ice cream')
desserts[1:3] # ('pie', 'cookies')
```

- **Removendo Itens de Tuplas**: Remover um item de uma tupla gerará um `TypeError` pois tuplas são imutáveis:

```py
developer = ('Jane Doe', 23, 'Python Developer')
del developer[1]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object doesn't support item deletion
"""
```

- **Quando usar uma Tuple vs uma List?**: Se você precisa de uma coleção dinâmica de elementos onde pode adicionar, remover e atualizar elementos, então deve usar uma list. Se você sabe que está trabalhando com uma coleção fixa e imutável de dados, então deve usar uma tuple.

## Métodos Comuns de Tupla

- **`count()`**: Usado para determinar quantas vezes um item aparece em uma tupla. Por exemplo, você pode verificar quantas vezes a linguagem `'Rust'` aparece na tupla:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('Rust') # 2
```

- Se o item especificado na função `count()` não estiver presente na tupla, o valor retornado será `0`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('JavaScript') # 0
```

- Se nenhum argumento for passado para a função `count()`, então o Python retornará um `TypeError`.

- **index()**: Usado para encontrar o índice onde um item específico está presente na tupla. Aqui está um exemplo de uso do método `index()` para encontrar o índice da linguagem `'Java'`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.index('Java') # 1
```

- Se o item especificado não puder ser encontrado, então o Python retornará um `ValueError`.

- Você pode passar um índice inicial opcional para o método `index()` para especificar onde começar a procurar o item na tupla:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
programming_languages.index('Python', 3) # 5
```

- Você também pode passar um índice final opcional para o método `index()` para especificar onde parar de procurar o item na tupla:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python', 'JavaScript', 'Python')
programming_languages.index('Python', 2, 5) # 2
```

- **`sorted()`**: Usado para ordenar os elementos em qualquer iterável e retornar uma nova lista ordenada. Aqui está um exemplo de como criar uma nova lista de números usando a função `sorted()`:

```py
numbers = (13, 2, 78, 3, 45, 67, 18, 7)
sorted(numbers) # [2, 3, 7, 13, 18, 45, 67, 78]
```

- **Modificando o Comportamento de Ordenação**: Você pode personalizar o comportamento de ordenação para um iterável usando os argumentos opcionais `reverse` e `key`. Aqui está um exemplo de uso do argumento `key` para ordenar itens em uma tupla por comprimento:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
sorted(programming_languages, key=len)

# Result
# ['C++', 'Rust', 'Java', 'Rust', 'Python', 'Python']
```

- Você pode criar uma nova lista de valores em ordem reversa, usando o argumento `reverse` assim:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')

print(sorted(programming_languages, reverse=True))

# Result
# ['Rust', 'Rust', 'Python', 'Python', 'Java', 'C++']
```

## Loops em Python

- **Definição**: Loops são usados para repetir um bloco de código por um número definido de vezes.

- **`for` loop**: Usado para iterar sobre uma sequência (como uma lista, tupla ou string) e executar um bloco de código para cada item nessa sequência. Aqui está um exemplo de uso de um `for` loop para iterar por uma lista e imprimir cada linguagem no console:

```py
programming_languages = ['Rust', 'Java', 'Python', 'C++']

for language in programming_languages:
    print(language)

"""
Result 

Rust
Java
Python
C++
"""
```

- Aqui está um exemplo de uso de um loop `for` para percorrer a string `code` e imprimir cada caractere:

```py
for char in 'code':
    print(char)

"""
Result 

c
o
d
e
"""
```

- Loops `for` podem ser aninhados. Aqui está um exemplo de uso de um loop `for` aninhado:

```py
categories = ['Fruit', 'Vegetable']
foods = ['Apple', 'Carrot', 'Banana']

for category in categories:
    for food in foods:
        print(category, food)

"""
Result

Fruit Apple
Fruit Carrot
Fruit Banana
Vegetable Apple
Vegetable Carrot
Vegetable Banana
"""

```

- **Laço `while`**: Repete um bloco de código até que a condição seja `False`. Aqui está um exemplo de uso de um laço `while` para um jogo de adivinhação:

```py
secret_number = 3
guess = 0

while guess != secret_number:
    guess = int(input('Guess the number (1-5): '))
    if guess != secret_number:
        print('Wrong! Try again.')

print('You got it!')

"""
Result

Guess the number (1-5): 2
Wrong! Try again.
Guess the number (1-5): 1
Wrong! Try again.
Guess the number (1-5): 3
You got it!
"""

```

- **Instruções `break` e `continue`**: Usadas em loops para modificar a execução de um loop.

- A instrução `break` é usada para sair do loop imediatamente quando uma determinada condição é atendida. Aqui está um exemplo de uso da instrução `break` para uma lista de `developer_names`:

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        break
    print(developer)
```

- A declaração `continue` é usada para pular a iteração atual e passar para a próxima iteração do loop. Aqui está um exemplo de como usar a declaração `continue` em vez da declaração `break`:

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        continue
    print(developer)
```

- Tanto os loops `for` e `while` podem ser combinados com uma cláusula `else`, que é executada somente quando o loop não foi terminado por um `break`:

```python
words = ['sky', 'apple', 'rhythm', 'fly', 'orange']

for word in words:
    for letter in word:
        if letter.lower() in 'aeiou':
            print(f"'{word}' contains the vowel '{letter}'")
            break
    else:
        print(f"'{word}' has no vowels")
```

## Intervalos e Seu Uso em Loops

- **A função `range()`**: Usada para gerar uma sequência de números inteiros. 

```py
range(start, stop, step)
```

- O argumento obrigatório `stop` é um inteiro (não inclusivo) que representa o ponto final para a sequência de números sendo gerada. Aqui está um exemplo de uso da função `range()`:

```py
for num in range(3):
    print(num)
```

- Se um argumento `start` não for especificado, o padrão será `0`. Por padrão a sequência de inteiros incrementará por `1`. Você pode usar o argumento opcional `step` para alterar o valor do incremento padrão. Aqui está um exemplo de geração de uma sequência de inteiros pares de 2 até, mas não incluindo 11 (ou seja, inclui 10)

```py
for num in range(2, 11, 2):
    print(num)
```

- Se você não fornecer nenhum argumento para a função `range()`, então você receberá um `TypeError`.

- A função `range()` aceita apenas inteiros como argumentos e não floats. Usar floats também resultará em um `TypeError`:

```py
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
```

- Você pode usar um inteiro negativo para o argumento `step` para gerar uma sequência de inteiros em ordem decrescente:

```py
for num in range(40, 0, -10):
    print(num)
```

- A função `range()` também pode ser usada para criar uma lista de inteiros usando-a com o construtor `list`. O construtor `list` é usado para converter um iterável em uma lista. Aqui está um exemplo de como gerar uma lista de inteiros pares entre 2 e 10 inclusive:

```py
numbers = list(range(2, 11, 2))
print(numbers) # [2, 4, 6, 8, 10]
```

## funções `enumerate()` e `zip()` em Python

- **`enumerate()`**: usado para iterar sobre uma sequência e acompanhar o índice de cada item nessa sequência. A função `enumerate()` recebe um iterável como argumento e retorna um objeto `enumerate` que consiste no índice e no valor de cada item no iterável.

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

for index, language in enumerate(languages):
    print(f'Index {index} and language {language}')

# Result
# Index 0 and language Spanish
# Index 1 and language English
# Index 2 and language Russian
# Index 3 and language Chinese

```

- A função `enumerate()` também pode ser usada fora de um loop `for`:

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

print(list(enumerate(languages)))
# [(0, 'Spanish'), (1, 'English'), (2, 'Russian'), (3, 'Chinese')]
```

- A função `enumerate()` também aceita um argumento opcional `start` que especifica o valor inicial para a contagem. Se esse argumento for omitido, a contagem começará em `0`.

-  **`zip()`** : Usado para iterar sobre múltiplos iteráveis em paralelo. Aqui está um exemplo usando a função `zip()` para iterar sobre `developers` e `ids`:

```python
developers = ['Naomi', 'Dario', 'Jessica', 'Tom']
ids = [1, 2, 3, 4]

for name, id in zip(developers, ids):
    print(f'Name: {name}')
    print(f'ID: {id}')


"""
Result

Name: Naomi
ID: 1
Name: Dario
ID: 2
Name: Jessica
ID: 3
Name: Tom
ID: 4
"""

```

## Compreensões de listas em Python

- **Definição**: List comprehension permite que você crie uma nova lista em uma única linha combinando o loop e a condição diretamente dentro de colchetes. Isso torna o código mais curto e frequentemente mais fácil de ler.

```py
even_numbers = [num for num in range(21) if num % 2 == 0]
print(even_numbers)
```

## Métodos iteráveis

- **`filter()`**: Usado para filtrar elementos de um iterável com base em uma condição. Ele retorna um iterador que contém apenas os elementos que satisfazem a condição. Aqui está um exemplo de como criar uma nova lista apenas com palavras com mais de quatro caracteres:

```py
words = ['tree', 'sky', 'mountain', 'river', 'cloud', 'sun']

def is_long_word(word):
    return len(word) > 4

long_words = list(filter(is_long_word, words))
print(long_words) # ['mountain', 'river', 'cloud']
```

- **`map()`**: Usado para aplicar uma função a cada item em um iterável e retornar um novo iterável com os resultados. Aqui está um exemplo de uso da função `map()` para converter uma lista de temperaturas em celsius para fahrenheit:

```py
celsius = [0, 10, 20, 30, 40]

def to_fahrenheit(temp):
    return (temp * 9/5) + 32

fahrenheit = list(map(to_fahrenheit, celsius))
print(fahrenheit) # [32.0, 50.0, 68.0, 86.0, 104.0]
```

- **`sum()`**: Usado para obter a soma de um iterável como uma lista ou tupla. Aqui está um exemplo de uso da função `sum()`:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers)
print(total) # Result: 50
```

- Você também pode passar um argumento opcional `start` que define o valor inicial para a soma. Aqui está um exemplo atualizado usando o argumento `start` como um argumento posicional:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, 10) # positional argument
print(total) # 60
```

- Você também pode optar por usar o argumento `start` como um argumento nomeado assim:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, start=10) # keyword argument
print(total) # 60
```

## Funções Lambda

- **Definição**: Uma função lambda em Python é uma forma concisa de criar uma função sem nome (uma função anônima). 
- Funções lambda são frequentemente usadas como argumento para outra função. Aqui está um exemplo de uma função lambda:

```py
numbers = [1, 2, 3, 4, 5]

even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]
```

- As melhores práticas para usar funções lambda incluem não atribuí-las a uma variável, mantê-las simples e legíveis e usá-las para funções curtas e pontuais.

## Dicionários

- **Dicionários**: Dicionários são estruturas de dados embutidas que armazenam coleções de pares chave-valor. As chaves precisam ser tipos de dados imutáveis. Esta é a sintaxe geral de um dicionário Python:

```python
dictionary = {
    key1: value1,
    key2: value2
}
```

- **Construtor `dict()`**: O construtor `dict()` é uma forma alternativa de construir o dicionário. Você passa uma lista de tuplas como argumento para o construtor `dict()`. Essas tuplas contêm a chave como o primeiro elemento e o valor como o segundo elemento.

```python
pizza = dict([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250), ('toppings', ['mozzarella', 'basil'])])
```

- **Notação de Colchetes**: Para acessar o valor de um par chave-valor, você pode usar a sintaxe conhecida como notação de colchetes.

```python
dictionary[key]
```

## Métodos Comuns de Dicionário

- **Método `get()`**: O método `get()` recupera o valor associado a uma chave. É semelhante à notação de colchetes, mas permite definir um valor padrão, evitando erros se a chave não existir.

```python
dictionary.get(key, default)
```

- **Métodos `keys()` e `values()`**: Os métodos `keys()` e `values()` retornam um objeto view com todas as chaves e valores no dicionário, respectivamente. Um objeto view é uma forma de ver o conteúdo de um dicionário sem criar uma cópia separada dos dados.

```python
pizza = {
    'name': 'Margherita Pizza',
    'price': 8.9,
    'calories_per_slice': 250
}

pizza.keys()
# dict_keys(['name', 'price', 'calories_per_slice'])

pizza.values()
# dict_values(['Margherita Pizza', 8.9, 250])
```

- **Método `items()`**: O método `items()` retorna um objeto view com todos os pares chave-valor no dicionário, incluindo tanto as chaves quanto os valores.

```python
pizza.items()
# dict_items([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250)])
```

- **Método `clear()`**: O método `clear()` remove todos os pares chave-valor do dicionário.

```python
pizza.clear()
```

- **Método `pop()`**: O método `pop()` remove o par chave-valor com a chave especificada como o primeiro argumento e retorna seu valor. Se a chave não existir, ele retorna o valor padrão especificado como o segundo argumento. Se a chave não existir e o valor padrão não for especificado, um `KeyError` é gerado.

```python
pizza.pop('price', 10)
pizza.pop('total_price') # KeyError
```

- **Método `popitem()`**: No Python 3.7 e versões superiores, o método `popitem()` remove o último item inserido.

```python
pizza.popitem()
```

- **Método `update()`**: O método `update()` atualiza os pares chave-valor com os pares chave-valor de outro dicionário. Se eles tiverem chaves em comum, seus valores serão sobrescritos. Novas chaves serão adicionadas ao dicionário como novos pares chave-valor.

```python
pizza.update({ 'price': 15, 'total_time': 25 })
```

## Iterando Sobre um Dicionário

- **Iterando Sobre Valores**: Se você precisar iterar sobre os valores em um dicionário, pode escrever um loop `for` com `values()` para obter todos os valores de um dicionário.

```python
products = {
    'Laptop': 990,
    'Smartphone': 600,
    'Tablet': 250,
    'Headphones': 70,
}

for price in products.values():
    print(price)
```

Resultado:

```md
990
600
250
70
```

- **Iterando Sobre Chaves**: Se você precisar iterar sobre as chaves no dicionário `products` acima, você pode escrever `products.keys()` ou `products` diretamente.

```python
for product in products.keys():
    print(product)

for product in products:
    print(product)
```

Resultado:

```md
Laptop
Smartphone
Tablet
Headphones
```

- **Iterando Sobre Pares Chave-Valor**: Se você precisar iterar sobre as chaves e seus valores correspondentes simultaneamente, você pode iterar sobre `products.items()`. Você obtém tuplas individuais com as chaves e seus valores correspondentes.

```python
for product in products.items():
    print(product)
```

Resultado:

```md
('Laptop', 990)
('Smartphone', 600)
('Tablet', 250)
('Headphones', 70)
```

Para armazenar a chave e o valor em variáveis de loop separadas, você precisa separá-las com uma vírgula. A primeira variável armazena a chave e a segunda armazena o valor.

```python
for product, price in products.items():
    print(product, price)
```

Resultado:

```md
Laptop 990
Smartphone 600
Tablet 250
Headphones 70
```

- **Função `enumerate()`**: Se você precisa iterar sobre um dicionário enquanto mantém o controle de um contador, pode chamar a função `enumerate()`. A função retorna um objeto `enumerate`, que atribui um inteiro a cada item, como um contador. Você pode iniciar o contador a partir de qualquer número, mas por padrão, ele começa em 0.

Atribuir o índice e o item a variáveis de loop separadas é a forma comum de usar `enumerate()`. Por exemplo, com `products.items()`, você pode obter o par chave-valor inteiro além do índice:

```python
for index, product in enumerate(products.items()):
    print(index, product)
```

Resultado:

```md
0 ('Laptop', 990)
1 ('Smartphone', 600)
2 ('Tablet', 250)
3 ('Headphones', 70)
```

Para personalizar o valor inicial do count, você pode passar um segundo argumento para o `enumerate()`. Por exemplo, aqui estamos começando a contagem a partir de 1.

```python
for index, product in enumerate(products.items(), 1):
    print(index, product)
```

Resultado:

```md
1 ('Laptop', 990)
2 ('Smartphone', 600)
3 ('Tablet', 250)
4 ('Headphones', 70)
```

## Conjuntos

- **Conjuntos**: Conjuntos são estruturas de dados embutidas em Python que não permitem valores duplicados. Conjuntos são mutáveis e não ordenados, o que significa que seus elementos não são armazenados em uma ordem específica, então você não pode usar índices ou chaves para acessá-los. Além disso, conjuntos só podem conter valores de tipos de dados imutáveis, como números, strings e tuplas.

- **Definindo um Conjunto**: Para definir um conjunto, você precisa escrever seus elementos dentro de chaves e separá-los com vírgulas.

```python
my_set = {1, 2, 3, 4, 5}
```

- **Definindo um Conjunto Vazio**: Se você precisar definir um conjunto vazio, deve usar a função `set()`. Apenas escrever chaves vazias criará automaticamente um dicionário.

```python
set() # Set
{}    # Dictionary
```

## Métodos Comuns de Conjunto

- **Método `add()`**: Você pode adicionar um elemento a um conjunto com o método `add()`, passando o novo elemento como argumento.

```python
my_set.add(6)
```

- **Métodos `remove()` e `discard()`**: Para remover um elemento de um conjunto, você pode usar o método `remove()` ou o método `discard()`, passando o elemento que deseja remover como argumento. O método `remove()` gerará um `KeyError` se o elemento não for encontrado e o método `discard()` não gerará.

```python
my_set.remove(4)
my_set.discard(4)
```

- **Método `clear()`**: O método `clear()` remove todos os elementos do conjunto.

```python
my_set.clear()
```

## Operações Matemáticas de Conjuntos

- **Métodos `issubset()` e `issuperset()`**: Os métodos `issubset()` e `issuperset()` verificam se um conjunto é um subconjunto ou superconjunto de outro conjunto, respectivamente.

```python
my_set = {1, 2, 3, 4, 5} 
your_set = {2, 3, 4, 5}

print(your_set.issubset(my_set)) # True
print(my_set.issuperset(your_set)) # True
```

- **Método `isdisjoint()`**: O método `isdisjoint()` verifica se dois conjuntos são disjuntos, se eles não têm elementos em comum.

```python
print(my_set.isdisjoint(your_set)) # False
```

- **Operador de União (`|`)**: O operador de união `|` retorna um novo conjunto com todos os elementos de ambos os conjuntos.

```python
my_set | your_set # {1, 2, 3, 4, 5, 6}
```

- **Operador de Interseção (`&`)**: O operador de interseção `&` retorna um novo conjunto com apenas os elementos que os conjuntos têm em comum.

```python
my_set & your_set # {2, 3, 4}
```

- **Operador de Diferença (`-`)**: O operador de diferença `-` retorna um novo conjunto com os elementos do primeiro conjunto que não estão nos outros conjuntos.

```python
my_set - your_set # {1, 5}
```

- **Operador de Diferença Simétrica (`^`)**: O operador de diferença simétrica `^` retorna um novo conjunto com os elementos que estão no primeiro ou no segundo conjunto, mas não em ambos.

```python
my_set ^ your_set # {1, 5, 6}
```

- **Operador `in`**: Você pode verificar se um elemento está em um conjunto ou não com o operador `in`.

```python
print(5 in my_set)
```

## Biblioteca Padrão do Python

- **Biblioteca Padrão do Python**: Uma biblioteca oferece código pré-escrito e reutilizável, como funções, classes e estruturas de dados, que você pode reutilizar em seus projetos. Python possui uma extensa biblioteca padrão com módulos integrados que implementam soluções padronizadas para muitos problemas e tarefas. Alguns exemplos de módulos integrados populares são `math`, `random`, `re` (abreviação de "regular expressions") e `datetime`.

## Declaração de Importação

- **Declaração de Importação**: Para acessar os elementos definidos em módulos embutidos, você usa uma declaração de importação. Declarações de importação geralmente são escritas no topo do arquivo. Declarações de importação funcionam da mesma forma para funções, classes, constantes, variáveis e quaisquer outros elementos definidos no módulo.

- **Declaração Básica de Importação**: Você pode usar a palavra-chave `import` seguida pelo nome do módulo:

```python
import module_name
```

Então, se você precisar chamar um método desse módulo, você usaria a notação de ponto, com o nome do módulo seguido do nome do método.

```python
module_name.method_name()
```

Por exemplo, você escreveria o seguinte no seu código para importar o módulo `math` e obter a raiz quadrada de 36:

```python
import math

math.sqrt(36)
```

- **Importando um Módulo com um Nome Diferente**: Se você precisar importar o módulo com um nome diferente (também conhecido como "alias"), você pode usar `as` seguido do alias no final da declaração de importação. Isso é frequentemente usado para nomes de módulos longos ou para evitar conflitos de nomes.

```python
import module_name as module_alias
```

Por exemplo, para se referir ao módulo `math` como `m` no seu código, você pode atribuir um alias assim:

```python
import math as m
```

Então, você pode acessar os elementos do módulo usando o alias:

```python
m.sqrt(36)
```

- **Importando Elementos Específicos**: Se você não precisa de tudo de um módulo, pode importar elementos específicos usando `from`. Nesse caso, a declaração de importação começa com `from`, seguida pelo nome do módulo, depois a palavra-chave `import` e finalmente os nomes dos elementos que você deseja importar.

```python
from module_name import name1, name2
```

Então, você pode usar esses nomes sem o prefixo do módulo no seu script Python. Por exemplo:

```python
from math import radians, sin, cos

angle_degrees = 40
angle_radians = radians(angle_degrees)

sine_value = sin(angle_radians)
cos_value = cos(angle_radians)

print(sine_value) # 0.6427876096865393
print(cos_value)  # 0.766044443118978
```
 
Isso é útil, mas pode resultar em conflitos de nomes se você já tiver funções ou variáveis com o mesmo nome. Tenha isso em mente ao escolher qual tipo de declaração de importação você quer usar.

Se você precisar atribuir aliases a esses nomes, também pode fazer isso usando a palavra-chave `as` seguida do alias.

```python
from module_name import name1 as alias1, name2 as alias2
```

- **Declaração de Importação com Asterisco (`*`)**: O asterisco indica ao Python que você quer importar tudo naquele módulo, mas quer importar de forma que não precise usar o nome do módulo como prefixo.

```python
from module_name import *
```

Por exemplo, se você usar isso para importar o módulo `math`, poderá chamar qualquer função definida nesse módulo sem especificar o nome do módulo como prefixo.

```python
from math import *
print(sqrt(36))  # 6.0
```

No entanto, isso geralmente é desencorajado porque pode levar a colisões de namespace e dificultar saber de onde os nomes vêm.

## `if __name__ == '__main__'`

- **Variável `__name__`**: `__name__` é uma variável interna especial no Python. Quando um arquivo Python é executado diretamente, o Python define o valor dessa variável para a string `"__main__"`. Mas se o arquivo Python for importado como um módulo em outro script Python, o valor da variável `__name__` é definido como o nome desse módulo.

É por isso que você frequentemente encontrará essa condicional em scripts Python. Ele contém o código que você quer executar **somente** se o script Python estiver sendo executado como o programa principal.

```python
if __name__ == '__main__': 
    # Code
```

## Erros Comuns em Python

- **SyntaxError**: O erro que o Python gera quando seu código não segue suas regras de sintaxe. Por exemplo, o código `print("Hello there"` levará a um erro de sintaxe com a mensagem, `SyntaxError: '(' was never closed`, porque o código está sem um parêntese de fechamento.
- **NameError**: Python gera um `NameError` quando você tenta acessar uma variável ou função que não definiu. Por exemplo, se você tiver a linha `print(username)` no seu código sem ter uma variável `username` definida primeiro, você receberá um erro de nome com a mensagem `NameError: name 'username' is not defined`.
- **TypeError**: Este é o erro que o Python lança quando você realiza uma operação em dois ou mais tipos de dados incompatíveis. Por exemplo, se você tentar adicionar uma string a um número, você receberá o erro `TypeError: can only concatenate str (not "int") to str`.
- **IndexError**: Você receberá um `IndexError` se acessar um índice que não existe em uma lista ou outras sequências como tuple e string. Por exemplo, em uma string `Hello world`, o índice do último caractere é `11`. Se você acessar um caractere desta forma, `greet = "hello world"; print(greet[12])`, você receberá um erro com a mensagem `IndexError: string index out of range`.
- **AttributeError**: Python gera esse erro quando você tenta usar um método ou propriedade que não existe em um objeto desse tipo. Por exemplo, chamar `.append()` em uma string como `"hello".append("!")` levará a um erro com a mensagem `AttributeError: 'str' object has no attribute 'append'`.

## Boas Técnicas de Depuração em Python

- **Usando a função `print`**: Inserir declarações `print()` em vários pontos do seu código durante a depuração ajuda você a ver os valores das variáveis e como seu código flui.
- **Usando o Depurador Embutido do Python (`pdb`)**: Python fornece um módulo `pdb` para depuração. Ele faz parte da biblioteca padrão do Python, então está sempre disponível para uso. Com o `pdb`, você pode definir um trace com o método `set_trace()` para começar a executar o código passo a passo e inspecionar variáveis de forma interativa.
- **Aproveitando as Ferramentas de Depuração do IDE**: Muitos ambientes de desenvolvimento integrados (IDEs) e editores de código como Pycharm e VS Code oferecem ferramentas de depuração com breakpoints, execução passo a passo, inspeção de variáveis e outros recursos de depuração.

## Tratamento de Exceções

- **`try...except`**: Isso é usado para executar um bloco de código que pode gerar uma exceção. O bloco `try` é onde você antecipa que um erro pode ocorrer, enquanto o bloco `except` captura uma exceção especificada e é executado se esse erro especificado for levantado. Aqui está um exemplo:

  ```py
  try:
    print(22 / 0)
  except ZeroDivisionError:
    print('You can\'t divide by zero!')
    # You can't divide by zero!
  ```

  Você também pode encadear múltiplos blocos `except` para que possa tratar mais tipos de exceções:

  ```py
  try:
    number = int(input('Enter a number: '))
    print(22 / number)
  except ZeroDivisionError:
    print('You cannot divide by zero!')
    # You cannot divide by zero! prints when you enter 0
  except ValueError:
    print('Please enter a valid number!')
    # Please enter a valid number! prints when you enter a string  
  ```

- **`else` e `finally`**: Esses blocos estendem `try...except`. Se nenhuma exceção ocorrer, o bloco `else` é executado. O bloco `finally` sempre é executado independentemente de erros.

  ```py
  try:
    result = 100 / 4
  except ZeroDivisionError:
    print('You cannot divide by zero!') # This will not run
  else:
    print(f'Result is {result}') # Result is 25.0
  finally:
    print('Execution complete!') # Execution complete!
  ```

- **Objeto de Exceção**: Isso permite que você acesse a exceção em si para um melhor debug e para imprimir a mensagem de erro direta. Para acessar o objeto de exceção, você precisa usar a palavra-chave `as`. Aqui está um exemplo:

  ```py
  try:
      value = int('This will raise an error')
  except ValueError as e:
      print(f'Caught an error: {e}')
      # Caught an error: invalid literal for int() with base 10: 'This will raise an error'
  ```

- **A declaração `raise`**: Isso permite que você levante manualmente uma exceção. Você pode usá-la para lançar uma exceção quando uma determinada condição for atendida. Aqui está um exemplo:

  ```py
  def divide(a, b):
      if b == 0:
          raise ZeroDivisionError('You cannot divide by zero')
      return a / b
  ```
  
## Sinalização de Exceção
  
  A instrução `raise` também é útil quando você cria suas próprias exceções personalizadas, pois pode usá-la para lançar uma exceção com uma mensagem personalizada. Aqui está um exemplo disso:

  ```py
  class InvalidCredentialsError(Exception):
      def __init__(self, message="Invalid username or password"):
          self.message = message
          super().__init__(self.message)

  def login(username, password):
      stored_username = "admin"
      stored_password = "password123"
      
      if username != stored_username or password != stored_password:
          raise InvalidCredentialsError()
      
      return f"Welcome, {username}!"
  ```  

  Aqui está como você pode usar a função `login` da exceção `InvalidCredentialsError`:

  ```py
  # failed login attempt
  try:
      message = login("user", "wrongpassword")
      print(message)
  except InvalidCredentialsError as e:
      print(f"Login failed: {e}")

  # successful login attempt
  try:
      message = login("admin", "password123")
      print(message)
  except InvalidCredentialsError as e:
      # This block is not executed because the login was successful
      print(f"Login failed: {e}")
  else:
      # The else block runs if the 'try' block completes without an exception
      print(message)
  ```

  A instrução `raise` também pode ser usada com a palavra-chave `from` para encadear exceções, mostrando a relação entre diferentes erros:

  ```py
  def parse_config(filename):
    try:
        with open(filename, 'r') as file:
            data = file.read()
            return int(data)
    except FileNotFoundError:
        raise ValueError('Configuration file is missing') from None
    except ValueError as e:
        raise ValueError('Invalid configuration format') from e

  config = parse_config('config.txt')
```

## Classes e Objetos em Python

- **Definição de Classe**: Uma classe é um modelo para criar objetos. Ela define o comportamento que um objeto terá através de seus atributos e métodos. Aqui está um exemplo básico de uma definição de classe em Python:

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f'{self.name.upper()} says woof woof!')
```

- **Criando Objetos**: Objetos são instâncias de uma classe. Eles são criados chamando a classe com os argumentos necessários.

```python
dog1 = Dog('Jack', 3)
dog2 = Dog('Thatcher', 5)

dog1.bark()  # JACK says woof woof!
dog2.bark()  # THATCHER says woof woof!
```

- **Chamando métodos com objetos**: Você pode chamar métodos em objetos para executar ações ou recuperar informações.

```python
objectName1.methodName()
objectName2.methodName()
```

- **Diferença Entre Classe e Objeto**: Uma classe é um modelo reutilizável, enquanto um objeto é uma instância específica dessa classe com dados reais.

## Atributos

- **Atributos de Instância**: Definidos em `__init__()` usando `self` e únicos para cada objeto.
- **Atributos da Classe**: Definidos diretamente dentro da classe e compartilhados por todas as instâncias.

```python
class Dog:
    species = 'French Bulldog'  # Class attribute

    def __init__(self, name):
        self.name = name  # Instance attribute

print(Dog.species) # French Bulldog

jack = Dog('Jack')
print(jack.name)     # Jack
print(jack.species)  # French Bulldog
```

## Métodos

- **Métodos**: Funções definidas dentro de uma classe que operam nos atributos do objeto.

```python
class Car:
    def __init__(self, color, model):
        self.color = color
        self.model = model

    def describe(self):
        return f'This car is a {self.color} {self.model}'

my_car_1 = Car('red', 'Tesla Model S')
print(my_car_1.describe())  # This car is a red Tesla Model S
```

- **Acessando Métodos**: Chame métodos em objetos usando a notação de ponto. Aqui está um exemplo de chamada do método `describe` em dois objetos de carro diferentes:

```python
class Car:
 def __init__(self, color, model):
   self.color = color  
   self.model = model  

 def describe(self):
   return f'This car is a {self.color} {self.model}'

my_car_1 = Car('red', 'Tesla Model S')
my_car_2 = Car('green', 'Lamborghini Revuelto')

print(my_car_1.describe()) # Calling methods using the dot notation

print(my_car_2.describe()) # Calling methods using the dot notation
```

## Métodos Dunder (Mágicos)

- **Definição**: Métodos especiais que começam e terminam com um duplo underscore (por exemplo, `__init__`, `__len__`, `__str__`, `__eq__`). Python os usa internamente para operações internas.

```python
class Book:
    def __init__(self, title, pages):
        self.title = title
        self.pages = pages

    def __len__(self):
        return self.pages

    def __str__(self):
        return f"'{self.title}' has {self.pages} pages"

    def __eq__(self, other):
        return self.pages == other.pages

book1 = Book('Built Wealth Like a Boss', 420)
print(len(book1))        # 420
print(str(book1))        # 'Built Wealth Like a Boss' has 420 pages
```

- **Chamando métodos dunder indiretamente**: Você não precisa chamar métodos dunder diretamente. Em vez disso, o Python os chama automaticamente quando certas ações acontecem. Essas operações incluem:

  - **operações aritméticas como adição, subtração, multiplicação, divisão e outras**. Além disso, `__add__()` é chamado, `__sub__()` para subtração, `__mul__()` para multiplicação e `__truediv__()` para divisão.
        
  - **operações de string como concatenação, repetição, formatação e conversão para texto**. `__add__()` é chamado para concatenação, `__mul__()` para repetição, `__format__()` para formatação, `__str__()` e `__repr__()` para conversão para texto e assim por diante.
        
  - **operações de comparação como igualdade, menor que, maior que e outras**. `__eq__()` é chamado para verificações de igualdade, `__lt__()` para menor que, `__gt__()` para maior que e assim por diante.
        
  - **operações de iteração como tornar um objeto iterável e avançar pelos itens**. `__iter__()` é chamado para retornar um iterador e `__next__()` para buscar o próximo item.

## Exemplo do Mundo Real: Carrinho de Compras

- **Classe Cart com Métodos Dunder**: Permite adicionar, remover, iterar e verificar conteúdos com comportamento embutido.

```python
class Cart:
    def __init__(self):
        self.items = []

    def add(self, item):
        self.items.append(item)

    def remove(self, item):
        if item in self.items:
            self.items.remove(item)
        else:
            print(f'{item} is not in cart')

    def list_items(self):
        return self.items

    def __len__(self):
        return len(self.items)

    def __getitem__(self, index):
        return self.items[index]

    def __contains__(self, item):
        return item in self.items

    def __iter__(self):
        return iter(self.items)

cart = Cart()
cart.add('Laptop')
print(len(cart))        # 1
print('Laptop' in cart) # True
```

## O que é Programação Orientada a Objetos?

- **Programação orientada a objetos**: Um estilo de programação no qual os desenvolvedores tratam tudo no seu código como um objeto do mundo real. É popularmente chamada de OOP. Os quatro princípios-chave que ajudam você a organizar e gerenciar o código de forma eficaz são **encapsulamento**, **herança**, **polimorfismo** e **abstração**
- **Classes**: O modelo para criar objetos. Cada objeto criado a partir de uma classe possui atributos que definem dados e métodos que determinam os comportamentos dos objetos.

## O que é Encapsulamento?

- **Encapsulamento**: A agregação dos atributos e métodos de um objeto em uma única unidade. Isso permite ocultar o estado interno do objeto atrás de um conjunto simples de métodos e atributos públicos que funcionam como portas. Por trás dessas portas estão atributos e métodos privados que controlam como os dados mudam e quem pode vê-los.
- **Exemplo de Encapsulamento**: Se você quiser acompanhar o saldo da carteira, permitirá depósito e saque, mas não desejará que ninguém altere o próprio saldo da carteira:

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

- **Diferença Entre Prefixar Atributos com Underscore Simples e Duplo**: Prefixar atributos e métodos com um underscore simples significa que eles são destinados para uso interno. Isso é uma convenção e não impede o acesso aos atributos de fora. Prefixar atributos e métodos com um underscore duplo efetivamente impede que eles sejam acessados de fora da sua classe.

## O que são Getters e Setters?

- **Getters e Setters**: Métodos que permitem controlar como os atributos de uma classe são acessados e modificados. Você recupera valores com getters e define valores com setters.
- **Propriedades**: Elas conectam getters e setters e permitem o acesso a dados. Elas executam lógica extra nos bastidores quando você obtém, define ou exclui valores.
- **Por que Propriedades em vez de Métodos**: Propriedades são usadas em vez de métodos para melhor legibilidade e código mais limpo. Elas permitem que você acesse valores com notação de ponto, como atributos regulares, sem parênteses.
- **Criando um Getter**: Para criar um getter, você usa o decorador `@property`. Aqui está um getter que obtém o raio de um círculo:

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

- **Criando um Setter**: Para criar o setter que definirá o raio, você precisa definir outro método com o mesmo nome e usar `@<property_name>.setter` acima dele:

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

- **Como o Python Lida com Getters e Setters**: Depois que você define getters e setters, o Python os chama automaticamente nos bastidores sempre que você usa a sintaxe normal de atributo desta forma:

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

 Ao definir um valor, você não deve atribuir ao próprio nome da propriedade porque isso causará um `RecursionError`. Use um nome interno separado, frequentemente com um underscore, para armazenar o valor.

- **Deleter**: Depois de definir e obter um valor com setter e getter, você pode controlar como ele é deletado com um `deleter`. Um deleter executa uma lógica personalizada quando você usa a instrução `del` em uma propriedade. Para criar um deleter, você usa o decorador `@<property_name>.deleter`.

```py
  # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

## O que é Herança e Como Ela Promove a Reutilização de Código?

- **Herança**: O processo pelo qual uma classe filha usa os atributos e métodos de uma classe pai. A herança promove a reutilização de código, fornece hierarquias claras e personaliza o comportamento sem reescrever tudo. Para implementar a herança, uma classe filha recebe o nome de uma classe pai:

```py
class Parent:
    # Parent attributes and methods

class Child(Parent):
    # Child inherits, extends, and/or overrides where necessary
```

- **Herança Simples e Múltipla**: Quando uma classe filha herda propriedades e métodos de um único pai, como você pode ver acima, o processo é chamado de **herança simples**. Quando uma classe filha herda propriedades e métodos de mais de um pai, isso é **herança múltipla**. Aqui está a sintaxe para isso:

```py
class Parent:
    # Attributes and methods for Parent

class Child:
    # Attributes and methods for Child

class GrandChild(Parent, Child):
    # GrandChild inherits from both Parent and Child
    # GrandChild can combine or override behavior from each
```

- **Função `super()`**: Uma função que permite sobrescrever um método de uma classe pai dentro de uma classe filha.

## O que é Polimorfismo e Como Ele Promove a Reutilização de Código?

- **Polimorfismo**: O princípio da POO que permite que diferentes classes usem o mesmo nome de método, mas cada classe o implemente de forma diferente quando chamado. Aqui está a sintaxe para isso:

```py
class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # Works for A, B, or C
```

- **Polimorfismo baseado em herança**: Um pai configura um método e cada classe filha o adapta para seu uso.

## O que é Name Mangling e Como Ele Funciona?

- **Name Mangling**: Um processo no qual o Python renomeia internamente um atributo prefixado com dois underscores adicionando um underscore e o nome da classe como prefixo, transformando `__attribute` em `_ClassName__attribute`.
- **O Propósito do Name Mangling**: O principal propósito do name mangling é prevenir a sobrescrição acidental de atributos e métodos quando você usa herança. Aqui está um código que torna isso mais compreensível:

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

## O que é Abstração e Como Ela Ajuda a Manter Sistemas Complexos Organizados?

- **Abstração**: Um conceito de programação no qual detalhes complexos de implementação de um objeto ou sistema são ocultados e apenas as funcionalidades essenciais são mostradas. Em Python e outras linguagens de programação, a abstração simplifica sistemas complexos aumentando a reutilização.
- **Exemplo de Abstração**: Um bom exemplo de abstração no dia a dia é um carro que permite que você use apenas o volante, os pedais e o câmbio sem saber como o `engine` ou os `brakes` funcionam.
- **Como o Python Implementa Abstração**: Python implementa abstração através do módulo `abc`. O módulo fornece a classe `ABC` (abstract base class) e o decorador `@abstractmethod`. Uma abstract base class (ABC) define os métodos e propriedades comuns que as subclasses devem implementar. Ela não pode ser instanciada.
- **Como o Método Abstrato é Definido**: Um método abstrato é definido com `@abstractmethod` e deve ser sobrescrito nas subclasses, mesmo que tenha uma implementação padrão. A sintaxe básica da abstração é assim:

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

## Algoritmos e Notação Big O

- **Algoritmos**: Um conjunto de instruções inequívocas para resolver um problema ou executar uma tarefa. Algoritmos devem terminar em um número finito de etapas e cada etapa deve ser precisa e inequívoca.

- **Notação Big O**: Descreve o desempenho no pior caso, ou taxa de crescimento, de um algoritmo conforme o tamanho da entrada aumenta. Ela foca em como o uso de recursos cresce com o tamanho da entrada, ignorando fatores constantes e termos de ordem inferior.

### Complexidades de Tempo Comuns

- **O(1) - Tempo Constante**: O algoritmo leva a mesma quantidade de tempo independentemente do tamanho da entrada.

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

- **O(log n) - Tempo Logarítmico**: O tempo aumenta lentamente conforme a entrada cresce. Comum em algoritmos que reduzem repetidamente o tamanho do problema por uma fração (como `Binary Search`).

- **O(n) - Tempo Linear**: O tempo de execução aumenta proporcionalmente ao tamanho da entrada.

```python
for grade in grades:
    print(grade)
```

- **O(n log n) - Tempo Log-Linear**: Complexidade de tempo comum de algoritmos de ordenação eficientes como Merge Sort e Quick Sort.

- **O(n²) - Tempo Quadrático**: O tempo de execução aumenta quadraticamente. Frequentemente visto em loops aninhados.

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

### Complexidade de Espaço

- **O(1) - Espaço Constante**: Algoritmo usa a mesma quantidade de memória independentemente do tamanho da entrada.
- **O(n) - Espaço Linear**: O uso de memória cresce proporcionalmente ao tamanho da entrada.
- **O(n²) - Espaço Quadrático**: O uso de memória cresce quadraticamente com o tamanho da entrada.

## Técnicas de Resolução de Problemas

- **Entendendo o Problema**: Leia a declaração do problema várias vezes. Identifique a entrada, a saída esperada e como transformar a entrada na saída.

- **Pseudocódigo**: Descrição em alto nível da lógica do algoritmo que é independente de linguagem. Usa linguagem escrita comum misturada com construções de programação como `IF`, `ELSE`, `FOR` e `WHILE`.

```md
GET original_string
SET reversed_string = ""
FOR EACH character IN original_string:
  ADD character TO THE BEGINNING OF reversed_string
DISPLAY reversed_string
```

- **Casos de Borda**: Entradas específicas e válidas que ocorrem nos limites do que um algoritmo deve tratar. Sempre considere e teste casos de borda.

## Arrays

- **Arrays Estáticos**: Têm um tamanho fixo determinado na inicialização. Elementos armazenados em locais de memória adjacentes. O tamanho não pode ser alterado durante a execução do programa.

- **Arrays Dinâmicos**: Podem crescer ou encolher automaticamente durante a execução do programa. Gerencie o redimensionamento por meio da cópia automática para arrays maiores quando necessário.

### Listas Python (Arrays Dinâmicos)

```python
numbers = [3, 4, 5, 6]

# Access elements
numbers[0]  # 3

# Update elements
numbers[2] = 16

# Add elements
numbers.append(7)
numbers.insert(3, 15)  # Insert at specific index

# Remove elements
numbers.pop(2)  # Remove at specific index
numbers.pop()   # Remove last element
```

### Complexidades de Tempo para Arrays Dinâmicos

- **Acesso**: O(1)
- **Inserir no final**: O(1) em média, O(n) quando for necessário redimensionar
- **Inserir no meio**: O(n)
- **Delete**: O(n) para meio, O(1) para fim

## Pilhas

- **Pilhas**: estrutura de dados Last-In, First-Out (LIFO). Elementos adicionados e removidos apenas do topo.

- **Operação Push**: Adicionando um elemento ao topo da pilha. Complexidade de tempo: O(1).

- **Operação Pop**: Removendo um elemento do topo da pilha. Complexidade de tempo: O(1).

```python
# Using Python list as stack
stack = []

# Push operations
stack.append(1)
stack.append(2)
stack.append(3)

# Pop operations
top_element = stack.pop()  # Returns 3
```

## Filas

- **Filas**: estrutura de dados First-In, First-Out (FIFO). Elementos adicionados na parte de trás e removidos da frente.

- **Operação Enqueue**: Adicionando um elemento ao final da fila. Complexidade de tempo: O(1).

- **Operação Dequeue**: Removendo um elemento da frente da fila. Complexidade de tempo: O(1).

```python
from collections import deque

# Using deque for efficient queue operations
queue = deque()

# Enqueue operations
queue.append(1)
queue.append(2)
queue.append(3)

# Dequeue operations
first_element = queue.popleft()  # Returns 1
```

## Listas Ligadas

- **Listas Ligadas**: Estrutura de dados linear onde cada nó contém dados e uma referência para o próximo nó. Os nós estão conectados como uma corrente.

### Listas Ligadas Simples

- **Estrutura**: Cada nó possui dados e uma referência para o próximo nó.
- **Travessia**: Só pode mover-se para frente da cabeça até a cauda.
- **Head Node**: Primeiro nó na lista, geralmente o único nó acessível diretamente.
- **Nó Final**: Último nó na lista, aponta para `None`.

### Operações e Complexidades de Tempo

- **Inserir no início**: O(1)
- **Inserir no final**: O(n) - deve percorrer até o final
- **Inserir no meio**: O(n) - deve percorrer até a posição
- **Excluir do início**: O(1)
- **Excluir do final**: O(n) - é necessário percorrer para encontrar o nó anterior
- **Excluir do meio**: O(n) - é necessário percorrer para encontrar o nó

### Listas Duplamente Ligadas

- **Estrutura**: Cada nó possui dados e duas referências: próximo nó e nó anterior.
- **Travessia**: Pode se mover em ambas as direções.
- **Memória**: Requer mais memória do que listas simplesmente encadeadas devido à referência extra.

## Hash Maps e Sets

### Mapas e Hash Maps

- **Map (Abstract Data Type)**: Gerencia coleções de pares chave-valor. Cada chave deve ser única, mas os valores podem ser repetidos.

- **Hash Map**: Implementação concreta do ADT map usando técnica de hashing. Usa função hash para gerar valores hash para as chaves, que determinam o local de armazenamento no array subjacente.

### Dicionários Python (Hash Maps)

```python
# Creating dictionaries
my_dictionary = {
    "A": 1,
    "B": 2, 
    "C": 3
}

# Alternative creation
my_dictionary = dict(A=1, B=2, C=3)

# Access and modify
value = my_dictionary["A"]  # 1
my_dictionary["A"] = 4      # Update value
del my_dictionary["A"]      # Remove key-value pair

# Check membership
"C" in my_dictionary

# Get keys, values, items
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

### Complexidades de Tempo para Hash Maps

- **Caso médio**: O(1) para insert, get, delete
- **Pior caso**: O(n) quando muitas colisões de hash ocorrem

### Conjuntos

- **Conjuntos**: Coleções não ordenadas de elementos únicos. Não são permitidos duplicados e nenhuma ordem específica é mantida.

- **Apenas Elementos Imutáveis**: Conjuntos só podem conter tipos de dados imutáveis (números, strings, tuplas) porque os valores de hash devem permanecer constantes.

```python
# Creating sets
numbers = {1, 2, 3, 4}
empty_set = set()  # Must use set(), not {}

# Add and remove elements
numbers.add(5)
numbers.remove(4)      # Raises KeyError if not found
numbers.discard(4)     # No error if not found

# Set operations
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

# Union, intersection, difference, symmetric difference
set_a.union(set_b)                    # or set_a | set_b
set_a.intersection(set_b)             # or set_a & set_b
set_a.difference(set_b)               # or set_a - set_b
set_a.symmetric_difference(set_b)     # or set_a ^ set_b

# Subset and superset checks
set_a.issubset(set_b)
set_a.issuperset(set_b)
set_a.isdisjoint(set_b)

# Membership testing
5 in numbers
```

### Complexidades de Tempo para Conjuntos

- **Caso médio**: O(1) para add, remove e membership testing
- **Pior caso**: O(n) devido a colisões de hash

## Colisões de Hash

- **Colisão de Hash**: Ocorre quando duas chaves diferentes produzem o mesmo valor de hash.

- **Estratégias de Resolução de Colisões**:
  - **Encadeamento**: Cada índice do array aponta para uma lista encadeada que armazena todos os elementos com o mesmo valor de hash
  - **Open Addressing**: Procure pelo próximo índice disponível usando uma sequência predefinida

## Quando Usar Cada Estrutura de Dados

- **Listas**: Quando você precisa de acesso ordenado, indexado e não sabe o tamanho antecipadamente
- **Pilhas**: Para operações LIFO (funcionalidade de desfazer, avaliação de expressões, retrocesso)
- **Filas**: Para operações FIFO (agendamento de tarefas, busca em largura)
- **Listas Ligadas**: Quando inserções/remoções frequentes no início, tamanho desconhecido, sem necessidade de acesso aleatório
- **Hash Maps**: Para buscas rápidas de chave-valor, contagem de ocorrências e cache
- **Conjuntos**: Para verificação de unicidade, operações matemáticas de conjunto, remoção de duplicatas

## Algoritmos de Busca

Algoritmos de busca permitem que você procure um alvo dentro de uma determinada lista de itens.

Em ciência da computação, existem dois algoritmos de busca que você deve conhecer. Eles são algoritmos de **busca linear** e **busca binária**. É importante entender as diferenças entre os dois algoritmos e quando usar cada um.

### Busca Linear

- A busca linear itera por uma lista de itens, verificando cada item desde o início até que o item alvo seja encontrado.
- Se o item alvo for encontrado, o índice onde ele está localizado na lista é retornado.
- Se o alvo não for encontrado, ele retorna `-1`, o que significa **índice inválido** na maioria das linguagens de programação.
- Porque a busca linear verifica cada item até encontrar o alvo, ela não é eficiente para uma lista grande de itens.
- A complexidade de tempo da busca linear é `O(n)` porque o tempo que leva para percorrer a lista cresce linearmente com o tamanho da lista.
- A complexidade de espaço da busca linear é `O(1)` porque não requer espaço adicional para percorrer a lista.

### Busca Binária

- A busca binária funciona dividindo uma lista de itens ao meio e verificando se o valor alvo está no meio da lista.
- A condição para que a busca binária funcione é que os itens na lista estejam em ordem crescente.
- A busca binária é um algoritmo mais eficiente para pesquisar em uma grande lista de itens porque divide a lista de itens ao meio e ignora qualquer metade onde o alvo não é encontrado.
- Se o item alvo for encontrado no meio da lista, o índice do item alvo é retornado.
- Se o item não for encontrado, o algoritmo verifica se o item alvo está na metade esquerda ou direita da lista.
- Ele continua a dividir as partes restantes da lista em metades até que o item alvo seja encontrado.
- Se o item alvo finalmente não for encontrado na lista, ele retorna `-1`
- A complexidade de tempo da busca binária é `O(log n)` porque o tempo que leva para buscar na lista cresce logaritmicamente com o tamanho da lista.
- A complexidade de espaço da busca binária é `O(1)` porque não requer espaço adicional para percorrer a lista.

### Como a Busca Linear Difere da Busca Binária

- A busca binária é mais adequada para uma lista grande de itens em comparação com a busca linear.
- A complexidade de tempo da busca linear é `O(n)` porque o tempo que leva para percorrer a lista cresce linearmente com o tamanho da lista.
- A complexidade de tempo da busca binária é `O(log n)` porque o tempo que leva para buscar na lista cresce logaritmicamente com o tamanho da lista.

## Algoritmos de Ordenação e Dividir-e-Conquistar

Em ciência da computação, divide-and-conquer é uma técnica usada para dividir um problema em subproblemas menores para que sejam mais fáceis de resolver. Recursão é a técnica frequentemente empregada em divide-and-conquer e divide-and-conquer é uma estratégia poderosa usada para implementar muitos algoritmos de ordenação eficientes como merge sort.

### Ordenação por Merge

- Merge sort é um algoritmo de ordenação que segue a abordagem de dividir e conquistar.
- Funciona dividindo recursivamente uma lista em sublistas menores até que cada sublista contenha apenas um elemento.
- Em seguida, ele mescla repetidamente as sublistas de volta em uma ordem ordenada.
- A complexidade de tempo do merge sort é `O(n log n)` porque a lista é continuamente dividida ao meio `(log n)` e depois mesclada `(O(n))`.
- A complexidade de espaço do merge sort é `O(n)` porque ele não é um algoritmo de ordenação in-place.

## Visão Geral dos Grafos

Um grafo é um conjunto de nós (vértices) conectados por arestas (conexões). Cada nó pode se conectar a vários outros nós, formando uma rede. Os diferentes tipos de grafos incluem:

- Direcionado: as arestas têm uma direção (de um nó para outro), frequentemente representadas com linhas retas e setas.
- Não direcionado: as arestas não têm direção, representadas por linhas simples.
- Vértice: cada nó está associado a um rótulo ou identificador.
- Cíclico: contém ciclos (um caminho que começa e termina no mesmo nó).
- Acilíclico (DAG): não contém ciclos.
- Aresta rotulada: cada aresta tem um rótulo geralmente desenhado próximo à aresta correspondente.
- Ponderado: as arestas têm pesos (valores) associados a elas, que podem ser usados para realizar operações aritméticas. 
- Desconectado: contém dois ou mais nós que não estão conectados por nenhuma aresta.

Grafos são usados em várias aplicações como mapas, redes, sistemas de recomendação e resolução de dependências.

## Percursos em Grafos

Isso envolve visitar todos os nós em um grafo. Os dois principais algoritmos são:

- **Busca em Largura (BFS)**
  - Usa uma fila.
  - Explora nível por nível.
  - Encontra o caminho mais curto em grafos não ponderados.

- **Busca em Profundidade (DFS)**
  - Usa uma pilha (ou recursão).
  - Explora completamente um branch antes de retroceder.
  - Útil para detecção de ciclos e busca de caminhos.

## Representações de Grafos

Grafos podem ser representados de duas maneiras principais:

- **Lista de Adjacência**
  - Cada nó tem uma lista de seus vizinhos.
  - Eficiente em espaço para grafos esparsos.
  - Fácil de iterar sobre vizinhos.

- **Matriz de Adjacência**
  - Um array 2D onde linhas e colunas representam nós.
  - Intensivo em espaço para grafos grandes.
  - Rápido para verificar se existe uma aresta entre dois nós.

## Árvores

Uma árvore é um tipo especial de grafo que é acíclico e conectado. Propriedades principais incluem:

- Eles não têm loops ou ciclos (caminhos onde os nós inicial e final são os mesmos).
- Eles devem estar conectados (cada nó pode ser alcançado a partir de qualquer outro nó).

### Tipos comuns de árvores

Os tipos mais comuns de árvores são:

- Árvores Binárias
  - Cada nó tem no máximo dois filhos, um filho esquerdo e um filho direito.

- Árvores de Busca Binária (BST)
  - Uma árvore binária na qual todo filho à esquerda é menor que seu pai e todo filho à direita é maior que seu pai.  


## Tentativas

Também conhecidos como árvores de prefixo, eles são usados para armazenar conjuntos de strings, onde cada nó representa um caractere.

Prefixos compartilhados são armazenados apenas uma vez, tornando-os eficientes para tarefas como autocomplete e verificação ortográfica.

Operações de busca e inserção têm complexidade de tempo O(L), onde L é o comprimento da string.

## Filas de Prioridade

Uma fila de prioridade é um tipo abstrato de dado onde cada elemento tem uma prioridade.

Filas e pilhas consideram apenas a ordem de inserção, enquanto filas de prioridade consideram a prioridade dos elementos. 

Filas padrão seguem FIFO (First In First Out) e pilhas seguem LIFO (Last In First Out). No entanto, em uma fila de prioridade, elementos com maior prioridade são atendidos antes daqueles com menor prioridade, independentemente da ordem de inserção.

## Heaps

É uma estrutura de dados especializada baseada em árvore com uma propriedade muito específica chamada heap property. 

A propriedade heap determina a relação entre os nós pai e filho. Existem dois tipos de heaps:

- Max-Heap
  - O valor de cada nó pai é maior ou igual aos valores de seus filhos.
  - O maior elemento está na raiz.

- Min-Heap
  - O valor de cada nó pai é menor ou igual aos valores de seus filhos.
  - O menor elemento está na raiz.

### Exemplo do módulo Python `heap`

```py
import heapq

# Create empty heap
my_heap = []

# Insert elements
heapq.heappush(my_heap, 9)
heapq.heappush(my_heap, 3)
heapq.heappush(my_heap, 5)

# Remove smallest element
print(heapq.heappop(my_heap))  # 3

# Push + Pop in one step
print(heapq.heappushpop(my_heap, 2)) # 2

# Transform list into heap
nums = [5, 7, 3, 1]
heapq.heapify(nums)
```

### Usando Prioridades

```py
my_heap = []
heapq.heappush(my_heap, (3, "A"))
heapq.heappush(my_heap, (2, "B"))
heapq.heappush(my_heap, (1, "C"))

# Removes lowest number = highest priority
print(heapq.heappop(my_heap))  # (1, "C")
```

## Introdução à Programação Dinâmica

- **Definição**: Programação dinâmica é uma técnica algorítmica que resolve problemas complexos dividindo-os em subproblemas mais simples e armazenando os resultados para evitar cálculos redundantes. 
- **Subproblemas Sobrepostos**: Os mesmos problemas menores aparecem várias vezes ao resolver o problema maior. Em vez de recalcular esses subproblemas repetidamente, armazenamos suas soluções.
- **Subestrutura Ótima**: A solução ótima para o problema contém soluções ótimas para seus subproblemas. Isso significa que podemos construir a melhor solução combinando as melhores soluções para partes menores.

## Soluções de Programação Dinâmica

- **Memoização (Abordagem de Cima para Baixo)**: A memoização armazena os resultados de chamadas de função custosas e retorna o resultado em cache quando as mesmas entradas ocorrem novamente. 

```py
def climb_stairs_memo(n, memo={}):
    """Dynamic programming with memoization"""
    # Check if we've already calculated this value
    if n in memo:
        return memo[n]  # Return cached result - O(1) lookup!
    
    # Base cases
    if n <= 2:
        return n
    
    # Calculate once and store in memo for future use
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    return memo[n]
```

- **Tabulação (Abordagem Bottom-Up)**: A tabulação constrói a solução de baixo para cima, preenchendo uma tabela com soluções para subproblemas.

```py
def climb_stairs_tabulation(n):
    """Dynamic programming with tabulation"""
    if n <= 2:
        return n
    
    # Create array to store results for all steps from 0 to n
    dp = [0] * (n + 1)
    dp[1] = 1  # 1 way to reach step 1
    dp[2] = 2  # 2 ways to reach step 2
    
    # Build up the solution iteratively
    for i in range(3, n + 1):
        # Ways to reach step i = ways to reach (i-1) + ways to reach (i-2)
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

## Aplicações do Mundo Real Usando Programação Dinâmica

- **Otimização de Rotas**: sistemas de GPS usam algoritmos de programação dinâmica para encontrar os caminhos mais curtos entre os locais.
- **Processamento de Texto**: Verificadores ortográficos e recursos de autocompletar frequentemente dependem de programação dinâmica para calcular distâncias de edição entre palavras.
- **Modelagem Financeira**: Estratégias de investimento e otimização de portfólio frequentemente empregam técnicas de programação dinâmica.
- **Alocação de Recursos**: O problema da mochila e suas variantes aparecem em agendamento, orçamento e gerenciamento de recursos.

## Quando Usar Programação Dinâmica

Você deve considerar usar programação dinâmica nos seguintes cenários:

- O problema pode ser dividido em subproblemas sobrepostos.
- O problema apresenta subestrutura ótima.
- Uma solução recursiva ingênua envolveria cálculos repetidos.
- Você precisa otimizar para complexidade de tempo ao custo da complexidade de espaço.

# --assignment--

Revise os tópicos e conceitos de Python.
