---
id: 67e2a4cab99d4e8bc795e99d
title: 什么是 useActionState Hook，它是如何工作的？
challengeType: 19
dashedName: what-is-the-useactionstate-hook-and-how-does-it-work
---

# --description--

React 19 带来了两个显著的新特色，称为服务器组件和服务器调用。 

从该版本开始，服务器组件成为像 Next.js 这样能够轻松支持它们的框架中的默认选项。

另一方面，服务器操作是运行在服务器上的函数，允许直接在服务器上处理形式，而无需 API 端点。

服务器操作看起来像这样： 

```js
"use server";

async function submitForm(formData) {
  const name = formData.get("name");
  return { message: `Hello, ${name}!` };
}
```

此服务器操作从表单中提取 `name` 字段并返回一个问候该名称的字串。

为了简化服务器操作的状态管理并消除简单形式对客户端 JavaScript 的需求，React 团队在 19 版本中引入了 `useActionState` 钩子。

让我们仔细看看这个 hook 并了解它是如何工作的。

React 文档将 `useActionState` 钩子描述为一个“允许你根据表单操作的结果更新状态”的钩子。

但这并不意味着你只能将 `useActionState` 钩子用于形式。只要你有相应的动作，也可以用它来管理按钮点击和其他事件。

请记住，由于 `useActionState` 是一个 hook，你不能在服务器组件内使用它。

这是 `useActionState` 钩子的基本语法：

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` 是动作返回的当前状态。

- `action` 是触发服务器操作的函数。

- `isPending` 是一个布尔值，表示该操作当前是否正在运行。

- `actionFunction` 参数就是服务器操作本身。

- `initialState` 是表现动作运行前状态起点的参数。

- `permalink` 是一个可选的字串，包含该形式修改的唯一页面链接。

要使用 `useActionState` 钩子，首先确保你已有一个动作。让我们使用前面示例中的动作，并稍作修改：

```js
"use server";

export async function submitForm(_, formData) {
  const name = formData.get("name");

  const hour = new Date().getHours();
  let greeting;

  if (hour < 12) {
    greeting = "Good morning";
  } else if (hour < 18) {
    greeting = "Good afternoon";
  } else {
    greeting = "Good evening";
  }

  return { message: `${greeting}, ${name}` };
}
```

在你的组件中，你需要导入 `useActionState` 钩子并在组件体的顶层（在 `return` 语句之前）调用它，就像其他钩子一样。你还应该导入该动作：

```jsx
"use client";

// Import the useActionState hook
import { useActionState } from "react";

// Import the submitForm action
import { submitForm } from "./actions/submitForm";

const Greeter = () => {

 // Initialize the hook
 const [state, submit, isPending] = useActionState(submitForm, {
   message: "",
 });

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6">
      {/* Rest of component */}
    </div>
  );
};

export default Greeter;
```

完整的代码加上一点样式如下：

```jsx
"use client";

import { useActionState } from "react";
import { submitForm } from "./actions/submitForm";

const Greeter = () => {
  const [state, submit, isPending] = useActionState(submitForm, {
    message: "",
  });

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6">
      <form
        action={submit}
        className="bg-white p-6 rounded-2xl shadow-md w-full max-w-md"
      >
        <h2 className="text-2xl text-center font-semibold text-gray-700 mb-4">
          Greet Someone
        </h2>

        <input
          type="text"
          name="name"
          placeholder="Enter your name"
          required
          className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-400"
        />

        <button
          type="submit"
          disabled={isPending}
          className="w-full mt-4 p-3 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 disabled:bg-gray-400 transition-all"
        >
          {isPending ? "Greeting..." : "Greet"}
        </button>

        {state.message && (
          <p className="mt-4 text-green-600 text-center font-medium">
            {state.message}
          </p>
        )}
      </form>
    </div>
  );
};

export default Greeter;
```

在浏览器中，当动作 `isPending` 时，你会看到你的表单按钮从 `Greet` 变为 `Greeting...` ——问候语会显示为 `Good morning, {name}`、`Good afternoon, {name}` 或 `Good evening, {name}`，具体取决于表单提交的时间。

还记得我们提到过你也可以在 `form` 外使用 `useActionState` 钩子吗？

在此示例中，我们将通过点击按钮从 JSONPlaceholder 获取五个用户：

```js
"use server";

export async function getUsers() {
  const res = await fetch(
    "https://jsonplaceholder.typicode.com/users?_start=0&_limit=5/"
  );
  return await res.json();
}
```

这是样式化的 UI：

```jsx
"use client";

import { useActionState } from "react";
import { getUsers } from "./actions/getUsers";

export default function FetchUsers() {
  const [users, fetchAction, isPending] = useActionState(getUsers, []);

  return (
    <div className="p-6 max-w-lg mx-auto">
      <button
        onClick={fetchAction}
        disabled={isPending}
        className="px-4 py-2 cursor-pointer bg-green-500 text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400 font-bold"
      >
        {isPending ? "Fetching Users..." : "Fetch Users"}
      </button>

      <ul className="mt-4 space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-3 bg-gray-100 rounded-lg">
            <p className="font-semibold">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

在浏览器中，你会看到按钮文本在点击后从未更新为 `Fetching Users...`。

这是因为 React 将数据获取和渲染视为比 `isPending` 状态更高的优先级，这会在进程中锁定 `isPending` 并抛出误差。

要解决此问题，你需要将操作包裹在 `startTransition` 中：

```jsx
"use client";

// import startTransition from React
import { useActionState, startTransition } from "react";
import { getUsers } from "./actions/getUsers";

export default function FetchUsers() {
  const [users, fetchAction, isPending] = useActionState(getUsers, []);

  return (
    <div className="p-6 max-w-lg mx-auto">
      <button
        {/* wrap fetchAction in startTransition */}
        onClick={() => startTransition(() => fetchAction())}
        disabled={isPending}
        className="px-4 py-2 bg-green-500 font-bold cursor-pointer text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400"
      >
        {isPending ? 'Fetching Users...' : 'Fetch Users'}
      </button>

      <ul className="mt-4 space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-3 bg-gray-100 rounded-lg">
            <p className="font-semibold">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

如果你想知道 `startTransition` 是什么，它是一个告诉 React 状态更新是低优先级且可以中止的函数。这在处理像服务器操作这样的异步更新时保持了 UI 的响应性。

这就是如何在表单内外使用 `useActionState` 钩子。

# --questions--

## --text--

`useActionState` 钩子在 React 中的目的是什么？

## --answers--

它根据操作的结果管理状态，包括表单提交、按钮点击和其他基于事件的更新。

---

它仅在表单提交时更新状态，不支持按钮点击或自定义事件处理器等其他类型的操作。

### --feedback--

它适用于动作，而不仅仅是形式。

---

它处理跨多个组件的全局状态管理，作为 Redux 或 Zustand 等状态管理库的替代方案。

### --feedback--

它适用于动作，而不仅仅是形式。

---

它完全取代了 `useState` 钩子，提供了一种内置方式来管理局部和全局状态，无需额外依赖。

### --feedback--

它适用于动作，而不仅仅是形式。

## --video-solution--

1

## --text--

为什么你不能在服务器组件内使用 `useActionState` 钩子？

## --answers--

因为服务器组件不支持状态管理，导致 `useActionState` 不兼容。

### --feedback--

Hooks 仅在特定类型的组件中工作。

---

因为 `useActionState` 需要数据库连接，而数据库连接仅在客户组件中可用。

### --feedback--

Hooks 仅在特定类型的组件中工作。

---

因为 `useActionState` 是一个 React hook，且 hook 只能在客户组件内部使用。

---

因为 `useActionState` 依赖于服务器上不可用的浏览器 API。

### --feedback--

Hooks 仅在特定类型的组件中工作。

## --video-solution--

3

## --text--

哪个版本的 React 引入了服务器组件和服务器操作？

## --answers--

React 17

### --feedback--

此版本专注于改进服务器端渲染。

---

React 18

### --feedback--

此版本专注于改进服务器端渲染。

---

React 19

---

React 16

### --feedback--

此版本专注于改进服务器端渲染。

## --video-solution--

3
