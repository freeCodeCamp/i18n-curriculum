---
id: 64df3f1011888113fbd3d81b
title: 步骤 44
challengeType: 20
dashedName: step-44
---

# --description--

要用递归解决难题，首先要做的就是将原始问题分解为更小的子问题。

通过移动可以获得最终配置，其中 `n` 个圆盘按降序堆叠到第三根杆：

- `n - 1` 个圆盘从源到辅助杆
- 从源到目标的最大圆盘
- 然后将 `n - 1` 个圆盘从辅助杆移到目标。

因此，`move` 函数应该做的第一件事就是以 `n - 1` 作为第一个参数调用自身。 但是如果你尝试这样做而不定义基本情况，那么你将得到 `RecursionError`。 发生这种情况是因为该函数不断无限地调用自身。

在你的注释和 `print()` 调用之前，添加以 `n - 1` 作为第一个参数的递归函数调用，并确保仅当 `n` 大于零时才执行函数体。 现在，保持其他参数的顺序不变。

# --hints--

`move` 函数主体应以 `if` 语句开头，该语句在 `n` 大于零时触发。

```js
({ test: () => assert.match(code, /def\s+move\(\s*n\s*,\s*source\s*,\s*auxiliary\s*,\s*target\s*\)\s*:\s+if\s+n\s*>\s*0\s*:/) })
```

你应该在 `if` 语句内调用 `move(n - 1, source, auxiliary, target)`。 记得缩进你的 `print()` 调用。

```js
const transformedCode = "\n" + code.replace(/\r/g, '');
const move = __helpers.python.getDef(transformedCode, "move");
const { function_parameters, function_body } = move;

assert.match(function_parameters, /n\s*,\s*source\s*,\s*auxiliary\s*,\s*target/);
const functionBodyIndent = function_body.match(/ +/)[0];
const re = new RegExp(`${functionBodyIndent}if\\s+n\\s*>\\s*0\\s*:\\s+^${functionBodyIndent}( +)move\\(\\s*n\\s*-\\s*1\\s*,\\s*source\\s*,\\s*auxiliary\\s*,\\s*target\\s*\\).+?^${functionBodyIndent}\\1print\\s*\\(\\s*rods\\s*,\\s*("|')\\\\n\\2\\s*\\)`, "ms");
assert.match(function_body, re);
```

# --seed--

## --seed-contents--

```py
NUMBER_OF_DISKS = 4
rods = {
    'A': list(range(NUMBER_OF_DISKS, 0, -1)),
    'B': [],
    'C': []
}

--fcc-editable-region--
def move(n, source, auxiliary, target):
    # display starting configuration
    print(rods, '\n')

--fcc-editable-region--
# initiate call from source A to target C with auxiliary B
move(NUMBER_OF_DISKS, 'A', 'B', 'C')
```
