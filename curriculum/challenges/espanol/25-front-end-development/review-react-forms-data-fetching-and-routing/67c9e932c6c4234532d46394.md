---
id: 67c9e932c6c4234532d46394
title: Revisión de Formularios, Obtención de Datos y Enrutamiento en React
challengeType: 24
dashedName: review-react-forms-data-fetching-and-routing
---

# --description--

## Trabajando con Formularios en React

- **Entradas Controladas**: Esto ocurre cuando almacenas el valor del campo de entrada en un estado y lo actualizas a través de eventos `onChange`. Esto te brinda un control completo sobre los datos del formulario y permite la validación instantánea y el renderizado condicional.

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form>
    </>
  );
}

export default App;
```

- **Entradas No Controladas**: En lugar de manejar las entradas mediante el gancho `useState`, las entradas no controladas en HTML mantienen su propio estado interno con la ayuda del DOM. Dado que el DOM controla los valores de entrada, necesitas obtener los valores de los campos de entrada con un `ref`.

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">Your</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">Submit</button>
   </form>
 );
}

export default App;
```

## Trabajando con el Gancho `useActionState`

- **Acciones del Servidor**: Estas son funciones que se ejecutan en el servidor para permitir el manejo de formularios directamente en el servidor sin necesidad de puntos finales de API. Aquí hay un ejemplo de una aplicación Next.js:

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `Hello, ${name}!` };
}
```

La directiva `"user server"` marca la función como una acción del servidor.

- **Gancho `useActionState`**: Este gancho actualiza el estado basado en el resultado de una presentación de formulario. Aquí está la sintaxis básica del gancho `useActionState`:

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` es el estado actual que la acción retorna.
- `action` es la función que desencadena la acción del servidor.
- `isPending` es un booleano que indica si la acción se está ejecutando actualmente o no.
- `actionFunction` parámetro es la propia acción del servidor.
- `initialState` es el parámetro que representa el punto de inicio para el estado antes de que la acción se ejecute.
- `permalink` es una cadena opcional que contiene la URL única de la página que el formulario modifica.

## Obtención de Datos en React

- **Opciones Para Obtener Datos**: Existen muchas formas diferentes de obtener datos en React. Puedes usar la API nativa Fetch, o herramientas de terceros como Axios o SWR.
- **Variables de Estado Comunes al Obtener Datos**: Independientemente de cómo elijas obtener tus datos en React, hay algunos fragmentos de estado que necesitarás rastrear. El primero es el propio dato. El segundo rastrea si los datos aún se están obteniendo. El tercero es una variable de estado que capturará cualquier error que pueda ocurrir durante el proceso de obtención de datos.

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

Dado que la obtención de datos es un efecto secundario, es mejor usar el `Fetch API` dentro de un gancho `useEffect`.

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");

      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Entonces puedes mostrar un mensaje de carga si la obtención de datos no está completa, un mensaje de error si hubo un error al obtener los datos o los resultados.

```jsx
if (loading) {
  return <p>Loading...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

Si deseas usar Axios, necesitas instalarlo e importarlo:

```bash
npm i axios
```

```js
import axios from "axios";
```

Entonces puedes obtener los datos usando `axios.get`:

```jsx
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Para obtener datos usando el gancho `useSWR`, primero debes instalarlo e importarlo.

```bash
npm i swr
```

```js
import useSWR from "swr";
```

Aquí está cómo puedes usar el gancho para obtener datos:

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>Loading...</h2>;
 }
 if (error) {
   return <h2>Error: {error.message}</h2>;
 }

 return (
   <>
     <h2>Todos</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## Trabajando con el Gancho `useOptimistic`

- **Gancho `useOptimistic`**: Este gancho se utiliza para mantener interfaces de usuario receptivas mientras se espera que una acción asincrónica se complete en segundo plano. Ayuda a gestionar "actualizaciones optimistas" en el UI, una estrategia en la que proporcionas actualizaciones inmediatas al UI basadas en el resultado esperado de una acción, como esperar una respuesta del servidor.

Aquí está la sintaxis básica:

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` es el estado temporal que se actualiza de inmediato para una mejor experiencia de usuario.
- `addOptimistic` es la función que aplica la actualización optimista antes de que cambie el estado real.
- `actualState` es el valor real del estado que resulta de una acción como obtener datos de un servidor.
- `updateFunction` es la función que determina cómo debería actualizarse el estado optimista cuando se llama.

Aquí hay un ejemplo de usar el gancho `useOptimistic` en un componente `TaskList`:

```jsx
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**: Esto se utiliza para renderizar parte del UI y marcar una actualización de estado como una transición no urgente. Esto permite que la interfaz de usuario sea receptiva durante actualizaciones costosas. Aquí está la sintaxis básica:

```js
startTransition(action);
```

La `action` realiza una actualización de estado o desencadena alguna lógica relacionada con la transición. Esto asegura que las actualizaciones urgentes de UI (como escribir o hacer clic) no se bloqueen.

## Trabajando con el Gancho `useMemo`

- **Memorización**: Esta es una técnica de optimización en la cual el resultado de llamadas a funciones costosas se almacenan en caché (recordados) basados en argumentos específicos. Cuando se proporcionan los mismos argumentos nuevamente, se devuelve el resultado en caché en lugar de volver a calcular la función.
- **Gancho `useMemo`**: Este gancho se usa para memorizar valores calculados. Aquí hay un ejemplo de memorizar el resultado de ordenar un arreglo grande. La función `expensiveSortFunction` solo se ejecutará cuando `largeArray` cambie:

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## Trabajando con el Gancho `useCallback`

- **Gancho `useCallback`**: Este se utiliza para memorizar referencias de funciones.

```js
const handleClick = useCallback(() => {
  // code goes here
}, [dependency]);
```

- **`React.memo`**: Esto se usa para memorizar un componente para evitar que se vuelva a rendereizar innecesariamente cuando su prop no ha cambiado.

```jsx
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* Presentation */}
   </>
 )
});
```

## Herramientas de Gestión de Dependencias

- **Definición de Dependencia**: En software, una dependencia es cuando un componente o módulo en una aplicación depende de otro para funcionar correctamente. Las dependencias son comunes en las aplicaciones de software porque permiten a los desarrolladores usar funciones o herramientas preconstruidas creadas por otros. Las dos dependencias principales necesarias para un proyecto de React serán los paquetes `react` y `react-dom`:

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **Definición del Administrador de Paquetes**: Para gestionar las dependencias de software en un proyecto, necesitarás usar un administrador de paquetes. Un administrador de paquetes es una herramienta utilizada para la instalación, actualizaciones y eliminación de dependencias. Muchos lenguajes de programación populares como JavaScript, Python, Ruby y Java, todos utilizan administradores de paquetes. Los administradores de paquetes populares para JavaScript incluyen npm, Yarn y pnpm.
- **Archivo `package.json`**: Este es un archivo clave de configuración en proyectos que contiene metadatos sobre tu proyecto, incluyendo su nombre, versión y dependencias. También define scripts, información de licencias y otras configuraciones que ayudan a gestionar el proyecto y sus dependencias.
- **Archivo `package-lock.json`**: Este archivo bloqueará las versiones exactas de todos los paquetes que tu proyecto está utilizando. Cuando actualices un paquete, las nuevas versiones también se actualizarán en el archivo de bloqueo.
- **Carpeta `node_modules`**: Esta carpeta contiene el código real para las dependencias listadas en tu archivo `package.json`, incluyendo tanto las dependencias directas de tu proyecto como las de esas dependencias.
- **Dependencias de Desarrollo**: Estos son paquetes que solo se usan para desarrollo y no en producción. Un ejemplo de esto sería una biblioteca de pruebas como Jest. Instalarías Jest como una dependencia de desarrollo porque se necesita para probar tu aplicación localmente, pero no para que la aplicación funcione en producción.

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **Introducción**: React Router es una biblioteca de terceros que te permite agregar enrutamiento a tus aplicaciones React. Para comenzar, necesitarás instalar React Router en un proyecto existente de React de esta manera:

```bash
npm i react-router
```

Luego, dentro del archivo `main.jsx` o `index.jsx`, deberás configurar la estructura de rutas de esta manera:

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

El `path` y `element` se utilizan para unir el URL y los componentes de la UI. En este caso, estamos configurando una ruta para la página de inicio que apunta al componente `App`.

- **Configuración de Vistas Múltiples y Rutas**: Es común en aplicaciones más grandes tener configuradas múltiples vistas y rutas de esta manera:

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

El prop `index` en estos ejemplos está destinado a representar la ruta predeterminada para un segmento de ruta dado. Por lo tanto, el componente `Home` se mostrará en la ruta raíz `/`, mientras que el componente `ProductsHome` se mostrará en la ruta `/products`.

- **Anidando Rutas**: Puedes anidar rutas dentro de otras rutas, lo que da como resultado que la ruta del hijo se agregue a la ruta del padre.

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

En el ejemplo anterior, la ruta para los productos en tendencia será productos/tendencia.

- **Segmentos Dinámicos**: Un segmento dinámico es donde cualquier parte de la ruta del URL es dinámica.

```jsx
<Route path=":category" element={<Category />} />
```

En este ejemplo tenemos un segmento dinámico llamado `category`. Cuando un usuario navega a una URL como productos/instrumentos-de-latón, el visor cambiará al componente `Category` y podrás obtener dinámicamente los datos apropiados basados en el segmento.

- **Gancho `useParams`**: Este gancho se utiliza para acceder a los parámetros dinámicos de una ruta de URL.

```jsx
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
  {/* Accessing the category param: params.category */}
  {/* rest of code goes here */}
}
```

## Frameworks de React

- **Introducción**: Los frameworks de React proporcionan características como enrutamiento, optimización de imágenes, obtención de datos, autenticación y más. Esto significa que podrías no necesitar configurar aplicaciones frontend y backend separadas para ciertos casos de uso. Ejemplos de Frameworks de React incluyen Next.js y Remix.
- **Enrutamiento en Next.js**: Este sistema de enrutamiento incluye soporte para rutas dinámicas, rutas paralelas, manejadores de rutas, redirecciones, internalización y más.

Aquí hay un ejemplo de crear un manejador de solicitudes personalizado:

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Optimización de Imágenes en Next.js**: El componente `Image` extiende el elemento HTML nativo `img` y permite cargas de página más rápidas y optimizaciones de tamaño. Esto significa que las imágenes solo se cargarán cuando entren en el campo de visión y el componente `Image` servirá automáticamente imágenes de tamaño correcto para cada dispositivo.

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
```

## Perforación de Props

- **Definición**: La perforación de props es el proceso de pasar props de un componente padre a componentes hijos profundamente anidados, incluso cuando algunos de los componentes hijos no necesitan los props.

## Gestión de Estado

- **API de contexto**: Contexto se refiere a cuando un componente padre hace que la información esté disponible para los componentes hijos sin necesidad de pasarla explícitamente a través de props. `createContext` se utiliza para crear un objeto contexto que representa el contexto que otros componentes leerán. El `Provider` se usa para proporcionar valores de contexto a los componentes hijos.

```jsx
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**: Redux maneja la gestión de estado al proporcionar una almacén central y un control estricto sobre las actualizaciones de estado. Utiliza un patrón predecible con acciones, reductores y middleware. Las acciones son cargas de información que envían datos desde tu aplicación al almacén de Redux, a menudo activadas por interacciones del usuario. Los reductores son funciones que especifican cómo debe cambiar el estado en respuesta a esas acciones, asegurando que el estado se actualiza de manera inmutable. El middleware, por otro lado, actúa como un puente entre el despacho de acciones y el reductor, permitiéndote extender la funcionalidad de Redux (por ejemplo, registro, manejo de operaciones asíncronas) sin modificar el flujo central.

- **Zustand**: Esta solución de gestión de estado es ideal para aplicaciones de pequeña a mediana escala. Funciona usando un gancho `useStore` para acceder directamente al estado en componentes y páginas. Esto te permite modificar y acceder a los datos sin necesidad de acciones, reductores o un proveedor.

## Depurando Componentes de React Usando las Herramientas de Desarrollo de React

- **Herramientas para Desarrolladores de React**: Esta es una extensión de navegador que puedes usar en Chrome, Firefox y Edge para inspeccionar componentes de React e identificar problemas de rendimiento. Para Safari, necesitarás instalar el paquete npm `react-devtools`. Después de instalar las Herramientas de Desarrollo de React y abrir una aplicación React en el navegador, abre las herramientas para desarrolladores del navegador para acceder a las dos pestañas adicionales proporcionadas para depurar React: Componentes y Perfilador.
- **Pestaña de Componentes**: Esta pestaña muestra cada componente para ti en un formato de vista de árbol. Aquí hay algunas cosas que puedes hacer en esta pestaña:
  - ver la jerarquía de componentes de la aplicación
  - ver y modificar props, estados y valores de contexto en tiempo real
  - verificar el código fuente de cada componente seleccionado
  - registrar los datos del componente en la consola
  - inspeccionar los elementos del DOM para el componente
- **Pestaña de Perfilador**: Esta pestaña te ayuda a analizar el rendimiento de los componentes. Puedes grabar el rendimiento de los componentes para identificar renderizados innecesarios, ver duraciones de commits y posteriormente optimizar componentes lentos.

## Componentes del Servidor React

- **Definición**: Los Componentes del Servidor React son componentes React que se renderizan exclusivamente en el servidor, enviando solo el HTML final al cliente. Esto significa que esos componentes pueden acceder directamente a recursos del servidor y reducir drásticamente la cantidad de JavaScript enviada al navegador.

# --assignment--

Revisar enrutamiento, gestión de estado, formularios y obtención de datos en React.
