---
id: 589a8eb3f9fc0f352b528e72
title: 社交驗證 III 的實作
challengeType: 2
forumTopicId: 301558
dashedName: implementation-of-social-authentication-iii
---

# --description--

策略的最後一部分是處理從 GitHub 傳回的評測。如果使用者的資料庫物件存在，我們需要載入它；如果不存在，則需要創建一個，並從評測中填入欄位，然後傳回使用者的物件。GitHub 在每個評測中提供一個唯一的 *id*，我們可以用它來搜尋並序列化使用者（此功能已實作）。以下是一個你可以在專案中使用的實作範例——它放在新策略的第二個引數所對應的函式內，正好在目前 `console.log(profile);` 下面：

```js
myDataBase.findOneAndUpdate(
  { id: profile.id },
  {
    $setOnInsert: {
      id: profile.id,
      username: profile.username,
      name: profile.displayName || 'John Doe',
      photo: profile.photos[0].value || '',
      email: Array.isArray(profile.emails)
        ? profile.emails[0].value
        : 'No public email',
      created_on: new Date(),
      provider: profile.provider || ''
    },
    $set: {
      last_login: new Date()
    },
    $inc: {
      login_count: 1
    }
  },
  { upsert: true, new: true },
  (err, doc) => {
    return cb(null, doc.value);
  }
);
```

`findOneAndUpdate` 允許你搜尋物件並更新它。如果物件不存在，將會插入該物件並提供給回呼函式。在此範例中，我們總是設定 `last_login`，將 `login_count` 增加 `1`，並且只有在插入新物件（新使用者）時才填入大部分欄位。請注意預設值的使用。有時候傳回的評測不會填滿所有資訊，或者使用者會保持私密。在這種情況下，你需要控制代碼以避免錯誤。

你現在應該能夠登入你的應用程式了。試試看！

當你認為已經正確完成時，提交你的頁面。如果你遇到錯誤，你可以<a href="https://forum.freecodecamp.org/t/advanced-node-and-express/567135#implementation-of-social-authentication-iii-5" target="_blank" rel="noopener noreferrer nofollow">查看至此為止完成的專案</a>。

# --hints--

GitHub 策略設定應該完成。

```js
  const url = new URL("/_api/auth.js", code);
  const res = await fetch(url);
  const data = await res.text();
  assert.match(
    data,
    /GitHubStrategy[^]*myDataBase/gi,
    'Strategy should use now use the database to search for the user'
  );
  assert.match(
    data,
    /GitHubStrategy[^]*cb/gi,
    'Strategy should return the callback function "cb"'
  );
```

