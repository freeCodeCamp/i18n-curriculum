---
id: 6733ab269b378bf724c9ac71
title: ¿Qué son los Conjuntos en JavaScript y cómo se diferencian de los Conjuntos Débiles?
challengeType: 19
dashedName: what-are-sets-in-javascript-and-how-does-it-differ-from-weaksets
---

# --description--

En JavaScript, `Set` es un objeto incorporado para gestionar colecciones de datos. Te permite almacenar valores únicos de cualquier tipo, ya sean primitivos o referencias a objetos. `Set` asegura que cada valor en él aparezca solo una vez, lo que lo hace útil para eliminar duplicados de un arreglo o manejar colecciones de valores distintos.

En cuanto a `WeakSet`, es un tipo especial de `Set` con menos características que le permite almacenar referencias de objetos mantenidas débilmente y símbolos. A diferencia de `Set`, `WeakSet` no soporta primitivos como números o cadenas.

A diferencia de un `Set` regular, un `WeakSet` solo almacena objetos, y las referencias a esos objetos son "débiles", lo que significa que los `WeakSets` no impiden que los objetos almacenados sean recolectados por el recolector de basura si no hay otras referencias a ellos. En términos más simples, si el objeto no se está usando en ningún otro lugar de su código, se elimina automáticamente para liberar memoria.

Para crear un `Set`, use el constructor `Set` y asígnelo a una variable:

```js
const myFirstSet = new Set();
```

También puede inicializar el `Set` con valores:

```js
const treeSet = new Set(['Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit']);
```

Si registra el `Set` en la consola, así es como se ve la salida:

```js
/*
Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
  [[Entries]]
  0: "Baobab"
    value: "Baobab"
  1: "Jackalberry"
    value: "Jackalberry"
  2: "Mopane Tree"
    value: "Mopane Tree"
  3: "Breadfruit"
    value: "Breadfruit"
  size: 4
  [[Prototype]]: Set
*/
```

Si no inicializó el `Set` con valores, puede utilizar el método `add()` para agregar un elemento al `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
```

El resultado y la apariencia del resultado en la consola permanece igual.

No olvide que los elementos duplicados serán ignorados en el `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
treeSet.add('Baobab'); //duplicate item will be ignored

console.log(treeSet);
// Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
```

Los otros métodos que puede utilizar para manipular un `Set` son:

- `delete()`  
- `clear()`
- `has()`
- `entries()`
- `forEach()`
- `keys()`
- `values()`

Veamos cómo funcionan estos métodos uno por uno. `delete()` elimina un elemento especificado del `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet); // Set(3) {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`has()` verifica si un valor específico existe en el `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.has('Breadfruit')); // false
```

`entries()` devuelve un iterador del `Set` que contiene un arreglo de los valores en formato `[valor, valor]`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.entries());
// SetIterator {'Baobab' => 'Baobab', 'Jackalberry' => 'Jackalberry', 'Mopane Tree' => 'Mopane Tree'}
```

`keys()` y `values()` muestran los valores en el `Set`. `keys()` es solo un alias para el método `values()`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log('Keys: ', treeSet.keys());
console.log('Values: ', treeSet.values());
// Keys: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
// Values: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`forEach()` le permite iterar a través del `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.forEach((tree) => console.log(tree));
/*
Baobab
Jackalberry
Mopane Tree
*/
```

`clear()` elimina todos los elementos del arreglo:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.clear();

console.log(treeSet); // Set(0) {size: 0}
```

También vale la pena mencionar que hay una propiedad `size` que devuelve el número de elementos en el `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.size); // 3
```

Al igual que `Set`, también hay un constructor `WeakSet` que puede utilizar para crear un `WeakSet`:

```javascript
const treeWeakSet = new WeakSet();
```

`WeakSet` también tiene los métodos `add()`, `delete()`, y `has()`:

```javascript
const treeWeakSet = new WeakSet();

treeWeakSet.add({ name: 'Baobab' });
treeWeakSet.add({ name: 'Jackalberry' });
treeWeakSet.add({ name: 'Mopane Tree' });
treeWeakSet.add({ name: 'Breadfruit' });

treeWeakSet.delete('Jackalberry');
console.log(treeWeakSet.has('Jackalberry')); // false

console.log(treeWeakSet);
```

En la salida, el contenido del `WeakSet` aparece así:

```javascript
/*
WeakSet {{…}, {…}, {…}, {…}}
  [[Entries]]
    No properties
  [[Prototype]]: WeakSet
    .
    .
    .
*/
```

El contenido aparece vacío porque los `WeakSets` no son iterables y no exponen su contenido directamente.

No olvide que solo se admiten símbolos y objetos con claves y valores bien definidos. Agregar un primitivo, como números o cadenas, resultará en un error:

```js
treeWeakSet.add('Alan Smith');

console.log(treeWeakSet); // Invalid value used in weak set
//    at WeakSet.add (<anonymous>)
```

La diferencia clave entre un `Set` y un `WeakSet` es que un `Set` almacena cualquier valor, mientras que un `WeakSet` solo puede almacenar objetos.

Aquí hay algunas otras diferencias notables entre un `Set` y un `WeakSet`:

| Característica | Set | WeakSet |
| --- | --- | --- |
| Tipo de Valores Almacenados | Almacena cualquier tipo de dato | Solo almacena objetos |
| Referencias | Referencias fuertes | Referencias débiles |
| Iteración | Soporta iteración con `forEach` y bucles | No soporta iteración |
| Métodos y Propiedades | `add()`, `delete()`, `has()`, `keys()`, `values()`, `size` y más | Solo `add()`, `delete()` y `has()` |
| Caso de uso | Colección de propósito general de valores únicos y eliminación de duplicados de arreglos | Seguimiento eficiente de la memoria de referencias de objetos |

Puede ver las diferencias en los tipos de valores que los dos tipos de conjuntos pueden almacenar, su soporte para iterar sobre los objetos almacenados y sus casos de uso ideales. Por favor, tómese un momento para leer el contenido de esta tabla.

# --questions--

## --text--

¿En qué se diferencia un `Set` de un `WeakSet` en cuanto a los datos que ambos soportan?

## --answers--

Un `Set` permite referencias de objetos mantenidas débilmente, mientras que un `WeakSet` soporta tanto objetos como tipos primitivos.

### --feedback--

Recuerde que un `Set` puede contener una variedad de tipos de datos.

---

Un `Set` almacena cualquier tipo, incluyendo primitivos, mientras que un `WeakSet` solo permite referencias de objetos mantenidas débilmente.

---

Un `Set` tiene menos características que un `WeakSet`.

### --feedback--

Recuerde que un `Set` puede contener una variedad de tipos de datos.

---

Un `Set` es exclusivamente para objetos, mientras que un `WeakSet` es para números.

### --feedback--

Recuerde que un `Set` puede contener una variedad de tipos de datos.

## --video-solution--

2

## --text--

¿Cómo se crea un `Set` o un `WeakSet` en JavaScript?

## --answers--

Llamando a `Set()` o `WeakSet()` sin la palabra clave `new`

### --feedback--

Piense en qué palabra clave debe incluirse para crear un `Set` o un `WeakSet`.

---

Usando literales de objeto `{}`

### --feedback--

Piense en qué palabra clave debe incluirse para crear un `Set` o un `WeakSet`.

---

Usando literales de arreglo `[]`

### --feedback--

Piense en qué palabra clave debe incluirse para crear un `Set` o un `WeakSet`.

---

Usando el constructor `Set` o `WeakSet` con la palabra clave `new`

## --video-solution--

4

## --text--

¿Qué métodos están disponibles tanto para un `Set` como para un `WeakSet` en JavaScript?

## --answers--

`keys()`, `values()`, `size()`

### --feedback--

Revisa el final de la lección donde se discutió esto. 

---

`add()`, `delete()`, `has()`

---

`clear()`, `entries()`, `forEach()`

### --feedback--

Revisa el final de la lección donde se discutió esto. 

---

`set()`, `get()`, `remove()`

### --feedback--

Revisa el final de la lección donde se discutió esto. 

## --video-solution--

2
