---
id: 68760c4c2648e7832c5eef16
title: Paso 14
challengeType: 20
dashedName: step-14
---

# --description--

Después del ciclo que encuentra el nodo no visitado más cercano, necesitas verificar si realmente se encontró un nodo válido.

Si no existe tal nodo, eso significa que los nodos restantes son inalcanzables desde el nodo inicial, y el algoritmo debería detenerse antes.

Al mismo nivel que el `for` anidado, agrega una sentencia `if` que verifique si `current == -1` y salga del ciclo si es verdadero.

# --hints--

Deberías tener una estructura `if` que verifique si `current` sigue siendo `-1` después del `for` interno.

```js
({
    test: () => {
      runPython(`
      cond = _Node(_code).find_function("shortest_path").find_for_loops()[0].find_bodies()[0].find_ifs()[0].find_conditions()[0]
      assert cond.is_equivalent("current == -1") or cond.is_equivalent("-1 == current")
      `);
    }
});
```

Debes usar una sentencia `break` para salir del ciclo.

```js
({
    test: () => {
      runPython(`
      assert _Node(_code).find_function("shortest_path").find_for_loops()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].has_stmt("break")
      `);
    }
});
```

# --seed--

## --seed-contents--

```py
INF = float('inf')
adj_matrix = [
    [0, 5, 3, INF, 11, INF],
    [5, 0, 1, INF, INF, 2],
    [3, 1, 0, 1, 5, INF],
    [INF, INF, 1, 0, 9, 3],
    [11, INF, 5, 9, 0, INF],
    [INF, 2, INF, 3, INF, 0],
]

def shortest_path(matrix, start_node, target_node=None):
    n = len(matrix)
    distances = [INF] * n
    distances[start_node] = 0
    paths = [[node_no] for node_no in range(n)]
    visited = [False] * n

    for _ in range(n):
        min_distance = INF  
        current = -1  
        for node_no in range(n):  
            if not visited[node_no] and distances[node_no] < min_distance:  
                min_distance = distances[node_no]  
                current = node_no

--fcc-editable-region--

--fcc-editable-region--
```
