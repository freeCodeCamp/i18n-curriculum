---
id: 587d7dba367417b2b2512ba9
title: 正向與反向先行斷言
challengeType: 1
forumTopicId: 301360
dashedName: positive-and-negative-lookahead
---

# --description--

<dfn>Lookaheads</dfn> 是告訴 JavaScript 在你的字串中向前搜尋以檢查後續樣式的樣式。當你想要在同一字串中搜尋多個樣式時，這會很有用。

有兩種前瞻：<dfn>正向前瞻</dfn> 和 <dfn>負向前瞻</dfn>。

正向前瞻會確認搜尋樣式中的元素存在，但不會實際匹配它。正向前瞻用作 `(?=...)`，其中 `...` 是不被匹配的必要零件。

另一方面，負向前瞻會確認搜尋樣式中的元素不存在。負向前瞻用法為 `(?!...)`，其中 `...` 是你不希望出現的樣式。如果負向前瞻的部分不存在，則傳回樣式的其餘部分。

先行斷言有點令人困惑，但一些範例會有所幫助。

```js
let quit = "qu";
let noquit = "qt";
let quRegex= /q(?=u)/;
let qRegex = /q(?!u)/;
quit.match(quRegex);
noquit.match(qRegex);
```

這兩個 `match` 呼叫都會傳回 `["q"]`。

更實用的 lookaheads 用法是在一個字串中檢查兩個或更多樣式。這裡有一個（天真地）簡單的密碼檢查器，用來檢查字元數在 3 到 6 個之間且至少有一個數字：

```js
let password = "abc123";
let checkPass = /(?=\w{3,6})(?=\D*\d)/;
checkPass.test(password);
```

# --instructions--

在 `pwRegex` 中使用前瞻，以符合長度大於 5 個字元且有兩個連續數字的密碼。

# --hints--

你的正則表達式應該使用兩個正向 `lookaheads`。

```js
assert(pwRegex.source.match(/\(\?=.*?\)\(\?=.*?\)/) !== null);
```

你的正則表達式不應該匹配字串 `astronaut`

```js
pwRegex.lastIndex = 0;
assert(!pwRegex.test('astronaut'));
```

你的正則表達式不應該匹配字串 `banan1`

```js
pwRegex.lastIndex = 0;
assert(!pwRegex.test('banan1'));
```

你的正規表達式應該符合字串 `bana12`

```js
pwRegex.lastIndex = 0;
assert(pwRegex.test('bana12'));
```

你的正規表達式應該符合字串 `abc123`

```js
pwRegex.lastIndex = 0;
assert(pwRegex.test('abc123'));
```

你的正則表達式不應該匹配字串 `12345`

```js
pwRegex.lastIndex = 0;
assert(!pwRegex.test('12345'));
```

你的正規表達式應該符合字串 `8pass99`

```js
pwRegex.lastIndex = 0;
assert(pwRegex.test('8pass99'));
```

你的正規表達式不應該匹配字串 `1a2bcde`

```js
pwRegex.lastIndex = 0;
assert(!pwRegex.test('1a2bcde'));
```

你的正則表達式應該匹配字串 `astr1on11aut`

```js
pwRegex.lastIndex = 0;
assert(pwRegex.test('astr1on11aut'));
```

# --seed--

## --seed-contents--

```js
let sampleWord = "astronaut";
let pwRegex = /change/; // Change this line
let result = pwRegex.test(sampleWord);
```

# --solutions--

```js
let pwRegex =  /(?=\w{6})(?=\w*\d{2})/;
```
