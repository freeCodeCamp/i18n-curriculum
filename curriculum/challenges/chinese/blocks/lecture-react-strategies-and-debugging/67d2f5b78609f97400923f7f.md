---
id: 67d2f5b78609f97400923f7f
title: 什么是状态管理库，以及你应该何时使用它们？
challengeType: 19
dashedName: what-are-state-management-libraries-and-when-should-you-use-them
---

# --description--

随着你的应用增长，管理数据在组件之间的流动可能变得复杂。

刚开始时，React 的 `useState` 钩子可能足够，但随着你添加特色，可能会遇到以下问题：

- 通过不需要它们的组件传递 props，也称为 prop drilling
- 保持应用不同部分之间的数据同步
- 处理同时影响多个组件的复杂更新

这些以及其他挑战可能会出现，导致代码库更难维护、调试和测试。这就是状态管理库的作用——它们提供了一个集中位置，组件可以在这里获取或更新所需的数据。

让我们来看一下你拥有的几种不同的状态管理选项，以及何时使用它们。

Context API 是内置于 React 的状态管理器，允许你在组件之间共享状态而无需使用第三方库。它是对 `useState` 钩子的成熟升级，因此非常适合主题切换或用户认证状态等分支。

然而，Context API 不擅长处理频繁更新，可能导致不必要的重新渲染，使其不太适合像电子商务和社交媒体平台这样复杂状态需求的应用。 

这是一个计数器组件，演示了 Context API 的基本用法：

```jsx
import { useState, createContext } from 'react';

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

这段代码创建了一个上下文和一个提供者，以便在整个应用中共享 `count` 状态。

`CounterProvider` 使用 `useState` 钩子来初始化和管理 `count` 状态及其设置函数。两者随后通过 `Provider` 传递给子组件。

因此，当你用 `CounterProvider` 包裹整个应用时，`count` 状态在你的整个应用中都可用。

以下是你如何将 `CounterProvider` 包裹在你的应用周围的方法：

```jsx
import { CounterProvider } from './context/CounterContext';

function App() {
  return (
    <CounterProvider>
        {/* App components */}
    </CounterProvider>
  );
}

export default App;
```

下面是你如何使用 `count` 状态的方法：

```jsx
import React, { useContext } from 'react';
import { CounterContext } from '../context/CounterContext';

const Counter = () => {
  const { count, setCount } = useContext(CounterContext);

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Context API Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => setCount(count - 1)}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => setCount(count + 1)}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

如你所见，`count` 及其设置函数 `setCount` 是通过 `useContext` 函数初始化的。 

当前的 `count` 状态随后被显示，当用户分别点击递减和递增按钮时，使用 `setCount` 来增加和减少 `count` 状态。

另一个流行的状态管理库是 Redux，它是与 React 一起使用的最流行的状态管理库之一。它已经存在很长时间，非常适合像电子商务和社交媒体平台、论坛等大型应用。

Redux 通过提供一个中央保存和对状态更新的严格控件来处理状态管理。它使用包含 actions、reducers 和中间件的可预测模式。

动作是信息的有效载荷，用于将数据从你的应用发送到 Redux `store`，通常由用户交互触发。

Reducers 是指定状态应如何响应这些操作而变化的函数，确保状态以不可变的方式更新。

另一方面，中间件充当动作分派和 reducer 之间的桥梁，允许你扩展 Redux 的功能性（例如，日志记录、处理异步操作），而无需修改核心流程。

关于 Redux 最常见的抱怨是你需要大量的公式化代码才能开始。作为响应，Redux 团队引入了 `Redux Toolkit` 和 `RTK Query`，它们大大简化了设置进程。

你通常在单个文件中使用 `createSlice()` 函数定义动作和 reducer。通常将文件命名为以 `Slice` 结尾，例如 `productSlice`、`userSlice`、`counterSlice` 等。

这是一个 `counterSlice` 文件，用来向你展示基础知识：

```jsx
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',

  initialState: { count: 0 },

  reducers: {
    increment: (state) => {
      state.count += 1;
    },
    decrement: (state) => {
      state.count -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;

export default counterSlice.reducer;
```

从这里开始，你需要用 `Provider` 包裹整个应用，使用 `useSelector()` 从切片中选择一部分状态，然后使用 `useDispatch()` 使状态生效。

另一个需要考虑的选项是 Zustand。

Zustand 是一个轻量级状态管理库，具有简单的 API。它基于 hooks，因此相比 Redux 有更少的公式化，使得设置更简单更快速。

Zustand 非常适合中小型应用。它通过使用 `useStore` 钩子直接在组件和页面中访问状态来工作。这让你无需使用 actions、reducers 或 provider 就能修改和访问数据。

这是一个实现了另一种计数器功能性的 `useCounterStore`：

```jsx
import { create } from 'zustand';

const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

export default useCounterStore;
```

下面是如何在你的应用中初始化并使用状态：

```jsx
// Import the useCounterStore (it's just a hook)
import useCounterStore from '../useCounterStore';

const Counter = () => {
  // Initialize the states with the useCounterStore hook
  const { count, increment, decrement } = useCounterStore();

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Zustand Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => decrement()}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => increment()}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

尽管前端生态系统不断发展，且新的状态管理库经常出现，但我们讨论的这些库在业界被广泛使用。

# --questions--

## --text--

使用状态管理库的原因有哪些？

## --answers--

为了避免在你的应用中编写任何状态逻辑。

### --feedback--

考虑跨多个组件和页面管理复杂状态的好处。

---

自动更新 UI 而无需重新渲染。

### --feedback--

考虑跨多个组件和页面管理复杂状态的好处。

---

为了创建一致且可预测的数据流。

---

完全消除对 props 的需求。

### --feedback--

考虑跨多个组件和页面管理复杂状态的好处。

## --video-solution--

3

## --text--

以下哪一个不是状态管理库？

## --answers--

上下文 API

### --feedback--

考虑哪一个是专门用于 API `request` 的。

---

Redux

### --feedback--

考虑哪一个是专门用于 API `request` 的。

---

Zustand

### --feedback--

考虑哪一个是专门用于 API `request` 的。

---

Axios

## --video-solution--

4

## --text--

关于 Redux 的一个常见抱怨是什么，且它是如何被解决的？

## --answers--

它的浏览器支持有限，通过创建 polyfills 解决了这个问题。

### --feedback--

考虑为减少设置复杂度所做的改进。

---

它存在性能问题，已通过优化其中间件来解决。

### --feedback--

考虑为减少设置复杂度所做的改进。

---

这需要大量复杂的公式化代码，Redux Toolkit 和 RTK Query 解决了这个问题。

---

文档不足，通过添加更多示例来解决。

### --feedback--

考虑为减少设置复杂度所做的改进。

## --video-solution--

3
