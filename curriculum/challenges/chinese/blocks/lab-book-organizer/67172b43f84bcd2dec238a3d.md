---
id: 67172b43f84bcd2dec238a3d
title: 构建一个书籍整理器
challengeType: 26
dashedName: build-a-book-organizer
---

# --description--

**目标：**实现以下用户需求并通过所有测试以完成实验。 

**用户故事：**

1. 你应该有一个名为 `books` 的对象数组，其中数组中的每个对象应包含一个字串 `title`、另一个字串 `authorName` 和一个数字 `releaseYear`。

2. 你的 `books` 数组应至少包含三个对象。

3. 你应该有一个名为 `sortByYear` 的回调函数，该函数接受两个书籍作为参数，用于排序数组。

4. 如果第一本书的 `releaseYear` 小于第二本书的，`sortByYear` 函数应返回 `-1`。

5. 如果第一本书的 `releaseYear` 大于第二本书的，`sortByYear` 函数应 `return` `1`。

6. 如果两个 `releaseYear` 值相等，`sortByYear` 函数应返回 `0`。

7. 你应该过滤掉 `books` 数组中 1950 年以后写的书，并将过滤后的数组储存在名为 `filteredBooks` 的新数组中。

8. 你应该根据书籍的 `releaseYear` 按升序对 `filteredBooks` 数组中的书籍进行排序。你在之前的课程中学到，`sort()` 方法会就地排序数组。这意味着 `filteredBooks` 数组将被修改。

# --hints--

你的代码中应该有一个函数 `sortByYear`。

```js
assert.isFunction(sortByYear);
```

你的 `sortByYear` 函数应接受两个参数。

```js
assert.lengthOf(sortByYear, 2);
```

你的 `sortByYear` 函数应当在 `book1` 对象的 `releaseYear` 小于 `book2` 对象的 `releaseYear` 时返回 `-1`，在 `book1` 对象的 `releaseYear` 大于 `book2` 对象的 `releaseYear` 时返回 `1`，在所有其他情况下返回 `0`。

```js
assert.equal(sortByYear({releaseYear: 1913}, {releaseYear: 1925}), -1);
assert.equal(sortByYear({releaseYear: 1925}, {releaseYear: 1913}), 1);
assert.equal(sortByYear({releaseYear: 1925}, {releaseYear: 1925}), 0);
```

你的代码中应该有一个数组 `books`。

```js
assert.isArray(books)
```

你的 `books` 数组应至少包含三个书籍对象。

```js
assert.isAtLeast(books.length, 3)
```

你的 `books` 数组应包含每个带有字串 `title`、另一个字串 `authorName` 和数字 `releaseYear` 的对象。

```js

books.forEach((book) => {
  assert.isObject(book);
  assert.sameMembers(Object.keys(book), ["title", "authorName", "releaseYear"]);
  assert.isString(book.title);
  assert.isNotEmpty(book.title);
  assert.isString(book.authorName);
  assert.isNotEmpty(book.authorName);
  assert.isNumber(book.releaseYear);
})
```

你的代码中应该有一个数组 `filteredBooks`。

```js
assert.isArray(filteredBooks)
```

`filteredBooks` 数组应从 `books` 数组中过滤出部分书籍，且不应为空。

```js
assert.isBelow(filteredBooks.length, books.length)
assert.isNotEmpty(filteredBooks)
```

`filteredBooks` 数组应仅包含来自原始 `books` 数组的书籍。

```js
filteredBooks.forEach(book => {
  assert.isTrue(
    books.some(original => 
      original.title === book.title &&
      original.authorName === book.authorName &&
      original.releaseYear === book.releaseYear
    )
  );
});
```

`filteredBooks` 数组应仅包含在指定年份或之前发布的书籍。

```js
const maxYear = Math.max(...filteredBooks.map(book => book.releaseYear));
const removedYears = books.filter(book => !filteredBooks.includes(book)).map(book => book.releaseYear);
assert.isTrue(removedYears.every(year => year > maxYear));
```

你应该通过在 `filteredBooks` 数组上传递 `sortByYear` 回调函数来调用 `sort` 高阶函数。

```js
assert.match(__helpers.removeJSComments(code), /\s*filteredBooks\s*\.\s*sort\s*\(\s*sortByYear\s*\)/);
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
function sortByYear(book1, book2) {
  if (book1.releaseYear < book2.releaseYear) {
    return -1;
  }

  if (book1.releaseYear > book2.releaseYear) {
    return 1;
  }

  return 0;
}

const books = [
  {
    title: "The Great Gatsby",
    authorName: "F. Scott Fitzgerald",
    releaseYear: 1925,
  },
  {
    title: "In Search of Lost Time",
    authorName: "Marcel Proust",
    releaseYear: 1913,
  },
  {
    title: "Ulysses",
    authorName: "James Joyce",
    releaseYear: 1922,
  },
  {
    title: "One Hundred Years of Solitude",
    authorName: "Gabriel García Márquez",
    releaseYear: 1967,
  },
  {
    title: "The Catcher in the Rye",
    authorName: "J. D. Salinger",
    releaseYear: 1951,
  },
];

let filteredBooks = books.filter((book) => book.releaseYear < 1950);

filteredBooks.sort(sortByYear);

console.log("Books Written Before 1950 (sorted according to release year)");
filteredBooks.forEach((book) => {
  console.log(`${book.title} by ${book.authorName} (${book.releaseYear})`);
});
```
