---
id: 673403d2aa52d8586a14a269
title: 什麼是類別繼承，以及它如何運作？
challengeType: 19
dashedName: what-is-class-inheritance-and-how-does-it-work
---

# --interactive--

在程式設計中，繼承允許你定義從其他類別繼承屬性和方法的類別。

例如，`Car` 是一種 `Vehicle` 型別，所以你可以定義一個具有所有車輛類型共通的最一般屬性和方法的 `Vehicle` 類別，然後定義一個繼承 `Vehicle` 類別屬性和方法的 `Car` 類別。

這種「是」關係是繼承的特徵。在此範例中，`Car` 是 `Vehicle` 的更專門化表單。

有兩個主要的概念你應該知道，以開始使用繼承：父類別和子類別。

父類別是一個類別，充當其他類別的藍圖。它定義了其他類別會繼承的屬性和方法。

子類別是繼承另一個類別的屬性和方法的類別。子類別也可以透過添加新的屬性和方法來擴充其父類別的功能。

在我們之前的範例中，`Vehicle` 會是 `Car` 類別的父類別，而 `Car` 類別會是 `Vehicle` 的子類別。

一個父類別可以有多個子類別。

在 JavaScript 中，我們使用 `extends` 關鍵字來實作繼承。這個關鍵字顯示一個類別是另一個類別的子類別。

在此範例中，我們只看到類別定義的第一行，你可以看到 `Car` 類別繼承自 `Vehicle` 類別，因此 `Car` 繼承了 `Vehicle`。

```js
class Vehicle {
  // Implementation of Vehicle...
}

class Car extends Vehicle {
  // Implementation of Car...
}
```

假設 `Vehicle` 類別有兩個屬性：`brand` 和 `year`。你可以在更新後的程式碼中看到這一點。

`Car` 有一個名為 `honk` 的方法。然而，請注意 `Car` 類別沒有自己的建構式。讓我們看看它是否繼承了屬性。

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

要定義一個 `Car` 的實體，你需要傳入兩個引數：`brand` 和 `year`。在這個例子中，品牌是 `freeCodeCamp Motors`，年份是 `2019`。

```js
let myCar = new Car("freeCodeCamp Motors", 2019);
```

如果你嘗試使用點記法存取這些屬性並呼叫該方法：

```js
console.log(myCar.brand);
console.log(myCar.year);
myCar.honk();
```

以下是完整範例：

:::interactive_editor

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}

let myCar = new Car("freeCodeCamp Motors", 2019);
console.log(myCar.brand);
console.log(myCar.year);
myCar.honk();
```

:::

確實，輸出是正確的，所以這些屬性和方法定義在 `Car` 實體中，而你只是透過從 `Vehicle` 類別繼承這些屬性，為你的程式碼節省了大量重複。

在這個範例中，子類別沒有任何額外的屬性。這就是為什麼該類別沒有建構式，只有一個方法。

如果你確實需要添加額外的屬性，你將需要定義一個建構式。

讓我們來看一個範例。


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

這次，我們將為 `Car` 子類別添加一個 `numDoors` 屬性。

你可以看到現在這個類別在更新後的程式碼中有一個建構式。在建構式中，有一個對 `super()` 的呼叫，並傳遞了引數 `brand` 和 `year`。

`super()` 會喚起父類別的建構式，所以透過使用 `super(brand, year)`，你基本上是在子類別中定義父類別的屬性。這是另一個你可以使用的術語－父類別是 parent class，子類別是 child class。

然後，`this.numDoors = numDoors` 這一行定義了一個專屬於 `Car` 類別的新屬性，即車門數量（`numDoors`）。

這是一種擴充 `Vehicle` 類別的方法，為你的 `Car` 實體添加專屬的屬性。

這是擴充性的範例，也是繼承的基本優勢之一。

現在，如果你創建一個 `Car` 類別的實體，你會看到它有三個屬性：`brand`、`year` 和 `numDoors`。當你創建實體時，也需要傳遞必要的引數。

```js
let myCar = new Car("freeCodeCamp Motors", 2019, 4);
```

如果你使用 `console.log()` 列印這些屬性的值：

```js
console.log(myCar.brand);
console.log(myCar.year);
console.log(myCar.numDoors);
```

以下是完整範例：

:::interactive_editor

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}

let myCar = new Car("freeCodeCamp Motors", 2019, 4);
console.log(myCar.brand);
console.log(myCar.year);
console.log(myCar.numDoors);
```

:::

繼承的主要優點是程式碼重複使用性、模組化、可擴充性，以及改善的程式碼結構。

透過實作階層體系，你可以在子類別中重複使用你已為父類別撰寫的程式碼，避免重複。

繼承也透過將複雜系統拆解為階層體系中的較簡單組件來促進模組化。

此外，能夠擴充父類別的功能，使你更容易適應不斷變化的需求，並在開發過程中後續添加新特性。

最後，階層式結構可以讓你的程式碼更容易理解和維護。

這些是繼承的基本原理。透過了解繼承的運作方式，你可以設計結構良好、易於維護且可擴充的物件導向程式。

# --questions--

## --text--

物件導向程式設計中繼承的主要目的是什麼？

## --answers--

創建新物件。

### --feedback--

思考繼承如何幫助程式碼的可重用性和組織。

---

為類別定義方法。

### --feedback--

思考繼承如何幫助程式碼的可重用性和組織。

---

為了重複使用程式碼並建立類別之間的階層關係。

---

將資料封裝在物件中。

### --feedback--

思考繼承如何幫助程式碼的可重用性和組織。

## --video-solution--

3

## --text--

在 JavaScript 中用來繼承父類別的關鍵字是什麼？

## --answers--

`inherit`

### --feedback--

思考建立繼承關係的關鍵字。

---

`extends`

---

`super`

### --feedback--

思考建立繼承關係的關鍵字。

---

`prototype`

### --feedback--

思考建立繼承關係的關鍵字。

## --video-solution--

2

## --text--

父類別和子類別之間有什麼差異？

## --answers--

父類別是子類別的專門版本。

### --feedback--

思考類別之間的階層關係。

---

子類別是父類別的專門版本。

---

父類別和子類別之間沒有差異。

### --feedback--

思考類別之間的階層關係。

---

父類別總是比子類別大。

### --feedback--

思考類別之間的階層關係。

## --video-solution--

2
