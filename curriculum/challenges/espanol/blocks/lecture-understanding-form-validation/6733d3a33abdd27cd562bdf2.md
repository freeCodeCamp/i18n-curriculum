---
id: 6733d3a33abdd27cd562bdf2
title: ¿Cuál es el propósito del método preventDefault()?
challengeType: 19
dashedName: what-is-the-purpose-of-e-preventdefault
---

# --interactive--

Aprendamos sobre el propósito del método `preventDefault()` en los eventos.

Todos los eventos que se activan en el DOM tienen algún tipo de comportamiento predeterminado. El evento `click` en una casilla de verificación alterna el estado de esa casilla, por defecto. Presionar la barra espaciadora en un botón enfocado activa el botón. El método `preventDefault()` en estos objetos de evento detiene que eso ocurra.

Veamos un ejemplo. Definamos un elemento `input` para que un usuario escriba:

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<label>Enter some characters:
  <input type="text">
</label>
```

```css
label {
  display: flex;
  flex-direction: column;
  font-family: Arial, sans-serif;
  font-size: 14px;
  color: #333;
  margin-bottom: 12px;
}

input[type="text"] {
  padding: 8px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
  margin-top: 4px;
  width: 100%;
  box-sizing: border-box;
  transition: border-color 0.2s, box-shadow 0.2s;
}

input[type="text"]:focus {
  border-color: #0078d4;
  box-shadow: 0 0 3px rgba(0, 120, 212, 0.5);
  outline: none;
}

```

:::

Y si miramos el resultado, podemos escribir en el campo de entrada como se espera. Pero tal vez no queremos eso. Tal vez, en su lugar, nos gustaría mostrar el carácter que el usuario escribe en un elemento separado. Primero, definamos nuestro elemento para eso:

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<label>Enter some characters:
  <input type="text">
</label>
<p id="output"></p>
```

```css
body {
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  margin: 0;
}

label {
  font-size: 1.2rem;
  color: #333;
  margin-bottom: 1rem;
  display: flex;
  flex-direction: column;
}

input[type="text"] {
  padding: 0.5rem;
  font-size: 1rem;
  border: 2px solid #ccc;
  border-radius: 5px;
  margin-top: 0.5rem;
  outline: none;
}

input[type="text"]:focus {
  border-color: #007BFF;
}

#output {
  margin-top: 1rem;
  font-size: 1.1rem;
  color: #555;
}

```

:::

Y luego, necesitamos conectar el evento `keydown` para escuchar cuando se escriba un carácter en el teclado. Tenga en cuenta que no queremos los eventos de `change` o `input` aquí, porque necesitamos la información del teclado.

```js
const input = document.querySelector("input");

input.addEventListener("keydown", (e) => {
    
})
```

El evento `keydown` se dispara cuando presiona una tecla en el teclado. Cuando esto ocurre, mostremos el carácter en nuestro elemento `p`.

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<label>Enter some characters:
  <input type="text">
</label>
<p id="output"></p>
<script src="index.js"></script>
```

```css
body {
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  margin: 0;
}

label {
  font-size: 1.2rem;
  color: #333;
  margin-bottom: 1rem;
  display: flex;
  flex-direction: column;
}

input[type="text"] {
  padding: 0.5rem;
  font-size: 1rem;
  border: 2px solid #ccc;
  border-radius: 5px;
  margin-top: 0.5rem;
  outline: none;
}

input[type="text"]:focus {
  border-color: #007BFF;
}

#output {
  margin-top: 1rem;
  font-size: 1.1rem;
  color: #555;
}

```

```js
const input = document.querySelector("input");
const output = document.getElementById("output");

input.addEventListener("keydown", (e) => {
  output.innerText = `You pressed the ${e.key} key`;
});
```

:::

`e.key` le da el valor de la tecla presionada, como `a` para la tecla `a` o `Enter` para la tecla `Enter`.

Con el código anterior, cuando escribes en el `input`, el carácter que escribes se mostrará en el elemento `p`. 

Esto es genial, pero no queremos mostrar los caracteres en el `input` también. Aquí es donde entra nuestro método `preventDefault()`. El comportamiento predeterminado de un `keydown` es renderizar el carácter en el input. Evitemos eso llamando a `e.preventDefault()`:

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<label>Enter some characters:
  <input type="text">
</label>
<p id="output"></p>
<script src="index.js"></script>
```

```css
body {
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  margin: 0;
}

label {
  font-size: 1.2rem;
  color: #333;
  margin-bottom: 1rem;
  display: flex;
  flex-direction: column;
}

input[type="text"] {
  padding: 0.5rem;
  font-size: 1rem;
  border: 2px solid #ccc;
  border-radius: 5px;
  margin-top: 0.5rem;
  outline: none;
}

input[type="text"]:focus {
  border-color: #007BFF;
}

#output {
  margin-top: 1rem;
  font-size: 1.1rem;
  color: #555;
}

```

```js
const input = document.querySelector("input");
const output = document.getElementById("output");

input.addEventListener("keydown", (e) => {
  e.preventDefault();
  output.innerText = `You pressed the ${e.key} key`;
});
```

:::

Y así de fácil, has evitado el comportamiento predeterminado para poder implementar tu propio manejo de eventos personalizado.

Otro ejemplo común de cuándo usar el método `e.preventDefault` se relaciona con el envío de formularios. Por defecto, enviar un formulario envía datos al servidor y recarga la página. Usar `e.preventDefault()` evita que esto ocurra.

```js
const form = document.querySelector("form");

form.addEventListener("submit", (e) => {
  e.preventDefault();
  // rest of code goes here
});
```

Evitar el comportamiento predeterminado es excelente cuando necesitas más control sobre cómo un usuario interactúa con la página, pero es importante tener en cuenta cosas como la accesibilidad: tu comportamiento personalizado debe proporcionar las mismas funciones que el predeterminado.

# --questions--

## --text--

¿Cuál es el propósito principal del método `preventDefault()` en el manejo de eventos?

## --answers--

Para detener la propagación del evento.

### --feedback--

La lección explica qué hace este método al comportamiento predeterminado de los eventos.

---

Para eliminar los escuchadores de eventos.

### --feedback--

La lección explica qué hace este método al comportamiento predeterminado de los eventos.

---

Para detener el comportamiento predeterminado de un evento.

---

Para activar eventos personalizados.

### --feedback--

La lección explica qué hace este método al comportamiento predeterminado de los eventos.

## --video-solution--

3

## --text--

En el ejemplo dado, ¿qué comportamiento predeterminado se está evitando al llamar a `preventDefault()` en un evento de `keydown` para un elemento `input`?

## --answers--

El campo de entrada pierde el enfoque.

### --feedback--

Piense en lo que normalmente ocurre cuando escribe en un campo de entrada.

---

La tecla se muestra en el campo de entrada.

---

El formulario se envía.

### --feedback--

Piense en lo que normalmente ocurre cuando escribe en un campo de entrada.

---

La página se desplaza.

### --feedback--

Piense en lo que normalmente ocurre cuando escribe en un campo de entrada.

## --video-solution--

2

## --text--

Cuando usa `preventDefault()`, ¿qué consideración importante deben tener en cuenta los desarrolladores?

## --answers--

Debe usarse solo en envíos de formularios.

### --feedback--

La lección menciona una preocupación específica relacionada con la interacción del usuario al usar comportamientos personalizados.

---

Mejorará automáticamente el rendimiento.

### --feedback--

La lección menciona una preocupación específica relacionada con la interacción del usuario al usar comportamientos personalizados.

---

Debe mantener las mismas características que el comportamiento predeterminado para la accesibilidad.

---

Evitará todos los eventos futuros en el elemento.

### --feedback--

La lección menciona una preocupación específica relacionada con la interacción del usuario al usar comportamientos personalizados.

## --video-solution--

3
