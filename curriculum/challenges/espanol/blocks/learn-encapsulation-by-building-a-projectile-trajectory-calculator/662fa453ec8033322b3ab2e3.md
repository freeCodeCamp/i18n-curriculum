---
id: 662fa453ec8033322b3ab2e3
title: Paso 8
challengeType: 20
dashedName: step-8
---

# --description--

Es hora de hablar sobre encapsulación y getters. Has escrito los tres atributos de instancia para que sean privados usando un doble guion bajo al inicio. Ten en cuenta que estos atributos se llaman privados por convención: aunque todavía se pueden acceder desde afuera, se acuerda no hacerlo.

Los getters son lo que se puede usar para obtener los valores desde afuera. Para definir un getter, defines un método que devuelve el valor del atributo deseado y le das un decorador `@property`:

```py
class Nest:
    ...
    @property
    def number_of_eggs(self):
        return self.__number_of_eggs
```

 El decorador convierte el método en una propiedad, lo que significa que el método no se llama como un método regular, sino que se usa como un atributo:

```py
n = Nest()
print(n.number_of_eggs)
```

En el ejemplo anterior, el atributo privado `__number of eggs` se accede a través de la propiedad `number_of_eggs` de `n`.

Crea un getter llamado `speed` y haz que retorne el valor del atributo privado `__speed`.

# --hints--

Debes definir un método `speed`.

```js
({test: () => assert(runPython(`
_Node(_code).find_class('Projectile').has_function('speed')
`))})
```

Tu método `speed` debe tener un solo parámetro, `self`.

```js
({test: () => assert(runPython(`
_Node(_code).find_class('Projectile').find_function('speed').has_args('self')
`))})
```

Tu método `speed` debe tener un decorador `@property`.

```js
({test: () => assert(runPython(`
_Node(_code).find_class('Projectile').find_function('speed').has_decorators('property')
`))})
```

Tu método `speed` debe devolver el valor del atributo privado `__speed`.

```js
({test: () => assert(runPython(`
a = Projectile(22, 23, 24)
a.speed == 22
`))})
```

# --seed--

## --seed-contents--

```py
import math

GRAVITATIONAL_ACCELERATION = 9.81
PROJECTILE = "∙"
x_axis_tick = "T"
y_axis_tick = "⊣"

class Projectile:
    __slots__ = ('__speed', '__height', '__angle')

    def __init__(self, speed, height, angle):
        self.__speed = speed
        self.__height = height
        self.__angle = math.radians(angle)
        
    def __str__(self):
        return f'''
Projectile details:
speed: {self.__speed} m/s
height: {self.__height} m
angle: {round(math.degrees(self.__angle))}°
displacement: {round(self.__calculate_displacement(), 1)} m
'''

    def __calculate_displacement(self):
        horizontal_component = self.__speed * math.cos(self.__angle)
        vertical_component = self.__speed * math.sin(self.__angle)
        squared_component = vertical_component**2
        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height
        sqrt_component = math.sqrt(squared_component + gh_component)
        
        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION
        
    def __calculate_y_coordinate(self, x):
        height_component = self.__height
        angle_component = math.tan(self.__angle) * x
        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (
                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)
        y_coordinate = height_component + angle_component - acceleration_component

        return y_coordinate
    
    def calculate_all_coordinates(self):
        return [
            (x, self.__calculate_y_coordinate(x))
            for x in range(math.ceil(self.__calculate_displacement()))
        ]

--fcc-editable-region--
    
--fcc-editable-region--

ball = Projectile(10, 3, 45)
print(ball)
coordinates = ball.calculate_all_coordinates()
   
```
