---
id: 697dc755c709772fad37dea0
title: ¿Cómo funcionan las colas de prioridad y los heaps?
challengeType: 19
dashedName: how-do-priority-queues-and-heaps-work
---

# --description--

Una **cola de prioridad** es un tipo abstracto de datos (ADT) que funciona de manera similar a una cola o pila, pero con una diferencia clave.

Como ya sabrás, las colas estándar siguen un enfoque FIFO (First-in, First-out), donde el primer elemento agregado a la cola es el primero en ser eliminado de la cola.

Las pilas siguen un enfoque LIFO (Last-in, First-out), donde el último elemento agregado a la pila es el primero en ser removido de la pila.

Las colas y pilas solo consideran el orden de inserción de los elementos.

Sin embargo, las colas de prioridad toman en cuenta la "prioridad" de los elementos. La prioridad se usa para determinar qué elemento debe ser eliminado a continuación.

Normalmente, el elemento con la prioridad más alta se elimina primero, pero algunas implementaciones también pueden elegir eliminar primero el elemento con la prioridad más baja. Esto dependerá de los requisitos de tu programa.

Las colas de prioridad son muy útiles para aplicaciones prácticas como encontrar el camino más corto entre dos ubicaciones, programar tareas en sistemas operativos, simular el tráfico, comprimir datos y gestionar redes.

En la práctica, las colas de prioridad se implementan comúnmente usando una estructura de datos heap.

Un **heap** es una estructura de datos en forma de árbol con una propiedad muy específica llamada **heap property**. Esta propiedad determina la relación entre cada nodo y sus hijos, basada en el tipo de heap.

Hay dos tipos principales de heaps:

* Montículo máximo
    
* Montículo mínimo
    

En un **max-heap**, el valor de cada nodo es mayor o igual que el valor de sus hijos.

En este ejemplo, puedes ver una estructura de árbol con los nodos 8, 7, 5, 2 y 1. Observa que el nodo 7 es mayor que el nodo 2 y el nodo 1, siguiendo la propiedad heap. Esto es cierto para todos los demás nodos también.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-1.png" alt="A max-heap tree structure showing nodes with values 8 at the root, 7 and 5 as children of 8, and 2 and 1 as children of 7, demonstrating that each parent node is greater than its children.">

En contraste, en una **min-heap**, el valor de cada nodo es menor o igual que el valor de sus hijos.

En este ejemplo, tenemos nodos con valores 4, 7, 9, 12 y 15. Por ejemplo, el nodo 7 es menor que el nodo 12 y el nodo 15, siguiendo la propiedad del heap. Esto también es cierto para todos los demás nodos.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-2.png" alt="A min-heap tree structure showing nodes with values 4 at the root, 7 and 9 as children of 4, and 12 and 15 as children of 7, demonstrating that each parent node is less than its children.">

La propiedad heap es clave porque garantiza que el elemento máximo (o mínimo) (dependiendo del tipo de heap) siempre se mantenga en la cima, lo que hace que sea muy fácil de eliminar.

En la práctica, las heaps se implementan típicamente como arrays para acceder eficientemente a los nodos padre e hijo.

Usar arrays simplifica la lógica para acceder a estos valores o "nodos" porque detrás de escena, si el heap mantiene la estructura de un árbol binario completo, la implementación con array solo requiere operaciones matemáticas simples basadas en sus índices para encontrar dónde están ubicados los elementos en la memoria.

JavaScript no tiene un módulo de heap incorporado, pero puedes implementar un min-heap usando un array.

Aquí tienes una implementación básica de min-heap en JavaScript:

```js
class MinHeap {
  constructor(compare = (a, b) => a - b) {
    this.data = [];
    this.compare = compare;
  }

  peek() {
    return this.data[0];
  }

  push(value) {
    this.data.push(value);
    this.#bubbleUp(this.data.length - 1);
  }

  pop() {
    if (this.data.length === 0) return undefined;

    const top = this.data[0];
    const last = this.data.pop();

    if (this.data.length > 0) {
      this.data[0] = last;
      this.#bubbleDown(0);
    }

    return top;
  }

  pushPop(value) {
    if (this.data.length === 0) return value;

    if (this.compare(this.data[0], value) < 0) {
      const top = this.data[0];
      this.data[0] = value;
      this.#bubbleDown(0);
      return top;
    }

    return value;
  }

  heapify(arr) {
    this.data = arr.slice();
    for (let i = Math.floor(this.data.length / 2) - 1; i >= 0; i--) {
      this.#bubbleDown(i);
    }
  }

  #bubbleUp(i) {
    while (i > 0) {
      const p = Math.floor((i - 1) / 2);
      if (this.compare(this.data[i], this.data[p]) >= 0) break;
      [this.data[i], this.data[p]] = [this.data[p], this.data[i]];
      i = p;
    }
  }

  #bubbleDown(i) {
    const n = this.data.length;

    while (true) {
      let smallest = i;
      const l = 2 * i + 1;
      const r = 2 * i + 2;

      if (l < n && this.compare(this.data[l], this.data[smallest]) < 0) smallest = l;
      if (r < n && this.compare(this.data[r], this.data[smallest]) < 0) smallest = r;

      if (smallest === i) break;

      [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];
      i = smallest;
    }
  }
}
````

Para usar este heap, puedes crear un heap vacío. Esta será la estructura de datos subyacente para el heap:

```js
const myHeap = new MinHeap();
```

Para agregar elementos al heap, debes llamar a `push()`. Esto añadirá automáticamente el elemento donde debe estar, para preservar la propiedad del heap:

```js
myHeap.push(9);
```

Para obtener el elemento con la prioridad más baja (en este caso, el valor más pequeño), debes llamar a `pop()`:

```js
myHeap.pop();
```

`pushPop()` combina ambas operaciones en una sola llamada.

Esto es más eficiente que llamarlos en una secuencia por separado, especialmente cuando el heap es grande, ya que solo realiza una operación de reordenamiento:

```js
myHeap.pushPop(15);
```

Si ya tienes un arreglo y quieres transformarlo en un heap, podrías llamar a `heapify()`:

```js
myHeap.heapify([9, 2, 7, 1]);
```

Pero actualmente, estamos ordenando los elementos por sus valores, ¿verdad?

¿Qué pasa si queremos ordenarlos por su "priority" en su lugar?

Podrías hacer esto almacenando arreglos con esta estructura: `[priority, element]`.

En JavaScript, los arrays no se comparan automáticamente elemento por elemento para el orden, por lo que pasas una función de comparación al heap que compara primero las prioridades.

Ten en cuenta que, en este caso, los valores más bajos representarán prioridades más altas. Esto significa que un ítem con prioridad 1 tendrá una prioridad **más alta** que un ítem con prioridad 3:

```js
const myHeap = new MinHeap((a, b) => a[0] - b[0]);

myHeap.push([3, "A"]);
myHeap.push([2, "B"]);
myHeap.push([1, "C"]);
```

Si necesitas que los elementos con la misma prioridad se eliminen en el orden en que fueron insertados, podrías considerar incluir un contador único como el segundo elemento de tu ítem para desempatar, así: `[priority, counter, element]`.

Por ejemplo, puedes comparar primero por prioridad y luego por el contador:

```js
let counter = 0;
const myHeap = new MinHeap((a, b) => (a[0] - b[0]) || (a[1] - b[1]));

myHeap.push([3, counter++, "A"]);
myHeap.push([2, counter++, "B"]);
myHeap.push([2, counter++, "C"]);
```

Ahora hablemos sobre la eficiencia de los heaps.

Las complejidades de tiempo promedio y en el peor caso para insertar y extraer el valor mínimo o máximo de un heap (dependiendo del tipo de heap) son logarítmicas, `O(log n)`, porque el número de intercambios requeridos suele ser proporcional a la altura del heap, que es log(n).

La complejidad temporal promedio y en el peor caso para la operación "peek" es tiempo constante, O(1). Hacer peek implica obtener el valor mínimo o máximo (dependiendo del tipo de heap) sin eliminarlo.

La operación de "heapify", donde la heap se construye a partir de una lista desordenada, tiene una complejidad de tiempo lineal, O(n), en los casos promedio y peor.

De manera similar, tanto buscar como eliminar un elemento arbitrario tienen complejidades de tiempo promedio y en el peor caso lineales de O(n), ya que potencialmente requieren recorrer todo el heap.

¿Y cuánto espacio requieren?

La complejidad espacial del heap es lineal, O(n), donde `n` es el número de elementos que contiene. Solo necesita almacenar los elementos y una pequeña sobrecarga adicional para el objeto array en sí.

Las colas de prioridad y los montículos son muy importantes en la informática. Te permiten encontrar y usar rápidamente los elementos más importantes de una lista. Esta eficiencia es crucial para muchos programas de computadora que realizan tareas críticas en el mundo real, como encontrar la ruta más rápida en un mapa.

# --questions--

## --text--

¿Cuál es la característica principal que distingue a una cola de prioridad de una cola o pila estándar?

## --answers--

Permite que los elementos sean accedidos por su índice.

### --feedback--

Piensa en el factor principal que determina qué elemento se elimina a continuación.

---

Siempre procesa los elementos en el orden en que fueron insertados.

### --feedback--

Piensa en el factor principal que determina qué elemento se elimina a continuación.

---

Recupera elementos basándose en una prioridad asignada.

---

Solo almacena elementos del mismo tipo de datos.

### --feedback--

Piensa en el factor principal que determina qué elemento se elimina a continuación.

## --video-solution--

3

## --text--

¿Cuál de las siguientes es una aplicación común en el mundo real donde una cola de prioridad sería útil?

## --answers--

Programación de tareas en un sistema operativo donde algunas tareas son más urgentes.

---

Gestionando una lista de reproducción donde las canciones se reproducen en un orden fijo.

### --feedback--

Piensa en escenarios donde algunos elementos son más importantes y necesitan ser manejados primero.

---

Almacenar una lista de artículos de supermercado.

### --feedback--

Piensa en escenarios donde algunos elementos son más importantes y necesitan ser manejados primero.

---

Llevar un registro de los nombres de clientes en orden alfabético.

### --feedback--

Piensa en escenarios donde algunos elementos son más importantes y necesitan ser manejados primero.

## --video-solution--

1

## --text--

¿Cuál es la razón principal por la que las heaps se implementan típicamente como arrays en la práctica, a pesar de ser conceptualizadas como árboles?

## --answers--

Los arrays siempre son más rápidos que cualquier otra estructura de datos.

### --feedback--

Piensa en cómo la estructura en forma de árbol de un heap puede mapearse eficientemente a una estructura de datos lineal.

---

Los arrays simplifican la lógica para acceder a nodos padre e hijo usando fórmulas matemáticas.

---

Los arrays permiten el acceso aleatorio directo a cualquier elemento, que es una operación fundamental del heap.

### --feedback--

Piensa en cómo la estructura en forma de árbol de un heap puede mapearse eficientemente a una estructura de datos lineal.

---

Los arrays son la única estructura de datos que puede garantizar la propiedad heap.

### --feedback--

Piensa en cómo la estructura en forma de árbol de un heap puede mapearse eficientemente a una estructura de datos lineal.

## --video-solution--

2
