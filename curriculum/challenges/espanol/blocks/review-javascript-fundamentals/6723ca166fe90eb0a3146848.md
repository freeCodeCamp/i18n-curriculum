---
id: 6723ca166fe90eb0a3146848
title: Revisión de Fundamentos de JavaScript
challengeType: 31
dashedName: review-javascript-fundamentals
---

# --interactive--

## Constructor de Cadenas y Método `toString()`

- **Definición**: Un objeto cadena se utiliza para representar una secuencia de caracteres. Los objetos cadena se crean utilizando la función constructora `String`, que envuelve el valor primitivo en un objeto.

:::interactive_editor

```js
const greetingObject = new String("Hello, world!");

console.log(typeof greetingObject); // "object"
```

:::

- **Método `toString()`**: Este método convierte un valor a su representación en cadena. Es un método que se puede utilizar para números, booleanos, arreglos y objetos.

:::interactive_editor

```js
const num = 10;
console.log(num.toString()); // "10"

const arr = [1, 2, 3];
console.log(arr.toString()); // "1,2,3"
```

:::

Este método acepta un radix opcional, que es un número de 2 a 36. Este radix representa la base, como la base 2 para binario o base 8 para octal. Si no se especifica el radix, por defecto será base 10, que es decimal.


:::interactive_editor

```js
const num = 10;
console.log(num.toString(2)); // "1010"(binary)
```

:::

## Constructor de Números

- **Definición**: El constructor `Number` se utiliza para crear un objeto número. El objeto número contiene algunas propiedades y métodos útiles como los métodos `isNaN` y `toFixed`. La mayor parte del tiempo, utilizarás el constructor `Number` para convertir otros tipos de datos al tipo de datos número.

:::interactive_editor

```js
const myNum = new Number("34");
console.log(typeof myNum); // "object"

const num = Number('100');
console.log(num); // 100

console.log(typeof num); // number
```

:::

## Mejores Prácticas para Nombrar Variables y Funciones

- **camelCasing**: Por convención, los desarrolladores de JavaScript usarán camel case para nombrar variables y funciones. El camel casing es donde la primera palabra está en minúsculas y las siguientes palabras comienzan con mayúscula.  Ex. `isLoading`.

- **Nombrar Booleanos**: Para variables booleanas, es una práctica común usar prefijos como "is", "has" o "can".

```js
let isLoading = true;
let hasPermission = false;
let canEdit = true;
```

- **Nombrar Funciones**: Para las funciones, el nombre debe indicar claramente qué hace la función. Para las funciones que devuelven un valor booleano (a menudo llamadas predicados), puedes usar los mismos prefijos "is", "has" o "can". Cuando tengas funciones que recuperan datos, es común comenzar con la palabra "get". Cuando tienes funciones que establecen datos, es común comenzar con la palabra "establecer". Para funciones manejadoras de eventos, podrías usar prefijos como "handle" o sufijos como "Handler".

```js
function getUserData() { /* ... */ }

function isValidEmail(email) { /* ... */ }

function getProductDetails(productId) { /* ... */ }

function setUserPreferences(preferences) { /* ... */ }

function handleClick() { /* ... */ }
```

- **Nombrar Variables Dentro de Bucles**: Al nombrar variables iteradoras en bucles, es común usar letras simples como `i`, `j` o `k`.

```js
for (let i = 0; i < array.length; i++) { /* ... */ }
```

## Trabajar con Arreglos Dispersos

- **Definición**: Es posible tener arreglos con espacios vacíos. Los espacios vacíos se definen como espacios sin nada dentro. Esto es diferente de los espacios de arreglos con el valor de `undefined`. Estos tipos de matrices se conocen como matrices dispersas.

:::interactive_editor

```js
const sparseArray = [1, , , 4];
console.log(sparseArray.length); // 4
```

:::

## Linters y Formateadores

- **Linters**: Un linter es una herramienta de análisis estático de código que señala errores de programación, errores estilísticos y estructuras sospechosas. Un ejemplo de linter común sería ESLint.
- **Formateadores**: Los formateadores son herramientas que formatean automáticamente tu código para adherirse a un guía de estilo específico. Un ejemplo de formateador común sería Prettier.

## Gestión de Memoria

- **Definición**: La gestión de memoria es el proceso de controlar la memoria, asignándola cuando se necesita y liberándola cuando ya no se necesita. JavaScript utiliza gestión automática de memoria.  This means that JavaScript (more specifically, the JavaScript engine in your web browser) takes care of memory allocation and deallocation for you.  You don't have to explicitly free up memory in your code. Este proceso automático a menudo se llama "recolección de basura".

## Clausuras

- **Definición**: Una clausura es una función que tiene acceso a variables en su ámbito léxico exterior (cercano), incluso después de que la función exterior haya retornado.

:::interactive_editor

```js
function outerFunction(x) {
  let y = 10;
  function innerFunction() {
    console.log(x + y);
  }
  return innerFunction;
}

let closure = outerFunction(5);
closure(); // 15
```

:::

## Palabra Clave `var` y Elevación

- **Definición**: `var` fue la forma original de declarar variables antes de 2015. Pero hubo algunos problemas que vinieron con `var` en términos de ámbito, redeclaración y más. Por eso, la programación moderna de JavaScript usa `let` y `const` en su lugar.
- **Redeclaring Variables with `var`**: Si intentas redeclarar una variable usando `let`, recibirías un `SyntaxError`. Pero con `var`, puedes redeclarar una variable.

```js
// Uncaught SyntaxError: Identifier 'num' has already been declared 
let num = 19;
let num = 18;

var myNum = 5;
var myNum = 10; // This is allowed and doesn't throw an error

console.log(myNum) // 10
```

- **`var` y Ámbito**: Las variables declaradas con `var` dentro de un bloque (como una declaración `if` o un bucle `for`) aún son accesibles fuera de ese bloque.

:::interactive_editor

```js
if (true) {
  var num = 5;
}
console.log(num); // 5
```

:::

- **Elevación**: Este es el comportamiento predeterminado de JavaScript de mover declaraciones al principio de sus respectivos ámbitos durante la fase de compilación antes de que el código se ejecute. Cuando declaras una variable usando la palabra clave `var`, JavaScript eleva la declaración a la cima de su ámbito.

:::interactive_editor

```js
console.log(num); // undefined
var num = 5;
console.log(num); // 5
```

:::

Cuando declaras una función usando la sintaxis de declaración de función, tanto el nombre de la función como el cuerpo de la función se elevan. Esto significa que puedes llamar a una función antes de haberla declarado en tu código.

:::interactive_editor

```js
sayHello(); // "Hello, World!"

function sayHello() {
  console.log("Hello, World!");
}
```

:::

Las declaraciones de variables hechas con `let` o `const` se elevan, pero no se inicializan, y no puedes acceder a ellas antes de la declaración real en tu código. Este comportamiento a menudo se refiere como la "zona temporalmente muerta".

:::interactive_editor

```js
console.log(num); // Throws a ReferenceError
let num = 10;
```

:::

## Trabajar con Importaciones, Exportaciones y Módulos

- **Módulo**: Este es una unidad de código autónoma que encapsula funciones, clases o variables relacionadas. Para crear un módulo, escribes tu código JavaScript en un archivo separado.
- **Exportaciones**: Cualquier variable, función o clase que deseas poner a disposición de otras partes de tu aplicación necesitas exportarla explícitamente usando la palabra clave `export`. Hay dos tipos de exportación: exportación nombrada y exportación por defecto.
- **Importaciones**: Para utilizar los elementos exportados en otra parte de tu aplicación, necesitas importarlos usando la palabra clave `import`. Los tipos pueden ser importación nombrada, importación por defecto e importación de espacio de nombres.

```js
// Within a file called math.js, we export the following functions:

// Named export
export function add(num1, num2) {
  return num1 + num2;
}

// Default export
export default function subtract(num1, num2) {
  return num1 - num2;
}

// Within another file, we can import the functions from math.js.

// Named import - This line imports the add function.
// The name of the function must exactly match the one exported from math.js.
import { add } from './math.js';

// Default import - This line imports the subtract function.
// The name of the function can be anything.
import subtractFunc from './math.js';

// Namespace import - This line imports everything from the file.
import * as Math from './math.js';

console.log(add(5, 3)); // 8
console.log(subtractFunc(5, 3)); // 2
console.log(Math.add(5, 3)); // 8
console.log(Math.subtract(5, 3)); // 2
```

# --assignment--

Revise los temas y conceptos fundamentales de JavaScript.
