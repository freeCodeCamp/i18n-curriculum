---
id: 5e44414f903586ffb414c950
title: 创建概率计算器项目
challengeType: 23
saveSubmissionToDB: true
forumTopicId: 462364
dashedName: build-a-probability-calculator-project
---

# --description--

假设有一顶帽子，里面有 5 个蓝球、4 个红球和 2 个绿球。 随机抽取的 4 个球中至少包含 1 个红球和 2 个绿球的概率是多少？ 虽然可以使用先进的数学计算概率， 一种较容易的方法是编写一个程序来进行大量的实验，以估计大致的概率。

对于这个项目，你将编写一个程序来确定从帽子中随机抽取某些球的大致概率。

首先，在`main.py`中创建一个`Hat`类。 该类应接受可变数量的参数，这些参数指定帽子中每种颜色的球的数量。 例如，类对象可以通过以下任何一种方式创建：

```py
hat1 = Hat(yellow=3, blue=2, green=6)
hat2 = Hat(red=5, orange=4)
hat3 = Hat(red=5, orange=4, black=1, blue=0, pink=2, striped=9)
```

帽子总是至少有一个球。  The arguments passed into the hat object upon creation should be converted to a `contents` instance variable. `contents` should be a list of strings containing one item for each ball in the hat. 列表中的每个项目都应该是一个颜色名称，代表该颜色的单个球。 例如，如果你的帽子是`{'red': 2, 'blue': 1}`，`contents`应该是 `['red', 'red', 'blue']`.

`Hat`类应该有一个`draw`方法，该方法接受一个参数，该参数指示从帽子中抽取的球的数量。 此方法应该从`contents`中随机删除球，并将这些球作为字符串列表返回。 在抽签过程中，球不应该回到帽子里，类似于不更换的瓮实验。 如果要抽取的球数超过可用数量，请退回所有球。

接下来，在`main.py`中创建一个`experiment`函数（不在`Hat`类中）。 此函数应接受以下参数：

- `hat`：一个包含应该在函数内复制的球的帽子对象。
- `expected_balls`：一个对象，指示尝试从帽子中抽取的确切球组以进行实验。 例如，要确定从帽子中抽出2个蓝色球和1个红色球的概率，请将`expected_balls`设置为`{'blue':2, 'red':1}`。
- `num_balls_drawn`：每次实验中从帽子中抽出的球数。
- `num_experiments`：要执行的实验次数。（执行的实验越多，近似概率越准确。）

`experiment`函数应该返回一个概率。

例如，如果你想确定当你从一顶包含六个黑色、四个红色和三个绿色的帽子中抽出五个球时，得到至少两个红色球和一个绿色球的概率。 要做到这一点，你将执行`N`次实验，计算获得至少两个红球和一个绿球的次数`M`，并将概率估计为`M/N`。 每个实验都包括从一顶装有指定球的帽子开始，画几个球，并检查你是否得到了你试图画的球。

以下是根据上面的2000个实验示例调用`experiment`函数的方法：

```py
hat = Hat(black=6, red=4, green=3)
probability = experiment(hat=hat,
                  expected_balls={'red':2,'green':1},
                  num_balls_drawn=5,
                  num_experiments=2000)
```

输出如下：

```bash
0.356
```

由于这是基于随机抽取的，因此每次运行代码时概率会略有不同。

*提示：考虑使用顶部已经导入的模块。不要在文件内初始化随机种子。*

注意：使用F12打开浏览器控制台，查看更详细的测试输出。

# --hints--

创建`hat`对象应添加正确的内容。

```js
({
  test: () => {
    pyodide.FS.writeFile("/home/pyodide/probability_calculator.py", code);
    pyodide.FS.writeFile(
      "/home/pyodide/test_module.py",
      `
import unittest
import probability_calculator
from importlib import reload

reload(probability_calculator)

probability_calculator.random.seed(95)
class UnitTests(unittest.TestCase):
    maxDiff = None
    def test_hat_class_contents(self):
        hat = probability_calculator.Hat(red=3,blue=2)
        actual = hat.contents
        expected = ["red","red","red","blue","blue"]
        self.assertEqual(actual, expected, 'Expected creation of hat object to add correct contents.')
        `
    );
    const testCode = `
from unittest import main
import test_module
from importlib import reload

reload(test_module)
t = main(module='test_module', exit=False)
t.result.wasSuccessful()
`;
    const out = runPython(testCode);
    assert(out);
  },
});
```

`hat`类中`draw`方法应减少内容中的项目数。


```js
({
  test: () => {
    pyodide.FS.writeFile("/home/pyodide/probability_calculator.py", code);
    pyodide.FS.writeFile(
      "/home/pyodide/test_module.py",
      `
import unittest
import probability_calculator
from importlib import reload

reload(probability_calculator)

probability_calculator.random.seed(95)

class UnitTests(unittest.TestCase):
    maxDiff = None
    def test_hat_draw(self):
        hat = probability_calculator.Hat(red=5,blue=2)
        actual = hat.draw(2)
        expected = ['blue', 'red']
        self.assertEqual(actual, expected, 'Expected hat draw to return two random items from hat contents.')
        actual = len(hat.contents)
        expected = 5
        self.assertEqual(actual, expected, 'Expected hat draw to reduce number of items in contents.')
        `
    );
    const testCode = `
from unittest import main
import test_module
from importlib import reload

reload(test_module)
t = main(module='test_module', exit=False)
t.result.wasSuccessful()
`;
    const out = runPython(testCode);
    assert(out);
  },
});
```

当要提取的球数大于帽子中的球数时，`draw`方法应正确运行。

```js
({
  test: () => {
    pyodide.FS.writeFile("/home/pyodide/probability_calculator.py", code);
    pyodide.FS.writeFile(
      "/home/pyodide/test_module.py",
      `
import unittest
import probability_calculator
from importlib import reload

reload(probability_calculator)

probability_calculator.random.seed(95)
class UnitTests(unittest.TestCase):
    maxDiff = None
    def test_hat_draw_2(self):
        hat = probability_calculator.Hat(yellow=5,red=1,green=3,blue=9,test=1)
        actual = sorted(hat.draw(20))
        expected = sorted(['yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'red', 'green', 'green', 'green', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'test'])
        self.assertEqual(actual, expected, 'Expected hat draw to return all items from hat contents.')
        actual = len(hat.contents)
        expected = 0
        self.assertEqual(actual, expected, 'Expected hat draw to leave no items in contents.')
        `
    );
    const testCode = `
from unittest import main
import test_module
from importlib import reload

reload(test_module)
t = main(module='test_module', exit=False)
t.result.wasSuccessful()
`;
    const out = runPython(testCode);
    assert(out);
  },
});
```

`experiment`方法应该返回不同的概率。


```js
({
  test: () => {
    pyodide.FS.writeFile("/home/pyodide/probability_calculator.py", code);
    pyodide.FS.writeFile(
      "/home/pyodide/test_module.py",
      `
import unittest
import probability_calculator
from importlib import reload

reload(probability_calculator)

probability_calculator.random.seed(95)
class UnitTests(unittest.TestCase):
    maxDiff = None
    def test_prob_experiment(self):
        hat = probability_calculator.Hat(blue=3,red=2,green=6)
        probability = probability_calculator.experiment(hat=hat, expected_balls={"blue":2,"green":1}, num_balls_drawn=4, num_experiments=1000)
        actual = probability
        expected = 0.272
        self.assertAlmostEqual(actual, expected, delta = 0.01, msg = 'Expected experiment method to return a different probability.')
        hat = probability_calculator.Hat(yellow=5,red=1,green=3,blue=9,test=1)
        probability = probability_calculator.experiment(hat=hat, expected_balls={"yellow":2,"blue":3,"test":1}, num_balls_drawn=20, num_experiments=100)
        actual = probability
        expected = 1.0
        self.assertAlmostEqual(actual, expected, delta = 0.01, msg = 'Expected experiment method to return a different probability.')
        `
    );
    const testCode = `
from unittest import main
import test_module
from importlib import reload

reload(test_module)
t = main(module='test_module', exit=False)
t.result.wasSuccessful()
`;
    const out = runPython(testCode);
    assert(out);
  },
});
```

# --seed--

## --seed-contents--

```py
import copy
import random

class Hat:
    pass

def experiment(hat, expected_balls, num_balls_drawn, num_experiments):
    pass
```

# --solutions--

```py
import copy
import random

class Hat:
    def __init__(self, **hat):
        self.hat = hat
        contents = []
        for i in hat:
            for j in range(hat[i]):
                contents.append(i)           
        self.contents = contents
               

    def draw(self, number): 
        drawn = []
        if number >= len(self.contents):
            drawn.extend(self.contents)
            self.contents = []
        else:
            for i in range(number):
                drawn.append(
                    self.contents.pop(random.randrange(len(self.contents)))
                )                
        return drawn

def experiment(hat, expected_balls, num_balls_drawn, num_experiments):    
    expected_balls_list = []
    drawn_list = []
    success = 0
    for i in expected_balls:
        for j in range(expected_balls[i]):
            expected_balls_list.append(i)
    for j in range(num_experiments):
        hat_copy = copy.deepcopy(hat)
        drawn_list.append(hat_copy.draw(num_balls_drawn))        
        exp_ball_list_copy = expected_balls_list[:]
        for k in range(len(drawn_list[j])):
            try:
                ind = exp_ball_list_copy.index(drawn_list[j][k])
                exp_ball_list_copy.pop(ind)
            except:
                continue
        if len(exp_ball_list_copy) == 0:
            success += 1        
    probability = success/num_experiments    
    return probability
```
