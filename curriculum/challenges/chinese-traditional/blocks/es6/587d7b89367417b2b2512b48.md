---
id: 587d7b89367417b2b2512b48
title: 使用展開運算子就地評估陣列
challengeType: 1
forumTopicId: 301222
dashedName: use-the-spread-operator-to-evaluate-arrays-in-place
---

# --description--

ES6 介紹了 <dfn>展開運算子</dfn>，它允許我們在期望多個參數或元素的地方展開陣列和其他表達式。

以下 ES5 程式碼使用 `apply()` 來計算陣列中的最大值：

```js
var arr = [6, 89, 3, 45];
var maximus = Math.max.apply(null, arr);
```

`maximus` 的值會是 `89`。

我們必須使用 `Math.max.apply(null, arr)`，因為 `Math.max(arr)` 傳回 `NaN`。`Math.max()` 預期的是以逗號分隔的引數，而不是陣列。展開運算子讓這個語法更容易閱讀和維護。

```js
const arr = [6, 89, 3, 45];
const maximus = Math.max(...arr);
```

`maximus` 的值會是 `89`。

`...arr` 傳回一個展開的陣列。換句話說，它會展開陣列。然而，展開運算子只會在原地生效，例如在函式的引數中或在陣列字面值中。<dfn>例如</dfn>：

```js
const spreaded = [...arr];
```

但是，以下程式碼將無法運作：

```js
const spreaded = ...arr;
```

# --instructions--

使用展開運算子將 `arr1` 的所有內容複製到另一個陣列 `arr2`。

# --hints--

`arr2` 應該是 `arr1` 的正確複本。

```js
assert(arr2.every((v, i) => v === arr1[i]) && arr2.length);
```

`...` 展開運算子應該用來複製 `arr1`。

```js
assert(__helpers.removeJSComments(code).match(/Array\(\s*\.\.\.arr1\s*\)|\[\s*\.\.\.arr1\s*\]/));
```

當 `arr1` 被更改時，`arr2` 應保持不變。

```js
assert((arr1, arr2) => {
  arr1.push('JUN');
  return arr2.length < arr1.length;
});
```

# --seed--

## --seed-contents--

```js
const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];
let arr2;

arr2 = [];  // Change this line

console.log(arr2);
```

# --solutions--

```js
const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];
let arr2;

arr2 = [...arr1];
```
