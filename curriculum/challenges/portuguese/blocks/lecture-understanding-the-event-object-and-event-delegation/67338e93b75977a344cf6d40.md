---
id: 67338e93b75977a344cf6d40
title: Como Funcionam o Event Bubbling e o Event Delegation?
challengeType: 19
dashedName: how-do-event-bubbling-and-event-delegation-work
---

# --description--

Event bubbling, ou propagação, refere-se a como um evento "bubbles up" para objetos pai quando acionado. Por exemplo, considere este código:

```html
<p>
  <span>Click me~!</span>
</p>
```

O elemento `p` aqui seria considerado o pai do elemento `span`. 

Quando você clica no elemento `span`, como foi instruído, o elemento `span` se torna o alvo de um evento `click`. Esse evento, no entanto, também sobe para o elemento pai – o elemento `p` pode receber e consumir esse evento conforme necessário.

Mas o que isso realmente significa? Bem, você poderia anexar um listener de evento ao elemento `p`:

```js
const p = document.querySelector("p");
p.addEventListener("click", (event) => {
  console.log(event.target);
});
```

Então, quando você clicar no elemento `span` você verá o texto `Click me~!` registrado no console.

O evento se propaga para o elemento pai `p`, que o consome em um listener de evento para exibir o alvo do evento. 

Note como o alvo ainda é o elemento `span`. Isso ocorre porque o elemento `span` recebeu o clique inicial.

Só para ter certeza de como as coisas estão funcionando, vamos expandir nosso código:

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {
  console.log("P listener: ");
  console.log(event.target);
});
span.addEventListener("click", (event) => {
  console.log("Span listener: ");
  console.log(event.target);
});
```

Para te dar uma ideia de como o evento propaga, aqui está o que você verá no console após clicar no elemento `span`:

```html
"Span listener: "
<span>Click me~!</span>
"P listener: "
<span>Click me~!</span>
```

Agora vamos ver o que acontece quando você impede a propagação de um evento com `stopPropagation()`. Chamaremos isso no listener de eventos do nosso `span`:

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {
  console.log("P listener: ");
  console.log(event.target);
});
span.addEventListener("click", (event) => {
  console.log("Span listener: ");
  console.log(event.target);
  event.stopPropagation();
});
```

E então clique novamente no nosso `span`:

```html
"Span listener: "
<span>Click me~!</span>
```
 
Desta vez, não vemos nosso listener `p` ser acionado. O evento nunca é disparado para o elemento `p`, porque dissemos para ele parar a propagação enquanto estava sendo processado para o elemento filho `span`.

A delegação de eventos pode ser vista como o oposto. É o processo de pegar um evento capturado e delegá-lo para outro elemento. 

Voltando ao nosso código, vamos atualizá-lo para que clicar em um elemento `span` o altere para vermelho:

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {});
span.addEventListener("click", (event) => {
  event.target.style.color = "red";
});
```

Mas e se você tiver vinte elementos `span`? Ou talvez você use JavaScript para criar mais elementos `span` dinamicamente?

Ao invés de ter que anexar um listener de evento a cada elemento `span`, você pode na verdade usar o listener no elemento `p` para todos eles. Em outras palavras, você pode delegar o tratamento dos cliques em `span` para o elemento pai `p`.

Nosso código agora pode parecer algo assim:

```js
const p = document.querySelector("p");
p.addEventListener("click", (event) => {
  event.target.style.color = "red";
});
```

Note como não temos mais nenhum listener anexado ao elemento `span`. Você delegou corretamente o tratamento de eventos para o elemento `p`. Mas funciona?

Vamos gerar alguns elementos `span` extras e ver:

```html
<p>
  <span>Click me~!</span>
  <span>Click me~!</span>
  <span>Click me~!</span>
  <span>Click me~!</span>
</p>
```

Agora, cada vez que clicarmos em um `span`, o texto desse elemento ficará vermelho. 

E assim, com um único event listener, permitimos corretamente que um evento `click` propague dos elementos `span` para o elemento pai `p` e delegamos a lógica para esse evento `click` ao elemento `p`.

A propagação e delegação de eventos podem ser um tópico complexo, especialmente quando você trabalha com elementos profundamente aninhados como tabelas. Você é incentivado a explorar isso mais a fundo e experimentar com parte do código que escrevemos aqui.


# --questions--

## --text--

O que é event bubbling em JavaScript?

## --answers--

O processo de criação de novos eventos.

### --feedback--

Pense em como a lição descreve a "direção" da propagação do evento.

---

A forma como um evento viaja dos elementos filhos para os elementos pais.

---

Um método para prevenir o comportamento padrão de eventos.

### --feedback--

Pense em como a lição descreve a "direção" da propagação do evento.

---

O processo de anexar múltiplos event listeners a um único elemento.

### --feedback--

Pense em como a lição descreve a "direção" da propagação do evento.

## --video-solution--

2

## --text--

Qual é o propósito do método `stopPropagation()`?

## --answers--

Para impedir o comportamento padrão de um evento.

### --feedback--

A lição demonstra o efeito desse método no event bubbling.

---

Para remover todos os event listeners de um elemento.

### --feedback--

A lição demonstra o efeito desse método no event bubbling.

---

Para impedir que um evento propague para elementos pai.

---

Delegar o tratamento de eventos para elementos filhos.

### --feedback--

A lição demonstra o efeito desse método no event bubbling.

## --video-solution--

3

## --text--

Qual é a principal vantagem de usar delegação de eventos?

## --answers--

Ele permite que eventos subam para elementos pai.

### --feedback--

Considere o exemplo com múltiplos elementos `span` e como o tratamento de eventos foi simplificado.

---

Ele previne o comportamento padrão dos eventos.

### --feedback--

Considere o exemplo com múltiplos elementos `span` e como o tratamento de eventos foi simplificado.

---

Ele reduz o número de event listeners necessários para múltiplos elementos.

---

Ele para a propagação do evento automaticamente.

### --feedback--

Considere o exemplo com múltiplos elementos `span` e como o tratamento de eventos foi simplificado.

## --video-solution--

3
