---
id: 688291b65db00473e1136725
title: O que é CI/CD e como o CI funciona com o GitHub Actions?
challengeType: 19
dashedName: what-is-ci-cd-and-how-does-ci-work-with-github-actions
---

# --description--

CI significa Integração Contínua e CD significa Entrega Contínua ou Implantação Contínua. Juntos, esses processos permitem que você implante automaticamente as alterações na sua aplicação após garantir que essas alterações estejam funcionais.

Em um pipeline de CI, você pode executar seu linter e testes contra o código. Pipelines de CI normalmente são executados em pull requests para garantir que as alterações feitas não estejam quebrando o app e também na branch `main` para garantir que ela esteja pronta para deploy.

Um pipeline de CD também pode ser executado em pull requests, se você configurar um ambiente de preview para poder ver as mudanças ao vivo. Mas você também o executará na sua branch `main` para implantar continuamente as mudanças conforme elas são aceitas e mescladas.

Mas como esses realmente funcionam com o GitHub Actions? Primeiro, precisamos entender o que o GitHub Actions realmente é. O GitHub Actions fornece runners efêmeros (pense como um computador temporário) que permitem executar comandos específicos.

As ações são configuradas com um arquivo YAML. Você pode ter vários arquivos para especificar diferentes ações a serem executadas. Por exemplo, você pode ter um arquivo para seu CI e outro para seu CD.

Vamos dar uma olhada em um exemplo básico de CI:

```yml
name: Node.js CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  lint:
    name: Lint and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Source Files
        uses: actions/checkout@v4

      - name: Use Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10

      - name: Install Dependencies
        run: pnpm install

      - name: Lint Source Files
        run: pnpm run lint

      - name: Verify Build
        run: pnpm run build

      - name: Run Tests
        run: pnpm run test
```

Isso é muito, então vamos dividir. Olhando para a primeira seção:

```yml
name: Node.js CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
```

O `name` define o nome da própria ação. Isso aparece em áreas como a seção de verificações de status de um PR. As propriedades `on` definem o que é chamado de "workflow triggers" - esses são os eventos que irão acionar sua ação para ser executada.

Neste exemplo, executamos a ação quando commits são enviados para `main` e quando um pull request tem como alvo `main`. Isso significa que o CI é executado quando alguém cria um pull request e novamente quando o mesclamos.

A seção `jobs` é onde você define o que sua action realmente faz. A chave `lint:` é uma chave arbitrária que define o nome interno para esse job. A propriedade `name` define o nome externo para este job em particular. E a propriedade `runs-on` define em que tipo de ambiente sua action deve ser executada - neste caso, estamos executando na versão mais recente suportada do Ubuntu.

A propriedade `steps` é onde a mágica acontece. Este bloco define os passos reais que sua ação deve executar. Vamos dar uma olhada no primeiro bloco ali:

```yml
      - name: Checkout Source Files
        uses: actions/checkout@v4
```

Esta etapa tem duas propriedades, o `name` que a etapa deve ter, e uma propriedade `uses`. Esta propriedade `uses` é especial, pois ela instrui o executor de ações a buscar uma ação pública do GitHub e executá-la, em vez de executar um comando. A ação `actions/checkout` lida com o clone e a configuração do repositório dentro do seu executor.

```yml
      - name: Use Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10
```

Os próximos dois blocos também usam ações de terceiros. Essas etapas configuram o Node e o gerenciador de pacotes pnpm. Ambos têm uma chave `with`, que você pode usar para passar argumentos para essas ações de terceiros. Pense nisso como passar argumentos para uma função.

Os quatro blocos finais são onde a mágica realmente acontece.

```yml
      - name: Install Dependencies
        run: pnpm install

      - name: Lint Source Files
        run: pnpm run lint

      - name: Verify Build
        run: pnpm run build

      - name: Run Tests
        run: pnpm run test
```

Temos um bloco `Install Dependencies`, que instala os pacotes npm. Nosso bloco `Lint Source Files` executa o linter, o bloco `Verify Build` garante que o código Typescript possa ser compilado e o bloco `Run Tests` executa os testes unitários.

O importante a saber sobre ações é que, por padrão, se uma dessas etapas falhar as restantes serão ignoradas e toda a execução será marcada como uma falha.

Onde você coloca seus arquivos YAML para poder executar essas ações? Eles precisam estar em um diretório `.github/workflows` no seu repositório para que o GitHub os encontre e utilize.

Existem muitas outras coisas que as actions podem fazer e eu incentivo você a ler a documentação e explorar actions existentes em projetos como o repositório freeCodeCamp. Mas por enquanto, você deve ter uma boa compreensão dos conceitos básicos de GitHub Actions e CI/CD!

# --questions--

## --text--

O que a propriedade on define em um arquivo de workflow do GitHub Actions?

## --answers--

O nome da ação.

### --feedback--

Pense em quando você quer que suas ações sejam executadas automaticamente.

---

Os eventos que disparam o workflow para ser executado.

---

O sistema operacional para executar.

### --feedback--

Pense em quando você quer que suas ações sejam executadas automaticamente.

---

Os passos para executar.

### --feedback--

Pense em quando você quer que suas ações sejam executadas automaticamente.

## --video-solution--

2

## --text--

Onde os arquivos YAML do fluxo de trabalho do GitHub Actions devem ser colocados em um repositório?

## --answers--

No diretório raiz.

### --feedback--

O GitHub procura arquivos de workflow em uma estrutura de diretórios específica.

---

Em um diretório `.github/actions`.

### --feedback--

O GitHub procura arquivos de workflow em uma estrutura de diretórios específica.

---

Em um diretório `.github/workflows`.

---

Em um diretório `workflows`.

### --feedback--

O GitHub procura arquivos de workflow em uma estrutura de diretórios específica.

## --video-solution--

3

## --text--

O que acontece por padrão quando uma etapa falha em um workflow do GitHub Actions?

## --answers--

O fluxo de trabalho continua com um aviso.

### --feedback--

Considere como o GitHub Actions lida com erros na execução do workflow.

---

Apenas essa etapa específica está marcada como falhada.

### --feedback--

Considere como o GitHub Actions lida com erros na execução do workflow.

---

O fluxo de trabalho reinicia desde o início.

### --feedback--

Considere como o GitHub Actions lida com erros na execução do workflow.

---

As etapas restantes são puladas e a execução é marcada como uma falha.

## --video-solution--

4
