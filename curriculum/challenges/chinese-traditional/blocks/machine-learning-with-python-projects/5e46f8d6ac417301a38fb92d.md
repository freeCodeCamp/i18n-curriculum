---
id: 5e46f8d6ac417301a38fb92d
title: 剪刀石頭布
challengeType: 10
forumTopicId: 462376
dashedName: rock-paper-scissors
---

# --description--

在這個挑戰中，你將創建一個程式來玩剪刀、石頭、布。隨機選擇的程式通常會贏得 50% 的比賽。為了通過這個挑戰，你的程式必須與四個不同的機器人進行比賽，每場比賽至少贏得 60% 的遊戲。

你將會<a href="https://app.ona.com/?autostart=true#https://github.com/freeCodeCamp/boilerplate-rock-paper-scissors/" target="_blank" rel="noopener noreferrer nofollow">使用我們的 Ona 起始程式碼來進行這個專案</a>。

我們仍在開發機器學習課程中互動式教學的零件。現在，你必須使用其他資源來學習如何通過這個挑戰。

# --instructions--

在檔案 `RPS.py` 中，你會得到一個名為 `player` 的函式。該函式接受一個引數，該引數是一個字串，描述對手的最後一次出招（"R"、"P" 或 "S"）。該函式應該傳回一個字串，表述下一步要出的招式（"R"、"P" 或 "S"）。

在比賽的第一場遊戲中，玩家函式會收到一個空字串作為引數，因為沒有先前的出招。

檔案 `RPS.py` 顯示了一個你需要更新的範例函式。範例函式是用兩個引數定義的（`player(prev_play, opponent_history = [])`）。該函式從未以第二個引數呼叫，因此那個引數是完全選用的。範例函式包含第二個引數（`opponent_history = []`）的原因是，這是唯一能在連續呼叫 `player` 函式之間儲存狀態的方法。只有當你想要追蹤 `opponent_history` 時，才需要 `opponent_history` 引數。

*提示：為了擊敗所有四個對手，你的程式可能需要有多種策略，並根據對手的出招進行變化。*

## 開發

請勿修改 `RPS_game.py`。請將所有程式碼寫在 `RPS.py`。在開發時，你可以使用 `main.py` 來測試你的程式碼。 

`main.py` 從 `RPS_game.py` 匯入遊戲函式（程式）和機器人。

要測試你的程式碼，使用 `play` 函式玩一個遊戲。`play` 函式接受四個引數：

- 兩個玩家彼此對戰（玩家實際上是函式（程式））
- 比賽中要玩的遊戲數量
- 一個選用的引數，用來查看每個遊戲的日誌。將它設為 `True` 以查看這些訊息。

```py
play(player1, player2, num_games[, verbose])
```

例如，如果你想讓 `player` 和 `quincy` 互相對戰 1000 場遊戲，並且想看到每場遊戲的結果，這是你如何呼叫該函式的方式：

```py
play(player, quincy, 1000, verbose=True)
```

## 測試

這個專案的單元測試位於 `test_module.py`。我們為了你的方便，將 `test_module.py` 的測試匯入到 `main.py`。如果你取消註解 `main.py` 中的最後一行，當你在主控台執行 `python main.py` 時，測試將會自動執行。

## 提交中

複製你的專案 URL 並提交到 freeCodeCamp。

# --hints--

它應該通過所有 Python 測試。

```js

```

# --solutions--

```py
  # Python challenges don't need solutions,
  # because they would need to be tested against a full working project.
  # Please check our contributing guidelines to learn more.
```
