---
id: 6723cdfa4ae237bf6b7e32eb
title: JavaScript 正規表達式複習
challengeType: 31
dashedName: review-javascript-regular-expressions
---

# --interactive--

## 正規表達式和常用方法

- **定義**：正規表達式，或稱 Regex，用來創建「樣式」，你可以用它來比對字串、擷取文字等等。

```js
const regex = /freeCodeCamp/;
```

- **`test()` 方法**：此方法接受一個字串，該字串是用來測試是否符合正規表達式的字串。若字串符合正規表達式，該方法將傳回一個布林值。

:::interactive_editor

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test); // false
```

:::

- **`match()` 方法**：此方法接受一個正規表達式，雖然你也可以傳入一個字串，該字串將被構造成正規表達式。`match` 方法會傳回該字串的匹配陣列。

:::interactive_editor

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match); // ["freeCodeCamp"]
```

:::

- **`replace()` 方法**：此方法接受兩個引數：用於匹配的正規表達式（或字串），以及用來取代匹配結果的字串（或對每個匹配執行的函式）。

:::interactive_editor

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced); // "freeCodeCamp is rly kewl"
```

:::

- **`replaceAll` 方法**：此方法用於將指定樣式的所有出現取代為新的字串。如果你給它沒有全域修飾詞的正規表達式，則此方法會發出錯誤。

:::interactive_editor

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

:::

- **`matchAll` 方法**：此方法用於取得字串中給定正規表達式的所有符合項目，包括捕獲群組，並將它們傳回為一個迭代器。迭代器是一種物件，允許你遍歷（或「迭代」）一個群集的項目。

:::interactive_editor

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

:::

## 正規表達式修飾詞

- **定義**：修飾詞，通常稱為「旗標」，用來修改正規表達式的行為。
- **`i` 旗標**：此旗標使正規表達式忽略大小寫。

:::interactive_editor

```js
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
```

:::

- **`g` 旗標**：此旗標，或全域的修飾詞，允許你的正規表達式多次匹配一個樣式。

:::interactive_editor

```js
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
```

:::

- **錨點定義**：位於正規表達式開頭的 `^` 錨點表示「比對字串的開始」。位於正規表達式結尾的 `$` 錨點表示「比對字串的結尾」。

:::interactive_editor

```js
const start = /^freeCodeCamp/i;
const end = /freeCodeCamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
```

:::

- **`m` 旗標**：錨點尋找整個字串的開始和結束。但你可以使用 `m` 旗標，或多行修飾詞，讓正規表達式控制代碼處理多行。

:::interactive_editor

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const str = `I love 
freecodecamp
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true
```

:::

- **`d` 旗標**：此旗標會擴展你在比對物件中取得的資訊。

:::interactive_editor

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

:::

- **`u` 旗標**：這會擴展正規表達式的功能，使其能匹配特殊的 unicode 字元。`u` 旗標讓你能存取像 `Extended_Pictographic` 這類特殊類別，以匹配大部分的表情符號。還有一個 `v` 旗標，進一步擴展 unicode 匹配的功能。
- **`y` 旗標**：sticky 修飾詞的行為與全域的修飾詞非常相似，但有一些例外。最大的一點是，全域的正規表達式會從 lastIndex 開始並搜尋字串剩餘部分的所有匹配項，但 sticky 正規表達式如果在先前的 lastIndex 沒有立即匹配，則會傳回 null 並將 lastIndex 重設為 0。
- **`s` 旗標**：單行修飾詞允許由正規表達式中 `.` 表述的萬用字元匹配換行字元——有效地將字串視為單行文字。

## 字元類別

- **萬用符號 `.`**：字元類別是一種特殊語法，你可以用來匹配字元的集合或子集合。你應該學習的第一個字元類別是萬用字元類別。萬用字元由句點（點號）表現，並匹配除了換行符以外的任意單一字元。若要讓萬用字元類別匹配換行符，請記得你需要使用 `s` 旗標。

```js
const regex = /a./;
```

- **`\d`**：這將匹配字串中所有的數字（`0-9`）。

```js
const regex = /\d/;
```

- **`\w`**：這用於匹配字串中任何字元（`a-z0-9_`）。字元定義為任何字母（a 到 z）、數字（0 到 9）或底線字元。

```js
const regex = /\w/;
```

- **`\s`**：空白類別 `\s`，由反斜線後接 `s` 表述。此字元類別會匹配任何空白字元，包括換行、空格、製表符及特殊 unicode 空白字元。
- **否定特殊字元類別**：要否定這些字元類別之一，不是使用反斜線後的小寫字母，而是使用大寫等價字母。以下範例不會符合數字字元，而是符合任何非數字字元的單一字元。

```js
const regex = /\D/;
```

- **訂製字元類別**：你可以透過將你想匹配的字元放在一組方括號內來創建訂製字元類別。

```js
const regex = /[abcdf]/;
```

## 前瞻與後顧斷言

- **定義**：前瞻和後顧斷言允許你根據周圍樣式的存在或缺失來匹配特定樣式。
- **正向先行斷言**：當某個樣式後面接著另一個樣式時，此斷言會匹配該樣式。要構造正向先行斷言，你需要從你想匹配的樣式開始。接著，使用小括弧將你想用作條件的樣式包起來。在開啟小括弧後，使用 `?=` 來定義該樣式為正向先行斷言。

```js
const regex = /free(?=code)/i;
```

- **負向前瞻斷言**：這是在正規表達式中用來檢查字串前方不出現某個樣式的一種條件。

```js
const regex = /free(?!code)/i;
```

- **正向後顧斷言**：此斷言僅在其前方有另一特定樣式時才會匹配該樣式，且不會將前方的樣式包含在匹配中。

```js
const regex = /(?<=free)code/i;
```

- **負向後顧斷言**：此斷言確保某個樣式前面不會有另一個特定的樣式。只有在指定的樣式前面沒有緊接著給定序列時才會匹配，且不會將前面的序列包含在匹配中。

```js
const regex = /(?<!free)code/i;
```

## 正則表達式量詞

- **定義**：正規表達式中的量詞用來指定樣式（或樣式的部分）應該出現多少次。它們有助於控制字元或群組在比對中出現的次數。以下範例用來精確比對前一個字元出現 4 次。

```js
const regex = /^\d{4}$/;
```

- **`*`** ：匹配前一個元素出現 0 次或多次。
- **`+`**：匹配前一個元素出現 1 次或以上。
- **`?`**：匹配前一個元素 0 次或 1 次出現。
- **`{n}`**：精確匹配前一個元素出現 n 次。
- **`{n,}`**：匹配前一元素出現 n 次或以上。
- **`{n,m}`**：匹配前一個元素出現介於 n 和 m 次之間。

## 捕捉群組和址參器

- **捕獲群組**：捕獲群組允許你「捕獲」匹配字串的一部分，以便你可以依需要使用。捕獲群組是由包含要捕獲樣式的小括弧所定義，且前面不帶有像是先行斷言的字元。

```js
const regex = /free(code)camp/i;
```

- **非捕獲群組**：非捕獲群組類似於捕獲群組，但不會儲存字串中符合的部分以供後續使用。非捕獲群組由 `(?:...)` 定義。

```js
const regex = /free(?:code)camp/i;
```

- **Backreferences**：在正規表達式中，backreference 指的是一種重複使用同一個運算式中先前匹配到的樣式零件的方法。它允許你以數字取用被捕捉的群組（小括弧中的樣式零件）。例如，`$1` 指涉第一個被捕捉的群組。

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

:::

- 你可以在正規表示式本身內使用反向引用，以反斜線和捕獲群組編號來匹配先前群組所捕獲的相同文字。例如：

:::interactive_editor

```js
const regex = /(hello) \1/i;
console.log(regex.test("hello hello"));  // true
console.log(regex.test("hello world"));  // false
```

:::

# --assignment--

檢視 JavaScript Regular Expressions 主題和概念。
