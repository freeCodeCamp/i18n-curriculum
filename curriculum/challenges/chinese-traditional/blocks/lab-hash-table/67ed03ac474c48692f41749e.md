---
id: 67ed03ac474c48692f41749e
title: 建置雜湊表
challengeType: 27
dashedName: build-a-hash-table
saveSubmissionToDB: true
---

# --description--

在本實驗中，你將從零開始建置一個雜湊表。雜湊表是一種儲存鍵值配對的資料結構。雜湊表的運作方式是將鍵作為輸入，然後根據特定的雜湊函式對該鍵進行雜湊。 

為了本實驗的目的，雜湊函式（hashing function）將會很簡單：它會將鍵中每個字元的 Unicode 值相加。然後，雜湊值將用作實際的鍵來儲存相關的值。相同的雜湊值也會用來檢索和刪除與該鍵相關的值。

**目標：** 完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 你應該定義一個名為 `HashTable` 的類別，當創建 `HashTable` 的新實體時，`collection` 屬性應初始化為空字典。`collection` 字典應根據鍵的雜湊值儲存鍵值對組。

2. `HashTable` 類別應該有四個實體方法：`hash`、`add`、`remove` 和 `lookup`。

3. `hash` 方法應該：

    - 將字串作為參數。
    - 傳回一個雜湊值，此值是字串中每個字元的 Unicode（ASCII）值總和計算而得。你可以使用 `ord` 函式來進行此計算。

4. `add` 方法應該：
    - 接受兩個表述鍵值對組的引數，並計算該鍵的雜湊值。
    - 使用計算出的雜湊值作為鍵，將包含鍵值對的字典儲存在 `collection` 字典內。
    - 如果多個鍵產生相同的雜湊值，它們的鍵值配對應該儲存在相同雜湊值下現有的巢狀字典中。

5. `remove` 方法應該：

    - 以鍵作為其引數並計算其雜湊值。
    - 確認鍵是否存在於群集中。
    - 從雜湊表中移除對應的鍵值配對。
    - 如果鍵不存在於群集中，則不應引發錯誤或移除任何東西。

6. `lookup` 方法應該：

    - 以鍵作為其引數。
    - 計算鍵的雜湊值，並傳回儲存在雜湊表中的對應值。
    - 如果該鍵不存在於群集中，則應傳回 `None`。

# --hints--

你應該定義一個 `HashTable` 類別。

```js
({ 
    test: () => assert(runPython(`
    _Node(_code).has_class("HashTable")
    `)) 
})
```

當創建 `HashTable` 類別的新實體時，其 `collection` 屬性應初始化為空字典。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.collection == {}
    `) 
})
```

`HashTable` 類別應該有一個 `hash` 方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('hash')`))}})
```

`hash` 方法應該接受一個字串作為參數。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.hash)
    len(sig.parameters) == 1
  `))
})
```

`hash` 方法應該接受一個字串作為其引數，並傳回該字串中每個字元的 Unicode 值總和。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("fcc")
        assert hash_result == 300

        # prevent hardcoding
        assert ht.hash("golf") == 424
        assert ht.hash("read") == 412
`) })
```

`HashTable` 類別應該有一個 `add` 方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('add')`))}})
```

`add` 方法應該接受一個鍵和值作為參數。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.add)
    len(sig.parameters) == 2
  `))
})
```

`HashTable` 類別應該有一個 `remove` 方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('remove')`))}})
```

`remove` 方法應該接受一個鍵作為參數。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.remove)
    len(sig.parameters) == 1
  `))
})
```

當你嘗試從群集中移除不存在的鍵時，不應該引發錯誤或移除任何東西。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        ht.add("rose", "flower")
        index = ht.hash("rose")
        original = ht.collection.copy()

        ht.remove("tulip")
        ht.remove("sore")

        assert ht.collection == original
        assert "rose" in ht.collection[index]
        assert "tulip" not in ht.collection.get(index, {})
    `) 
})
```

如果多個鍵經過雜湊後指向相同的索引，`remove` 方法應該只刪除特定的鍵值配對，而不是刪除該索引處的整個字典。

```js
({
  test: () => runPython(`
    ht = HashTable()
    ht.add("rose", "flower")
    ht.add("sore", "pain")  # "rose" and "sore" both hash to the same index

    index = ht.hash("rose")
    ht.remove("rose")

    assert index in ht.collection
    assert "rose" not in ht.collection[index]
    assert "sore" in ht.collection[index]
    assert ht.collection[index]["sore"] == "pain"
  `)
})
```

`HashTable` 類別應該有一個 `lookup` 方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('lookup')`))}})
```

`lookup` 方法應該接受一個鍵作為參數。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.lookup)
    len(sig.parameters) == 1
  `))
})
```

`HashTable().hash('golf')` 應該傳回 `424`。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("golf")
        assert hash_result == 424

        # prevent hardcoding
        assert ht.hash("dear") == 412
        assert ht.hash("cat") == 312
    `) 
})
```

`HashTable().add('golf', 'sport')` 應該將鍵值對添加到鍵為 `424` 的群集中。

```js

({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")
    expected_value = {424: {'golf': 'sport'}}

    assert ht.collection == expected_value
    `) 
})
```

`HashTable().add('dear', 'friend')` 和 `HashTable().add('read', 'book')` 應該將這兩個鍵值配對作為巢狀字典添加到索引為 `412` 的群集中。

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("dear", "friend")
    ht.add("read", "book")

    expected_value = {
        "dear": "friend",
        "read": "book"
    }

    assert ht.collection.get(412) == expected_value
    `) 
})
```

當雜湊表中存在鍵時，`remove()` 方法應該從群集中移除該鍵及其對應的值。

```js
({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")

    expected_value_before_removal = {
        "golf": "sport"
    }

    index = ht.hash("golf")

    assert ht.collection.get(index) == expected_value_before_removal

    ht.remove("golf")

    assert "golf" not in ht.collection.get(index, {})
    `) 
})
```

當雜湊表中存在 `'golf', 'sport'` 配對時，`HashTable().lookup('golf')` 應該傳回 `sport`。

```js
({ 
    test: () => runPython(`
    ht = HashTable()

    ht.add("golf", "sport")

    expected_value = "sport"
    assert ht.lookup("golf") == expected_value
    `) 
})

```

當群集中不存在 `'golf', 'sport'` 這個鍵值配對時，`HashTable().lookup('golf')` 應該傳回 `None`。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.lookup("golf") is None
`) })

```

當群集中存在 `'fcc'` 鍵時，`HashTable().lookup('cfc')` 應該傳回 `None`。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        ht.add("fcc", "coding")
        assert ht.lookup("cfc") is None
`) })
```

當你將 `('rose', 'flower')` 添加到雜湊表時，其 `collection` 屬性應該看起來像這樣：`{ 441: { 'rose': 'flower' }}`。

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("rose", "flower")

    expected_value = {
        "rose": "flower"
    }

    assert ht.collection.get(441) == expected_value

    # prevent hardcoding

    ht2 = HashTable()

    ht2.add("kebab", "food")
    expected_value = {
        "kebab": "food"
    }

    assert ht2.collection.get(501) == expected_value
    `)
})
```

當你添加一個鍵，其雜湊值與現有鍵相同，例如 `fcc` 和 `cfc`，`collection` 應該看起來像這樣：`{ 300: { 'fcc': 'coding', 'cfc':  'chemical' }}`。

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("fcc", "coding")
    ht.add("cfc", "chemical")

    expected_value = {
        "fcc": "coding",
        "cfc": "chemical"
    }

    assert ht.collection.get(300) == expected_value

    # prevent hardcoding

    ht2 = HashTable()
    ht2.add("cat", "animal")
    ht2.add("act", "verb")

    expected_value = {
        "cat": "animal",
        "act": "verb"
    }

    assert ht2.collection.get(312) == expected_value
    `)
})
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
class HashTable:
    def __init__(self):
        self.collection = {}

    def hash(self, string):
        hashed = 0
        for char in string:
            hashed += ord(char)  
        return hashed

    def add(self, key, val):
        the_hash = self.hash(key)
        if the_hash not in self.collection:
            self.collection[the_hash] = {}
        self.collection[the_hash][key] = val

    def remove(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            del self.collection[the_hash][key]
            if not self.collection[the_hash]: 
                del self.collection[the_hash]

    def lookup(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            return self.collection[the_hash][key]
        return None
```
