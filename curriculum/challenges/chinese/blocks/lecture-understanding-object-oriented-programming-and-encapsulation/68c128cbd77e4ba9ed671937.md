---
id: 68c128cbd77e4ba9ed671937
title: 什么是 Getters 和 Setters
challengeType: 19
dashedName: what-are-getters-and-setters
---

# --description--

Getter 和 setter 是允许你控制如何访问和修改类的属性的方法。通过 getter 你获取一个值，通过 setter 你设置一个值。

这些操作是通过所谓的属性完成的。它们连接了 getter 和 setter，并允许访问数据。

属性表现得像属性，但在底层行为像方法。可以将它们视为你像定义方法一样定义的数据，但像属性一样工作。这意味着你可以用点符号访问属性，而不是用括号或圆括号。

属性的主要作用是在你通过它们获取、设置或删除值时，在后台运行额外的逻辑。这使得它们成为你想要访问或操作对象内数据时的完美选择。

那么为什么要用属性而不是方法呢？这主要是关于可读性和惯例。它们使你的代码更简洁、更易于阅读。

当你使用一个方法时，你总是必须用括号调用它。但对于属性，你可以像访问普通属性一样使用点符号访问它。即使在后台执行额外工作，这也使你的代码看起来很简单。

例如，你可能想计算一个值或查看一个新值在保存前是否有效。你可以使用类似属性的方式来完成，而不是调用一个方法。

要创建一个属性，你需要定义一个方法并在其上方放置 `@property` 装饰器。这告诉 Python 将该方法视为属性。

这就引出了 getter。以下是如何使用 `@property` 装饰器创建一个 getter：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

此示例获取圆的半径和面积。

注意我们在类内部使用了 `_radius` 而不是 radius。下划线是 Python 中常见的约定，用来表示某个属性是私有的。换句话说，它表示该属性是供内部使用的，不应从类的外部直接访问。

要创建半径的 setter，例如，你必须定义另一个同名的方法，并在其上方使用 `@<property_name>.setter`：

在 `__init__` 中使用 `self.radius` 确保在对象创建期间调用 setter，因此无效的半径值会被立即捕获。

```py
class Circle:
    def __init__(self, radius):
        self.radius = radius # Calling the setter

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

在此示例中，半径设置器不仅设置圆的半径，还运行一个验证以确保半径不是负数。

一旦你定义了 getter 和 setter，Python 会在你使用普通属性语法时自动在底层调用它们：

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

请注意，在 setter 内部，赋值时不能使用与属性相同的名称。因为 `self.radius = value` 会在 setter 方法内部调用该 setter，导致无限递归和 `RecursionError`。所以你必须始终使用带下划线前缀的形式 `self._radius = value`。

就像你可以通过 getter 控制一个属性的访问方式，通过 setter 控制它的修改方式一样，你也可以通过 deleter 控制它的删除方式。

当你对一个属性使用 del 语句时，删除器会运行自定义逻辑。要创建一个删除器，你需要使用 `@<property_name>.deleter` 装饰器：

```py
class Circle:
    def __init__(self, radius):
        self.radius = radius

    # Getter
    @property
    def radius(self):
        return self._radius

    # Setter
    @radius.setter
    def radius(self, value):
        if value <= 0:
            raise ValueError("Radius must be positive")
        self._radius = value

    # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

以下是删除器的使用方法：

```py
# Create circle object with a radius
my_circle = Circle(33)
print("Initial radius:", my_circle.radius)  # 33

# Delete the radius
# This calls the deleter
del my_circle.radius # Deleting radius...
print("Radius deleted!") # Radius deleted!

# Try to access radius after deletion
try:
    print(my_circle.radius)
except AttributeError as e:
    print("Error:", e) # Error: 'Circle' object has no attribute '_radius'
```

这里的要点是：

- Getter 让你检索一个值，甚至可以运行中计算一个值。
- Setter 允许你通过在赋值前运行查看来安全地修改值。
- 属性是将这些 getter 和 setter 绑定在一起的东西，这样你就可以在使用点符号的同时编写逻辑。
- 删除器让你定义删除属性时发生的操作。

# --questions--

## --text--

什么让你在获取或设置一个属性的值时在后台运行逻辑？

## --answers--

导入外部模块。

### --feedback--

考虑允许在读取和写入数据时进行验证或计算的方法。

---

类继承。

### --feedback--

考虑允许在读取和写入数据时进行验证或计算的方法。

---

属性

---

直接属性访问。

### --feedback--

考虑允许在读取和写入数据时进行验证或计算的方法。

## --video-solution--

3

## --text--

是什么将 getter 和 setter 绑定在一起，使你能够在维护点符号 `access` 的同时执行逻辑？

## --answers--

属性

---

装饰器

### --feedback--

考虑一个让你可以用简单点语法将方法当作属性使用的特色。

---

类继承

### --feedback--

考虑一个让你可以用简单点语法将方法当作属性使用的特色。

---

直接调用方法

### --feedback--

考虑一个让你可以用简单点语法将方法当作属性使用的特色。

## --video-solution--

1

## --text--

创建属性的 getter 和 setter 使用哪两个装饰器？

## --answers--

`@getter` 和 `@setter`

### --feedback--

考虑允许方法调用使用简单点符号而无需括号的装饰器。

---

`@attr.get` 和 `@attr.set`

### --feedback--

考虑允许方法调用使用简单点符号而无需括号的装饰器。

---

`@compute` 和 `@assign`

### --feedback--

考虑允许方法调用使用简单点符号而无需括号的装饰器。

---

`@property` 和 `@<property_name>.setter`

## --video-solution--

4
