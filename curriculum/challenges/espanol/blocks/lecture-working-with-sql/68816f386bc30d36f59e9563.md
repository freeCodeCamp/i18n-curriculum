---
id: 68816f386bc30d36f59e9563
title: ¿Qué es la normalización en SQL?
challengeType: 19
dashedName: what-is-normalization-in-sql
---

# --description--

La normalización es el proceso de organizar una base de datos relacional usando formas normales establecidas para reducir la redundancia de datos y mejorar la integridad de los datos.

Para normalizar una base de datos, analizas los atributos y relaciones en tus estructuras de tablas para identificar oportunidades de simplificación basadas en las reglas de normalización. Luego, divides los datos en tablas más pequeñas y enfocadas y estableces relaciones entre ellas usando claves primarias y foráneas. Estas tablas más pequeñas almacenarán todos los datos que tenías originalmente, pero serán más fáciles de gestionar, organizar y trabajar en comparación con tablas más grandes.

Al minimizar la redundancia de datos, la normalización reduce el espacio de almacenamiento y previene inconsistencias. Por ejemplo, si cambia la dirección de un cliente, solo necesitas actualizarla en una tabla de clientes en lugar de en cada registro de pedido. 

También ayuda a preservar la integridad de los datos asegurando que las dependencias se apliquen mediante restricciones de clave primaria y clave foránea. Esto reduce la probabilidad de anomalías en inserciones, actualizaciones y eliminaciones.

Una base de datos normalizada es más fácil de entender y mantener, lo que contribuye a un sistema de base de datos bien diseñado.

El conjunto de reglas que debes seguir para organizar tus tablas se llama formas normales. Cada forma normal se basa en las anteriores, con reglas que se vuelven más estrictas a medida que avanzas a formas normales superiores. La Primera Forma Normal (1NF) es la forma fundamental, con las reglas más básicas.

Una tabla está en Primera Forma Normal (1NF) si:

- Cada celda debe contener solo un valor. Por ejemplo, si tienes una tabla `students`, puede que un estudiante tenga varios números de teléfono. En lugar de almacenarlos como una lista separada por comas en una celda, debes crear una tabla `phone_numbers` separada con una clave foránea que apunte a la tabla `students` y almacenar solo un valor en cada celda. Esto mantiene cada valor atómico y el diseño normalizado.
- Cada registro (fila) debe ser único. Mientras que las claves primarias imponen este requisito, 1NF exige explícitamente que no existan filas duplicadas en la tabla.
- El orden de las filas y columnas no debería ser relevante. Los datos no deberían depender de su ubicación física.

Esencialmente, la Primera Forma Normal (1NF) se enfoca en hacer que los valores sean simples y atómicos.

La Segunda Forma Normal (2NF) se basa en 1NF, requiriendo que se cumplan todos los requisitos de 1NF más restricciones adicionales.

Entender 2NF requiere familiaridad con dos conceptos clave: superkeys y candidate keys. Un superkey es cualquier conjunto de atributos que identifica de manera única cada fila en una tabla, lo que significa que no puede haber dos filas con valores idénticos en todas las columnas del superkey.

Por ejemplo, si tenemos una tabla `customers` con tres columnas:

```sql
customer_id | name | email
```

Digamos que `customer_id` y `email` deben ser únicos para cada registro. Algunos ejemplos de superclaves para esta tabla serían:

- `customer_id`
- `{ customer_id, name }`, esta combinación identifica filas de manera única porque `customer_id` por sí solo es único, independientemente de la unicidad de `name`.
- `{ customer_id, name, email }`
- `email`, ya que también estamos agregando la restricción única a esta columna, cada registro puede ser identificado de manera única por el email.

Cualquier conjunto de atributos que, juntos, identifiquen cada fila puede ser una superclave.

Una clave candidata es similar y, sin embargo, un poco diferente. Es un conjunto de una o más columnas en la tabla que pueden identificar de manera única cada registro. Una tabla puede tener múltiples claves candidatas, pero tendrás que elegir una para que actúe como la clave primaria.

Suena bastante similar, ¿verdad? La diferencia es que la superkey también puede contener atributos adicionales que no son necesarios para identificar cada fila de manera única, mientras que la candidate key solo contiene atributos que sí identifican la fila de manera única.

En nuestro ejemplo de `customers`, mencionamos que `customer_id`, `{ customer_id, name }`, `{ customer_id, name, email }` y `email` pueden ser superclaves. En este caso, solo `customer_id` y `email` pueden ser claves candidatas porque las claves candidatas no pueden incluir atributos que no identifiquen la fila de manera única, como `name`. Esto ilustra el principio de minimalidad que distingue las claves candidatas de las superclaves.

Ahora que estás familiarizado con estos conceptos, volvamos a la Segunda Forma Normal (2NF).

La Segunda Forma Normal (2NF) se basa en abordar las dependencias parciales. Una dependencia parcial ocurre en una tabla cuando un atributo que no forma parte de la clave primaria depende solo de una parte de una clave primaria compuesta (una clave compuesta es una clave primaria formada por múltiples columnas). Esto puede provocar redundancia de datos y anomalías en las actualizaciones.

Por ejemplo, digamos que tenemos una tabla `orders` con estas columnas:

```sql
order_id | item_id | order_date | quantity | order_shipping_city
```

En esta tabla, la clave primaria es la combinación de `order_id` y `item_id` porque el mismo ID de artículo puede estar en diferentes órdenes, pero su combinación será única. Puedes ver que hay una dependencia parcial entre `order_id` y `order_shipping_city`. `order_id` es parte de la clave primaria. `order_shipping_city` depende de `order_id` porque cada orden con el mismo ID tendrá la misma ciudad de envío. Sin embargo, la ciudad de envío no depende de `item_id`, pero este también es parte de la clave primaria. Por lo tanto, `order_shipping_city` no depende de toda la clave primaria.

Para solucionar esto, puedes dividir la tabla en dos tablas más pequeñas, como `order_header` y `order_items`. En la tabla `order_header`, podrías almacenar la información de nivel superior sobre los pedidos: 

```sql
order_id | order_date | order_shipping_city
```

En la tabla `order_items`, podrías almacenar información sobre los artículos en los diferentes pedidos que se enviaron:

```sql
order_id | item_id | quantity
```

Con estos cambios, ambas tablas estarán en Segunda Forma Normal (2NF).

Y eso nos lleva a la Tercera Forma Normal (3NF). Esta forma normal se basa en la segunda forma normal.

Para que una tabla esté en Tercera Forma Normal, debe:

- Estar en Segunda Forma Normal.
- Haz que todos los atributos no clave dependan directamente de la clave primaria, lo que significa que ningún atributo no clave debe depender de otro atributo no clave.

Para entender la Tercera Forma Normal (3NF), necesitas comprender las dependencias transitivas. Una dependencia transitiva ocurre cuando un atributo que no forma parte de la clave primaria depende de otro atributo que tampoco forma parte de la clave primaria, y este a su vez depende de la clave primaria.

Por ejemplo, vamos a modificar nuestra tabla `orders` para que tenga estas columnas:

```sql
order_id | customer_id | customer_city | city_postal_code | order_date | quantity
```

La clave primaria en esta nueva tabla es `order_id` porque identifica de manera única cada fila.

Hay una dependencia transitiva en esta tabla:

```sql
order_id > customer_id > customer_city > city_postal_code
```

El código postal de la ciudad está determinado por la ciudad del cliente, que está determinada por el ID del cliente, que está determinado por el ID del pedido. `city_postal_code`, un atributo que no forma parte de la clave primaria, está determinado por `customer_city`, que tampoco forma parte de la clave primaria, pero `customer_city` está determinado por `order_id` a través de `customer_id`. Esto significa que el código postal de la ciudad se repetirá en cada pedido realizado por clientes que viven en la misma ciudad. Esto conducirá a redundancia de datos. Además, cualquier cambio en el código postal de una ciudad requeriría actualizaciones en múltiples registros.

Para resolver la dependencia transitiva, necesitarías dividir la tabla en varias tablas. Primero, una tabla `orders`:

```sql
order_id | customer_id | order_date | quantity
```

Luego, una tabla `customers`:

```sql
customer_id | city_name
```

Y una tabla `cities`:

```sql
city_name | city_postal_code
```

Esto elimina la dependencia transitiva de la tabla.

Y finalmente, tenemos la Forma Normal Boyce-Codd (BCNF). Esto también se conoce como Forma Normal 3.5 porque aborda algunas anomalías que la Tercera Forma Normal puede no resolver. Para que una tabla esté en la Forma Normal Boyce-Codd (BCNF), debe:

- Estar en Tercera Forma Normal.
- Cada lado izquierdo de una dependencia funcional tiene que ser una superclave.

El objetivo de esta forma normal es asegurar que cada atributo o conjunto de atributos que determina otro atributo sea una superclave, que es una clave candidata o un superconjunto de ellas.

Entender y aplicar las formas normales es esencial para diseñar bases de datos relacionales robustas y eficientes. Al eliminar la redundancia de datos y asegurar dependencias lógicas de datos, la normalización conduce a una mejor integridad de datos, reducción de los requisitos de almacenamiento y simplificación del mantenimiento de la base de datos. Normalmente, debes aspirar a alcanzar la Tercera Forma Normal (3NF).

# --questions--

## --text--

¿Qué forma normal se ocupa principalmente de reemplazar grupos de datos dentro de una sola fila con valores individuales?

## --answers--

Primera Forma Normal (1NF)

---

Segunda Forma Normal (2NF)

### --feedback--

Piensa en el nivel más básico de organización dentro de una tabla y qué constituye una sola pieza indivisible de datos.

---

Tercera Forma Normal (3NF)

### --feedback--

Piensa en el nivel más básico de organización dentro de una tabla y qué constituye una sola pieza indivisible de datos.

---

Forma Normal de Boyce-Codd (BCNF)

### --feedback--

Piensa en el nivel más básico de organización dentro de una tabla y qué constituye una sola pieza indivisible de datos.

## --video-solution--

1

## --text--

Una tabla está en Segunda Forma Normal (2NF) si está en Primera Forma Normal (1NF) y si se cumple alguna de las siguientes condiciones:

## --answers--

Todos los atributos no clave dependen transitivamente de la clave primaria.

### --feedback--

Piensa en el problema que la Segunda Forma Normal (2NF) aborda cuando una tabla tiene una clave primaria compuesta.

---

Todos los atributos no clave dependen funcionalmente de manera completa de toda la clave primaria.

---

Cada determinante es una clave candidata.

### --feedback--

Piensa en el problema que la Segunda Forma Normal (2NF) aborda cuando una tabla tiene una clave primaria compuesta.

---

No hay grupos de datos repetidos.

### --feedback--

Piensa en el problema que la Segunda Forma Normal (2NF) aborda cuando una tabla tiene una clave primaria compuesta.

## --video-solution--

2

## --text--

¿Qué forma normal aborda las dependencias transitivas, donde un atributo que no es clave depende de otro atributo que no es clave?

## --answers--

Primera Forma Normal (1NF)

### --feedback--

Piensa en las relaciones indirectas entre atributos no clave y la clave primaria que esta forma normal busca eliminar.

---

Segunda Forma Normal (2NF)

### --feedback--

Piensa en las relaciones indirectas entre atributos no clave y la clave primaria que esta forma normal busca eliminar.

---

Tercera Forma Normal (3NF)

---

Forma Normal de Boyce-Codd (BCNF)

### --feedback--

Piensa en las relaciones indirectas entre atributos no clave y la clave primaria que esta forma normal busca eliminar.

## --video-solution--

3
