---
id: 67d1ec87b34cee1d9219f7e9
title: 你如何在 React 中創建訂製掛鉤？
challengeType: 19
dashedName: how-can-you-create-custom-hooks-in-react
---

# --description--

React 提供許多內建的掛鉤，讓你在專案中實作不同的功能。這些包括 `useState`、`useEffect`、`useContext` 等。

但有時候，你需要添加一個內建掛鉤都無法幫助的功能。幸運的是，你可以在 React 中創建你自己的訂製掛鉤。

訂製掛鉤並不像看起來那麼複雜。它們只是可重複使用的函式（程式），讓你能在多個組件之間共享邏輯。這表示可重複使用性是你想要建造自己掛鉤的另一個原因。

使用訂製掛鉤，你可以將邏輯從任何使用它們的組件中抽離出來，例如資料擷取、狀態管理、切換、像是檢查使用者線上或離線狀態等副作用。 

你接著可以匯入該掛鉤以在任何組件中使用，這樣你就能專注於這些組件內的呈現與展示。這表示重複次數更少、複製更少，也代表當你想進行任何更新時，需要修改的地方更少。

現在，讓我們來看看你如何製作你自己的訂製掛鉤。

在 React 中，所有內建掛鉤都以字 `use` 開頭，所以你的訂製掛鉤也應該遵循相同的慣例。你的訂製掛鉤名稱也應該清楚地傳達它的功能。

所以，如果你的訂製掛鉤…

- 擷取資料，你可以呼叫它 `useFetch`

- 切換某物的開啟與關閉，你可以呼叫它為 `useToggle`

- 或者如果它實作了防彈跳，`useDebounce` 是一個不錯的名稱

假設你想要建置一個訂製掛鉤，為你的應用程式添加防彈跳功能。

防彈跳（Debouncing）是一種程式設計技巧，用來限制函式執行的頻率。它的運作方式是等待使用者停止執行某個動作達到指定的時間後，才執行該函式。例如，在搜尋框中，防彈跳不會在每次按鍵時都進行 API 呼叫，而是等待使用者停止輸入，例如 500 毫秒後才執行。

要創建一個防抖訂製掛鉤，你首先需要創建一個 `useDebounce.jsx` 或 `useDebounce.js` 檔案。慣例上，你創建的任何訂製掛鉤檔案都會儲存到一個 `hooks` 資料夾中。

你可以在你自己的訂製掛鉤中使用一些內建掛鉤。若要進行防彈跳，則需要 `useState` 和 `useEffect` 掛鉤，因此請在你的檔案頂部匯入它們：

```js
import { useState, useEffect } from "react";
```

接著，創建一個 `useDebounce` 函式（程式），它接受 `value` 和 `delay` 作為參數。`value` 是你想等待的資源，`delay` 是你想等待的時間週期。由於你想等待一段時間，`setTimeout` 和 `clearTimeout` 函式（程式）會很有用：

```js
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

`debouncedValue` 狀態會保存並傳回延遲的值，該值僅在指定的逾時期間後更新。

`useEffect` 是真正發生魔法的地方。如果你還記得上一課，任何存在於 React 呈現週期之外的事物，例如設定和清除計時器，都是副作用，你應該使用 `useEffect` 掛鉤來控制代碼。

在這裡的 `useEffect` 掛鉤中，你使用 `setTimeout` 來設定 `debouncedValue`。然後你傳回一個清理函式，該函式會在 `value` 或 `delay` 改變，或組件卸載時使用 `clearTimeout` 清除先前的逾時。

要使用這個掛鉤，我們已準備好一個 `footballers` 陣列，並搭配簡單的搜尋欄來篩選：

```js
const footballers = [
  'Lionel Messi', 'Cristiano Ronaldo', 'Neymar Jr',
  'Kylian Mbappe', 'Mohamed Salah', 'Sadio Mane',
  'Kevin De Bruyne', 'Robert Lewandowski', 'Harry Kane',
  'Sergio Ramos', 'Virgil van Dijk', 'Alisson Becker', 
  'Joshua Kimmich', 'Manuel Neuer', 'Karim Benzema', 
  'Thibaut Courtois', 'Eden Hazard', 'Raheem Sterling',
  'Bruno Fernandes', 'Trent Alexander-Arnold', 'Son Heung-min',
  'Pierre-Emerick Aubameyang','Sergio Aguero', 'Luis Suarez', 
  'Luka Modric', 'Casemiro', 'Frenkie de Jong', 'Gerard Pique',
  'Marc-Andre ter Stegen', 'Keylor Navas', 'Angel Di Maria', 
  "N'Golo Kante", 'Kai Havertz', 'Timo Werner', 'Hakim Ziyech', 
  'Christian Pulisic', 'Mason Mount', 'Olivier Giroud', 'Tammy Abraham', 
  'Kepa Arrizabalaga', 'Ben Chilwell', 'Thiago Silva', 'Kurt Zouma', 
  'John Terry', 'Didier Drogba', 'Frank Lampard', 'Ashley Cole', 'Petr Cech',
];

export default footballers;
```

這裡有一個 `FootballerSearch` 組件，使用 `useDebounce` 掛鉤在使用者停止輸入後延遲 1 秒進行搜尋：

```jsx
import { useState, useEffect } from "react";
import { useDebounce } from "./hooks/useDebounce";
import footballers from "./footballers";

const FootballerSearch = () => {
  const [query, setQuery] = useState("");
  const debouncedQuery = useDebounce(query, 1000); // Start searching 1 second after the user stops typing

  useEffect(() => {
    if (debouncedQuery) {
      const results = footballers.filter((footballer) =>
        footballer.toLowerCase().includes(debouncedQuery.toLowerCase()),
      );
      console.log("Search results:", results);
    } else {
      console.log("Search results: []");
    }
  }, [debouncedQuery]);

  return (
    <>
      <h1 style={{ textAlign: "center" }}>Footballer Search App</h1>
      <div style={{ textAlign: "center" }}>
        <input
          style={{ padding: "0.5rem", width: "30%" }}
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search for a footballer..."
        />
      </div>
    </>
  );
};

export default FootballerSearch;
```

如你所見，`debouncedQuery` 變數是用來以查詢狀態（使用者輸入的內容）和 1,000 毫秒（或 1 秒）的延遲初始化 `useDebounce` 掛鉤。搜尋本身是在 `useEffect` 掛鉤內處理，搜尋結果會記錄到主控台。

# --questions--

## --text--

在 React 中建立訂製掛鉤的顯著利益是什麼？

## --answers--

它使組件算繪更快。

### --feedback--

訂製掛鉤有助於避免在不同組件中重複相同的邏輯。

---

它允許你在多個組件中重複使用邏輯。

---

它取代了內建掛鉤的需求。

### --feedback--

訂製掛鉤有助於避免在不同組件中重複相同的邏輯。

---

它強制組件共享相同的狀態。

### --feedback--

訂製掛鉤有助於避免在不同組件中重複相同的邏輯。

## --video-solution--

2

## --text--

React 中訂製掛鉤的正確命名慣例是什麼？

## --answers--

應該以 `use` 開頭。

---

它可以有任何名稱。

### --feedback--

考慮為掛鉤指定一個特定的前置式。

---

它應該以 "`Hook`" 結尾。

### --feedback--

考慮為掛鉤指定一個特定的前置式。

---

它必須符合內建掛鉤名稱。

### --feedback--

考慮為掛鉤指定一個特定的前置式。

## --video-solution--

1

## --text--

你會如何稱呼一個切換值開關的訂製掛鉤？

## --answers--

`useSwitch`

### --feedback--

訂製掛鉤應遵循 React 的命名慣例並清楚描述其用途。

---

`useToggle`

---

`toggleHook`

### --feedback--

訂製掛鉤應遵循 React 的命名慣例並清楚描述其用途。

---

`useBoolean`

### --feedback--

訂製掛鉤應遵循 React 的命名慣例並清楚描述其用途。

## --video-solution--

2
