---
id: 6724e5e321bce627736ea145
title: 關聯式資料庫回顧
challengeType: 31
dashedName: review-relational-databases
---

# --description--

## 終端機、Shell 與命令列基礎

- **命令列**：一種使用者輸入指令的文字介面。
- **終端機**：提供存取命令列的應用程式。
- **終端機模擬器**：為終端機添加額外的特性。
- **Shell**：解譯輸入到終端機的指令（例如，Bash）。
- **PowerShell / Command Prompt / Microsoft Terminal**：在 Windows 上存取命令列的選項。
- **終端機 (macOS)**：macOS 上的原生選項，可使用第三方替代方案如 iTerm 或 Ghostty。
- **終端機 (Linux)**：選項因發行版本而異，並有許多第三方模擬器如 kitty。
- **術語**：雖然「終端機」、「shell」和「命令列」經常互換使用，但它們有特定的意義。

## 命令列捷徑

- **上/下箭頭**：在歷史紀錄中循環瀏覽先前/下一個指令。
- **Tab**：自動完成指令。
- **`Control+L`**（Linux/macOS）或輸入 `cls`（Windows）：清除終端機螢幕。
- **`Control+C`**：中斷正在執行的指令（如果選取了文字，在 PowerShell 中也用於複製）。
- **`Control+Z`**（僅限 Linux/macOS）：將工作暫停到背景；使用 `fg` 來恢復它。
- **`!!`**：立即重新執行最後執行的指令。

## Bash 基礎知識

- **Bash**（Bourne Again Shell）：廣泛使用的類 Unix shell。主要指令：

  - **`pwd`**：顯示目前的目錄。
  - **`cd`**：切換目錄。
    - **`..`** 取用父目錄（上一層）。
    - **`.`** 指的是目前的目錄。
  - **`ls`**：列出檔案和資料夾。
    - **`-a`**：顯示所有檔案，包括隱藏檔案。
    - **`-l`**：顯示關於檔案的詳細資訊。
  - **`less`**：以分頁方式檢視檔案內容，並提供向後捲動及搜尋等導覽選項。
  - **`more`**：一次顯示一個螢幕的檔案內容，具有限制向後捲動和基本導覽功能。
  - **`cat`**：一次顯示整個檔案內容，無需捲動或導航，適用於較小的檔案。
  - **`mkdir`**：創建一個新的目錄。
  - **`rmdir`**：移除空的目錄。
  - **`touch`**：創建一個新檔案。
  - **`mv`**：移動或重新命名檔案。
    - 重新命名：`mv oldname.txt newname.txt`
    - 移動：`mv filename.txt /path/to/target/`
  - **`cp`**：複製檔案。
    - **`-r`**：遞迴複製目錄及其內容。
  - **`rm`**：刪除檔案。
    - **`-r`**：遞迴刪除目錄及其內容。
  - **`echo`**：顯示一行文字或變數的值。
    - 使用 `>` 覆寫檔案中現有的內容。（例如，`echo "text" > file.txt`）
    - 使用 `>>` 將輸出附加到檔案 **而不覆寫現有內容**（例如，`echo "text" >> file.txt`）。
  - **`exit`**：離開終端機工作階段。
  - **`clear`**：清除終端機螢幕。
  - **`find`**：搜尋檔案和目錄。
    - **`-name`**：依檔案名稱樣式搜尋檔案（例如，`find . -name "*.txt"`）。
  - 使用 **`man`** 後接指令（例如，`man ls`）來存取詳細的手冊／說明頁面。

## 指令選項和旗標

- **選項** 或 **旗標**：修改指令的行為，通常以連字號作為前置式：
  - **長表單（兩個連字號）**：
    - 範例：`--help`、`--version`
    - 值是使用等號附加的，例如，`--width=50`。
  - **短表單（一個連字號）**：
    - 範例：`-a`、`-l`
    - 值以空格傳遞，例如，`-w 50`。
    - 多個短選項可串鏈在一起，例如，`ls -alh`。
- **`--help`**：你可以隨時使用帶有此旗標的指令來了解任何指令的可用選項。

## 關聯式資料庫簡介

- **關聯式資料庫**：將資料組織成由列和行組成的相關表格。每列表述一筆記錄，每行表述資料的一個屬性。
- **關聯式資料庫的優點**：可擴充、廣泛適用於各領域（例如，醫療、商務、遊戲），且結構化以維護可靠的資料。
- **常見使用案例**：網頁開發、庫存系統、電子商務、醫療保健和企業應用程式。

## 關鍵概念

- **Schema**：關聯式資料庫需要一個定義其結構—資料表、行、資料型別、條件和關聯的 schema。
- **主鍵**：每個資料表中每列的唯一識別符。它們對資料完整性至關重要，並用於透過外鍵關聯資料表之間的記錄。
- **外鍵**：對另一個資料表中主鍵的引用，用於連結跨資料表的相關資料。
- **關聯**：透過主鍵和外鍵連接資料表，你可以結構化正規化的資料並執行有意義的查詢。
- **物體關聯圖（ERDs）**：視覺化物體（資料表）在資料庫架構中彼此的關聯。
- **資料完整性**：使用鍵和資料型別強制執行。確保儲存資料的一致性和準確性。

## SQL 基礎知識

- **查詢**：從資料庫中擷取特定資料的請求。

```sql
SELECT * FROM dogs WHERE age < 3;
```

- **WHERE 語句**：根據條件篩選結果。使用比較運算子如 `<`、`=`、`>` 等。
- **使用 ORDER BY 選取**：根據行檢索並排序結果。

```sql
SELECT columns FROM table_name ORDER BY column_name;
```

## 表格操作

- **`CREATE TABLE` 述語**：此述語用於在資料庫中創建新資料表。

```sql
CREATE TABLE first_table();
```

- **`ALTER TABLE ADD COLUMN` 述語**：此述語用於為現有資料表添加行。

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE;
```

- **`ALTER TABLE DROP COLUMN` 述語**：此述語用於從現有資料表中刪除一個行。

```sql
ALTER TABLE table_name DROP COLUMN column_name;
```

- **`ALTER TABLE RENAME COLUMN` 述語**：此述語用於重新命名資料表中的行。

```sql
ALTER TABLE table_name RENAME COLUMN column_name TO new_name;
```

- **`DROP TABLE` 述語**：此述語用於從資料庫中刪除整個資料表。

```sql
DROP TABLE table_name;
```

- **`ALTER DATABASE RENAME` 述語**：此述語用於重新命名資料庫。

```sql
ALTER DATABASE database_name RENAME TO new_database_name;
```

- **`DROP DATABASE` 述語**：此述語用於刪除整個資料庫。

```sql
DROP DATABASE database_name;
```

## 條件與資料完整性

- **`ALTER TABLE ADD COLUMN` 搭配條件**：此述語用於為現有資料表添加帶有條件的行。

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE CONSTRAINT;
```

- **`NOT NULL` 條件**：此條件確保行不能有 NULL 值。

```sql
column_name VARCHAR(50) NOT NULL
```

- **`ALTER TABLE ADD PRIMARY KEY` 述語**：此述語用於為資料表添加主鍵條件。

```sql
ALTER TABLE table_name ADD PRIMARY KEY(column_name);
```

- **`ALTER TABLE DROP CONSTRAINT` 述語**：此述語用於從資料表中刪除條件。

```sql
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
```

- **`ALTER TABLE ADD COLUMN` 與外鍵**：此述語用於新增一個外鍵行，該行引用另一個資料表。

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE REFERENCES referenced_table_name(referenced_column_name);
```

- **`ALTER TABLE ADD UNIQUE` 述語**：此述語用於為你的行添加 UNIQUE 條件。

```sql
ALTER TABLE table_name ADD UNIQUE(column_name);
```

- **`ALTER TABLE ALTER COLUMN SET NOT NULL` 述語**：此述語用於在現有的行上設定 NOT NULL 條件。

```sql
ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL;
```

- **`INSERT` 述語與 NULL 值**：此述語示範如何將 NULL 值插入資料表中。

```sql
INSERT INTO table_name(column_a) VALUES(NULL);
-- or
INSERT INTO table_name(column_b) VALUES('value'); -- if column_a allows nulls
```

- **複合主鍵**：此條件定義由多個行組成的主鍵。

```sql
CREATE TABLE course_enrollments (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id)
);
```

## 資料操作（CRUD）

- **`INSERT` 述語**：此述語用於將單一列插入資料表中。

```sql
INSERT INTO table_name(column_1, column_2) VALUES(value1, value2);
```

- **省略行的 `INSERT` 述語**：此述語示範如何在不明確列出行名稱的情況下插入值，依賴資料表中的預設行順序。

```sql
INSERT INTO dogs VALUES ('Gino', 3);
```

- **多列的 `INSERT` 述語**：此述語用於在單一操作中將多列插入資料表。

```sql
INSERT INTO dogs (name, age) VALUES 
('Gino', 3),
('Nora', 2);
```

- **`UPDATE` 述語**：此述語用於根據條件更新資料表中現有的資料。

```sql
UPDATE table_name SET column_name=new_value WHERE condition;
```

- **`DELETE` 述語**：此述語用於根據條件刪除資料表中的列。

```sql
DELETE FROM table_name WHERE condition;
```

## 資料型別

- **`NUMERIC` 資料型別**：此資料型別用於儲存具有指定精度和小數位數的精確十進位數字。

```sql
price NUMERIC(10, 2)
```

- **`TEXT` 資料型別**：此資料型別用於儲存無特定長度限制的可變長度字元字串。

```sql
column_name TEXT
```

- **`INTEGER` 資料型別**：此資料型別用於儲存沒有小數位的整數。

```sql
units_sold INTEGER
```

- **`SMALLINT` 和 `BIGINT` 資料型別**：這些是 INTEGER 的變體，分別具有較小和較大的範圍。

- **`SERIAL` 資料型別**：此資料型別用於在 PostgreSQL 中創建自動遞增的整數行。

```sql
id SERIAL
```

- **`AUTO_INCREMENT` 屬性**：此屬性用於 MySQL 中以創建自動遞增的整數行。

```sql
id INT AUTO_INCREMENT
```

- **`VARCHAR` 資料型別**：此資料型別用於儲存具有指定最大長度的可變長度字元字串。

```sql
name VARCHAR(50)
```

- **`DATE` 資料型別**：此資料型別用於儲存日期值（年、月、日）。

```sql
event_date DATE
```

- **`TIME` 資料型別**：此資料型別用於儲存時間值（小時、分鐘、秒）。

```sql
start_time TIME
```

- **`TIMESTAMP` 資料型別**：此資料型別用於儲存日期和時間值，並可選擇性地包含時區資訊。

```sql
event_timestamp TIMESTAMP
event_timestamp TIMESTAMP WITH TIME ZONE
```

- **`BOOLEAN` 資料型別**：此資料型別用於儲存 true/false 值。

```sql
is_active BOOLEAN
```

## 資料庫關聯

- **關係的型別**：這些是在關聯式資料庫中資料表彼此關聯的不同方式。
  - 一對一
  - 一對多
  - 多對一
  - 多對多
  - 自我取用（遞迴）

- **一對一關係**：此關係型別表示一個資料表中的每個記錄對應另一個資料表中的恰好一個記錄。

```md
One employee is assigned exactly one vehicle.
Tables: employees, vehicles
```

- **一對多關係**：此關係型別表示一個資料表中的一筆記錄可以與另一個資料表中的多筆相關記錄。

```md
One customer can have many orders.
Tables: customers → orders
```

- **多對多關係透過連接表**：此關係型別是使用包含兩個相關資料表外鍵的連接表來實作。

```sql
CREATE TABLE books_authors (
    author_id INT REFERENCES authors(id),
    book_id INT REFERENCES books(id)
);
```

- **自我取用關係**：當一個資料表取用自身時，會產生階層式結構的關係型態。

```md
An employee table where each employee may report to another employee.
```

## 進階 SQL（連接）

- **`INNER JOIN` 述語**：此連接僅傳回兩個資料表中具有相符值的列。

```sql
SELECT *
FROM products
INNER JOIN sales ON products.product_id = sales.product_id;
```

- **`FULL OUTER JOIN` 述語**：此連接會傳回兩個資料表中的所有列，包括任一資料表中未配對的列。

```sql
SELECT *
FROM products
FULL OUTER JOIN sales ON products.product_id = sales.product_id;
```

- **`LEFT OUTER JOIN` 述語**：此連接會傳回左表的所有列以及右表中符合條件的列。

```sql
SELECT *
FROM products
LEFT JOIN sales ON products.product_id = sales.product_id;
```

- **`RIGHT OUTER JOIN` 述語**：此連接會傳回右表的所有列以及左表中符合條件的列。

```sql
SELECT *
FROM products
RIGHT JOIN sales ON products.product_id = sales.product_id;
```

- **`SELF JOIN` 述語**：此連接用於將資料表與自身連接，以比較同一資料表內的列。

```sql
SELECT A.column_name, B.column_name
FROM table_name A
JOIN table_name B ON A.related_column = B.related_column;
```

- **`CROSS JOIN` 述語**：此連接會傳回兩個資料表的笛卡兒積，將第一個資料表的每一列與第二個資料表的每一列組合。

```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

## PostgreSQL 專用指令

- **`psql` 登入指令**：此指令用於使用特定使用者名稱和資料庫登入 PostgreSQL。

```bash
psql --username=freecodecamp --dbname=postgres
```

- **`\l` 指令**：此指令會列出 PostgreSQL 實體中的所有資料庫。

```sql
\l
```

- **`CREATE DATABASE` 和 `\c` 指令**：這些指令用於創建新的資料庫並連接到該資料庫。

```sql
CREATE DATABASE database_name;
\c database_name
```

- **`\d` 指令**：此指令會列出目前資料庫中的所有資料表。

```sql
\d
```

- **`\d table_name` 指令**：此指令會顯示特定資料表的 schema／結構。

```sql
\d table_name
```

- **`\q` 指令**：此指令會離開 PostgreSQL 客戶端。

```bash
\q
```

## 關聯式與非關聯式

- **非關聯式（NoSQL）資料庫**：儲存非結構化或半結構化資料。不需要嚴格的結構，對於演變中的資料模型更具彈性。
- **選擇關聯式與非關聯式**：取決於你的資料性質和應用需求。
- **關聯式與非關聯式**：為結構化資料和一致性選擇關聯式；為彈性和快速變動的資料選擇 NoSQL。

## 熱門的 RDBMS 系統

- **MySQL**：開放原始碼、可靠、廣泛用於網頁開發，由龐大社群支援。
- **PostgreSQL**：開放原始碼、進階、可擴充。支援訂製資料型別和伺服端程式設計。
- **SQLite**：輕量級、基於檔案、無伺服端。適合小型應用程式。
- **Microsoft SQL Server**：專有的企業級資料庫。
- **Oracle Database**：以大規模效率與可擴充性著稱的商業關聯式資料庫管理系統。

## 最佳實務

- **命名慣例**：對於資料表和行名稱，使用 `snake_case`（例如，`delivery_orders`）。

## Bash 腳本基礎

- **Bash 腳本撰寫**：在一個檔案中撰寫一連串的 Bash 指令，然後你可以使用 Bash 來執行該檔案的內容。
- **Shebang**：腳本開頭的註解行（例如 `#!/bin/bash`），用來顯示應該使用哪個直譯器來執行該腳本。

  ```bash
  #!/bin/bash
  ```

- **變數指派**：使用語法 `variable_name=value` 來實例化變數。

  ```bash
  servers=("prod" "dev")
  ```

- **變數產生規則**：使用 `VARIABLE_NAME=VALUE` 語法創建變數。等號（`=`）兩邊不得有空格。如果值包含空格，請使用雙引號。

  ```bash
  NAME=John
  MESSAGE="Hello World"
  COUNT=5
  TEXT="The next number is, "
  ```

- **變數使用**：在變數名稱前加上 `$` 以存取變數值。

  ```bash
  echo $NAME
  echo "The message is: $MESSAGE"
  ```

- **變數插值**：使用 `$variable_name` 在字串和指令中存取變數的值。

  ```bash
  TEXT="The next number is, "
  NUMBER=42
  echo $TEXT B:$NUMBER
  echo $TEXT I:$NUMBER
  
  echo "Pulling $server"
  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf
  ```

- **變數範圍**：Shell 腳本從上到下執行，所以變數只能在它們被創建的下方使用。

  ```bash
  NAME="Alice"
  echo $NAME
  ```

- **使用者輸入**：使用 `read` 從使用者接收輸入並將其儲存在變數中。

  ```bash
  read USERNAME
  echo "Hello $USERNAME"
  ```

- **註解**：為你的腳本添加註解，使用 `#` 後接你的註解文字。
  - 單行註解以 `#` 開頭，並持續到該行結尾。
  - Shell 會忽略註解，且不會影響腳本執行。

  ```bash
  # This is a single-line comment
  NAME="John"  # Comment at end of line
  ```

- **多行註解**：使用冒號和引號將程式碼區塊註解起來。

  ```bash
  : '
  This is a multi-line comment
  Everything between the quotes is ignored
  Useful for debugging or documentation
  '
  ```

- **內建指令與說明**：
  - 使用 `help` 查看內建 bash 指令的列表
  - 使用 `help <command>` 來取得關於特定內建指令的資訊
  - 有些指令（例如 `if`）是內建指令，沒有 man 頁面。
  - 內建指令由 shell 直接執行，而非作為外部程式。
  - 使用 `help function` 查看有關建立函式（程式） 的資訊

  ```bash
  help
  help if
  help function
  ```

- **尋找指令位置**：使用 `which` 來定位執行檔安裝的位置。
  - 顯示可執行檔的完整路徑
  - 有助於尋找直譯器位置（例如 bash）
  - 有助於驗證將執行哪個版本的指令

  ```bash
  which bash
  which python
  which ls
  ```

- **手冊頁**：使用 `man` 存取指令的詳細文件。
  - 提供關於指令使用的完整資訊
  - 顯示所有可用的選項和範例
  - 使用方向鍵導航，按 q 退出
  - 並非所有指令都有手冊頁（內建指令改用 `help`）

  ```bash
  man echo
  man ls
  man bash
  ```

- **說明旗標**：許多指令支援 `--help` 以快速取得說明資訊。
  - 快速取用的手冊頁替代方案
  - 顯示指令語法和常見選項
  - 並非所有指令都支援此旗標（有些可能會顯示錯誤）

  ```bash
  ls --help
  chmod --help
  mv --help
  ```

- **Echo 指令選項**：`echo` 指令支援各種選項：
  - `-e` 選項啟用反斜線轉義的解釋
  - `\n` 產生新的一行
  - 只有當值被引號包住時，空行才會被列印
  - 有助於建立格式化輸出和程式標題

  ```bash
  echo -e "Line 1\nLine 2"
  echo ""
  echo -e "\n~~ Program Title ~~\n"
  echo "Line 1\nLine 2"
  ```

- **腳本引數**：程式可以接受可透過 `$` 變數存取的引數。
  - `$*` 列印傳遞給腳本的所有引數
  - `$@` 將所有傳遞給腳本的引數以獨立的帶引號字串列印出來
  - `$<number>` 依位置存取特定引數（例如，`$1`、`$2`、`$3`）

  ```bash
  echo $*
  echo $@
  echo $1
  echo $2
  ```

## 雙中括號表達式 `[[ ]]`

- **雙括號語法**：使用 `[[ ]]` 進行條件測試和樣式匹配。
  - 括號內及運算子兩側必須有空格
  - 根據測試結果傳回離開狀態 0（true）或 1（false）

  ```bash
  [[ $variable == "value" ]]
  [[ $number -gt 10 ]]
  [[ -f filename.txt ]]
  ```

- **字串比較運算子**：在 `[[ ]]` 中使用各種運算子比較字串。
  - `==`（相等）：測試兩個字串是否相同
  - `!=`（不相等）：測試兩個字串是否不同
  - `<`（字典序較小）：字串依字母順序比較
  - `>`（字典序較大）：字串按字母順序比較

  ```bash
  [[ "apple" == "apple" ]]
  [[ "apple" != "orange" ]]
  [[ "apple" < "banana" ]]
  [[ "zebra" > "apple" ]]
  ```

- **數值比較運算子**：使用特定的數值運算子比較數字。
  - `-eq`（相等）：數值相等比較
  - `-ne`（不相等）：數值不相等比較
  - `-lt`（小於）：數值小於比較
  - `-le`（小於或相等）：數值小於或相等比較
  - `-gt`（大於）：數值大於比較
  - `-ge`（大於或相等）：數值大於或相等比較

  ```bash
  [[ $number -eq 5 ]]
  [[ $count -ne 0 ]]
  [[ $age -ge 18 ]]
  [[ $score -lt 100 ]]
  ```

- **邏輯運算子**：使用邏輯運算子結合多個條件。
  - `&&`（且）：兩個條件都必須為真
  - `||`（或）：至少有一個條件必須為真
  - `!` (not)：否定條件（使 true 變成 false，false 變成 true）

  ```bash
  [[ $age -ge 18 && $age -le 65 ]]
  [[ $name == "John" || $name == "Jane" ]]
  [[ ! -f missing_file.txt ]]
  ```

- **檔案測試運算子**：測試檔案屬性和存在性。
  - `-e file`：如果檔案存在則為 True
  - `-f file`：如果檔案存在且為一般檔案，則為真
  - `-d file`：如果檔案存在且是目錄，則為 True
  - `-r file`：如果檔案存在且可讀，則為 True
  - `-w file`：如果檔案存在且可寫入，則為 True
  - `-x file`：如果檔案存在且可執行，則為 True
  - `-s file`：如果檔案存在且大小大於零，則為真

  ```bash
  [[ -e /path/to/file ]]
  [[ -f script.sh ]]
  [[ -d /home/user ]]
  [[ -x program ]]
  ```

- **使用 `=~` 進行樣式匹配**：使用正則表達式進行進階樣式匹配。
  - `=~` 運算子啟用正則表達式樣式比對
  - 使用正則表達式元字元時，樣式不應加引號
  - 支援完整的正規表達式語法
  - 預設區分大小寫

  ```bash
  [[ "hello123" =~ [0-9]+ ]]
  [[ "email@domain.com" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
  [[ "filename.txt" =~ \.txt$ ]]
  ```

- **變數存在性測試**：檢查變數是否已設定或為空。
  - 測試變數是否為空：`[[ ! $variable ]]`

  ```bash
  [[ ! $undefined_var ]]
  ```

## 雙重小括弧表達式 `(( ))`

- **算術運算**：使用 `(( ))` 進行數學計算和數值比較。
  - 使用 C 風格語法評估算術運算式
  - 在雙重小括弧內，變數不需要 `$` 前置式
  - 如果結果非零，傳回離開狀態 0；如果結果為零，傳回離開狀態 1。
  - 支援所有標準算術運算子

  ```bash
  (( result = 10 + 5 ))
  (( count++ ))
  (( total += value ))
  ```

- **算術運算子**：`(( ))` 中可用的數學運算子。
  - `+`（加法）：將兩個數字相加
  - `-`（減法）：從第一個數字中減去第二個數字
  - `*`（乘法）：將兩個數字相乘
  - `/`（除法）：將第一個數字除以第二個數字（整數除法）
  - `%`（取餘數）：除法後的餘數
  - `**`（次方運算）：將第一個數字引發到第二個數字的次方

  ```bash
  (( sum = a + b ))
  (( diff = x - y ))
  (( product = width * height ))
  (( remainder = num % 10 ))
  (( power = base ** exponent ))
  ```

- **指定運算子**：使用算術指定運算子修改變數。
  - `=`（指派）：將值指定給變數
  - `+=`（加並指定）：將值加到變數
  - `-=`（減去並指定）：從變數中減去值
  - `*=`（乘法並指定）：將變數乘以值
  - `/=`（除以並指定）：將變數除以值
  - `%=`（取餘數並指定）：將變數設值為餘數

  ```bash
  (( counter = 0 ))
  (( counter += 5 ))
  (( total -= cost ))
  (( area *= 2 ))
  (( value /= 3 ))
  ```

- **遞增與遞減運算子**：將變數增加或減少一。
  - `++variable`（前置遞增）：使用前遞增
  - `variable++`（後置遞增）：使用後遞增
  - `--variable`（前置遞減）：使用前遞減
  - `variable--`（後置遞減）：使用後遞減

  ```bash
  (( ++counter ))
  (( index++ ))
  (( --remaining ))
  (( attempts-- ))
  ```

- **比較運算子**：使用算術比較來比較數字。
  - `==`（相等）：數字相等
  - `!=`（不相等）：數字不相等
  - `<`（小於）：第一個數字小於第二個數字
  - `<=`（小於或相等）：第一個數字小於或相等於第二個數字
  - `>`（大於）：第一個數字大於第二個數字
  - `>=`（大於或相等）：第一個數字大於或相等於第二個數字

  ```bash
  (( age >= 18 ))
  (( score < 100 ))
  (( count == 0 ))
  (( temperature > freezing ))
  ```

- **邏輯運算子**：結合算術條件。
  - `&&`（且）：兩個條件都必須為真
  - `||`（或）：至少有一個條件必須為真
  - `!` (not)：否定條件

  ```bash
  (( age >= 18 && age <= 65 ))
  (( score >= 90 || extra_credit > 0 ))
  (( !(count == 0) ))
  ```

- **以 bit 為單元逐一操作的運算子**：對整數執行以位元層級的操作行為。
  - `&`（以 bit 為單元逐一 AND）：對每個位元進行 AND 操作
  - `|`（以 bit 為單元逐一 OR）：對每個位元進行 OR 操作
  - `^`（以 bit 為單元逐一 XOR）：對每個位元進行 XOR 操作行為
  - `~`（以 bit 為單元逐一 NOT）：反轉所有位元
  - `<<`（左移）：將位元向左移動
  - `>>`（右移）：將位元向右移動

  ```bash
  (( result = a & b ))
  (( flags |= new_flag ))
  (( shifted = value << 2 ))
  ```

- **條件（三元）運算子**：使用 `condition ? true_value : false_value` 語法。
  - 提供一種根據條件指定值的簡潔方式
  - 類似於 C 類語言中的三元運算子
  - 評估條件並傳回兩個值中的一個

  ```bash
  (( result = (score >= 60) ? 1 : 0 ))
  (( max = (a > b) ? a : b ))
  (( sign = (num >= 0) ? 1 : -1 ))
  ```

- **算術運算的命令替換**：使用 `$(( ))` 來取得算術結果。
  - 傳回算術表達式的結果字串
  - 可用於指派或命令引數中
  - 適用於需要在其他地方使用的計算

  ```bash
  result=$(( 10 + 5 ))
  echo "The answer is $(( a * b ))"
  array_index=$(( RANDOM % array_length ))
  ```

## 控制流程與條件判斷

- **條件述語**：使用 `if` 述語根據條件執行程式碼。
  - 基本語法：`if [[ CONDITION ]] then STATEMENTS fi`
  - 完整語法：`if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`
  - 可以同時使用 `[[ ]]` 和 `(( ))` 表達式來處理不同型別的條件。
  - **elif (else if)**：選用，可重複多次以依序測試其他條件
  - **else**：選用，當所有先前條件皆為假時執行
  - 可以在同一條件串鏈中混用雙小括弧 `(( ... ))` 和雙中括弧 `[[ ... ]]`

  ```bash
  if (( NUMBER <= 15 ))
  then
      echo "B:$NUMBER"
  elif [[ $NUMBER -le 30 ]]
  then
      echo "I:$NUMBER"
  elif (( NUMBER < 46 ))
  then
      echo "N:$NUMBER"
  elif [[ $NUMBER -lt 61 ]]
  then
      echo "G:$NUMBER"
  else
      echo "O:$NUMBER"
  fi
  ```

## 指令執行與處理程序控制

- **指令分隔**：使用分號（`;`）在同一行中執行多個指令。
  - 命令從左到右依序執行
  - 每個指令的 `exit` 狀態都可以單獨檢查。

  ```bash
  [[ 4 -ge 5 ]]; echo $?
  ls -l; echo "Done"
  ```

- **離開狀態**：每個指令都有一個離開狀態，用來顯示成功或失敗。
  - 使用 `$?` 存取最後一個指令的離開狀態
  - 離開狀態 `0` 表示成功（true/無錯誤）
  - 任何非零的 `exit` 狀態代表失敗（發生錯誤／錯誤）。
  - 常見錯誤代碼：`127`（找不到指令）、`1`（一般錯誤）

  ```bash
  echo $?
  [[ 4 -le 5 ]]; echo $?
  ls; echo $?
  bad_command; echo $?
  ```

- **子殼層與指令替換**：小括弧在執行背景關係中的不同用法。
  - 單一小括弧 `( ... )` 會創建子殼層
  - `$( ... )` 執行指令替換
  - 子殼層在獨立環境中執行，且不會影響父殼層的變數。

  ```bash
  ( cd /tmp; echo "Current dir: $(pwd)" )
  current_date=$(date)
  file_count=$(ls | wc -l)
  echo "Today is $current_date"
  echo "Found $file_count files"
  ```

- **Sleep 指令**：暫停腳本執行指定秒數。
  - 適用於在腳本中建立延遲
  - 可用於小數秒延遲

  ```bash
  sleep 3
  sleep 0.5
  sleep 1
  ```

## 迴圈

- **While loops**：當條件為真時，重複執行程式碼。
  - 語法：`while [[ CONDITION ]] do STATEMENTS done`

  ```bash
  I=5
  while [[ $I -ge 0 ]]
  do
      echo $I
      (( I-- ))
      sleep 1
  done
  ```

- **Until 迴圈**：重複執行程式碼直到條件變為真。
  - 語法：`until [[ CONDITION ]] do STATEMENTS done`

  ```bash
  until [[ $QUESTION =~ \?$ ]]
  do
      echo "Please enter a question ending with ?"
      read QUESTION
  done
  until [[ $QUESTION =~ \?$ ]]
  do
      GET_FORTUNE again
  done
  ```

- **For 迴圈**：使用 `for` 迴圈搭配 `do` 和 `done` 來定義迴圈的邏輯區塊，對陣列或列表進行迭代。

  ```bash
  for server in "${servers[@]}"
  do
      echo "Processing $server"
  done
  for (( i = 1; i <= 5; i++ ))
  do
      echo "Number: $i"
  done
  for (( i = 5; i >= 1; i-- ))
  do
      echo "Countdown: $i"
  done
  for i in {1..5}
  do
      echo "Count: $i"
  done
  ```

## 陣列

- **陣列**：在單一變數中儲存多個值。
  - 使用小括弧創建陣列：`ARRAY=("value1" "value2" "value3")`
  - 透過索引存取元素：`${ARRAY[0]}`、`${ARRAY[1]}`
  - 存取所有元素：`${ARRAY[@]}` 或 `${ARRAY[*]}`
  - 陣列索引從 0 開始

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Ask again later")

  echo ${RESPONSES[0]}     # Yes          
  echo ${RESPONSES[1]}     # No         
  echo ${RESPONSES[5]}     # Index 5 doesn't exist; empty string              
  echo ${RESPONSES[@]}     # Yes No Maybe Ask again later   
  echo ${RESPONSES[*]}     # Yes No Maybe Ask again later 
  ```

- **使用 declare 進行陣列檢查**：使用 `declare -p` 查看陣列詳細資訊。
  - 顯示帶有 `-a` 旗標的陣列型別
  - 顯示所有陣列元素及其結構

  ```bash
  ARR=("a" "b" "c")
  declare -p ARR # ARR=([0]="a" [1]="b" [2]="c")
  ```

- **陣列展開**：使用 `"${array_name[@]}"` 語法將陣列展開為個別元素。

```bash
for server in "${servers[@]}"
```

## 函式（程式）

- **函式（程式）**：創建可重複使用的程式碼區塊。
  - 使用 `FUNCTION_NAME() { STATEMENTS }` 定義
  - 透過使用函式名稱來呼叫
  - 可以接受可透過 `$1`、`$2` 等存取的引數。

  ```bash
  GET_FORTUNE() {
      echo "Ask a question:"
      read QUESTION
  }
  GET_FORTUNE
  ```

- **函式引數**：函式可以接受引數，就像腳本一樣。
  - 在呼叫函式時會傳遞引數
  - 使用 `$1`、`$2` 等存取函式內的引數。
  - 使用條件邏輯來處理不同的引數

  ```bash
  GET_FORTUNE() {
      if [[ ! $1 ]]
      then
          echo "Ask a yes or no question:"
      else
          echo "Try again. Make sure it ends with a question mark:"
      fi
      read QUESTION
  }
  GET_FORTUNE
  GET_FORTUNE again
  ```

## 隨機數與數學操作

- **隨機數**：使用 `$RANDOM` 變數來產生隨機值。
  - `$RANDOM` 會產生介於 0 和 32767 之間的數字
  - 使用取模運算子限制範圍：`$RANDOM % 75`
  - 為避免零，為 1 添加：`$(( RANDOM % 75 + 1 ))`
  - 必須使用 `$(( ... ))` 語法來進行 `$RANDOM` 的計算

  ```bash
  NUMBER=$(( RANDOM % 6 ))
  DICE=$(( RANDOM % 6 + 1 ))
  BINGO=$(( RANDOM % 75 + 1 ))
  echo $(( RANDOM % 10 ))
  ```

- **隨機陣列存取**：使用隨機數來隨機存取陣列元素。
  - 在陣列範圍內產生隨機索引
  - 使用隨機索引存取陣列元素
  - 適用於從預定義的選項中隨機選擇

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Outlook good" "Don't count on it" "Ask again later")
  N=$(( RANDOM % 6 ))
  echo ${RESPONSES[$N]}
  ```

- **取模運算子**：使用 `%` 來取得除法操作的餘數。
  - 限制隨機數範圍的必要條件
  - 與 `$RANDOM` 一起使用以創建有界隨機值
  - `RANDOM % n` 會產生從 0 到 n-1 的數字

  ```bash
  echo $(( 15 % 4 ))
  echo $(( RANDOM % 100 ))
  echo $(( RANDOM % 10 + 1 ))
  ```

## 環境與系統資訊

- **環境變數**：在 shell 環境中可用的預定義變數。
  - `$RANDOM`：產生介於 0 和 32767 之間的隨機數。
  - `$LANG`：系統語言設定
  - `$HOME`：使用者主目錄路徑
  - `$PATH`：用於搜尋可執行指令的目錄
  - 使用 `printenv` 或 `declare -p` 查看全部

  ```bash
  echo $RANDOM
  echo $HOME
  echo $LANG
  printenv
  ```

- **變數檢查**：使用 `declare` 來查看和操作變數。
  - `declare -p`：列印所有變數及其值
  - `declare -p VARIABLE`：列印特定變數的詳細資訊
  - 顯示變數型別（字串、陣列等）和屬性

  ```bash
  declare -p
  declare -p RANDOM
  declare -p MY_ARRAY
  ```

- **指令型別**：bash 中可用的不同指令類別。
  - **內建指令**：由 shell 直接執行（例如 `echo`、`read`、`if`）
  - **外部指令**：系統目錄中的二進位檔案（例如，`ls`、`sleep`、`bash`）
  - **Shell 關鍵字**：語言構件（例如 `then`、`do`、`done`）
  - 使用 `type <command>` 查看指令的型別。

  ```bash
  type echo
  type ls
  type if
  type ./script.sh
  ```

## 檔案產生與管理

- **檔案產生**：使用 `touch` 來創建新的空白檔案。
  - 如果不存在，則創建新的檔案
  - 如果檔案已存在，則更新時間戳記
  - 常用於在編輯前創建腳本檔案

  ```bash
  touch script.sh
  touch bingo.sh
  touch filename.txt
  ```

## 建立與執行 Bash 腳本

- **腳本執行方法**：多種方式來執行 bash 腳本：
  - **`sh scriptname.sh`**：使用 sh shell 直譯器執行。
  - **`bash scriptname.sh`**：使用 bash shell 直譯器執行。
  - **`./scriptname.sh`**：直接執行（需要可執行權限）。

```bash
sh questionnaire.sh
bash questionnaire.sh
./questionnaire.sh
```

## 檔案權限與腳本執行

- **權限拒絕錯誤**：當使用 `./scriptname.sh` 時，如果該檔案缺少可執行權限，你可能會收到「permission denied」的錯誤。
- **檢查權限**：使用 `ls -l` 查看檔案權限。

  ```bash
  ls -l questionnaire.sh
  ```

- **權限格式**：輸出顯示權限為 `-rw-r--r--`，其中：
  - 第一個字元（`-`）：檔案型別（`-` 表示一般檔案，`d` 表示目錄）
  - 接下來 9 個字元：擁有者、群組和其他人的權限
  - `r` = 讀取、`w` = 寫入、`x` = 執行
  
- **添加可執行權限**：使用 `chmod +x` 為所有人添加可執行權限。

  ```bash
  chmod +x questionnaire.sh
  ```

- **腳本組織**：結構化 bash 腳本的最佳實踐。
  - 以 shebang (`#!/bin/bash`) 開頭
  - 為你的腳本添加關於目的的描述性註解
  - 在頂部定義變數
  - 將相關的函式（程式）群組在一起
  - 主要腳本邏輯位於底部

  ```bash
  #!/bin/bash
  NAME="value"
  ARRAY=("item1" "item2")
  my_function() {
      echo "Function code here"
  }
  my_function
  echo "Script complete"
  ```

- **序列腳本執行**：創建主腳本以依序執行多個程式。
  - 適用於自動化涉及多個腳本的工作流程
  - 每個腳本在下一個開始之前會執行完成。
  - 可以將不同的程式合併成單一執行流程
  - 可以根據需要將引數傳遞給個別腳本。
  - 可以包含不同型別的程式（互動式、 自動化等）。

  ```bash
  #!/bin/bash
  ./setup.sh
  ./interactive.sh
  ./processing.sh
  ./cleanup.sh
  ```

## 資料庫正規化

這是組織關聯式資料庫以減少資料冗餘並提升完整性的處理程序。

它的利益包括：

- 將重複的資料降到最低，這樣可以節省儲存空間並減少不一致性。
- 透過使用主鍵和外鍵來強制執行資料完整性。
- 讓資料庫更容易維護和理解。

### 正常表單

- **1NF（第一正規化形式）**
  - 每個儲存格包含一個單一的（不可分割的）值。
  - 每個記錄都是唯一的（由主鍵強制執行）。
  - 列/行的順序無關緊要。
  - 範例：將多個電話號碼從 `students` 資料表移動到獨立的 `student_phones` 資料表中。

- **2NF（第二正規化形式）**
  - 符合 1NF 要求。
  - 沒有**部分相依性**：每個非鍵屬性必須依賴整個組合主鍵。
  - 範例：將 `orders` 資料表拆分為 `order_header` 和 `order_items`，以避免屬性只依賴於鍵的部分。

- **3NF（第三正規化形式）**
  - 符合 2NF 要求。
  - 沒有**傳遞依賴**：非鍵屬性不能依賴其他非鍵屬性。
  - 範例：將 `city_postal_code` 移動到 `cities` 資料表，而不是與每筆訂單一起儲存。

- **BCNF（Boyce-Codd 正規型）**
  - 符合 3NF 要求。
  - 每個決定項（函式相依性的左側）必須是超鍵。

**提示**：在大多數設計中，目標是達到 3NF，以取得完整性和效率的良好平衡。

## 關鍵 SQL 概念

- SQL 是用於與關聯式資料庫通訊的結構化查詢語言。
- **基本指令** → `SELECT`、`INSERT`、`UPDATE`、`DELETE`、`CREATE TABLE`、`ALTER TABLE` 等。
- `Joins` → 將多個資料表的資料合併（`INNER JOIN`、`LEFT JOIN`、`RIGHT JOIN`、`FULL JOIN`）。

## 在 Bash 中執行 SQL 指令

你可以使用 PostgreSQL 的 `psql` 命令列客戶端或其他資料庫的類似工具，直接從命令列執行 SQL 指令。

例如，要在 PostgreSQL 中執行一個 SQL 檔案：

```bash
psql -U username -d database_name -c "SELECT * FROM students;"
```

你也可以直接執行 MySQL 指令：

```bash
mysql -u username -p database_name -e "SELECT * FROM students;"
```

### 從檔案執行 SQL

```bash
# PostgreSQL
psql -U username -d database_name -f script.sql

# MySQL
mysql -u username -p database_name < script.sql
```

### 在 Bash 腳本中嵌入 SQL

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Insert student data
psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'CS');"
```

### SQL 中變數的使用

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"
STUDENT_NAME="Bob"
AGE=21

psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age) VALUES ('$STUDENT_NAME', $AGE);"
```

**提示**：清理變數以避免 SQL 注入。

## 在 Bash 中擷取和使用 SQL 查詢結果

當你透過 `psql` 執行 SQL 查詢時，你可以在你的 Bash 腳本中**擷取**並**處理**傳回的值。

### 擷取單一值

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get total student count
STUDENT_COUNT=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -c \
"SELECT COUNT(*) FROM students;")

echo "Total students: $STUDENT_COUNT"
```

輸出 → 42

### 擷取多個行

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get top 3 students' names and ages
RESULTS=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, age FROM students LIMIT 3;")

echo "Top 3 students:"
echo "$RESULTS"
```

輸出

```bash
Alice,20
Bob,21
Charlie,22
```

### 迴圈遍歷查詢結果

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get student names and majors
psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, major FROM students;" | while IFS="," read -r name major
do
    echo "Student: $name | Major: $major"
done
```

輸出形狀

```bash
Student: Alice | Major: CS
Student: Bob   | Major: Math
Student: Carol | Major: Physics
```

## SQL 注入

這是一種網路安全漏洞，攻擊者會將惡意的 SQL 程式碼插入輸入欄位，以操控資料庫。

這可能導致像以下的風險行為：

- 繞過身份驗證。
- 竊取敏感資料。
- 修改或刪除記錄。

SQL 注入攻擊的範例：

```sql
SELECT * FROM users WHERE username = ' " " OR "1"="1" -- ' AND password = 'anything';
```

此查詢會傳回所有使用者，因為條件 `OR "1"="1"` 永遠為真，讓攻擊者能繞過登入檢查。

### 防止 SQL 注入

1. **使用 Prepared Statements**：這些將 SQL 程式碼與資料分離，防止注入。以下是一個範例（Node.js 搭配 pg）：

    ```sql
    client.query('SELECT * FROM users WHERE username = $1 AND password = $2', [username, password]);
    ```

2. **輸入驗證**：清理並驗證所有使用者輸入，以確保其符合預期格式。

3. **最小權限**：使用具有應用程式所需最低權限的資料庫帳號。

**注意**：切勿授予應用程式帳戶管理員權限。

## N+1 問題

N+1 問題發生在應用程式執行一次查詢以取得項目（N）的列表，然後對每個項目執行額外查詢以取得相關資料，導致執行 N+1 次查詢。

**為什麼這樣不好**

- 每個查詢都會增加網路和處理程序的額外負擔。
- 多個小查詢比一個最佳化的查詢更慢。

### N+1 樣式範例

```sql
-- 1: Get list of orders
SELECT * FROM orders LIMIT 50;

-- N: For each order, get customer
SELECT * FROM customers WHERE customer_id = ...;
```

**解決方案**：使用 `JOINs` 或其他基於集合的操作。

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name,
  customers.email,
  customers.address
FROM orders
JOIN customers 
  ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50);
```

始終尋找將相關資料合併到單一查詢中的機會。

## 版本控制簡介

- **定義**：版本控制系統允許你追蹤和管理你專案中的變更。在軟體中使用的版本控制系統範例有 Git、SVN 或 Mercurial。

## 基於雲端的版本控制提供者

- **雲端版本控制提供者列表**：GitHub 和 GitLab 是流行的雲端版本控制提供者範例，允許軟體團隊協作並管理儲存庫。

## 安裝與設定 Git

- **安裝 Git**：要檢查你的機器上是否已經安裝 Git，你可以在終端機中執行以下指令：

```sh
git --version
```

如果你看到版本號，表示已安裝 Git。若沒有，則你需要安裝它。

對於 Linux 系統，Git 通常隨大多數發行版預先安裝。如果你沒有預先安裝 Git，應該可以使用你的軟體包管理指令來安裝，例如 `sudo apt-get install git` 或 `sudo pacman -S git`。

對於 Mac 使用者，你可以透過 Homebrew 使用 `brew install git` 安裝 Git，或者你可以從 Git 的網站下載可執行安裝程式。

對於 Windows，你可以從 Git 的網站下載可執行安裝程式。或者，如果你已經設定好 Chocolatey，你可以在 PowerShell 中執行 `choco install git.install`。請注意，在 Windows 上，你可能還想下載 Git Bash，以便擁有類 Unix 的 shell 環境。

為了確保安裝成功，請在終端機中再次執行 `git --version` 指令。

- **Git 設定**：`git config` 用於設定負責 Git 在你的機器上如何運作的設定變數。若要查看你目前的設定變數以及它們在系統中的儲存位置，你可以執行以下指令：

```sh
git config --list --show-origin
```

現在如果你是第一次安裝 Git，應該只會看到系統層級的設定。 

要設定你的使用者名稱，你可以執行以下指令：

```sh
git config --global user.name "Jane Doe"
```

這裡使用 `--global` 旗標來設定系統中所有使用 Git 的專案的使用者名稱。如果你需要為特定專案改寫使用者名稱，則可以在該特定專案目錄中執行該指令，且不使用 `--global` 旗標。

要設定使用者電子郵件位址，你可以執行以下指令：

```sh
git config --global user.email janedoe@example.com
```

另一個你可以設定的組態是你希望 Git 使用的偏好編輯器。以下是如何將你的偏好編輯器設定為 Emacs 的範例：

```sh
git config --global core.editor emacs
```

如果你選擇不設定偏好的編輯器，則 Git 將使用你系統的預設編輯器。

## 開放原始碼軟體與封閉原始碼軟體

- **定義**：「開放原始碼」表示人們可以看到你發佈的程式碼、提出更改建議、回報問題，甚至執行修改過的版本。「封閉原始碼」表示唯一可以看到並互動該專案的人是你明確授權的人。

## GitHub

- **定義**：GitHub 是一個基於雲端的解決方案，提供稱為「repositories」的版本控制專案儲存，並啟用可與這些專案一起使用的協作特性。
- **GitHub CLI**：此工具用於在不離開命令列的情況下執行 GitHub 專屬的任務。如果你尚未安裝，可以從 GitHub 的文件中取得安裝說明－但你應該在系統的軟體包管理員中取得它。
- **GitHub Pages**：GitHub Pages 是一種部署靜態網站的選項，或是不需要後端伺服器來控制邏輯的應用程式。也就是說，完全在客戶端或使用者瀏覽器中執行的應用程式，可以完整部署在此平台上。
- **GitHub Actions**：GitHub Actions 是一個特性，讓你能直接在你的 GitHub 儲存庫中自動化工作流程，包括建置、測試和部署你的程式碼。

## 常用 Git 指令

- **`git init`**：這將初始化一個空的 Git 儲存庫，使 Git 可以開始追蹤此專案的變更。當你為專案初始化一個空的 Git 儲存庫時，會新增一個 `.git` 隱藏目錄。這個 `.git` 目錄包含 Git 用來管理你的專案的重要資訊。
- **`git status`**：此指令用於顯示你工作目錄的當前狀態－你會在工作流程中頻繁使用此指令。
- **`git add`**：此指令用於暫存你的變更。暫存區中的任何內容都會被加入到下一次提交中。如果你想暫存所有未暫存的變更，則可以使用 `git add .`。句點（`.`）是你所在當前目錄的別名。
- **`git commit`**：此指令用於提交你的變更。提交是你專案狀態在特定時間點的螢幕快照。若你執行 `git commit`，它會開啟你在 Git 設定中所設定的偏好編輯器。編輯器開啟後，你可以提供詳細的變更訊息。你也可以選擇使用 `git commit -m` 指令來提供較短的訊息，如下所示：

```sh
git commit -m "short message goes here"
```

- **`git log`**：這會列出所有先前的提交，並附有有用的資訊，例如作者、提交日期、提交訊息和提交雜湊值。提交雜湊值是一個長字串，作為提交的唯一識別符。
- **`git remote add`**：此指令用於設定到你的遠端儲存庫的遠端連線。
- **`git push`**：此指令用於將你的變更推送到遠端儲存庫。
- **`git pull`**：此指令用於將遠端儲存庫中的最新變更拉取到你的區域的儲存庫中。
- **`git clone`**：此指令會複製一個儲存庫。這表示你將擁有該儲存庫的複製本。此複製本包含儲存庫歷史記錄、所有檔案／資料夾及提交，並存在你的區域裝置上。
- **`git remote -v`**：此指令會顯示與你的區域的 Git 倉庫相關的遠端倉庫列表。
- **`git branch`**：此指令會列出你所有的區域的分支。
- **`git fetch upstream`**：此指令告訴 Git 去取得你上游遠端（即原始倉庫）上的最新變更。
- **`git merge upstream/main`**：此指令告訴 Git 將上游遠端中 `main` 分支的最新變更合併到你目前的分支。
- **`git reset`**：此指令允許你重設分支的當前狀態。傳入 `--hard` 旗標會告訴 Git 強制將區域的檔案與分支狀態相符。這可確保你有一個乾淨的起點來進行作業。
- **`git rebase`**：Git 中的 rebase 是將一連串提交從一個分支移動或合併到另一個分支的方法。
  
## 使用分支

- **定義**：Git 中的分支是一個獨立的工作區，你可以在其中進行更改。`main` 分支通常會表現為實際應用中的主要或生產分支。開發團隊會為新功能和錯誤修正創建多個分支，然後將這些更改合併回 `main` 分支。
- **創建新分支**：你可以執行以下指令來創建新分支：

```sh
git branch feature
```

要切換到該分支，你可以執行以下指令：

```sh
git checkout feature
```

大多數開發者會使用建立並切換分支的簡寫指令，指令如下：

```sh
git checkout -b new-branch-name
```

較新且替代的指令是 `git switch` 指令。以下是建立並切換到新分支的範例：

```sh
git switch -c new-branch-name
```

- **分支策略**：你的 `main` 分支是你的預設分支，通常相當穩定。因此，最好從那裡分支出新的分支，用於像是錯誤修正、新功能或其他雜項工作。
- **合併衝突**：當 Git 嘗試自動合併來自不同分支的變更但無法決定保留哪些變更時，就會發生這種情況。這通常發生在同一部分的 `file` 有衝突的變更時。

## Git 追蹤檔案的五種狀態

- **「未追蹤」**：這表示該檔案是新加入到版本庫中，且 Git 之前未曾「看過」它。
- **「已修改」**：此檔案存在於先前的提交中，且有尚未提交的變更。
- **「已忽略」**：你可能不會在 Git 中看到已忽略的檔案，但你的整合開發環境可能會有指示標示它們。已忽略的檔案會被排除在 Git 操作之外，通常是因為它們被包含在 `.gitignore` 檔案中。
- **「Deleted」**：已刪除的檔案是未追蹤檔案的相反——它是先前存在且已被移除的檔案。
- **「重新命名」**：重新命名的檔案是指內容未更改，但檔案的名稱或位置被修改。在某些情況下，即使檔案有少量變更，也可以視為重新命名。

## `.gitignore` 檔案

- **定義**：`.gitignore` 檔案是一種與 Git 操作相關的特殊檔案。名稱暗示這個檔案用來告訴 Git 忽略某些東西，這是常見的使用情境。但它實際上是告訴 Git 停止追蹤某個檔案。

## 與儲存庫合作

- **定義**：儲存庫就像是一個專案的容器－如果你正在開發一個應用程式，你會將該應用程式的檔案集中保存在儲存庫中。儲存庫可以是你電腦上的區域的，也可以是在像 GitHub 這樣的服務上的遠端儲存庫。
- **公開與私人儲存庫**：公開儲存庫可以被任何人檢視和下載。私人儲存庫只能由你和你明確授權存取的人存取。
- **在 GitHub 上創建儲存庫**：要在 GitHub 上創建新的儲存庫，你可以點擊 `"New Repository"` 按鈕，並透過 GitHub 的使用者介面完成新儲存庫的設定。
- **將區域的儲存庫推送到 GitHub**：如果你在你的電腦上有一個區域的專案，你可以將該儲存庫推送到 GitHub。以下是該過程的逐步概述：

1. 在專案目錄中初始化一個空的 git 倉庫（`git init`）。
2. 對你的專案進行更改。
3. 執行 `git status` 指令以查看所有被 git 追蹤的變更。
4. 將你的變更暫存（`git add`）。
5. 提交你的變更（`git commit`）。
6. 設定遠端連線（`git remote add`）。
7. 將你的變更推送到 GitHub（`git push`）。

## 拉取請求

- **Pull Requests**：Pull request 是一個請求，將變更從你的分支拉取到標的分支。當你想為專案貢獻程式碼變更時，Pull request 是你使用的流程。這種方式允許專案的維護者審查你的變更。他們可以留下評論、提出問題，並建議調整。然後，一旦審查程序完成，就可以批准並合併到主分支。

## 為其他儲存庫做出貢獻

- **處理程序**：有數千個專案你可以貢獻。以下是如何為另一個儲存庫貢獻的基本處理程序：

1. 閱讀貢獻文件
2. 尋找可處理的議題
3. 分叉此儲存庫
4. 複製你分支的儲存庫副本
5. 創建一個新分支
6. 根據問題進行更改
7. 創建一個 PR（Pull Request）
8. 等待該 PR 的審查

## 使用 SSH 和 GPG 金鑰

- **GPG 金鑰**：GPG，或稱 Gnu Privacy Guard，金鑰通常用於簽署檔案或提交。其他人可以使用你的公開 GPG 金鑰來驗證該檔案標記是否來自你的金鑰，以及檔案內容是否未被修改或竄改。

要產生 GPG 金鑰，你需要執行：

```sh
gpg --full-generate-key
```

- **SSH 金鑰**：SSH，或稱安全殼層，金鑰通常用於透過 `ssh` 工具驗證遠端連線到伺服器。你也可以使用 SSH 金鑰來簽署提交。

對於 SSH 金鑰，你將執行：

```sh
ssh-keygen -t ed25519 -C "your_email@example.com"
```

`ed25519` 是一種現代公開金鑰標記演算法。

- **使用 GPG 金鑰簽署提交**：為了使用你的 GPG 金鑰簽署提交，你需要將你的公鑰（而非私鑰）上傳到你的 GitHub 帳戶。若要列出你的公鑰，你需要執行以下指令：

```sh
gpg --list-secret-keys --keyid-format=long
```

然後，要取得公鑰，請使用：

```sh
gpg --armor --export "<key id>"
```
  
然後，將你從列出金鑰中取得的短 ID 用來執行此命令，將其設為你的 git 簽署金鑰：

```sh
git config --global user.signingkey <your_gpg_key_id>
```

然後，你可以將 `-S` 旗標傳遞給你的 `git commit` 指令來簽署特定的提交－你需要提供你的密碼短語。或者，如果你想自動簽署每個提交，你可以將 autosign 設定為 `true`：

```sh
git config --global commit.gpgsign true
```

- **使用 SSH 金鑰簽署提交**：要使用 SSH 金鑰簽署，這是 GitHub 上相對較新的特性，你需要先將金鑰上傳到你的 GitHub 帳戶。然後你需要設定 git 的簽署模式以使用 SSH：

```sh
git config --global gpg.format ssh
```

然後，為了設定簽署金鑰，你將傳遞檔案路徑而非 ID：

```sh
git config --global user.signingkey <path_to_your_ssh_keys>
```

# --assignment--

複習 Bash、SQL 和其他關聯式資料庫主題與概念。
