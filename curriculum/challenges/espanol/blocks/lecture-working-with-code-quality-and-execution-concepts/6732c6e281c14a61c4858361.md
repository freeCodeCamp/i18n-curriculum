---
id: 6732c6e281c14a61c4858361
title: ¿Qué son los closures y cómo funcionan?
challengeType: 19
dashedName: what-are-closures-and-how-do-they-work
---

# --interactive--

Los closures son una de las características más poderosas y a menudo malentendidas en JavaScript. En su núcleo, un cierre es una función que tiene acceso a variables en su ámbito léxico envolvente externo, incluso después de que la función externa haya retornado. Esto puede parecer complejo, pero es un concepto fundamental que permite muchos patrones de programación avanzados en JavaScript. 

Para entender los closures, comencemos con un ejemplo:

:::interactive_editor

```js
function outerFunction(x) {
    let y = 10;
    function innerFunction(){
        console.log(x + y);
    }
    return innerFunction;
}

let closure = outerFunction(5);
console.log(closure()); // 15
```

:::

En este ejemplo, `outerFunction` toma un parámetro `x` y define una variable local `y`. Entonces define una `innerFunction` que utiliza tanto `x` como `y`. Finalmente, retorna `innerFunction`. Cuando llamamos a `outerFunction(5)` retorna `innerFunction`, lo cual asignamos a la variable `closure`. Cuando más tarde llamamos a `closure()`, todavía tiene acceso a `x` y `y` de `outerFunction`, incluso después de que `outerFunction` haya terminado de ejecutarse. Esta es la esencia de un closure.

La función interna mantiene una referencia a su entorno léxico externo, preservando el acceso a las variables en ese entorno incluso después de que la función externa haya terminado.

Los closures son particularmente útiles para crear variables y funciones privadas. Considera este ejemplo:

:::interactive_editor

```js
function createCounter() {
    let count = 0;
    return function () {
        count++;
        return count;
    };
}

let counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

:::

En este caso, `createCounter` retorna una función que incrementa y retorna una variable `count`. La variable `count` no es accesible directamente desde el exterior de `createCounter`, pero la función retornada (nuestro closure) tiene acceso a ella. Cada vez que llamamos a `counter()`, incrementa y retorna el `count`.

Los closures también pueden capturar múltiples variables de su ámbito externo. Por ejemplo:

:::interactive_editor

```js
function multiply(x) {
    return function (y) {
        return x * y;
    };
}

let double = multiply(2);
console.log(double(5)); // 10
```

:::

Aquí, la función interna captura el parámetro `x` de `multiply`. Cuando creamos `double` llamando a `multiply(2)` retorna una función que siempre multiplica su argumento por `2`.

Una cosa importante a observar sobre los closures es que éstos capturan variables, por referencia no por valor. Esto significa que si el valor de una variable capturada cambia, el closure verá el nuevo valor. Por ejemplo:

:::interactive_editor

```js
function createIncrementer() {
    let count = 0;
    return function () {
        count++;
        console.log(count);
    };
}

let increment = createIncrementer();
increment(); // 1
increment(); // 2
```

:::

Cada vez que llamamos a `increment` está trabajando con la misma variable `count`, no con una copia de su valor inicial. Los closures son una herramienta poderosa en JavaScript. A medida que continúes trabajando con JavaScript, descubrirás que entender y usar closures de manera efectiva puede mejorar enormemente tu capacidad para escribir código limpio, eficiente y poderoso.

# --questions--

## --text--

¿Cuál será la salida del siguiente código?

```js
function outer(x) {
    return function(y) {
        return x + y;
    };
}

let add5 = outer(5);
console.log(add5(3));
```

## --answers--

`5`

### --feedback--

Considera cómo la función interna en externa captura el parámetro `x`.

---

`3`

### --feedback--

Considera cómo la función interna en externa captura el parámetro `x`.

---

`8`

---

`undefined`

### --feedback--

Considera cómo la función interna en externa captura el parámetro `x`.

## --video-solution--

3

## --text--

¿Qué concepto demuestra el siguiente código?

```js
function createGreeter(greeting) {
    return function(name) {
        console.log(greeting + ", " + name);
    };
}

let sayHello = createGreeter("Hello");
sayHello("Alice");
```

## --answers--

Hoisting.

### --feedback--

Piensa en cómo la función retornada retiene acceso al parámetro `saludo`.

---

Cierre.

---

Recursión.

### --feedback--

Piensa en cómo la función retornada retiene acceso al parámetro `saludo`.

---

Herencia prototípica.

### --feedback--

Piensa en cómo la función retornada retiene acceso al parámetro `saludo`.

## --video-solution--

2

## --text--

¿Cuál será la salida del siguiente código?

```js
function counter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}

let increment = counter();
console.log(increment());
console.log(increment());
console.log(increment());
```

## --answers--

```js
1
1
1
```

### --feedback--

Considera cómo la función interna en contador mantiene acceso a la variable de cuenta a través de múltiples llamadas.

---

```js
1
2
3
```

---

```js
0
1
2
```

### --feedback--

Considera cómo la función interna en contador mantiene acceso a la variable de cuenta a través de múltiples llamadas.

---

```js
undefined
undefined
undefined
```

### --feedback--

Considera cómo la función interna en contador mantiene acceso a la variable de cuenta a través de múltiples llamadas.

## --video-solution--

2
