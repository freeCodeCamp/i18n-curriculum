---
id: 6733b02d1e556005a544c5e3
title: 什么是递归，它是如何工作的？
challengeType: 19
dashedName: what-is-recursion-and-how-does-it-work
---

# --interactive--

递归是一种复杂的特色，允许你重复调用一个函数，直到达到基准分支。与传统的循环不同，递归允许你处理具有未知深度的内容，例如深度嵌套的对象/数组，或文件树。但你也可以将其用于更基本的任务，例如从给定数字倒计时。

让我们构造一个函数来完成这项工作。我们将调用我们的函数 `recursiveCountdown`，它需要接受一个数字。我们将让它打印这个数字到控制台：

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  console.log(number);
};

recursiveCountdown(5);
```

:::

现在如果我们调用这个并传入数字 5，我们会看到数字打印到我们的终端。但除此之外没有其他任何事情发生——数字 5 当然不是倒计时。

在我们开始创建函数的递归部分之前，我们需要先确定基本情形。如果你没有确定基本情形，你的代码将一直运行，直到超过你的内存分配并崩溃。

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  if (number < 1) {
    return;
  }
  console.log(number);
};

recursiveCountdown(5);
```

:::

对于我们的基本情形，如果数字小于 1，我们希望倒计时停止。当达到该基本情形时，我们可以通过 `return` 来中断函数执行。

现在我们已经安全地准备好了基准分支，我们可以设置递归。使函数成为递归的关键点是它在执行过程中调用自身。在这种情况下，我们想在打印数字后调用该函数。但为了倒数，我们的新数字需要减一：

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  if (number < 1) {
    return;
  }
  console.log(number);
  recursiveCountdown(number - 1);
};

recursiveCountdown(5); 
```

:::

这将把数字 5、4、3、2 和 1 记录到控制台日志。

我们确实得到了我们的五个数字！但是如果我们想要递增计数呢？与其编写一个全新的函数，我们可以交换我们的日志和递归调用的顺序：

:::interactive_editor

```js
const recursiveCountdown = (number) => {
    if (number < 1) {
        return;
    }
    recursiveCountdown(number - 1);
    console.log(number);
  };

recursiveCountdown(5);
```

:::

这将把数字 1、2、3、4 和 5 记录到控制台。

但是为什么这会起作用？要理解这一点，你需要了解调用栈。调用栈是 JavaScript 跟踪和解析函数调用的方式。栈在某种程度上充当后进先出队列。为了更好地理解这一点，让我们为我们的函数添加一些日志：

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  console.log(`Function execution started for number: ${number}`);
  if (number < 1) {
    console.log(`Base case reached, begin resolving stack`);
    return;
  }
  console.log(`Calling recursiveCountdown with number: ${number - 1}`);
  recursiveCountdown(number - 1);
  console.log(`Function execution completed for number: ${number}`);
};

recursiveCountdown(5);
```

:::

我们在这里添加了四个关键语句。第一个日志在函数调用开始执行时运行。第三个日志在递归函数被调用之前运行。第四个日志在函数执行结束时运行。结果是：

```md
Function execution started for number: 5
Calling recursiveCountdown with number: 4
Function execution started for number: 4
Calling recursiveCountdown with number: 3
Function execution started for number: 3
Calling recursiveCountdown with number: 2
Function execution started for number: 2
Calling recursiveCountdown with number: 1
Function execution started for number: 1
Calling recursiveCountdown with number: 0
Function execution started for number: 0
Base case reached, begin resolving stack
Function execution completed for number: 1
Function execution completed for number: 2
Function execution completed for number: 3
Function execution completed for number: 4
Function execution completed for number: 5
```

但是这是如何发生的呢？这就是调用栈发挥作用的地方。当我们调用 `recursiveCountdown(5)` 时，该函数调用被添加到调用栈中。 

当该函数调用达到需要调用 `recursiveCountdown(4)` 的点时，它必须停止并等待该结果。与此同时，我们的 `recursiveCountdown(4)` 被添加到调用栈中，位于 `recursiveCountdown(5)` 之上。

当该函数调用达到需要调用 `recursiveCountdown(3)` 的点时，它必须停止并等待该结果。与此同时，我们的 `recursiveCountdown(3)` 被添加到调用栈中，位于 `recursiveCountdown(4)` 之上。

当该函数调用达到需要调用 `recursiveCountdown(2)` 的点时，它必须停止并等待该结果。与此同时，我们的 `recursiveCountdown(2)` 被添加到调用栈中，位于 `recursiveCountdown(3)` 之上。

当该函数调用达到需要调用 `recursiveCountdown(1)` 的点时，它必须停止并等待该结果。与此同时，我们的 `recursiveCountdown(1)` 被添加到调用栈中，位于 `recursiveCountdown(2)` 之上。

最后，当该函数调用达到需要调用 `recursiveCountdown(0)` 的点时，它必须停止并等待该结果。与此同时，我们的 `recursiveCountdown(0)` 被添加到调用栈中，位于 `recursiveCountdown(1)` 之上。

但是 `recursiveCountdown(0)` 不会调用另一个函数——它触及了我们的基本情形，在那里它提前返回。因为该函数的执行已经结束，该函数调用可以被视为“已解析”。当调用被解析时，它会从栈中移除。

现在我们的 `recursiveCountdown(1)` 不再等待那个调用——它位于栈顶，可以继续执行。

`recursiveCountdown(1)` 解析完成，从栈中移除，并允许 `recursiveCountdown(2)` 继续执行。

`recursiveCountdown(2)` 被解析，从栈中移除，并允许 `recursiveCountdown(3)` 继续执行。

`recursiveCountdown(3)` 被解析，从栈中移除，并允许 `recursiveCountdown(4)` 继续执行。

`recursiveCountdown(4)` 被解析，从栈中移除，并允许 `recursiveCountdown(5)` 继续执行。

`recursiveCountdown(5)` 被解析并从栈中移除。我们的调用栈现在为空，因此递归完成！

这是关于递归在 JavaScript 中如何工作的基本概述。这是一个复杂的概念，你应该多尝试一些代码和日志语句，直到你熟悉调用栈的行为。

作为一个有趣的小知识，我们讨论了缺少基准分支如何导致你的代码在内存耗尽时崩溃。这是因为递归不断将越来越多的函数调用堆积到调用栈中，直到栈溢出。就像那个流行编程社区的名字一样。

# --questions--

## --text--

递归函数中基本情形的主要目的是什么？

## --answers--

启动递归调用。

### --feedback--

课程提到如果你没有建立基本情形会发生什么。

---

为了防止无限递归和栈溢出。

---

为了提高函数的性能。

### --feedback--

课程提到如果你没有建立基本情形会发生什么。

---

处理器误差条件。

### --feedback--

课程提到如果你没有建立基本情形会发生什么。

## --video-solution--

2

## --text--

在递归的上下文中，调用栈用于什么？

## --answers--

保存局部变量。

### --feedback--

本课解释了调用栈如何在递归过程中管理函数调用。

---

用于跟踪和解析函数调用。

---

优化递归的函数。

### --feedback--

本课解释了调用栈如何在递归过程中管理函数调用。

---

处理异步的操作。

### --feedback--

本课解释了调用栈如何在递归过程中管理函数调用。

## --video-solution--

2

## --text--

当递归的函数调用达到其基本情形时会发生什么？

## --answers--

它启动一个新的递归周期。

### --feedback--

考虑函数在遇到停止递归的条件时的行为。

---

会报错。

### --feedback--

考虑函数在遇到停止递归的条件时的行为。

---

它返回并允许之前的调用恢复执行。

---

它会无限地调用自身。

### --feedback--

考虑函数在遇到停止递归的条件时的行为。

## --video-solution--

3
