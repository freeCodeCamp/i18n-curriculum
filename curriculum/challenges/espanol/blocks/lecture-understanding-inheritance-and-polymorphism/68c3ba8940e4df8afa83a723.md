---
id: 68c3ba8940e4df8afa83a723
title: ¿Qué es la herencia y cómo promueve la reutilización de código?
challengeType: 19
dashedName: what-is-inheritance-and-how-does-it-promote-code-reuse
---

# --description--

La herencia es el siguiente concepto clave de la programación orientada a objetos (OOP) que cubriremos.

Veamos más a fondo este concepto y cómo te permite escribir código reutilizable.

Con la herencia, una subclase (o clase hija) puede usar los atributos y métodos de una clase base (o clase padre). Esto te permite reutilizar código, crear jerarquías claras de clases y personalizar el comportamiento sin reescribir todo. Puedes personalizar extendiendo métodos existentes o sobrescribiéndolos en la clase hija.

Aquí está la sintaxis básica para la herencia:

```py
class Parent:
    # Parent attributes and methods

class Child(Parent):
    # Child inherits, extends, and/or overrides where necessary
```

Para que la clase `Child` herede de la clase `Parent`, tienes que pasar el `Parent` al `Child`.

Este estilo se llama herencia simple, ya que una clase hija hereda de exactamente una clase padre.

Aquí tienes un ejemplo:

```py
class Animal:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return f'{self.name} makes a sound'

class Dog(Animal):
    bark = 'woof! woof!! woof!!!'

jack = Dog('Jack')
print(jack.sound())  # Jack makes a sound
print(jack.bark)  # woof! woof!! woof!!!
```

Puedes ver que podemos reutilizar el atributo `self.name` y el método `sound()` de la clase padre `Animal` en la clase hija `Dog`.

Vamos a sobrescribir el método `sound()` de la clase padre `Animal` en la clase hija `Dog` para que `sound()` use la variable de clase `bark`:

```py
class Animal:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return f'{self.name} makes a sound.'

class Dog(Animal):
    bark = 'woof! woof!! woof!!!'

    # Override sound() to use bark class variable
    def sound(self):
        return f'{self.name} barks {self.bark}'

jack = Dog('Jack')
print(jack.sound())  # Jack barks woof! woof!! woof!!!
```

Si quieres conservar el valor de retorno de `sound()` y agregar la variable de clase bark más adelante, puedes extender `sound()` usando la función `super()`:

```py
class Animal:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return f'{self.name} makes a sound'

class Dog(Animal):
    bark = 'woof! woof!! woof!!!'

    # Call Animal.sound(), then append bark
    def sound(self):
        base = super().sound()
        return f'{base}, then {self.name} barks {self.bark}'

jack = Dog('Jack')
print(jack.sound())  # Jack makes a sound, then Jack barks woof! woof!! woof!!!
```

En este ejemplo, `base` es el resultado de llamar al método `sound()` de la clase `Animal`, y luego le añadimos el sonido específico de la clase `Dog`. De esta manera, puedes extender la funcionalidad de la clase padre `Animal` mientras mantienes su comportamiento original.

También existe la herencia múltiple, donde una clase hija puede heredar de más de una clase padre.

Aquí está la sintaxis básica de la herencia múltiple:

```py
class Parent:
    # Attributes and methods for Parent

class Child:
    # Attributes and methods for Child

class GrandChild(Parent, Child):
    # GrandChild inherits from both Parent and Child
    # GrandChild can combine or override behavior from each
```

Una forma sencilla de demostrar la herencia múltiple es con una rana, que puede tanto caminar en tierra como nadar en el agua:

```py
class Walker:
    def walk(self):
        return 'I can walk on land'

class Swimmer:
    def swim(self):
        return 'I can swim in water'

# Amphibian inherits from both Walker and Swimmer
class Amphibian(Walker, Swimmer):
    def __init__(self, name):
        self.name = name

    def introduce(self):
        return f"I'm {self.name} the frog. {self.walk()} and {self.swim()}."

frog = Amphibian('Freddy')
print(frog.introduce())
# Output: I'm Freddy the frog. I can walk on land and I can swim in water.
```

# --questions--

## --text--

¿Cuál es el propósito principal de la herencia en la programación orientada a objetos?

## --answers--

Para crear copias idénticas de una clase padre.

### --feedback--

Piensa en cómo una clase hija puede reutilizar y extender atributos y métodos de una clase padre.

---

Para permitir que una clase hija reutilice y extienda atributos/métodos de una clase padre.

---

Para hacer que todos los métodos en una clase sean privados.

### --feedback--

Piensa en cómo una clase hija puede reutilizar y extender atributos y métodos de una clase padre.

---

Para evitar la duplicación de código al fusionar clases no relacionadas.

### --feedback--

Piensa en cómo una clase hija puede reutilizar y extender atributos y métodos de una clase padre.

## --video-solution--

2

## --text--

¿Qué es la herencia múltiple en Python?

## --answers--

Una clase hija que hereda de una clase padre.

### --feedback--

Piensa en el estilo de herencia que permite que un hijo herede de varias clases.

---

Una clase padre con múltiples clases hijo.

### --feedback--

Piensa en el estilo de herencia que permite que un hijo herede de varias clases.

---

Una clase hija que hereda de múltiples clases padre.

---

Una clase que no puede heredar en absoluto.

### --feedback--

Piensa en el estilo de herencia que permite que un hijo herede de varias clases.

## --video-solution--

3

## --text--

¿Cómo haces que una clase hija herede de una clase padre en Python?

## --answers--

Al llamar a `Parent.inherit(Child)`.

### --feedback--

La sintaxis implica paréntesis en la definición de la clase.

---

Copiando todos los métodos manualmente.

### --feedback--

La sintaxis implica paréntesis en la definición de la clase.

---

Al usar la palabra clave `extends`.

### --feedback--

La sintaxis implica paréntesis en la definición de la clase.

---

Pasando la clase Parent como argumento a la clase Child.

## --video-solution--

4
