---
id: 6724e417419c2f211bb41bfc
title: Revisión de scripting Bash
challengeType: 31
dashedName: review-bash-scripting
---

# --description--

## Conceptos Básicos de Scripting en Bash

- **Scripting en Bash**: Escribir una secuencia de comandos Bash en un archivo, que luego puedes ejecutar con Bash para correr el contenido del archivo.
- **Shebang**: La línea comentada al inicio de un script (por ejemplo, `#!/bin/bash`) que indica qué intérprete debe usarse para el script.

  ```bash
  #!/bin/bash
  ```

- **Asignación de variables**: Instancia variables usando la sintaxis `variable_name=value`.

  ```bash
  servers=("prod" "dev")
  ```

- **Reglas para la creación de variables**: Crea variables con la sintaxis `VARIABLE_NAME=VALUE`. No se permiten espacios alrededor del signo igual (`=`). Usa comillas dobles si el valor contiene espacios.

  ```bash
  NAME=John
  MESSAGE="Hello World"
  COUNT=5
  TEXT="The next number is, "
  ```

- **Uso de variables**: Accede a los valores de las variables colocando `$` delante del nombre de la variable.

  ```bash
  echo $NAME
  echo "The message is: $MESSAGE"
  ```

- **Interpolación de variables**: Usa `$variable_name` para acceder al valor de una variable dentro de cadenas y comandos.

  ```bash
  TEXT="The next number is, "
  NUMBER=42
  echo $TEXT B:$NUMBER
  echo $TEXT I:$NUMBER
  
  echo "Pulling $server"
  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf
  ```

- **Ámbito de variable**: Los scripts de Shell se ejecutan de arriba hacia abajo, por lo que las variables solo pueden usarse debajo del lugar donde se crean.

  ```bash
  NAME="Alice"
  echo $NAME
  ```

- **Entrada del usuario**: Usa `read` para aceptar entrada de los usuarios y almacenarla en una variable.

  ```bash
  read USERNAME
  echo "Hello $USERNAME"
  ```

- **Comentarios**: Añade comentarios a tus scripts usando `#` seguido del texto de tu comentario.
  - Los comentarios de una sola línea comienzan con `#` y continúan hasta el final de la línea
  - Los comentarios son ignorados por el shell y no afectan la ejecución del script

  ```bash
  # This is a single-line comment
  NAME="John"  # Comment at end of line
  ```

- **Comentarios multilínea**: Comenta bloques de código usando dos puntos y comillas.

  ```bash
  : '
  This is a multi-line comment
  Everything between the quotes is ignored
  Useful for debugging or documentation
  '
  ```

- **Comandos integrados y ayuda**:
  - Usa `help` para ver una lista de comandos bash integrados
  - Usa `help <command>` para obtener información sobre comandos integrados específicos
  - Algunos comandos (como `if`) son incorporados y no tienen páginas man
  - Los comandos integrados se ejecutan directamente por el shell en lugar de como programas externos
  - Usa `help function` para ver información sobre cómo crear funciones

  ```bash
  help
  help if
  help function
  ```

- **Encontrar ubicaciones de comandos**: Usa `which` para localizar dónde están instalados los ejecutables.
  - Muestra la ruta completa a los archivos ejecutables
  - Útil para encontrar ubicaciones del intérprete (como bash)
  - Ayuda a verificar qué versión de un comando se ejecutará

  ```bash
  which bash
  which python
  which ls
  ```

- **Páginas de manual**: Usa `man` para acceder a la documentación detallada de los comandos.
  - Proporciona información completa sobre el uso de comandos
  - Muestra todas las opciones y ejemplos disponibles
  - Usa las teclas de flecha para navegar, 'q' para salir
  - No todos los comandos tienen páginas de manual (los integrados usan `help` en su lugar)

  ```bash
  man echo
  man ls
  man bash
  ```

- **Banderas de ayuda**: Muchos comandos soportan `--help` para información rápida de ayuda.
  - Alternativa a las páginas de manual para referencia rápida
  - Muestra la sintaxis del comando y las opciones comunes
  - No todos los comandos soportan esta bandera (algunos pueden mostrar error)

  ```bash
  ls --help
  chmod --help
  mv --help
  ```

- **Opciones del comando Echo**: El comando `echo` soporta varias opciones:
  - La opción `-e` habilita la interpretación de secuencias de escape con barra invertida
  - `\n` crea una nueva línea
  - Las líneas vacías solo se imprimen cuando los valores están entre comillas
  - Útil para crear salida formateada y títulos de programas

  ```bash
  echo -e "Line 1\nLine 2"
  echo ""
  echo -e "\n~~ Program Title ~~\n"
  echo "Line 1\nLine 2"
  ```

- **Argumentos de script**: Los programas pueden aceptar argumentos que son accesibles usando variables `$`.
  - `$*` imprime todos los argumentos pasados al script
  - `$@` imprime todos los argumentos pasados al script como cadenas separadas entre comillas
  - `$<number>` accede a argumentos específicos por posición (por ejemplo, `$1`, `$2`, `$3`)

  ```bash
  echo $*
  echo $@
  echo $1
  echo $2
  ```

## Expresiones de Doble Corchete `[[ ]]`

- **Sintaxis de doble corchete**: Usa `[[ ]]` para pruebas condicionales y coincidencia de patrones.
  - Debe haber espacios dentro de los corchetes y alrededor de los operadores
  - Devuelve el estado de salida 0 (true) o 1 (false) según el resultado de la prueba

  ```bash
  [[ $variable == "value" ]]
  [[ $number -gt 10 ]]
  [[ -f filename.txt ]]
  ```

- **Operadores de comparación de cadenas**: Compara cadenas usando varios operadores dentro de `[[ ]]`.
  - `==` (equal): Prueba si dos cadenas son idénticas
  - `!=` (no es igual): Prueba si dos cadenas son diferentes
  - `<` (menos lexicográficamente): comparación de cadenas en orden alfabético
  - `>` (lexicográficamente mayor): comparación de cadenas en orden alfabético

  ```bash
  [[ "apple" == "apple" ]]
  [[ "apple" != "orange" ]]
  [[ "apple" < "banana" ]]
  [[ "zebra" > "apple" ]]
  ```

- **Operadores de comparación numérica**: Compara números usando operadores numéricos específicos.
  - `-eq` (equal): comparación de igualdad numérica
  - `-ne` (not equal): comparación de desigualdad numérica
  - `-lt` (less than): comparación numérica de menor que
  - `-le` (less than or equal): comparación numérica de menor o igual
  - `-gt` (greater than): comparación numérica de mayor que
  - `-ge` (greater than or equal): comparación numérica de mayor o igual que

  ```bash
  [[ $number -eq 5 ]]
  [[ $count -ne 0 ]]
  [[ $age -ge 18 ]]
  [[ $score -lt 100 ]]
  ```

- **Operadores lógicos**: Combina múltiples condiciones usando operadores lógicos.
  - `&&` (y): Ambas condiciones deben ser verdaderas
  - `||` (o): Al menos una condición debe ser verdadera
  - `!` (not): Niega la condición (convierte true en false, false en true)

  ```bash
  [[ $age -ge 18 && $age -le 65 ]]
  [[ $name == "John" || $name == "Jane" ]]
  [[ ! -f missing_file.txt ]]
  ```

- **Operadores de prueba de archivo**: Prueba propiedades y existencia de archivos.
  - `-e file`: Verdadero si el archivo existe
  - `-f file`: Verdadero si el archivo existe y es un archivo regular
  - `-d file`: Verdadero si el archivo existe y es un directorio
  - `-r file`: Verdadero si el archivo existe y es legible
  - `-w file`: Verdadero si el archivo existe y es escribible
  - `-x file`: Verdadero si el archivo existe y es ejecutable
  - `-s file`: Verdadero si el archivo existe y tiene un tamaño mayor que cero

  ```bash
  [[ -e /path/to/file ]]
  [[ -f script.sh ]]
  [[ -d /home/user ]]
  [[ -x program ]]
  ```

- **Coincidencia de patrones con `=~`**: Usa expresiones regulares para una coincidencia avanzada de patrones.
  - El operador `=~` permite la coincidencia de patrones regex
  - El patrón no debe ir entre comillas cuando uses metacaracteres de regex
  - Soporta la sintaxis completa de expresiones regulares
  - Sensible a mayúsculas y minúsculas por defecto

  ```bash
  [[ "hello123" =~ [0-9]+ ]]
  [[ "email@domain.com" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
  [[ "filename.txt" =~ \.txt$ ]]
  ```

- **Prueba de existencia de variable**: Verifica si las variables están definidas o vacías.
  - Prueba si la variable está vacía: `[[ ! $variable ]]`

  ```bash
  [[ ! $undefined_var ]]
  ```

## Expresiones de Doble Paréntesis `(( ))`

- **Evaluación aritmética**: Usa `(( ))` para cálculos matemáticos y comparaciones numéricas.
  - Evalúa expresiones aritméticas usando sintaxis estilo C
  - Las variables no necesitan el prefijo `$` dentro de los paréntesis dobles
  - Devuelve el estado de salida 0 si el resultado es distinto de cero, 1 si el resultado es cero
  - Soporta todos los operadores aritméticos estándar

  ```bash
  (( result = 10 + 5 ))
  (( count++ ))
  (( total += value ))
  ```

- **Operadores aritméticos**: Operadores matemáticos disponibles en `(( ))`.
  - `+` (adición): Suma dos números
  - `-` (subtraction): Resta el segundo número del primero
  - `*` (multiplicación): Multiplica dos números
  - `/` (división): Divide el primer número por el segundo (división entera)
  - `%` (módulo): Residuo después de la división
  - `**` (exponenciación): Eleva el primer número a la potencia del segundo

  ```bash
  (( sum = a + b ))
  (( diff = x - y ))
  (( product = width * height ))
  (( remainder = num % 10 ))
  (( power = base ** exponent ))
  ```

- **Operadores de asignación**: Modifica variables usando operadores de asignación aritmética.
  - `=` (asignación): Asigna un valor a la variable
  - `+=` (sumar y asignar): Añade un valor a la variable
  - `-=` (restar y asignar): Resta un valor a la variable
  - `*=` (multiplicar y asignar): Multiplica la variable por el valor
  - `/=` (divide y asigna): Divide la variable por el valor
  - `%=` (módulo y asignar): Establece la variable al resto

  ```bash
  (( counter = 0 ))
  (( counter += 5 ))
  (( total -= cost ))
  (( area *= 2 ))
  (( value /= 3 ))
  ```

- **Operadores de incremento y decremento**: Modifica variables en uno.
  - `++variable` (pre-incremento): Incrementa antes de usar
  - `variable++` (post-incremento): Incrementa después de usarlo
  - `--variable` (pre-decremento): Decrementa antes de usar
  - `variable--` (post-decremento): Decrementa después de usar

  ```bash
  (( ++counter ))
  (( index++ ))
  (( --remaining ))
  (( attempts-- ))
  ```

- **Operadores de comparación**: Compara números usando comparación aritmética.
  - `==` (equal): Los números son iguales
  - `!=` (no es igual): Los números no son iguales
  - `<` (menos que): El primer número es menor que el segundo
  - `<=` (menor o igual): El primer número es menor o igual que el segundo
  - `>` (mayor que): El primer número es mayor que el segundo
  - `>=` (mayor o igual que): El primer número es mayor o igual que el segundo

  ```bash
  (( age >= 18 ))
  (( score < 100 ))
  (( count == 0 ))
  (( temperature > freezing ))
  ```

- **Operadores lógicos**: Combina condiciones aritméticas.
  - `&&` (y): Ambas condiciones deben ser verdaderas
  - `||` (o): Al menos una condición debe ser verdadera
  - `!` (not): Niega la condición

  ```bash
  (( age >= 18 && age <= 65 ))
  (( score >= 90 || extra_credit > 0 ))
  (( !(count == 0) ))
  ```

- **Operadores a nivel de bits**: Realizan operaciones a nivel de bits en enteros.
  - `&` (AND a nivel de bits): operación AND en cada bit
  - `|` (bitwise OR): operación OR en cada bit
  - `^` (bitwise XOR): operación XOR en cada bit
  - `~` (bitwise NOT): Invierte todos los bits
  - `<<` (left shift): Desplaza bits hacia la izquierda
  - `>>` (right shift): Desplaza bits hacia la derecha

  ```bash
  (( result = a & b ))
  (( flags |= new_flag ))
  (( shifted = value << 2 ))
  ```

- **Operador condicional (ternario)**: Usa la sintaxis `condition ? true_value : false_value`.
  - Proporciona una forma concisa de asignar valores basados en condiciones
  - Similar al operador ternario en lenguajes estilo C
  - Evalúa la condición y devuelve uno de dos valores

  ```bash
  (( result = (score >= 60) ? 1 : 0 ))
  (( max = (a > b) ? a : b ))
  (( sign = (num >= 0) ? 1 : -1 ))
  ```

- **Sustitución de comandos con aritmética**: Usa `$(( ))` para capturar resultados aritméticos.
  - Devuelve el resultado de la expresión aritmética como una cadena
  - Puede usarse en asignaciones o argumentos de comando
  - Útil para cálculos que necesitan ser usados en otro lugar

  ```bash
  result=$(( 10 + 5 ))
  echo "The answer is $(( a * b ))"
  array_index=$(( RANDOM % array_length ))
  ```

## Flujo de Control y Condicionales

- **Sentencias condicionales**: Usa sentencias `if` para ejecutar código basado en condiciones.
  - Sintaxis básica: `if [[ CONDITION ]] then STATEMENTS fi`
  - Sintaxis completa: `if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`
  - Puedes usar tanto las expresiones `[[ ]]` como `(( ))` para diferentes tipos de condiciones
  - **elif (else if)**: Opcional, puede repetirse varias veces para probar condiciones adicionales en secuencia
  - **else**: Opcional, se ejecuta cuando todas las condiciones anteriores son falsas
  - Puedes mezclar dobles paréntesis `(( ... ))` y dobles corchetes `[[ ... ]]` en la misma cadena condicional

  ```bash
  if (( NUMBER <= 15 ))
  then
      echo "B:$NUMBER"
  elif [[ $NUMBER -le 30 ]]
  then
      echo "I:$NUMBER"
  elif (( NUMBER < 46 ))
  then
      echo "N:$NUMBER"
  elif [[ $NUMBER -lt 61 ]]
  then
      echo "G:$NUMBER"
  else
      echo "O:$NUMBER"
  fi
  ```

## Ejecución de Comandos y Control de Procesos

- **Separación de comandos**: Usa punto y coma (`;`) para ejecutar múltiples comandos en una sola línea.
  - Los comandos se ejecutan secuencialmente de izquierda a derecha
  - El estado de salida de cada comando puede verificarse individualmente

  ```bash
  [[ 4 -ge 5 ]]; echo $?
  ls -l; echo "Done"
  ```

- **Estado de salida**: Cada comando tiene un estado de salida que indica éxito o fallo.
  - Accede al estado de salida del último comando con `$?`
  - El estado de salida `0` significa éxito (verdadero/sin errores)
  - Cualquier estado de salida distinto de cero significa fallo (ocurrieron errores/falso)
  - Códigos de error comunes: `127` (comando no encontrado), `1` (error general)

  ```bash
  echo $?
  [[ 4 -le 5 ]]; echo $?
  ls; echo $?
  bad_command; echo $?
  ```

- **Subshells y sustitución de comandos**: Diferentes usos de paréntesis para contextos de ejecución.
  - Los paréntesis simples `( ... )` crean una subshell
  - `$( ... )` realiza la sustitución de comandos
  - Las subshells se ejecutan en entornos separados y no afectan las variables del shell padre

  ```bash
  ( cd /tmp; echo "Current dir: $(pwd)" )
  current_date=$(date)
  file_count=$(ls | wc -l)
  echo "Today is $current_date"
  echo "Found $file_count files"
  ```

- **Comando Sleep**: Pausa la ejecución del script por un número especificado de segundos.
  - Útil para crear retrasos en scripts
  - Puede usarse con valores decimales para retrasos de subsegundos

  ```bash
  sleep 3
  sleep 0.5
  sleep 1
  ```

## Loops

- **Bucles while**: Ejecuta código repetidamente mientras una condición sea verdadera.
  - Sintaxis: `while [[ CONDITION ]] do STATEMENTS done`

  ```bash
  I=5
  while [[ $I -ge 0 ]]
  do
      echo $I
      (( I-- ))
      sleep 1
  done
  ```

- **Bucles Until**: Ejecuta código repetidamente hasta que una condición se vuelva verdadera.
  - Sintaxis: `until [[ CONDITION ]] do STATEMENTS done`

  ```bash
  until [[ $QUESTION =~ \?$ ]]
  do
      echo "Please enter a question ending with ?"
      read QUESTION
  done
  until [[ $QUESTION =~ \?$ ]]
  do
      GET_FORTUNE again
  done
  ```

- **Bucles for**: Itera a través de arreglos o listas usando bucles `for` con `do` y `done` para definir el bloque lógico del bucle.

  ```bash
  for server in "${servers[@]}"
  do
      echo "Processing $server"
  done
  for (( i = 1; i <= 5; i++ ))
  do
      echo "Number: $i"
  done
  for (( i = 5; i >= 1; i-- ))
  do
      echo "Countdown: $i"
  done
  for i in {1..5}
  do
      echo "Count: $i"
  done
  ```

## Arreglos

- **Arrays**: Almacena múltiples valores en una sola variable.
  - Crea arreglos con paréntesis: `ARRAY=("value1" "value2" "value3")`
  - Accede a elementos por índice: `${ARRAY[0]}`, `${ARRAY[1]}`
  - Accede a todos los elementos: `${ARRAY[@]}` o `${ARRAY[*]}`
  - El índice de un array comienza en 0

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Ask again later")
  echo ${RESPONSES[0]}     # Yes          
  echo ${RESPONSES[1]}     # No         
  echo ${RESPONSES[5]}     # Index 5 doesn't exist; empty string              
  echo ${RESPONSES[@]}     # Yes No Maybe Ask again later   
  echo ${RESPONSES[*]}     # Yes No Maybe Ask again later 
  ```

- **Inspección de arrays con declare**: Usa `declare -p` para ver los detalles del array.
  - Muestra el tipo de arreglo con la bandera `-a`
  - Muestra todos los elementos del array y su estructura

  ```bash
  ARR=("a" "b" "c")
  declare -p ARR # ARR=([0]="a" [1]="b" [2]="c")
  ```

- **Expansión de arrays**: Usa la sintaxis `"${array_name[@]}"` para expandir un array en elementos individuales.

```bash
for server in "${servers[@]}"
```

## Funciones

- **Funciones**: Crea bloques reutilizables de código.
  - Define con `FUNCTION_NAME() { STATEMENTS }`
  - Llama usando el nombre de la función
  - Puede aceptar argumentos accesibles como `$1`, `$2`, etc.

  ```bash
  GET_FORTUNE() {
      echo "Ask a question:"
      read QUESTION
  }
  GET_FORTUNE
  ```

- **Argumentos de función**: Las funciones pueden aceptar argumentos al igual que los scripts.
  - Los argumentos se pasan al llamar a la función
  - Accede a los argumentos dentro de la función usando `$1`, `$2`, etc.
  - Usa lógica condicional para manejar diferentes argumentos

  ```bash
  GET_FORTUNE() {
      if [[ ! $1 ]]
      then
          echo "Ask a yes or no question:"
      else
          echo "Try again. Make sure it ends with a question mark:"
      fi
      read QUESTION
  }
  GET_FORTUNE
  GET_FORTUNE again
  ```

## Números aleatorios y operaciones matemáticas

- **Números aleatorios**: Genera valores aleatorios usando la variable `$RANDOM`.
  - `$RANDOM` genera números entre 0 y 32767
  - Usa el operador módulo para limitar el rango: `$RANDOM % 75`
  - Suma 1 para evitar cero: `$(( RANDOM % 75 + 1 ))`
  - Debes usar la sintaxis `$(( ... ))` para cálculos con `$RANDOM`

  ```bash
  NUMBER=$(( RANDOM % 6 ))
  DICE=$(( RANDOM % 6 + 1 ))
  BINGO=$(( RANDOM % 75 + 1 ))
  echo $(( RANDOM % 10 ))
  ```

- **Acceso aleatorio a arrays**: Usa números aleatorios para acceder a elementos del array de forma aleatoria.
  - Genera un índice aleatorio dentro de los límites del array
  - Usa un índice aleatorio para acceder a los elementos del arreglo
  - Útil para selecciones aleatorias de opciones predefinidas

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Outlook good" "Don't count on it" "Ask again later")
  N=$(( RANDOM % 6 ))
  echo ${RESPONSES[$N]}
  ```

- **Operador módulo**: Usa `%` para obtener el resto de las operaciones de división.
  - Esencial para limitar rangos de números aleatorios
  - Funciona con `$RANDOM` para crear valores aleatorios limitados
  - `RANDOM % n` da números desde 0 hasta n-1

  ```bash
  echo $(( 15 % 4 ))
  echo $(( RANDOM % 100 ))
  echo $(( RANDOM % 10 + 1 ))
  ```

## Información del entorno y del sistema

- **Variables de entorno**: Variables predefinidas disponibles en el entorno de la shell.
  - `$RANDOM`: Genera números aleatorios entre 0 y 32767
  - `$LANG`: configuración del idioma del sistema
  - `$HOME`: ruta del directorio personal del usuario
  - `$PATH`: Directorios donde se buscan los comandos ejecutables
  - Ve todo con `printenv` o `declare -p`

  ```bash
  echo $RANDOM
  echo $HOME
  echo $LANG
  printenv
  ```

- **Inspección de variables**: Usa `declare` para ver y trabajar con variables.
  - `declare -p`: Imprime todas las variables y sus valores
  - `declare -p VARIABLE`: Imprime detalles específicos de la variable
  - Muestra el tipo de variable (string, array, etc.) y los atributos

  ```bash
  declare -p
  declare -p RANDOM
  declare -p MY_ARRAY
  ```

- **Tipos de comandos**: Diferentes categorías de comandos disponibles en bash.
  - **Comandos integrados**: Ejecutados directamente por el shell (por ejemplo, `echo`, `read`, `if`)
  - **Comandos externos**: Archivos binarios en directorios del sistema (por ejemplo, `ls`, `sleep`, `bash`)
  - **Palabras clave de Shell**: Estructuras del lenguaje (por ejemplo, `then`, `do`, `done`)
  - Usa `type <command>` para ver qué tipo es un comando

  ```bash
  type echo
  type ls
  type if
  type ./script.sh
  ```

## Creación y gestión de archivos

- **Creación de archivos**: Usa `touch` para crear archivos vacíos nuevos.
  - Crea un archivo nuevo si no existe
  - Actualiza la marca de tiempo si el archivo ya existe
  - Comúnmente usado para crear archivos de script antes de editar

  ```bash
  touch script.sh
  touch bingo.sh
  touch filename.txt
  ```

## Creando y Ejecutando Scripts Bash

- **Métodos de ejecución de scripts**: Varias formas de ejecutar scripts bash:
  - **`sh scriptname.sh`**: Ejecuta con el intérprete de shell sh.
  - **`bash scriptname.sh`**: Ejecuta con el intérprete de la shell bash.
  - **`./scriptname.sh`**: Ejecuta directamente (requiere permisos de ejecución).

```bash
sh questionnaire.sh
bash questionnaire.sh
./questionnaire.sh
```

## Permisos de Archivos y Ejecución de Scripts

- **Error de permiso denegado**: Al usar `./scriptname.sh`, puedes recibir "permission denied" si el archivo no tiene permisos de ejecución.
- **Comprobando permisos**: Usa `ls -l` para ver los permisos de archivos.

  ```bash
  ls -l questionnaire.sh
  ```

- **Formato de permisos**: La salida muestra los permisos como `-rw-r--r--` donde:
  - Primer carácter (`-`): Tipo de archivo (- para archivo regular, d para directorio)
  - Los siguientes 9 caracteres: Permisos para propietario, grupo y otros
  - `r` = leer, `w` = escribir, `x` = ejecutar
  
- **Agregar permisos de ejecución**: Usa `chmod +x` para dar permisos de ejecución a todos.

  ```bash
  chmod +x questionnaire.sh
  ```

- **Organización de scripts**: Mejores prácticas para estructurar scripts bash.
  - Comienza con shebang (`#!/bin/bash`)
  - Agrega comentarios descriptivos sobre el propósito del script
  - Define variables en la parte superior
  - Agrupa funciones relacionadas juntas
  - Lógica principal del script al final

  ```bash
  #!/bin/bash
  NAME="value"
  ARRAY=("item1" "item2")
  my_function() {
      echo "Function code here"
  }
  my_function
  echo "Script complete"
  ```

- **Ejecución secuencial de scripts**: Crea scripts maestros que ejecuten múltiples programas en secuencia.
  - Útil para automatizar flujos de trabajo que involucran múltiples scripts
  - Cada script se ejecuta hasta completarse antes de que comience el siguiente
  - Puedes combinar diferentes programas en un solo flujo de ejecución
  - Los argumentos pueden pasarse a scripts individuales según sea necesario
  - Puede incluir diferentes tipos de programas (interactivos, automatizados, etc.)

  ```bash
  #!/bin/bash
  ./setup.sh
  ./interactive.sh
  ./processing.sh
  ./cleanup.sh
  ```

# --assignment--

Revise los temas y conceptos de scripting Bash.
