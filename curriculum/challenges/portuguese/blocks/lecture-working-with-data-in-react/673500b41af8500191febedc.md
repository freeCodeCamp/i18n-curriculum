---
id: 673500b41af8500191febedc
title: Como Você Renderiza Listas em React?
challengeType: 19
dashedName: how-do-you-render-lists-in-react
---

# --description--

Renderizar listas é uma tarefa fundamental em aplicativos web React e é usada para exibir dados para os usuários. No React, o método `map` é usado para transformar um array de dados em um array de elementos JSX que podem ser renderizados na interface do usuário.

Aqui está um exemplo de um componente chamado `FruitList` que exibe uma lista de frutas:

```jsx
function FruitList() {
  const fruits = ['Apple', 'Banana', 'Cherry', 'Date'];
  return (
    <ul>
      {fruits.map(fruit => <li>{fruit}</li>)}
    </ul>
  );
}
```

Neste exemplo, a função `map` itera sobre cada item no array `fruits`. Para cada fruta, ele cria um novo elemento `li` contendo o nome da fruta. O array recém-criado de elementos `li` é então exibido dentro das tags pai `ul`.

No entanto, ao renderizar listas em React, é importante não esquecer a prop `key` para cada elemento da lista. A chave deve ser sempre única e ela ajuda o React a identificar quais itens foram alterados, adicionados ou removidos, o que é essencial para a renderização eficiente e atualização da lista.

Se você esquecer a key, o React mostrará um aviso no console, mas não gerará um erro fatal. A aplicação ainda pode renderizar e funcionar, mas você pode encontrar bugs sutis, especialmente quando a lista mudar. Esses bugs podem ser difíceis de depurar porque a interface pode parecer correta inicialmente.

Um erro comum é usar o índice do array como a chave, assim:

```jsx
{fruits.map((fruit, index) => <li key={index}>{fruit}</li>)}
```

Embora isso silencie o aviso, geralmente é considerado um anti-padrão. Usar o índice como chave pode causar problemas quando a lista é reordenada, classificada ou filtrada. O React usa a chave para rastrear elementos. Se a ordem da lista mudar, o React pode reutilizar incorretamente o estado do componente ou falhar em atualizar o DOM de forma eficiente porque as chaves (índices) permanecem as mesmas mesmo que o conteúdo naquele índice tenha mudado.

A melhor prática é usar um identificador estável e único para cada item. Normalmente, este é um ID do seu banco de dados, como um UUID ou um database ID.

Se seus dados não tiverem um ID único, você pode gerar um quando os dados forem criados (por exemplo, usando `crypto.randomUUID()` ou uma biblioteca como `uuid`), ou usar uma combinação de campos que sejam garantidamente únicos. No entanto, você deve evitar gerar chaves dinamicamente durante a renderização (por exemplo, `key={Math.random()}`), pois isso fará com que o React recrie os elementos do DOM a cada renderização e redefina seu estado.

Vamos modificar nosso exemplo para incluir chaves:

```jsx
function FruitList() {
  const fruits = ["Apple", "Banana", "Cherry", "Date"];
  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={`${fruit}-${index}`}>{fruit}</li>
      ))}
    </ul>
  );
}
```

Neste exemplo refatorado, estamos criando uma chave única para cada item da lista concatenando o nome da fruta com seu índice. Isso garante que cada item da lista tenha uma chave distinta, o que ajuda o React a gerenciar e atualizar a lista de forma eficiente quando os itens são adicionados, removidos ou reordenados.

React também permite que você renderize estruturas mais complexas. Por exemplo, você pode ter um array de objetos que representam usuários, cada um com múltiplas propriedades que você deseja exibir:

```jsx
function UserList() {
  const users = [
    { id: "user-001-employee", name: "Alice", email: "alice@example.com" },
    { id: "user-002-employee", name: "Bob", email: "bob@example.com" },
    { id: "user-003-employee", name: "John", email: "john@example.com" },
  ];
  return (
    <div>
      {users.map((user) => (
        <div key={user.id}>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      ))}
    </div>
  );
}
```

Neste exemplo, estamos criando uma estrutura JSX mais complexa para cada usuário, exibindo tanto o nome quanto o endereço de email. Estamos usando o `id` do usuário como a `key`, o que é uma boa prática.

Em conclusão, renderizar listas em React envolve converter arrays de dados em elementos JSX, tipicamente usando a função `map`.

# --questions--

## --text--

Qual é o propósito principal de usar a prop `key` ao renderizar listas no React?

## --answers--

Para estilizar itens de lista.

### --feedback--

Pense no que dissemos sobre a otimização de renderização do React.

---

Para ajudar o React a identificar mudanças na lista de forma eficiente.

---

Para ordenar os itens da lista.

### --feedback--

Pense no que dissemos sobre a otimização de renderização do React.

---

Para filtrar os itens da lista.

### --feedback--

Pense no que dissemos sobre a otimização de renderização do React.

## --video-solution--

2

## --text--

Qual método JavaScript é tipicamente usado para transformar um array de dados em um array de elementos JSX no React?

## --answers--

`forEach()`

### --feedback--

Lembre-se do método que usamos consistentemente em nossos exemplos para criar elementos JSX a partir de itens de array.

---

`reduce()`

### --feedback--

Lembre-se do método que usamos consistentemente em nossos exemplos para criar elementos JSX a partir de itens de array.

---

`map()`

---

`filter()`

### --feedback--

Lembre-se do método que usamos consistentemente em nossos exemplos para criar elementos JSX a partir de itens de array.

## --video-solution--

3

## --text--

Ao renderizar uma lista de itens que possuem IDs únicos, qual é a melhor prática considerada para a prop `key`?

## --answers--

Use o índice do item no array.

### --feedback--

Lembre-se do que dissemos sobre usar identificadores estáveis e únicos para as chaves.

---

Use um número aleatório.

### --feedback--

Lembre-se do que dissemos sobre usar identificadores estáveis e únicos para as chaves.

---

Use o ID único do item.

---

Use o nome ou título do item.

### --feedback--

Lembre-se do que dissemos sobre usar identificadores estáveis e únicos para as chaves.

## --video-solution--

3
