---
id: 587d8255367417b2b2512c75
title: 創建循環佇列
challengeType: 1
forumTopicId: 301625
dashedName: create-a-circular-queue
---

# --description--

在這個挑戰中你將建立一個 Circular Queue。Circular Queue 是一種佇列，它會寫入群集的尾端，然後開始從群集的開頭覆寫自身。這種類型的資料結構在某些情況下非常有用。例如，Circular Queue 可以用於資料流媒體。一旦佇列已滿，新的媒體資料將覆寫舊資料。

說明這個概念的一個好方法是使用長度為 `5` 的陣列：

```js
[null, null, null, null, null]
 ^Read @ 0
 ^Write @ 0
```

這裡讀取和寫入都在位置 `0`。現在佇列獲得了 3 筆新的記錄 `a`、`b` 和 `c`。我們的佇列現在看起來像這樣：

```js
[a, b, c, null, null]
 ^Read @ 0
          ^Write @ 3
```

當讀取頭讀取時，它可以移除值或保留它們：

```js
[null, null, null, null, null]
                   ^Read @ 3
                   ^Write @ 3
```

現在我們將值 `d`、`e` 和 `f` 寫入佇列。一旦寫入到達陣列的末端，它會回到起點繼續迴圈：

```js
[f, null, null, d, e]
                ^Read @ 3
    ^Write @ 1
```

這種方法需要固定量的記憶體，但允許處理更大尺寸的檔案。

# --instructions--

在這個挑戰中，我們將實作一個環狀佇列。環狀佇列應該提供 `enqueue` 和 `dequeue` 方法，讓你可以從佇列中讀取和寫入。該類別本身也應該接受一個整數引數，讓你在建立時指定佇列的大小。我們已經在程式碼編輯器中為你寫好了這個類別的起始版本。

當你將項目加入佇列時，寫入指標應該向前移動，並在到達佇列末端時迴圈回到起點。`enqueue` 方法如果成功，應該傳回你加入的項目；否則會傳回 `null`。

同樣地，當你從佇列中取出項目時，讀取指標應該向前移動。當你取出一個項目時，該項目應該被傳回。如果你無法取出項目，你應該傳回 `null`。

寫入指標不應該被允許移動超過讀取指標（我們的類別不會讓你覆寫尚未讀取的資料），且讀取指標不應該能夠前進超過你已寫入的資料。

# --hints--

`enqueue` 方法應該將項目添加到環形佇列。

```js
assert(
  (function () {
    var test = new CircularQueue(3);
    test.enqueue(17);
    test.enqueue(32);
    test.enqueue(591);
    var print = test.print();
    return print[0] === 17 && print[1] === 32 && print[2] === 591;
  })()
);
```

你不應該將項目加入讀取指標之後的佇列。

```js
assert(
  (function () {
    var test = new CircularQueue(3);
    test.enqueue(17);
    test.enqueue(32);
    test.enqueue(591);
    test.enqueue(13);
    test.enqueue(25);
    test.enqueue(59);
    var print = test.print();
    return print[0] === 17 && print[1] === 32 && print[2] === 591;
  })()
);
```

`dequeue` 方法應該從佇列中出列項目。

```js
assert(
  (function () {
    var test = new CircularQueue(3);
    test.enqueue(17);
    test.enqueue(32);
    test.enqueue(591);
    return (
      test.dequeue() === 17 && test.dequeue() === 32 && test.dequeue() === 591
    );
  })()
);
```

在一個項目從佇列中出列後，其在佇列中的位置應該重設為 `null`。

```js
assert(
  (function () {
    var test = new CircularQueue(3);
    test.enqueue(17);
    test.enqueue(32);
    test.enqueue(672);
    test.dequeue();
    test.dequeue();
    var print = test.print();
    return print[0] === null && print[1] === null && print[2] === 672;
  })()
);
```

嘗試從寫入指標之後的佇列中取出應傳回 `null`，且不會推進寫入指標。

```js
assert(
  (function () {
    var test = new CircularQueue(3);
    test.enqueue(17);
    test.enqueue(32);
    test.enqueue(591);
    return (
      test.dequeue() === 17 &&
      test.dequeue() === 32 &&
      test.dequeue() === 591 &&
      test.dequeue() === null &&
      test.dequeue() === null &&
      test.dequeue() === null &&
      test.dequeue() === null &&
      test.enqueue(100) === 100 &&
      test.dequeue() === 100
    );
  })()
);
```

# --seed--

## --seed-contents--

```js
class CircularQueue {
  constructor(size) {

    this.queue = [];
    this.read = 0;
    this.write = 0;
    this.max = size - 1;

    while (size > 0) {
      this.queue.push(null);
      size--;
    }
  }

  print() {
    return this.queue;
  }

  enqueue(item) {
    // Only change code below this line

    // Only change code above this line
  }

  dequeue() {
    // Only change code below this line

    // Only change code above this line
  }
}
```

# --solutions--

```js
class CircularQueue {
  constructor(size) {
    this.queue = [];
    this.read = 0;
    this.write = 0;
    this.max = size - 1;

    while (size > 0) {
      this.queue.push(null);
      size--;
    }
  }

  print() {
    return this.queue;
  }

  enqueue(item) {
    // Only change code below this line
    console.log(this.write, this.max);
    if (this.queue[this.write] === null) {
      this.queue[this.write++] = item;

      if (this.write > this.max) {
        this.write = 0;
      }
      return item;
    }
    return null;
    // Only change code above this line
  }

  dequeue() {
    // Only change code below this line
    if (this.queue[this.read] !== null) {
      let item = this.queue[this.read];
      this.queue[this.read++] = null;
      if (this.read > this.max) {
        this.read = 0;
      }
      return item;
    }
    return null;
    // Only change code above this line
  }
}
```
