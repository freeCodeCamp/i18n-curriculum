---
id: 67f39dc7129b092b27099d8c
title: 資料結構複習
challengeType: 31
dashedName: review-data-structures
---

# --description--
 
## 演算法與 Big O 符號

- **演算法**：一組明確無誤的指令，用於解決問題或執行任務。演算法必須在有限的步驟內完成，且每個步驟必須精確且明確無誤。

- **Big O 符號**：描述演算法在輸入大小增加時的最壞效率、性能或成長速率。它著重於資源使用量隨輸入大小的成長，忽略常數因子和低階項。

### 常見時間複雜度

- **O(1) - 常數時間**：演算法無論輸入大小，所需時間皆相同。

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

- **O(log n) - 對數時間**：隨著輸入成長，時間緩慢增加。常見於反覆將問題規模縮小一部分（如二分搜尋法）的演算法。

- **O(n) - 線性時間**：執行時間隨輸入大小成比例增加。

```python
for grade in grades:
    print(grade)
```

- **O(n log n) - 對數線性時間**：高效排序演算法如合併排序和快速排序的常見時間複雜度。

- **O(n²) - 二次時間複雜度**：執行時間以二次方增加。常見於巢狀迴圈中。

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

### 空間複雜度

- **O(1) - 常數空間**：演算法使用相同數量的記憶體，無論輸入大小為何。
- **O(n) - 線性空間**：記憶體使用量隨輸入大小成比例增加。
- **O(n²) - 二次方空間**：記憶體使用量隨輸入大小二次方成長。

## 問題解決技巧

- **理解問題**：多次閱讀問題述語。識別輸入、預期輸出，以及如何將輸入轉換為輸出。

- **偽程式碼**：獨立於語言的演算法邏輯高層次描述。使用一般書面語言混合程式設計構件如 `IF`、`ELSE`、`FOR`、`WHILE`。

```md
GET original_string
SET reversed_string = ""
FOR EACH character IN original_string:
  ADD character TO THE BEGINNING OF reversed_string
DISPLAY reversed_string
```

- **邊界情況**：演算法應該控制代碼的邊界上發生的特定且有效的輸入。務必考慮並測試邊界情況。

## 陣列

- **靜態陣列**：在初始化時具有固定大小。元素儲存在相鄰的記憶體位置。大小在程式執行期間無法更改。

- **動態陣列**：可以在程式執行期間自動擴展或縮小。當需要時，透過自動複製到較大的陣列來控制大小調整。

### Python 列表（動態陣列）

```python
numbers = [3, 4, 5, 6]

# Access elements
numbers[0]  # 3

# Update elements
numbers[2] = 16

# Add elements
numbers.append(7)
numbers.insert(3, 15)  # Insert at specific index

# Remove elements
numbers.pop(2)  # Remove at specific index
numbers.pop()   # Remove last element
```

### 動態陣列的時間複雜度

- **存取**：O(1)
- **插入於末端**：平均 O(1)，需要調整大小時為 O(n)
- **插入於中間**：O(n)
- **刪除**：中間為 O(n)，結尾為 O(1)

## 堆疊

- **堆疊**：後進先出（LIFO）的資料結構。元素僅能從頂部添加和移除。

- **Push 操作行為**：將元素添加到堆疊頂端。時間複雜度：O(1)。

- **Pop 操作行為**：從堆疊頂端移除一個元素。時間複雜度：O(1)。

```python
# Using Python list as stack
stack = []

# Push operations
stack.append(1)
stack.append(2)
stack.append(3)

# Pop operations
top_element = stack.pop()  # Returns 3
```

## 佇列

- **佇列**：先進先出（FIFO）資料結構。元素從後方加入，從前方移除。

- **入佇列操作**：將元素添加到佇列的尾端。時間複雜度：O(1)。

- **Dequeue 操作行為**：從佇列前端移除一個元素。時間複雜度：O(1)。

```python
from collections import deque

# Using deque for efficient queue operations
queue = deque()

# Enqueue operations
queue.append(1)
queue.append(2)
queue.append(3)

# Dequeue operations
first_element = queue.popleft()  # Returns 1
```

## 鏈結串列

- **鏈結串列**：線性資料結構，其中每個節點包含資料和指向下一個節點的引用。節點像串鏈一樣連結。

### 單向鏈結串列

- **結構**：每個節點都有資料和一個指向下一個節點的引用。
- **遍歷**：只能從頭部向尾部前進。
- **Head Node**：列表中的第一個節點，通常是唯一可直接存取的節點。
- **尾節點**：列表中的最後一個節點，指向 `None`。

### 操作行為與時間複雜度

- **在開頭插入**：O(1)
- **插入於結尾**：O(n) - 必須巡訪至結尾
- **插入中間**：O(n) - 必須巡訪到該位置
- **從開頭刪除**：O(1)
- **從尾端刪除**：O(n) - 必須巡訪以找到前一個節點
- **從中間刪除**：O(n) - 必須巡訪以找到節點

### 雙向鏈結串列

- **結構**：每個節點都有資料和兩個引用：下一個節點和前一個節點。
- **遍歷**：可以雙向移動。
- **記憶體**：由於額外的引用，所需的記憶體比單向鏈結串列多。

## 雜湊映射和集合

### 映射和雜湊映射

- **Map（抽象資料型別）**：管理鍵值配對的群集。每個鍵必須唯一，但值可以重複。

- **Hash Map**：使用雜湊技術的映射 ADT 具體實作。使用雜湊函式（`hash function`）為鍵產生雜湊值，該值決定底層陣列中的儲存位置。

### Python 字典（雜湊映射）

```python
# Creating dictionaries
my_dictionary = {
    "A": 1,
    "B": 2, 
    "C": 3
}

# Alternative creation
my_dictionary = dict(A=1, B=2, C=3)

# Access and modify
value = my_dictionary["A"]  # 1
my_dictionary["A"] = 4      # Update value
del my_dictionary["A"]      # Remove key-value pair

# Check membership
"C" in my_dictionary

# Get keys, values, items
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

### 雜湊映射的時間複雜度

- **平均情況**：插入、取得、刪除皆為 O(1)
- **最壞情況**：當發生大量雜湊碰撞時為 O(n)

### 集合

- **集合**：無序且元素唯一的群集。不允許重複，且不維護特定順序。

- **僅限不可變元素**：集合只能包含不可變的資料型別（數字、字串、元組），因為雜湊值必須保持不變。

```python
# Creating sets
numbers = {1, 2, 3, 4}
empty_set = set()  # Must use set(), not {}

# Add and remove elements
numbers.add(5)
numbers.remove(4)      # Raises KeyError if not found
numbers.discard(4)     # No error if not found

# Set operations
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

# Union, intersection, difference, symmetric difference
set_a.union(set_b)                    # or set_a | set_b
set_a.intersection(set_b)             # or set_a & set_b
set_a.difference(set_b)               # or set_a - set_b
set_a.symmetric_difference(set_b)     # or set_a ^ set_b

# Subset and superset checks
set_a.issubset(set_b)
set_a.issuperset(set_b)
set_a.isdisjoint(set_b)

# Membership testing
5 in numbers
```

### 集合的時間複雜度

- **平均情況**：對於新增、移除、成員測試為 O(1)
- **最壞情況**：由於雜湊碰撞，時間複雜度為 O(n)

## 雜湊碰撞

- **雜湊碰撞**：當兩個不同的鍵產生相同的雜湊值時發生。

- **碰撞決議策略**：
  - **串鏈**：每個陣列索引指向一個鏈結串列，該串列儲存所有具有相同雜湊值的元素
  - **開放定址法**：使用預定義序列搜尋下一個可用索引

## 何時使用每種資料結構

- **列表**：當你需要有序、索引存取且事先不知道大小時
- **堆疊**：用於 LIFO 操作（復原功能、表達式評估、回溯）
- **佇列**：用於 FIFO 操作（任務排程、廣度優先搜尋）
- **鏈結串列**：當頻繁在開頭插入/刪除、大小未知、且不需要隨機存取時
- **雜湊映射**：用於快速鍵值查找、計數出現次數、快取
- **集合**：用於唯一性檢查、數學集合操作、移除重複項目

# --assignment--

檢視 `Data Structures` 主題和概念。
