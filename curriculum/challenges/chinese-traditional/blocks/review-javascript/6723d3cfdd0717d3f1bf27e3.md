---
id: 6723d3cfdd0717d3f1bf27e3
title: JavaScript 複習
challengeType: 31
dashedName: review-javascript
---

# --description--

請檢視以下概念以準備即將到來的預備考試。


## 使用 HTML、CSS 和 JavaScript

雖然 HTML 和 CSS 提供網站結構，但 JavaScript 透過啟用複雜的功能，例如處理使用者輸入、動畫元素，甚至建置完整的網頁應用程式，為網站帶來互動性。

## JavaScript 中的資料型別

資料型別幫助程式了解它正在處理的資料種類，無論是數字、文字或其他類型。

- **Number**：數字表述整數和浮點數值。整數的範例包括 7、19 和 90。
- **浮點數**：浮點數是帶有小數點的數字。範例包括 3.14、0.5 和 0.0001。
- **字串**：字串是一連串被引號包圍的字元或文字。`"I like coding"` 和 `'JavaScript is fun'` 是字串的範例。
- **布林值**：布林值表述兩種可能的值之一：`true` 或 `false`。你可以使用布林值來表述一個條件，例如 `isLoggedIn = true`。
- **Undefined 和 Null**：undefined 值是已宣告但未指定值的變數。null 值是空值或已故意指定為 `null` 的變數。
- **物件**：物件是一個由鍵值對組成的群集。鍵是屬性名稱，值是屬性值。

這裡，`pet` 物件有三個屬性或鍵：`name`、`age` 和 `type`。其值分別是 `Fluffy`、`3` 和 `dog`。

```js
let pet = {
  name: 'Fluffy',
  age: 3,
  type: 'dog'
};
```

- **Symbol**：Symbol 資料型別是一種獨特且不可變的值，可用作物件屬性的識別字。

在下面的範例中，創建了兩個具有相同描述的符號，但它們並不相等。

```js
const crypticKey1= Symbol('saltNpepper');
const crypticKey2= Symbol('saltNpepper');
console.log(crypticKey1 === crypticKey2); // false
```

- **BigInt**：當數字對於 `Number` 資料型別來說太大時，你可以使用 BigInt 資料型別來表述任意長度的整數。

透過在數字末尾添加 `n`，你可以創建 BigInt。

```js
const veryBigNumber = 1234567890123456789012345678901234567890n;
```

## JavaScript 中的變數

- 變數可以使用 `let` 關鍵字宣告。

```js
let cityName;
```

- 要為變數指定值，你可以使用指定運算子 `=`。

```js
cityName = 'New York';
```

- 使用 `let` 宣告的變數可以被重新指定新值。

```js
cityName = 'Los Angeles';
console.log(cityName); // Los Angeles
```

- 除了 `let`，你也可以使用 `const` 來宣告變數。然而，`const` 變數無法被重新指定新值。

```js
const cityName = 'New York';
cityName = 'Los Angeles'; // TypeError: Assignment to constant variable.
```

- 使用 `const` 宣告的變數用於宣告常數，這些常數在整個程式碼中不允許更改，例如 `PI` 或 `MAX_SIZE`。

## 變數命名慣例

- 變數名稱應該具描述性且有意義。
- 變數名稱應該是駝峰式命名法，例如 `cityName`、`isLoggedIn` 和 `veryBigNumber`。
- 變數名稱不應以數字開頭。它們必須以字母、`_` 或 `$` 開頭。
- 變數名稱不應包含空格或特殊字元，除了 `_` 和 `$`。
- 變數名稱不應該是保留關鍵字。
- 變數名稱區分大小寫。`age` 和 `Age` 是不同的變數。

## JavaScript 中的字串與字串不變性

- 字串是被引號包圍的字元序列。它們可以使用單引號和雙引號來創建。

```js
let correctWay = 'This is a string';
let alsoCorrect = "This is also a string";
```

- 在 JavaScript 中，字串是不可變的。這表示一旦字串被創建，你就無法更改字串中的字元。然而，你仍然可以將字串重新指定為新的值。

```js
let firstName = 'John';
firstName = 'Jane'; // Reassigning the string to a new value
```

## JavaScript 中的字串串接

- 串接是將多個字串連接起來或將字串與儲存文字的變數結合的處理程序。`+` 運算子是串接字串中最簡單且最常用的方法之一。

```js
let studentName = 'Asad';
let studentAge = 25;
let studentInfo = studentName + ' is ' + studentAge + ' years old.';
console.log(studentInfo); // Asad is 25 years old.
```

- 如果你需要為現有的字串添加或附加內容，則可以使用 `+=` 運算子。當你想隨著時間為字串添加更多文字以進行建置時，這非常有用。

```js
let message = 'Welcome to programming, ';
message += 'Asad!';
console.log(message); // Welcome to programming, Asad!
```

- 另一種串接字串的方法是使用 `concat()` 方法。此方法會將兩個或多個字串連接在一起。

```js
let firstName = 'John';
let lastName = 'Doe';
let fullName = firstName.concat(' ', lastName);
console.log(fullName); // John Doe
```

## 使用 `console.log()` 記錄訊息

- `console.log()` 方法用於將訊息記錄到主控台。它是偵錯和測試你的程式碼的有用工具。

```js
console.log('Hello, World!');
// Output: Hello, World!
```

## JavaScript 中的分號

- 分號主要用於標示述語的結尾。這有助於 JavaScript 引擎理解各個指令的分隔，對於正確執行至關重要。

```js
let message = 'Hello, World!'; // first statement ends here
let number = 42; // second statement starts here
```

- 分號有助於防止程式碼執行中的歧義，並確保述語正確終止。

## JavaScript 中的註解

- 任何被註解掉的程式碼行都會被 JavaScript 引擎忽略。註解用於說明程式碼、做筆記或暫時停用程式碼。
- 單行註解是使用 `//` 創建的。

```js
// This is a single-line comment and will be ignored by the JavaScript engine
```

- 多行註解是使用 `/*` 來開始註解，並使用 `*/` 來結束註解。

```js
/*
This is a multi-line comment.
It can span multiple lines.
*/
```

## JavaScript 作為一種動態型別語言

- JavaScript 是一種動態型別語言，這表示你在宣告變數時不需要指定變數的資料型別。JavaScript 引擎會根據指定給變數的值自動判斷資料型別。

```js
let error = 404; // JavaScript treats error as a number
error = "Not Found"; // JavaScript now treats error as a string
```

- 其他語言，例如 C#，如果不是動態型別，將會導致錯誤：

```csharp
int error = 404; // value must always be an integer
error = "Not Found"; // This would cause an error in C#
```

## 使用 `typeof` 運算子

- `typeof` 運算子用於檢查變數的資料型別。它會傳回一個字串，表示該變數的型別。

```js
let age = 25;
console.log(typeof age); // number

let isLoggedIn = true;
console.log(typeof isLoggedIn); // boolean
```

- 然而，JavaScript 在處理 null 時有一個眾所周知的怪癖。`typeof` 運算子會對 null 值傳回 `object`。

```js
let user = null;
console.log(typeof user); // object
```

## 字串基礎

- **定義**：字串是一連串被單引號、雙引號或反引號包裹的字元。字串是原始資料型別，且它們是不可變的。不變性表示字串一旦被創建，就無法被更改。
- **從字串存取字元**：要從字串存取字元，你可以使用括號表示法並傳入索引數字。索引是字元在字串中的位置，且從零開始計算。

```js
const developer = "Jessica";
developer[0] // J
```

- **`\n`（換行字元）**：你可以透過使用 `\n` 換行字元在字串中創建換行。

```js
const poem = "Roses are red,\nViolets are blue,\nJavaScript is fun,\nAnd so are you.";
console.log(poem);
```

- **字串跳脫**：你可以在引號前放置反斜線（`\`）來跳脫字串中的字元。

```js
const statement = "She said, \"Hello!\"";
console.log(statement); // She said, "Hello!"
```
  
## 模板字串（模板、範本字串）與字串插值

- **定義**：模板字面值是用反引號（`）定義的。它們允許更輕鬆的字串操作，包括直接在字串中嵌入變數，這種特性稱為字串插值。

```js
const name = "Jessica";
const greeting = `Hello, ${name}!`; // "Hello, Jessica!"
```

## ASCII、`charCodeAt()` 方法和 `fromCharCode()` 方法

- **ASCII**：ASCII，全名為美國資訊交換標準碼，是用於計算機中表述文字的字元編碼標準。它為每個字元指定一個數值，該數值被機器普遍識別。
- **`charCodeAt()` 方法**：此方法會在字串上呼叫，並傳回指定索引處字元的 ASCII 碼。

```js
const letter = "A";
console.log(letter.charCodeAt(0));  // 65
```

- **`fromCharCode()` 方法**：此方法將 ASCII 碼轉換為其對應的字元。

```js
const char = String.fromCharCode(65);
console.log(char);  // A
```

## 其他常見的字串方法

- **`indexOf` 方法**：此方法用於在字串中搜尋子字串。如果找到子字串，`indexOf` 傳回該子字串第一次出現的位置（或索引）。如果未找到子字串，`indexOf` 傳回 -1，顯示搜尋失敗。

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.indexOf("fox")); // 16
console.log(text.indexOf("cat")); // -1
```
  
- **`includes()` 方法**：此方法用於檢查字串是否包含特定子字串。如果在字串中找到該子字串，該方法會傳回 true。否則，會傳回 false。

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.includes("fox")); // true
console.log(text.includes("cat")); // false
```

- **`slice()` 方法**：此方法傳回一個新的陣列，該陣列包含原始陣列中由起始和結束索引指定的部分淺層複本。新的陣列包含對與原始陣列相同元素的參考（而非複製品）。這表示如果元素是原始型別（例如數字或字串），則值會被複製；但如果元素是物件或陣列，則會複製參考，而非物件本身。

```js
const text = "freeCodeCamp";
console.log(text.slice(0, 4));  // "free"
console.log(text.slice(4, 8));  // "Code"
console.log(text.slice(8, 12)); // "Camp"
```

- **`toUpperCase()` 方法**：此方法將所有字元轉換為大寫字母，並傳回一個包含所有大寫字元的新字串。

```js
const text = "Hello, world!";
console.log(text.toUpperCase()); // "HELLO, WORLD!"
```

- **`toLowerCase()` 方法**：此方法將字串中的所有字元轉換為小寫。

```js
const text = "HELLO, WORLD!"
console.log(text.toLowerCase()); // "hello, world!"
```

- **`replace()` 方法**：此方法允許你在字串中尋找指定的值（例如字或字元），並將其替換為另一個值。此方法會傳回一個包含替換結果的新字串，並保持原始字串不變，因為 JavaScript 字串是不可變的。

```js
const text = "I like cats";
console.log(text.replace("cats", "dogs")); // "I like dogs"
```
 
- **`repeat()` 方法**：此方法用於重複字串指定的次數。

```js
const text = "Hello";
console.log(text.repeat(3)); // "HelloHelloHello"
```

- **`trim()` 方法**：此方法用於移除字串開頭和結尾的空白字元。

```js
const text = "  Hello, world!  ";
console.log(text.trim()); // "Hello, world!"
```

- **`trimStart()` 方法**：此方法會移除字串開頭（或「開始」）的空白字元。

```js
const text = "  Hello, world!  ";
console.log(text.trimStart()); // "Hello, world!  "
```

- **`trimEnd()` 方法**：此方法會移除字串末端的空白字元。

```js
const text = " Hello, world! ";
console.log(text.trimEnd()); // "  Hello, world!"
```

- **`prompt()` 方法**：這個 `window` 的方法用來透過對話盒的表單從使用者取得資訊。這個方法接受兩個引數。第一個引數是會出現在對話盒內的訊息，通常用來提示使用者輸入資訊。第二個引數是選用的預設值，會預先填入輸入欄位。

```js
const answer = window.prompt("What's your favorite animal?"); // This will change depending on what the user answers
```

## 使用 Number 資料型別

- **定義**：JavaScript 的 `Number` 型別包括整數、浮點數、`Infinity` 和 `NaN`。浮點數是帶有小數點的數字。正的 `Infinity` 是大於任何其他數字的數字，而 `-Infinity` 是小於任何其他數字的數字。`NaN`（`Not a Number`）表述像字串 `"Jessica"` 這樣的無效數值。

## 常見算術操作

- **加法運算子**：此運算子（`+`）用於計算兩個或多個數字的總和。
- **減法運算子**：此運算子（`-`）用於計算兩個數字之間的差異。
- **乘法運算子**：此運算子（`*`）用於計算兩個或多個數字的乘積。
- **除法運算子**：此運算子（`/`）用於計算兩個數字之間的商。
- **除以零**：如果你嘗試除以零，JavaScript 將傳回 `Infinity`。
- **餘數運算子**：此運算子（`%`）傳回除法的餘數。
- **冪次運算子**：此運算子（`**`）會將一個數字引發到另一個數字的次方。

## 數字和字串的計算

- **說明**：當你使用 `+` 運算子搭配數字和字串時，JavaScript 會將數字強制轉換為字串並串接這兩個值。當你使用 `-`、`*` 或 `/` 運算子搭配字串和數字時，JavaScript 會將字串強制轉換為數字，結果將會是數字。對於 `null` 和 `undefined`，JavaScript 在數學運算中將 `null` 視為 0，將 `undefined` 視為 `NaN`。

```js
const result = 5 + '10';

console.log(result); // 510
console.log(typeof result); // string

const subtractionResult = '10' - 5;
console.log(subtractionResult); // 5
console.log(typeof subtractionResult); // number

const multiplicationResult = '10' * 2;
console.log(multiplicationResult); // 20
console.log(typeof multiplicationResult); // number

const divisionResult = '20' / 2;
console.log(divisionResult); // 10
console.log(typeof divisionResult); // number

const result1 = null + 5;
console.log(result1); // 5
console.log(typeof result1); // number

const result2 = undefined + 5;
console.log(result2); // NaN
console.log(typeof result2); // number
```

## 運算子優先

- **定義**：運算子優先決定運算式中操作的評估順序。優先較高的運算子會先於優先較低的運算子被評估。括號內的值會先被評估，而乘法／除法的優先會高於加法／減法。如果運算子具有相同的優先，則 JavaScript 會使用結合性。結合性告訴 JavaScript 是從左到右還是從右到左評估運算子。舉例來說，指數運算子也是從右到左結合：

```js
const result = (2 + 3) * 4;

console.log(result); // 20

const result2 = 10 - 2 + 3;

console.log(result2); // 11

const result3 = 2 ** 3 ** 2;

console.log(result3); // 512
```

## 遞增和遞減運算子

- **累加運算子**：此運算子用於將數值增加一。前置式 `++num` 會先增加變數的值，然後傳回新的值。後置式 `num++` 會先傳回變數的當前值，然後再增加它。

```js
let x = 5;

console.log(++x); // 6
console.log(x); // 6


let y = 5;

console.log(y++); // 5
console.log(y); // 6
```

- **遞減運算子**：此運算子用於將數值減少一。前置式和後置式的用法與先前的累加運算子相同。

```js
let num = 5;

console.log(--num); // 4
console.log(num--); // 4
console.log(num); // 3
```

## 複合指定運算子

- **加法指派 (`+=`) 運算子**：此運算子對值執行加法並將結果指定給變數。
- **減法指派（`-=`）運算子**：此運算子對值執行減法並將結果指定給變數。
- **乘法指派 (`*=`) 運算子**：此運算子對值進行乘法運算，並將結果指定給變數。
- **除法指派 (`/=`) 運算子**：此運算子對值執行除法並將結果指定給變數。
- **餘數指派（`%=`）運算子**：此運算子將變數除以指定的數字，並將餘數指定給該變數。
- **指數指派 (`**=`) 運算子**：此運算子將變數提升到指定數字的次方，並將結果重新指定給該變數。

## 布林值和相等性

- **布林值定義**：布林值是一種只能有兩個值的資料型別：`true` 或 `false`。
- **相等 (`==`) 運算子**：此運算子在檢查值是否相等之前會使用型別強制轉換。

```js
console.log(5 == '5'); // true
```

- **嚴格相等 (`===`) 運算子**：此運算子不執行型別強制轉換，並檢查型別與值是否都相等。

```js
console.log(5 === '5'); // false
```

- **不相等 (`!=`) 運算子**：此運算子在檢查值是否不相等之前會使用型別強制轉換。
- **嚴格不相等 (`!==`) 運算子**：此運算子不執行型別強制轉換，並檢查型別和數值是否皆不相等。

## 比較運算子

- **大於 (`>`) 運算子**：此運算子檢查左邊的值是否大於右邊的值。
- **大於（`>=`）或相等運算子**：此運算子檢查左邊的值是否大於或相等於右邊的值。
- **小於 (`<`) 運算子**：此運算子檢查左邊的值是否小於右邊的值。
- **小於 (`<=`) 或相等運算子**：此運算子檢查左邊的值是否小於或相等於右邊的值。

## 一元運算子

- **一元加號運算子**：此運算子會將其運算元轉換為數字。如果運算元已經是數字，則保持不變。

```js
const str = '42';
const num = +str;

console.log(num); // 42
console.log(typeof num); // number
```

- **一元負號（`-`）運算子**：此運算子會對運算元取負。

```js
const num = 4;
console.log(-num); // -4
```

- **邏輯 NOT (`!`) 運算子**：此運算子會反轉其運算元的布林值。因此，如果運算元是 `true`，它會變成 `false`，如果是 `false`，它會變成 `true`。

## 以 bit 為單元逐一運算子

- **以 bit 為單元逐一 AND (`&`) 運算子**：此運算子會在兩個運算元的對應位元皆為 1 的每個位元位置傳回 1。
- **以 bit 為單元逐一 AND 指派 (`&=`) 運算子**：此運算子會對指定的數字執行 `bitwise AND` 操作，並將結果重新指定給該變數。
- **以 bit 為單元逐一 OR (`|`) 運算子**：此運算子會在任一或兩個運算元的對應位元為 1 的每個位元位置傳回 1。
- **以 bit 為單元逐一 OR 指派 (`|=`) 運算子**：此運算子會對指定的數字執行 `bitwise OR` 操作，並將結果重新指定給該變數。
- **以 bit 為單元逐一異或 (`^`) 運算子**：此運算子會在任一但非兩個運算元相對應的位元為 1 的每個位元位置傳回 1。
- **以 bit 為單元逐一反轉 NOT (`~`) 運算子**：此運算子會反轉數字的二進位表述。
- **左移 (`<<`) 運算子**：此運算子將所有位元向左移動指定數量的位置。
- **右移 (`>>`) 運算子**：此運算子將所有位元向右移動。

## 條件述語、真值、假值和三元運算子

- **`if/else if/else`**：`if` 述語會接受一個條件，並在該條件為 `truthy` 時執行一個區塊的程式碼。如果條件為 `false`，則會移至 `else if` 區塊。如果這些條件都不為 `true`，則會執行 `else` 語句。`Truthy` 值是指在布林值背景關係中（例如 `if` 述語）評估結果為 `true` 的任何值。`Falsy` 值是指在布林值背景關係中評估結果為 `false` 的值。

```js
const score = 87;

if (score >= 90) {
 console.log('You got an A'); 
} else if (score >= 80) {
 console.log('You got a B'); // You got an B
} else if (score >= 70) {
 console.log('You got a C');
} else {
 console.log('You failed! You need to study more!');
}
```

- **三元運算子**：這個運算子常用來作為撰寫 `if else` 述語的簡短方式。

```js
const temperature = 30;
const weather = temperature > 25 ? 'sunny' : 'cool';

console.log(`It's a ${weather} day!`); // It's a sunny day!
```

## 二進位邏輯運算子

- **邏輯 AND (`&&`) 運算子**：此運算子會檢查兩個運算元是否皆為真值。如果第一個值為真值，則會傳回第二個值。如果第一個值為假值，則會傳回第一個值。

```js
const result = true && 'hello';

console.log(result); // hello
```

- **邏輯 OR (`||`) 運算子**：此運算子會檢查是否至少有一個運算元為真值。如果第一個值為真值，則傳回該值。如果第一個值為假值，則傳回第二個值。
- **Nullish Coalescing (`??`) 運算子**：只有當第一個值是 `null` 或 `undefined` 時，這個運算子才會傳回該值。

```js
const userSettings = {
 theme: null,
 volume: 0,
 notifications: false,
};

let theme = userSettings.theme ?? 'light';
console.log(theme); // light
```

## `Math` 物件

- **`Math.random()` 方法**：此方法會產生介於 0（含）與 1（不含）之間的隨機浮點數。這表示可能的輸出可以是 0，但絕不會實際達到 1。
- **`Math.max()` 方法**：此方法接受一組數字並傳回最大值。
- **`Math.min()` 方法**：此方法接受一組數字並傳回最小值。
- **`Math.ceil()` 方法**：此方法會將數值無條件進位到最接近的整數。
- **`Math.floor()` 方法**：此方法會將數值向下取整到最接近的整數。
- **`Math.round()` 方法**：此方法會將數值四捨五入到最接近的整數。

```js
console.log(Math.round(2.3)); // 2
console.log(Math.round(4.5)); // 5
console.log(Math.round(4.8)); // 5
```

- **`Math.trunc()` 方法**：此方法會移除數字的小數部分，只傳回整數部分，且不進行四捨五入。
- **`Math.sqrt()` 方法**：此方法會傳回一個數字的平方根。
- **`Math.cbrt()` 方法**：此方法會傳回一個數字的立方根。
- **`Math.abs()` 方法**：此方法會傳回數字的絕對值。
- **`Math.pow()` 方法**：此方法接受兩個數字，並將第一個數字引發至第二個數字的次方。

## 常用數字方法

- **`isNaN()`**：`NaN` 代表「不是數字」。它是一個特殊值，用來表述無法表現或未定義的數值結果。`isNaN()` 函式屬性用來判斷一個值是否為 `NaN`。`Number.isNaN()` 提供了一種更可靠的方式來檢查 `NaN` 值，特別是在型別強制轉換可能導致全域 `isNaN()` 函式出現意外結果的情況下。

```js
console.log(isNaN(NaN));       // true
console.log(isNaN(undefined)); // true
console.log(isNaN({}));        // true

console.log(isNaN(true));      // false
console.log(isNaN(null));      // false
console.log(isNaN(37));        // false


console.log(Number.isNaN(NaN));        // true
console.log(Number.isNaN(Number.NaN)); // true
console.log(Number.isNaN(0 / 0));      // true

console.log(Number.isNaN("NaN"));      // false
console.log(Number.isNaN(undefined));  // false
```

- **`parseFloat()` 方法**：此方法解析字串引數並傳回浮點數。它設計用來從字串開頭擷取數字，即使字串後面包含非數字字元。
- **`parseInt()` 方法**：此方法解析一個字串引數並傳回一個整數。`parseInt()` 在遇到第一個非數字字元時停止解析。對於浮點數，它只傳回整數部分。如果它無法在字串開頭找到有效的整數，則傳回 `NaN`。
- **`toFixed()` 方法**：此方法在數字上呼叫，並接受一個選用引數，該引數為小數點後要顯示的位數。它傳回具有指定小數位數的數字字串表述。

## 比較與 `null` 和 `undefined` 資料型別

- **比較與 `undefined`**：當變數已宣告但尚未指定值時，該變數即為 `undefined`。這是未初始化變數和未提供引數的函式參數的預設值。`undefined` 在數值背景關係中會轉換為 `NaN`，這使得所有與 `undefined` 的數值比較皆傳回 `false`。

```js
console.log(undefined < 0); // false (NaN < 0 is false)
console.log(undefined >= 0); // false (NaN >= 0 is false)
```

- **比較與 `null`**：`null` 型別表述有意的值缺失。`null` 在數值上下文中會轉換為 `0`，這可能導致數值比較時出現意外行為：

```js
console.log(null < 0); // false (0 < 0 is false)
console.log(null >= 0); // true (0 >= 0 is true)
```

- 當使用等號運算子（`==`）時，`null` 和 `undefined` 只彼此相等且與自身相等：

```js
console.log(null == undefined); // true
console.log(null == 0); // false
console.log(undefined == NaN); // false
```

- 然而，當使用嚴格等號運算子（`===`），該運算子會檢查值和型別且不進行型別強制轉換時，`null` 和 `undefined` 並不相等：

```js
console.log(null === undefined); // false
```

## `switch` 陳述式

- **定義**：`switch` 述語會評估一個運算式，並將其值與一系列的 `case` 語句進行比對。當找到匹配時，會執行與該 case 相關的程式碼區段。

```js
const dayOfWeek = 3; 

switch (dayOfWeek) {
  case 1:
    console.log("It's Monday! Time to start the week strong.");
    break;
  case 2:
    console.log("It's Tuesday! Keep the momentum going.");
    break;
  case 3:
    console.log("It's Wednesday! We're halfway there.");
    break;
  case 4:
    console.log("It's Thursday! Almost the weekend.");
    break;
  case 5:
    console.log("It's Friday! The weekend is near.");
    break;
  case 6:
    console.log("It's Saturday! Enjoy your weekend.");
    break;
  case 7:
    console.log("It's Sunday! Rest and recharge.");
    break;
  default:
    console.log("Invalid day! Please enter a number between 1 and 7.");
}
```

## JavaScript 函式（程式）

- 函式（程式）是可重複使用的程式碼區塊，用來執行特定任務。
- 函式（程式）可以使用 `function` 關鍵字定義，後接名稱、一個參數列表，以及執行任務的程式碼區塊。
- 引數是在呼叫函式時傳遞給該函式的值。
- 當一個函式（程式）完成執行時，它將始終傳回一個值。
- 預設情況下，函式（程式）的返回值是 `undefined`。
- `return` 關鍵字用於指定從函式中傳回的值，並結束函式執行。

## 箭頭函式

- 箭頭函式是在 JavaScript 中撰寫函式（程式）的更簡潔方式。
- 箭頭函式是使用 `=>` 語法在參數和函式主體之間定義的。
- 在定義箭頭函式時，你不需要 `function` 關鍵字。
- 如果你使用單一參數，可以省略參數列周圍的小括弧。
- 如果函式（程式）主體只包含單一個表達式、運算式，你可以省略大括號和 `return` 關鍵字。

## 程式設計中的範圍

- **全域的範圍**：這是 JavaScript 中最外層的範圍。在全域的範圍中宣告的變數可以在程式碼的任何地方存取，並稱為全域變數。
- **區域的作用域**：這是指在函式內宣告的變數。這些變數只能在宣告它們的函式內存取，稱為區域變數。
- **區塊範圍**：區塊是一組用大括號 `{}` 包圍的述語，例如在 `if` 述語或迴圈中。
- 使用 `let` 和 `const` 的區塊作用域提供更細緻的變數存取控制，有助於防止錯誤並使你的程式碼更可預測。

## JavaScript 陣列基礎

- **定義**：JavaScript 陣列是一個有序的值群集，每個值由數字索引識別。JavaScript 陣列中的值可以是不同的資料型別，包括數字、字串、布林值、物件，甚至其他陣列。陣列在記憶體中是連續的，這表示所有元素都儲存在單一連續的記憶體區段中，允許高效的索引和透過索引快速存取元素。

```js
const developers = ["Jessica", "Naomi", "Tom"];
```

- **從陣列存取元素**：要從陣列存取元素，你需要取用陣列，接著在方括號內放入索引編號。JavaScript 陣列是從零開始編號，這表示第一個元素的索引是 0，第二個元素的索引是 1，依此類推。如果你嘗試存取陣列中不存在的索引，JavaScript 就會傳回 `undefined`。

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers[0] // "Jessica"
developers[1] // "Naomi"

developers[10] // undefined
```

- **`length` 屬性**：此屬性用於傳回陣列中的項目數量。

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers.length // 3
```

- **更新陣列中的元素**：要更新陣列中的元素，你使用指定運算子（`=`）為特定索引的元素指定新值。

```js
const fruits = ['apple', 'banana', 'cherry'];
fruits[1] = 'blueberry';

console.log(fruits); // ['apple', 'blueberry', 'cherry']
```

## 二維陣列

- **定義**：二維陣列本質上是一個陣列的陣列。它用來表述具有自然格狀結構的資料，例如棋盤、試算表或影像中的像素。要存取二維陣列中的元素，你需要兩個索引：一個用於列，一個用於行。

```js
const chessboard = [
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']
];

console.log(chessboard[0][3]); // "Q"
```

## 陣列解構

- **定義**：陣列解構是 JavaScript 中的一項特性，允許你從陣列中擷取值並將它們指定給變數，以更簡潔且易讀的方式。它提供了一種方便的語法，用於將陣列元素拆解到不同的變數中。

```js
const fruits = ["apple", "banana", "orange"];

const [first, second, third] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(third); // "orange"
```

- **Rest 語法**：這允許你將尚未被解構的陣列剩餘元素捕捉到一個新的陣列中。

```js
const fruits = ["apple", "banana", "orange", "mango", "kiwi"];
const [first, second, ...rest] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(rest); // ["orange", "mango", "kiwi"]
```

## 常用陣列方法

- **`push()` 方法**：此方法用於將元素添加到陣列的末端，並會傳回新的長度。

```js
const desserts = ["cake", "cookies", "pie"];
desserts.push("ice cream");

console.log(desserts); // ["cake", "cookies", "pie", "ice cream"];
```

- **`pop()` 方法**：此方法用於從陣列中移除最後一個元素，並會傳回該被移除的元素。如果陣列為空，則返回值將是 `undefined`。

```js
const desserts = ["cake", "cookies", "pie"];
desserts.pop();

console.log(desserts); // ["cake", "cookies"];
```

- **`shift()` 方法**：此方法用於從陣列中移除第一個元素並傳回該被移除的元素。如果陣列為空，則返回值將是 `undefined`。

```js
const desserts = ["cake", "cookies", "pie"];
desserts.shift();

console.log(desserts); // ["cookies", "pie"];
```

- **`unshift()` 方法**：此方法用於將元素添加到陣列的開頭，並會傳回新的長度。

```js
const desserts = ["cake", "cookies", "pie"];
desserts.unshift("ice cream");

console.log(desserts); // ["ice cream", "cake", "cookies", "pie"];
```

- **`indexOf()` 方法**：此方法用於尋找陣列中指定元素的第一個索引。如果找不到該元素，則會傳回 `-1`。

```js
const fruits = ["apple", "banana", "orange", "banana"];
const index = fruits.indexOf("banana");

console.log(index); // 1
console.log(fruits.indexOf("not found")); // -1
```

- **`splice()` 方法**：此方法用於從陣列中的任意位置新增或移除元素。`splice()` 方法的返回值將會是從陣列中移除的項目陣列。如果沒有移除任何項目，則會返回一個空陣列。此方法會變更原始陣列，直接在原地修改它，而非建立新的陣列。第一個引數指定開始修改陣列的索引位置。第二個引數是你希望移除的元素數量。接下來的引數是你希望新增的元素。

```js
const colors = ["red", "green", "blue"];
colors.splice(1, 0, "yellow", "purple");

console.log(colors); // ["red", "yellow", "purple", "green", "blue"]
```

- **`includes()` 方法**：此方法用於檢查陣列是否包含特定值。若陣列包含指定的元素，則此方法傳回 `true`，否則傳回 `false`。

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];

console.log(programmingLanguages.includes("Python")); // true
console.log(programmingLanguages.includes("Perl")); // false
```

- **`concat()` 方法**：此方法透過合併兩個或多個陣列來創建一個新的陣列。

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.concat("Perl");

console.log(newList); // ["JavaScript", "Python", "C++", "Perl"]
```

- **`slice()` 方法**：此方法會傳回陣列部分的淺層複本，從指定的索引開始或整個陣列。淺層複本會複製對陣列的參考，而非複製陣列本身。

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.slice(1);

console.log(newList); // ["Python", "C++"]
```

- **展開語法**：展開語法用於創建陣列的淺層複製。

```js
const originalArray = [1, 2, 3];
const shallowCopiedArray = [...originalArray];

shallowCopiedArray.push(4);

console.log(originalArray); // [1, 2, 3]
console.log(shallowCopiedArray); // [1, 2, 3, 4]
```

- **`split()` 方法**：此方法將字串分割成子字串的陣列，並根據指定的分隔符決定每個分割的位置。如果未提供分隔符，該方法會傳回一個包含原始字串作為單一元素的陣列。

```js
const str = "hello";
const charArray = str.split("");

console.log(charArray); // ["h", "e", "l", "l", "o"]
```

- **`reverse()` 方法**：此方法會就地反轉陣列。

```js
const desserts = ["cake", "cookies", "pie"];
console.log(desserts.reverse()); // ["pie", "cookies", "cake"]
```

- **`join()` 方法**：此方法將陣列中所有元素串接成一個字串，並以指定的分隔符分隔每個元素。如果未提供分隔符，或使用空字串（`""`），則元素將不使用任何分隔符直接串接。

```js
const reversedArray = ["o", "l", "l", "e", "h"];
const reversedString = reversedArray.join("");

console.log(reversedString); // "olleh"
```

## 物件基礎知識

- **定義**：物件是一種由屬性組成的資料結構。屬性包含一個鍵和值。若要存取物件中的資料，你可以使用點記法或括號記法。

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};

console.log(person.name);  // Alice
console.log(person["name"]); // Alice
```

要為現有物件的屬性設值，你可以使用點記法或括號記法，並搭配指定運算子。

```js
const person = {
  name: "Alice",
  age: 30
};

person.job = "Engineer"
person["hobby"] = "Knitting"
console.log(person);  // {name: 'Alice', age: 30, job: 'Engineer', hobby: 'Knitting'}
```

## 從物件中移除屬性

- **`delete` 運算子**：此運算子用於從物件中移除屬性。

```js
const person = {
  name: "Alice",
  age: 30,
  job: "Engineer"
};

delete person.job;

console.log(person.job); // undefined
```

## 檢查物件是否具有屬性

- **`hasOwnProperty()` 方法**：此方法傳回一個布林值，表示該物件是否擁有指定的屬性作為其自身的屬性。

```js
const person = {
  name: "Alice",
  age: 30
};

console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("job")); // false
```

- **`in` 運算子**：如果屬性存在於物件中，這個運算子將傳回 `true`。

```js
const person = {
  name: "Bob",
  age: 25
};

console.log("name" in person);  // true
```

## 從巢狀物件存取屬性

- **存取資料**：從巢狀物件存取屬性涉及使用點記號或括號記號，就像存取簡單物件的屬性一樣。然而，你需要串鏈這些存取器以深入巢狀結構。

```js
const person = {
  name: "Alice",
  age: 30,
  contact: {
    email: "alice@example.com",
    phone: {
      home: "123-456-7890",
      work: "098-765-4321"
    }
  }
};

console.log(person.contact.phone.work); // "098-765-4321"
```

## 原始型別與非原始型別資料型別

- **原始資料型別**：這些資料型別包括數字、字串、布林值、`null`、`undefined` 和符號。這些型別被稱為「原始」是因為它們表現單一值，且不是物件。原始值是不可變的，這表示一旦它們被創建，它們的值就無法改變。
- **非原生類型資料**：在 JavaScript 中，這些是物件，包括一般物件、陣列和函式。與原生類型不同，非原生類型可以將多個值作為屬性或元素來保存。

## 物件方法

- **定義**：物件的方法是與物件相關的函式（程式）。它們被定義為物件的屬性，並且可以存取及操作該物件的資料。方法內的 `this` 關鍵字取用的是物件本身，使其能存取物件的屬性。

```js
const person = {
  name: "Bob",
  age: 30,
  sayHello: function() {
    return "Hello, my name is " + this.name;
  }
};

console.log(person.sayHello()); // "Hello, my name is Bob"
```

## 物件建構式

- **定義**：在 JavaScript 中，建構式是一種用來創建並初始化物件的特殊型別函式（程式）。它是使用 `new` 關鍵字喚起，並且可以初始化新創建物件上的屬性和方法。`Object()` 建構式會創建一個新的空物件。

```js
new Object()
```

## 使用選用串鏈運算子（`?.`）

- **定義**：此運算子讓你安全地存取物件屬性或呼叫方法，而不必擔心它們是否存在。

```js
const user = {
  name: "John",
  profile: {
    email: "john@example.com",
    address: {
      street: "123 Main St",
      city: "Somewhere"
    }
  }
};

console.log(user.profile?.address?.street); // "123 Main St"
console.log(user.profile?.phone?.number);   // undefined
```

## 物件解構

- **定義**：物件解構允許你從物件中擷取值，並以更簡潔且易讀的方式將它們指定給變數。

```js
const person = { name: "Alice", age: 30, city: "New York" };

const { name, age } = person;

console.log(name); // Alice
console.log(age);  // 30
```

## 處理 JSON

- **定義**：JSON 代表 JavaScript 物件表示法。它是一種輕量級、基於文字的資料格式，常用於伺服端與網頁應用程式之間交換資料。

```js
{
  "name": "Alice",
  "age": 30,
  "isStudent": false,
  "list of courses": ["Mathematics", "Physics", "Computer Science"]
}
```

- **`JSON.stringify()`**：此方法用於將 JavaScript 物件轉換成 JSON 字串。當你想以一種可以輕鬆共享或在系統間傳輸的格式來儲存或傳送資料時，這非常有用。

```js
const user = {
  name: "John",
  age: 30,
  isAdmin: true
};

const jsonString = JSON.stringify(user);
console.log(jsonString); // '{"name":"John","age":30,"isAdmin":true}'
```

- **`JSON.parse()`**：此方法將 JSON 字串轉換回 JavaScript 物件。當你從網頁伺服器或 localStorage 取得 JSON 資料並需要在你的應用程式中操作該資料時，這非常有用。

```js
const jsonString = '{"name":"John","age":30,"isAdmin":true}';
const userObject = JSON.parse(jsonString);

// result: { name: 'John', age: 30, isAdmin: true }
console.log(userObject);
```


## 使用迴圈

- **`for` 迴圈**：這種類型的迴圈用於重複執行一個區塊的程式碼特定次數。這個迴圈分為三個部分：初始化述語、條件和遞增/遞減述語。初始化述語會在迴圈開始前執行，通常用於初始化計數器變數。條件會在每次迴圈執行前被計算。一次迴圈執行是指迴圈的一次通過。如果條件為 `true`，則執行迴圈內的程式碼區塊。如果條件為 `false`，迴圈停止並繼續執行下一個程式碼區塊。遞增/遞減述語會在每次迴圈執行後執行，通常用於遞增或遞減計數器變數。

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

- **`for...of` 迴圈**：當你需要對可迭代物件的值進行迴圈時，會使用這種類型的迴圈。可迭代物件的範例有陣列和字串。

```js
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num);
}
```

- **`for...in` 迴圈**：當你需要對物件的屬性進行迴圈時，這種類型的迴圈最適合使用。此迴圈會迭代物件的所有可列舉屬性，包括繼承的屬性和非數字屬性。

```js
const fruit = {
  name: 'apple',
  color: 'red',
  price: 0.99
};

for (const prop in fruit) {
  console.log(fruit[prop]);
}
```

- **`while` 迴圈**：只要條件為 `true`，此類型的迴圈就會執行一個區塊的程式碼。

```js
let i = 5;

while (i > 0) {
  console.log(i);
  i--;
}
```

- **`do...while` 迴圈**：這種類型的迴圈會先執行該區塊的程式碼至少一次，然後才檢查條件。

```js
let userInput;

do {
  userInput = prompt("Please enter a number between 1 and 10");
} while (Number(userInput) < 1 || Number(userInput) > 10);

alert("You entered a valid number!");
```

## `break` 和 `continue` 述語

- **定義**：`break` 述語用於提前離開迴圈，而 `continue` 述語用於跳過迴圈的當前迭代並移至下一次迭代。

```js
// Example of break statement
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, and 4

// Example of continue statement 
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    continue;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, 4, 6, 7, 8, and 9
```

## 字串建構式和 `toString()` 方法

- **定義**：字串物件用於表述一連串字元。字串物件是使用 `String` 建構式函式創建的，該函式會將原始值包裝在物件中。

```js
const greetingObject = new String("Hello, world!");

console.log(typeof greetingObject); // "object"
```

- **`toString()` 方法**：此方法將一個值轉換為其字串表現。你可以對數字、布林值、陣列和物件使用此方法。

```js
const num = 10;
console.log(num.toString()); // "10"

const arr = [1, 2, 3];
console.log(arr.toString()); // "1,2,3"
```

此方法接受一個選用的 radix，該數字介於 2 到 36 之間。此 radix 表述基數，例如二進位的基數為 2，八進位的基數為 8。如果未指定 radix，則預設為基數 10，即十進位。


```js
const num = 10;
console.log(num.toString(2)); // "1010"(binary)
```

## 數字建構式

- **定義**：`Number` 建構式用於創建數字物件。數字物件包含一些有用的屬性和方法，例如 `isNaN` 和 `toFixed` 方法。大多數時候，你會使用 `Number` 建構式將其他資料型別轉換為數字型別。

```js
const myNum = new Number("34");
console.log(typeof myNum); // "object"

const num = Number('100');
console.log(num); // 100

console.log(typeof num); // number
```

## 命名變數和函式（程式）的最佳實踐

- **camelCasing**：依慣例，JavaScript 開發者會使用 camel casing 來命名變數和函式。Camel casing 是指第一個字全部小寫，接下來的字以大寫字母開頭。例如 `isLoading`。

- **布林值命名**：對於布林值變數，常見的做法是使用像是「is」、「has」或「can」等前置式。

```js
let isLoading = true;
let hasPermission = false;
let canEdit = true;
```

- **命名函式（程式）**：對於函式（程式），名稱應該清楚顯示該函式（程式）所執行的功能。對於傳回布林值（通常稱為謂詞）的函式（程式），你可以使用相同的「is」、「has」或「can」前置式。當你有取得資料的函式（程式）時，通常會以「get」字開頭。當你有設定資料的函式（程式）時，通常會以「set」字開頭。對於事件處理常式函式（程式），你可以使用「handle」作為前置式或以「Handler」作為後綴。

```js
function getUserData() { /* ... */ }

function isValidEmail(email) { /* ... */ }

function getProductDetails(productId) { /* ... */ }

function setUserPreferences(preferences) { /* ... */ }

function handleClick() { /* ... */ }
```

- **在迴圈中命名變數**：在迴圈中命名迭代器變數時，通常會使用像 `i`、`j` 或 `k` 這樣的單一字母。

```js
for (let i = 0; i < array.length; i++) { /* ... */ }
```

## 操作稀疏陣列

- **定義**：陣列中可以有空槽。空槽被定義為槽中沒有任何內容。這與陣列槽中值為 `undefined` 不同。這種類型的陣列稱為稀疏陣列。

```js
const sparseArray = [1, , , 4];
console.log(sparseArray.length); // 4
```
  
## 程式碼檢查工具和格式化工具

- **Linters**：Linter 是一種靜態程式碼分析工具，用來標示程式錯誤、錯誤、風格錯誤和可疑的構件。常見的 linter 範例是 ESLint。
- **格式化工具**：格式化工具是自動將你的程式碼格式化以符合特定風格指南的工具。常見的格式化工具範例是 Prettier。

## 記憶體管理

- **定義**：記憶體管理是控制記憶體的處理程序，當需要時分配記憶體，當不再需要時釋放記憶體。JavaScript 使用自動記憶體管理。這表示 JavaScript（更具體來說，是你網頁瀏覽器中的 JavaScript 引擎）會為你處理記憶體的分配和釋放。你不需要在程式碼中明確釋放記憶體。這個自動處理程序通常稱為「垃圾回收」。

## 閉包

- **定義**：閉包是指一個函式（程式），即使在外部函式已經傳回之後，仍然可以存取其外部（包覆）詞彙範圍內的變數。

```js
function outerFunction(x) {
  let y = 10;
  function innerFunction() {
    console.log(x + y);
  }
  return innerFunction;
}

let closure = outerFunction(5);
closure(); // 15
```

## `var` 關鍵字與提升

- **定義**：`var` 是 2015 年之前宣告變數的原始方式。但在範圍、重新宣告等方面，`var` 存在一些問題。因此，現代 JavaScript 程式設計改用 `let` 和 `const`。
- **使用 `var` 重新宣告變數**：如果你嘗試使用 `let` 重新宣告變數，則會得到 `SyntaxError`。但使用 `var`，你可以重新宣告變數。

```js
// Uncaught SyntaxError: Identifier 'num' has already been declared 
let num = 19;
let num = 18;

var myNum = 5;
var myNum = 10; // This is allowed and doesn't throw an error

console.log(myNum) // 10
```

- **`var` 和範圍**：在區塊（例如 `if` 述語或 `for` 迴圈）內使用 `var` 宣告的變數，仍然可以在該區塊外被存取。

```js
if (true) {
  var num = 5;
}
console.log(num); // 5
```

- **提升（Hoisting）**：這是 JavaScript 在程式碼執行前的編譯階段，將宣告式移動到其各自作用域頂端的預設行為。當你使用 `var` 關鍵字宣告變數時，JavaScript 會將該宣告提升到其作用域的頂端。

```js
console.log(num); // undefined
var num = 5;
console.log(num); // 5
```

當你使用函式宣告語法宣告一個函式時，函式名稱和函式本體都會被提升。這表示你可以在程式碼中宣告函式之前就呼叫該函式。

```js
sayHello(); // "Hello, World!"

function sayHello() {
  console.log("Hello, World!");
}
```

使用 `let` 或 `const` 所做的變數宣告會被提升，但它們不會被初始化，且你無法在程式碼中實際宣告之前存取它們。這種行為通常被稱為「暫時性死區」。

```js
console.log(num); // Throws a ReferenceError
let num = 10;
```

## 使用匯入、匯出和模組

- **模組**：這是一個自包含的程式碼單元，封裝相關的函式（程式）、類別或變數。要創建模組，你需要將你的 JavaScript 程式碼寫在一個獨立的檔案中。
- **匯出**：你想要讓應用程式其他零件使用的任何變數、函式或類別，都需要使用 `export` 關鍵字明確匯出。匯出有兩種類型：命名匯出和預設匯出。
- **匯入**：若要在應用程式的其他零件中使用匯出的項目，你需要使用 `import` 關鍵字將它們匯入。型別可以是命名匯入、預設匯入和命名空間匯入。

```js
// Within a file called math.js, we export the following functions:

// Named export
export function add(num1, num2) {
  return num1 + num2;
}

// Default export
export default function subtract(num1, num2) {
  return num1 - num2;
}

// Within another file, we can import the functions from math.js.

// Named import - This line imports the add function.
// The name of the function must exactly match the one exported from math.js.
import { add } from './math.js';

// Default import - This line imports the subtract function.
// The name of the function can be anything.
import subtractFunc from './math.js';

// Namespace import - This line imports everything from the file.
import * as Math from './math.js';

console.log(add(5, 3)); // 8
console.log(subtractFunc(5, 3)); // 2
console.log(Math.add(5, 3)); // 8
console.log(Math.subtract(5, 3)); // 2
```

## 回呼函式與 `forEach` 方法

- **定義**：在 JavaScript 中，回呼函式是作為引數傳遞給另一個函式，並由第一個函式在某個時刻喚起的函式。
- **`forEach()` 方法**：此方法用於迭代陣列中的每個元素，並對每個元素執行操作。`forEach` 中的回呼函式最多可接受三個引數：目前的元素、目前元素的索引，以及呼叫 `forEach` 的陣列。

```js
const numbers = [1, 2, 3, 4, 5];

// Result: 2 4 6 8 10
numbers.forEach((number) => {
  console.log(number * 2);
});
```

## 高階函式（函數）

- **定義**：高階函式（程式）會將一個或多個函式（程式）作為引數，並傳回一個函式（程式）或值作為結果。

```js
function operateOnArray(arr, operation) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(operation(arr[i]));
  }
  return result;
}

function double(x) {
  return x * 2;
}

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = operateOnArray(numbers, double);
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
```

- **`map()` 方法**：此方法用於透過將指定的函式應用到原始陣列的每個元素來創建一個新的陣列。回呼函式最多可以接受三個引數：目前的元素、目前元素的索引，以及呼叫 `map` 的陣列。

```js
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);

console.log(numbers); // [1, 2, 3, 4, 5]
console.log(doubled); // [2, 4, 6, 8, 10]
```

- **`filter()` 方法**：此方法用於創建一個包含通過指定測試的元素的新陣列，使其在根據條件選擇性提取項目時非常有用。就像 `map` 方法一樣，`filter` 方法的回呼函式接受相同的三個引數：當前正在處理的元素、索引和陣列。

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter((num) => num % 2 === 0);

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

- **`reduce()` 方法**：此方法用於處理陣列並將其縮減為單一值。此單一值可以是數字、字串、物件，甚至是另一個陣列。`reduce()` 方法透過對陣列中的每個元素依序套用函式來運作，並將每次計算的結果傳遞給下一次。此函式通常稱為 reducer 函式。reducer 函式接受兩個主要參數：累加器和當前值。累加器是你用來儲存操作結果的變數，而當前值是正在處理的陣列元素。

```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0
);

console.log(sum); // 15
```

## 方法串鏈

- **定義**：串鏈方法是一種程式設計技巧，允許你在同一行 `code` 中對同一個物件呼叫多個方法。當你對同一個物件執行一連串操作時，這種技巧可以讓你的程式碼更具可讀性且更簡潔。

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

## 使用 `sort` 方法

- **定義**：`sort` 方法用於排序陣列的元素並傳回排序後陣列的引用。此情況下不會製作複本，因為元素是在原地排序。

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();

console.log(fruits); // ["Apple", "Banana", "Mango", "Orange"]
```

如果你需要排序數字，則你需要傳入一個比較函式。`sort` 方法會將元素轉換成字串，然後比較它們的 UTF-16 程式碼單元值序列。UTF-16 程式碼單元是表述字串中字元的數值。UTF-16 程式碼單元的範例是數字 65、66 和 67，分別表述字元 "A"、"B" 和 "C"。因此，數字 200 會出現在數字 3 之前，因為在比較它們的 UTF-16 程式碼單元時，字串 "200" 會出現在字串 "3" 之前。

```js
const numbers = [414, 200, 5, 10, 3];

numbers.sort((a, b) => a - b);

console.log(numbers); // [3, 5, 10, 200, 414]
```

參數 `a` 和 `b` 是被比較的兩個元素。比較函式應該在 `a` 應該排在 `b` 之前時傳回負值，`a` 應該排在 `b` 之後時傳回正值，且當 `a` 和 `b` 相等時傳回零。

## 使用 `every` 和 `some` 方法

- **`every()` 方法**：此方法會測試陣列中所有元素是否通過由提供的函式實作的測試。若提供的函式對陣列中所有元素皆傳回 `true`，`every()` 方法會傳回 `true`。若有任何元素未通過測試，該方法會立即傳回 `false` 並停止檢查剩餘的元素。

```js
const numbers = [2, 4, 6, 8, 10];
const hasAllEvenNumbers = numbers.every((num) => num % 2 === 0);

console.log(hasAllEvenNumbers); // true
```

- **`some()` 方法**：此方法會檢查是否至少有一個元素通過測試。`some()` 方法在找到通過測試的元素後立即傳回 `true`。如果沒有元素通過測試，則傳回 `false`。

```js
const numbers = [1, 3, 5, 7, 8, 9];
const hasSomeEvenNumbers = numbers.some((num) => num % 2 === 0);

console.log(hasSomeEvenNumbers); // true
```

## 操作 DOM 和 Web API

- **API**：API（應用程式設計介面）是一組規則和通訊協定，允許軟體應用程式彼此溝通並高效交換資料。
- **Web API**：Web API 專為網頁應用程式設計。這類 API 通常分為兩大類別：瀏覽器 API 和第三方 API。
- **瀏覽器 API**：這些 API 會揭露來自瀏覽器的資料。作為網頁開發者，你可以使用 JavaScript 存取並操作這些資料。
- **第三方 API**：這些不是瀏覽器預設內建的。你必須以某種方式取得它們的程式碼。通常，它們會有詳細的文件說明如何使用它們的服務。舉例來說，Google Maps API 可以用來在你的網站上顯示互動式地圖。
- **DOM**：DOM 代表文件物件模型。它是一個程式設計介面，讓你能與 HTML 文件互動。透過 DOM，你可以新增、修改或刪除網頁上的元素。DOM 樹的根節點是 `html` 元素。它是 HTML 文件所有內容的最高層級容器。所有其他節點都是此根節點的後代。接著，在根節點之下，我們會在階層體系中找到其他節點。父節點是包含其他元素的元素。子節點是被包含在另一個元素中的元素。
- **`navigator` 介面**：此介面提供瀏覽器環境的資訊，例如使用者代理字串、平台以及瀏覽器版本。使用者代理字串是一個用來識別所使用瀏覽器和作業系統的文字字串。
- **`window` 介面**：這表述包含 DOM 文件的瀏覽器視窗。它提供與瀏覽器視窗互動的行為和屬性，例如調整視窗大小、開啟新視窗以及導向不同的 URL。

## 使用 `querySelector()`、`querySelectorAll()` 和 `getElementById()` 方法

- **`getElementById()` 方法**：此方法用於取得表述具有指定 `id` 的 HTML 元素的物件。請記得每個 HTML 文件中的 ID 必須是唯一的，因此此方法只會傳回一個 Element 物件。

```html
<div id="container"></div>
```

```js
const container = document.getElementById("container");
```

- **`querySelector()` 方法**：此方法用於取得 HTML 文件中第一個符合作為引數傳入的 CSS 選擇器的元素。

```html
<section class="section"></section>
```

```js
const section = document.querySelector(".section");
```

- **`querySelectorAll()` 方法**：你可以使用此方法取得符合特定 CSS 選擇器的所有 DOM 元素的列表。

```html
<ul class="ingredients">
  <li>Sugar</li>
  <li>Milk</li>
  <li>Eggs</li>
</ul>
```

```js
const ingredients = document.querySelectorAll('ul.ingredients li');
```

## 使用 `innerText()`、`innerHTML()`、`createElement()` 和 `textContent()` 方法

- **`innerHTML` 屬性**：這是 `Element` 的一個屬性，用於設定或更新 HTML 標記的零件。

```html
<div id="container">
  <!-- Add new elements here -->
</div>
```

```js
const container = document.getElementById("container");
container.innerHTML = '<ul><li>Cheese</li><li>Tomato</li></ul>';
```

- **`createElement` 方法**：這用於創建一個 HTML 元素。

```js
const img = document.createElement("img");
```

- **`innerText`**：這表述 HTML 元素及其子孫的可見文字內容。

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.innerText);
```

- **`textContent`**：這會傳回元素的純文字內容，包括其所有子孫元素中的文字。

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.textContent);
```

## 使用 `appendChild()` 和 `removeChild()` 方法

- **`appendChild()` 方法**：此方法用於將節點添加到指定父節點的子節點列表末端。

```html
<ul id="desserts">
  <li>Cake</li>
  <li>Pie</li>
</ul>
```

```js
const dessertsList = document.getElementById("desserts");
const listItem = document.createElement("li");

listItem.textContent = "Cookies";
dessertsList.appendChild(listItem);
```

- **`removeChild()` 方法**：此方法用於從 DOM 中移除節點。

```html
<section id="example-section">
  <h2>Example sub heading</h2>
  <p>first paragraph</p>
  <p>second paragraph</p>
</section>
```

```js
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");

sectionEl.removeChild(lastParagraph);
```

## 使用 `setAttribute` 方法

- **定義**：此方法用於設定給定元素的屬性。如果屬性已存在，則會更新其值。否則，將新增一個帶有值的屬性。

```html
<p id="para">I am a paragraph</p>
```

```js
const para = document.getElementById("para");
para.setAttribute("class", "my-class");
```

## 事件物件

- **定義**：`Event` 物件是當使用者以某種方式與你的網頁交談時所觸發的有效負載。這些交談可以是從點擊按鈕或聚焦輸入框到搖動他們的行動裝置。所有 `Event` 物件都會有 `type` 屬性。此屬性揭示觸發有效負載的事件型別，例如 keydown 或 click。這些值將對應到你可能傳遞給 `addEventListener()` 的相同值，在那裡你可以捕捉並使用 `Event` 物件。

## `addEventListener()` 和 `removeEventListener()` 方法

- **`addEventListener` 方法**：此方法用於監聽事件。它接受兩個引數：你想監聽的事件以及當事件發生時會被呼叫的函式（程式）。一些常見的事件範例包括點擊事件、輸入事件和變更事件。

```js
const btn = document.getElementById("btn");

btn.addEventListener("click", () => alert("You clicked the button"));
```

- **`removeEventListener` 方法**：此方法用於移除先前使用 `addEventListener` 方法添加到元素的事件監聽器。當你想停止監聽元素上的特定事件時，這非常有用。

```js
const bodyEl = document.querySelector("body");
const para = document.getElementById("para");
const btn = document.getElementById("btn");

let isBgColorGrey = true;

function toggleBgColor() {
  bodyEl.style.backgroundColor = isBgColorGrey ? "blue" : "grey";
  isBgColorGrey = !isBgColorGrey;
}

btn.addEventListener("click", toggleBgColor);

para.addEventListener("mouseover", () => {
  btn.removeEventListener("click", toggleBgColor);
});
```

- **行內事件處理常式**：行內事件處理常式是 HTML 元素上的特殊屬性，用於在事件發生時執行 JavaScript 程式碼。在現代 JavaScript 中，行內事件處理常式不被視為最佳實務。建議改用 `addEventListener` 方法。

```html
<button onclick="alert('Hello World!')">Show alert</button>
```

## DOMContentLoaded

- **定義**：當 HTML 文件中的所有內容都已載入並解析時，會觸發 `DOMContentLoaded` 事件。如果你有外部樣式表或影像，`DOMContentLoaded` 事件不會等待那些載入。它只會等待 HTML 載入完成。

## 操作 `style` 和 `classList`

- **`Element.style` 屬性**：此屬性是一個唯讀屬性，表述元素的行內樣式。你可以使用此屬性來取得或設定元素的樣式。

```js
const paraEl = document.getElementById("para");
paraEl.style.color = "red";
```

- **`Element.classList` 屬性**：此屬性為唯讀屬性，可用來為元素添加、移除或切換類別。

```js
// Example adding a class
const paraEl = document.getElementById("para");
paraEl.classList.add("highlight");

// Example removing a class
paraEl.classList.remove("blue-background");

// Example toggling a class
const menu = document.getElementById("menu");
const toggleBtn = document.getElementById("toggle-btn");

toggleBtn.addEventListener("click", () => menu.classList.toggle("show"));
```


## 使用 `setTimeout` 和 `setInterval` 方法

- **`setTimeout()` 方法**：此方法讓你延遲指定時間後執行動作。

```js
setTimeout(() => {
 console.log('This runs after 3 seconds'); 
}, 3000);
```

- **`setInterval()` 方法**：此方法會以設定的間隔持續重複執行一段程式碼。由於 `setInterval()` 會在指定的間隔持續執行所提供的函式，你可能會想要停止它。為此，你必須使用 `clearInterval()` 方法。

```js
setInterval(() => {
 console.log('This runs every 2 seconds');
}, 2000);

// Example using clearInterval
const intervalID = setInterval(() => {
 console.log('This will stop after 5 seconds');
}, 1000);

setTimeout(() => {
 clearInterval(intervalID);
}, 5000);
```

## `requestAnimationFrame()` 方法

- **定義**：此方法允許你在下一次螢幕重新整理之前排程動畫的下一步，從而產生流暢且視覺上吸引人的體驗。下一次螢幕重新整理是指瀏覽器重新整理網頁視覺顯示的時刻。這通常每秒發生多次，在大多數顯示器上約為 60 次（或每秒 60 個影格）。

```js
function animate() {
 // Update the animation...
 // for example, move an element, change a style, and more.
 update();
 // Request the next frame
 requestAnimationFrame(animate);
}
```

## 網頁動畫 API

- **定義**：Web Animations API 讓你能夠直接在 JavaScript 中創建並控制動畫。

```js
const square = document.querySelector('#square');

const animation = square.animate(
 [{ transform: 'translateX(0px)' }, { transform: 'translateX(100px)' }],
 {
   duration: 2000, // makes animation lasts 2 seconds
   iterations: Infinity, // loops indefinitely
   direction: 'alternate', // moves back and forth
   easing: 'ease-in-out', // smooth easing
 }
);
```

## Canvas API

- **定義**：Canvas API 是一個強大的工具，讓你能夠直接在你的 JavaScript 檔案中操作圖形。要使用 Canvas API，首先你需要在 HTML 中提供一個 `canvas` 元素。這個元素充當一個繪圖表面，你可以使用 Canvas API 中介面的實體方法和屬性來操作它。這個 API 包含像是 `HTMLCanvasElement`、`CanvasRenderingContext2D`、`CanvasGradient`、`CanvasPattern` 和 `TextMetrics` 等介面，這些介面包含你可以用來在你的 JavaScript 檔案中創建圖形的方法和屬性。

```html
<canvas id="my-canvas" width="400" height="400"></canvas>
```

```js
const canvas = document.getElementById('my-canvas');

// Access the drawing context of the canvas. 
// "2d" allows you to draw in two dimensions 
const ctx = canvas.getContext('2d');

// Set the background color
ctx.fillStyle = 'crimson';

// Draw a rectangle
ctx.fillRect(1, 1, 150, 100);
```

## 使用 JavaScript 開啟和關閉對話窗與模態視窗

- **模態與對話盒定義**：對話盒讓你向使用者顯示重要的資訊或操作。利用 HTML 內建的 `dialog` 元素，你可以輕鬆地在你的網頁應用程式中創建這些對話盒（包括模態與非模態對話盒）。模態對話盒是一種強制使用者在存取應用程式或網頁的其他部分之前，必須先與其互動的對話盒。相反地，非模態對話盒允許使用者在對話盒開啟時，繼續與頁面或應用程式的其他部分互動。它不會阻止存取其他內容。
- **`showModal()` 方法**：此方法用於開啟一個模態視窗。

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');

openButton.addEventListener('click', () => {
  dialog.showModal();
});
```

- **`close()` 方法**：此方法用於關閉模態視窗。

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
   <button id="close-modal">Close Modal</button>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');
const closeButton = document.getElementById('close-modal');

openButton.addEventListener('click', () => {
  dialog.show();
});

closeButton.addEventListener('click', () => {
  dialog.close();
});
```

## 變更事件

- **定義**：`change event` 是一種特殊的事件，當使用者修改某些輸入元素的值時會觸發。範例包括勾選核取方塊或圓鈕、單選按鈕，或使用者從日期選擇器或下拉選單中做出選擇時。

```html
<label>
  Choose a programming language:
  <select class="language" name="language">
    <option value="">---Select One---</option>
    <option value="JavaScript">JavaScript</option>
    <option value="Python">Python</option>
    <option value="C++">C++</option>
  </select>
</label>

<p class="result"></p>
```

```js 
const selectEl = document.querySelector(".language");
const result = document.querySelector(".result");

selectEl.addEventListener("change", (e) => {
  result.textContent = `You enjoy programming in ${e.target.value}.`;
});
```

## 事件冒泡

- **定義**：事件冒泡，或稱傳播，指的是當事件被觸發時，該事件如何「冒泡」至父物件。

## 事件委派

- **定義**：事件委派是監聽已冒泡到父元素的事件的處理程序，而不是直接在觸發事件的元素上處理它們。

## JavaScript 和無障礙設計

### 常見的 ARIA 無障礙屬性

- **`aria-expanded` 屬性**：用於向螢幕閱讀器使用者傳達切換（或揭露）特性的狀態。
- **`aria-haspopup` 屬性**：此狀態用於顯示互動元素在作用時會觸發彈出元素。只有當彈出元素具有以下角色之一時，你才能使用 `aria-haspopup` 屬性：`menu`、`listbox`、`tree`、`grid` 或 `dialog`。`aria-haspopup` 的值必須是這些角色之一或 `true`，其意義與 `menu` 相同。
- **`aria-checked` 屬性**：此屬性用於顯示元素是否處於已勾選狀態。它最常用於建立訂製的核取方塊、圓鈕、切換開關和列表框時。
- **`aria-disabled` 屬性**：此狀態用於僅向使用輔助技術（例如螢幕閱讀器）的人員顯示該元素已被停用。
- **`aria-selected` 屬性**：此狀態用於顯示元素已被選取。你可以在訂製控制元件，如分頁介面、列表框或格線中使用此狀態。
- **`aria-controls` 屬性**：用來將一個元素與它所控制的另一個元素關聯起來。這有助於使用輔助技術的人理解這些元素之間的關係。
- **`hidden` 屬性**：將非作用中的面板隱藏，對視覺及輔助技術使用者皆然。

### 使用 Live Regions 和動態內容

- **`aria-live` 屬性**：使網頁的一部分成為即時區域，表示該區域內的任何更新都會由螢幕閱讀器宣告，讓使用者不會錯過重要變更。
- **`polite` 值**：大多數即時區域使用此值。此值表示更新並非緊急，因此螢幕閱讀器可以等到完成任何當前的公告或使用者完成當前操作後，再宣布該更新。

這是一個由 JavaScript 動態更新的即時區域範例：

```html
<div aria-live="polite" id="status"></div>
```

```js
const statusEl = document.getElementById("status");
statusEl.textContent = "Your file has been successfully uploaded.";
```

- **`contenteditable` 屬性**：將元素變成即時編輯器，允許使用者像編輯文字欄位一樣更新其內容。當 contenteditable 區域沒有可見的標籤或標題時，請使用 `aria-label` 屬性為其添加可存取名稱，以協助螢幕閱讀器使用者了解可編輯區域的用途。

```html
<div contenteditable="true" aria-label="Note editor">
  Editable content goes here
</div>
```

## `focus` 和 `blur` 事件

- **`blur` 事件**：當元素失去焦點時觸發。

```js
element.addEventListener("blur", () => {
  // Handle when user leaves the element
});
```

- **`focus` 事件**：當元素獲得焦點時觸發。

```js
element.addEventListener("focus", () => {
  // Handle when user enters the element
});
```

## 常見的錯誤訊息型別

- **SyntaxError**：當你在程式碼中寫錯東西時會發生這些錯誤，例如遺漏括號或方括號。可以把它想成句子中的語法錯誤。

```js
const arr = ["Beau", "Quincy" "Tom"]
```

- **ReferenceError**：有幾種不同型別的引用錯誤，會以不同方式被觸發。第一種引用錯誤是未定義的變數。另一個 ReferenceError 的例子是嘗試在使用 `let` 或 `const` 宣告的變數被定義之前存取該變數。

```js
console.log(num);
const num = 50;
```

- **TypeError**：當你嘗試對錯誤的型別執行操作時，會發生這些錯誤。

```js
const developerObj = {
  name: "Jessica",
  country: "USA",
  isEmployed: true
};

developerObj.map()
```

- **RangeError**：當你的程式碼嘗試使用超出 JavaScript 可控制代碼範圍的值時，會發生這些錯誤。

```js
const arr = [];
arr.length = -1; 
```

## `throw` 述語

- **定義**：JavaScript 中的 `throw` 述語用於丟出使用者定義的例外。程式設計中的例外，是指當發生意外事件並中斷程式的正常流程時。

```js
function validateNumber(input) {
  if (typeof input !== "number") {
    throw new TypeError("Expected a number, but received " + typeof input);
  }
  return input * 2;
}
```

## `try...catch...finally`

- **定義**：`try` 區塊用來包裹可能會丟出錯誤的程式碼。它作為一個安全空間來嘗試可能失敗的操作。`catch` 區塊會捕捉並控制代碼在 try 區塊中發生的錯誤。你可以在 catch 中使用錯誤物件來檢查錯誤原因。`finally` 區塊會在 try 和 catch 區塊之後執行，無論是否發生錯誤。它通常用於清理工作，例如關閉檔案或釋放資源。

```js
function processInput(input) {
  if (typeof input !== "string") {
    throw new TypeError("Input must be a string.");
  }

  return input.toUpperCase();
}

try {
  console.log("Starting to process input...");
  const result = processInput(9);
  console.log("Processed result:", result);
} catch (error) {
  console.error("Error occurred:", error.message);
} 
```

## 偵錯技術

- **`debugger` 述語**：此述語讓你在特定行暫停你的程式碼，以調查程式中發生的狀況。

```js
let firstNumber = 5;
let secondNumber = 10;

debugger; // Code execution pauses here
let sum = firstNumber + secondNumber;

console.log(sum);
```

- **中斷點**：中斷點讓你在指定的程式碼行暫停執行。暫停後，你可以檢查變數、評估表達式，並檢視呼叫堆疊。
- **監視器**：監視表達式讓你在程式碼執行時監控變數或表達式的值，即使它們不在目前的範圍內。
- **分析效能**：分析效能可協助你透過擷取螢幕截圖及記錄 CPU 使用率、函式呼叫和執行時間來識別效率瓶頸。
- **`console.dir()`**：此方法用於顯示指定 JavaScript 物件屬性的互動式列表。它輸出可展開以查看所有巢狀屬性的階層式清單。

```js
console.dir(document);
```

- **`console.table()`**：此方法會在主控台中以表格形式顯示表格式資料。它接受一個必填引數，該引數必須是陣列或物件，以及一個選用引數，用來指定要顯示哪些屬性（行）。

## 正規表達式和常用方法

- **定義**：正規表達式，或稱 Regex，用來創建「樣式」，你可以用它來比對字串、擷取文字等等。

```js
const regex = /freeCodeCamp/;
```

- **`test()` 方法**：此方法接受一個字串，該字串是用來測試是否符合正規表達式的字串。若字串符合正規表達式，該方法將傳回一個布林值。

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test); // false
```

- **`match()` 方法**：此方法接受一個正規表達式，雖然你也可以傳入一個字串，該字串將被構造成正規表達式。`match` 方法會傳回該字串的匹配陣列。

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match); // ["freeCodeCamp"]
```

- **`replace()` 方法**：此方法接受兩個引數：用於匹配的正規表達式（或字串），以及用來取代匹配結果的字串（或對每個匹配執行的函式）。

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced); // "freeCodeCamp is rly kewl"
```

- **`replaceAll` 方法**：此方法用於將指定樣式的所有出現取代為新的字串。如果你給它沒有全域修飾詞的正規表達式，則此方法會發出錯誤。

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

- **`matchAll` 方法**：此方法用於取得字串中給定正規表達式的所有符合項目，包括捕獲群組，並將它們傳回為一個迭代器。迭代器是一種物件，允許你遍歷（或「迭代」）一個群集的項目。

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

## 正規表達式修飾詞

- **定義**：修飾詞，通常稱為「旗標」，用來修改正規表達式的行為。
- **`i` 旗標**：此旗標使正規表達式忽略大小寫。

```js
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
```

- **`g` 旗標**：此旗標，或全域的修飾詞，允許你的正規表達式多次匹配一個樣式。

```js
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
```

- **錨點定義**：位於正規表達式開頭的 `^` 錨點表示「比對字串的開始」。位於正規表達式結尾的 `$` 錨點表示「比對字串的結尾」。

```js
const start = /^freeCodeCamp/i;
const end = /freeCodeCamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
```

- **`m` 旗標**：錨點尋找整個字串的開始和結束。但你可以使用 `m` 旗標，或多行修飾詞，讓正規表達式控制代碼處理多行。

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const str = `I love 
freecodecamp
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true

```

- **`d` 旗標**：此旗標會擴展你在比對物件中取得的資訊。

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

- **`u` 旗標**：這會擴展正規表達式的功能，使其能匹配特殊的 unicode 字元。`u` 旗標讓你能存取像 `Extended_Pictographic` 這類特殊類別，以匹配大部分的表情符號。還有一個 `v` 旗標，進一步擴展 unicode 匹配的功能。
- **`y` 旗標**：sticky 修飾詞的行為與全域的修飾詞非常相似，但有一些例外。最大的一點是，全域的正規表達式會從 lastIndex 開始並搜尋字串剩餘部分的所有匹配項，但 sticky 正規表達式如果在先前的 lastIndex 沒有立即匹配，則會傳回 null 並將 lastIndex 重設為 0。
- **`s` 旗標**：單行修飾詞允許由正規表達式中 `.` 表述的萬用字元匹配換行字元——有效地將字串視為單行文字。

## 字元類別

- **萬用符號 `.`**：字元類別是一種特殊語法，你可以用來匹配字元的集合或子集合。你應該學習的第一個字元類別是萬用字元類別。萬用字元由句點（點號）表現，並匹配除了換行符以外的任意單一字元。若要讓萬用字元類別匹配換行符，請記得你需要使用 `s` 旗標。

```js
const regex = /a./;
```

- **`\d`**：這將匹配字串中所有的數字（`0-9`）。

```js
const regex = /\d/;
```

- **`\w`**：這用於匹配字串中任何字元（`a-z0-9_`）。字元定義為任何字母（a 到 z）、數字（0 到 9）或底線字元。

```js
const regex = /\w/;
```

- **`\s`**：空白類別 `\s`，由反斜線後接 `s` 表述。此字元類別會匹配任何空白字元，包括換行、空格、製表符及特殊 unicode 空白字元。
- **否定特殊字元類別**：要否定這些字元類別之一，不是使用反斜線後的小寫字母，而是使用大寫等價字母。以下範例不會符合數字字元，而是符合任何非數字字元的單一字元。

```js
const regex = /\D/;
```

- **訂製字元類別**：你可以透過將你想匹配的字元放在一組方括號內來創建訂製字元類別。

```js
const regex = /[abcdf]/;
```

## 前瞻與後顧斷言

- **定義**：前瞻和後顧斷言允許你根據周圍樣式的存在或缺失來匹配特定樣式。
- **正向先行斷言**：當某個樣式後面接著另一個樣式時，此斷言會匹配該樣式。要構造正向先行斷言，你需要從你想匹配的樣式開始。接著，使用小括弧將你想用作條件的樣式包起來。在開啟小括弧後，使用 `?=` 來定義該樣式為正向先行斷言。

```js
const regex = /free(?=code)/i;
```

- **負向前瞻斷言**：這是在正規表達式中用來檢查字串前方不出現某個樣式的一種條件。

```js
const regex = /free(?!code)/i;
```

- **正向後顧斷言**：此斷言僅在其前方有另一特定樣式時才會匹配該樣式，且不會將前方的樣式包含在匹配中。

```js
const regex = /(?<=free)code/i;
```

- **負向後顧斷言**：此斷言確保某個樣式前面不會有另一個特定的樣式。只有在指定的樣式前面沒有緊接著給定序列時才會匹配，且不會將前面的序列包含在匹配中。

```js
const regex = /(?<!free)code/i;
```

## 正則表達式量詞

- **定義**：正規表達式中的量詞用來指定樣式（或樣式的部分）應該出現多少次。它們有助於控制字元或群組在比對中出現的次數。以下範例用來精確比對前一個字元出現 4 次。

```js
const regex = /^\d{4}$/;
```

- **`*`** ：匹配前一個元素出現 0 次或多次。
- **`+`**：匹配前一個元素出現 1 次或以上。
- **`?`**：匹配前一個元素 0 次或 1 次出現。
- **`{n}`**：精確匹配前一個元素出現 n 次。
- **`{n,}`**：匹配前一元素出現 n 次或以上。
- **`{n,m}`**：匹配前一個元素出現介於 n 和 m 次之間。

## 捕捉群組和址參器

- **捕獲群組**：捕獲群組允許你「捕獲」匹配字串的一部分，以便你可以依需要使用。捕獲群組是由包含要捕獲樣式的小括弧所定義，且前面不帶有像是先行斷言的字元。

```js
const regex = /free(code)camp/i;
```

- **Backreferences**：在正規表達式中，backreference 指的是一種重複使用同一個運算式中先前匹配到的樣式零件的方法。它允許你以數字取用被捕捉的群組（小括弧中的樣式零件）。例如，`$1` 指涉第一個被捕捉的群組。

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

## 使用 JavaScript 驗證表單

- **條件驗證 API**：某些 HTML 元素，例如 `textarea` 和 `input` 元素，會暴露條件驗證 API。這個 API 允許你斷言使用者為該元素提供的值通過你所撰寫的任何 HTML 層級驗證，例如最小長度或樣式匹配。
- **`checkValidity()` 方法**：如果元素符合所有 HTML 驗證（基於其屬性），此方法傳回 `true`，如果不符合則傳回 `false`。

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.setCustomValidity("You must use a .com email.")
  }
})
```

- **`reportValidity()` 方法**：此方法告訴瀏覽器 `input` 是無效的。

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.reportValidity();
  }
})
```

- **`validity` 屬性**：此屬性用於取得或設定表單控制元件（如 `<input>`、`<select>` 等）的有效性狀態，並提供有關使用者輸入是否符合該元素定義的條件（例如 `required` 欄位、樣式條件、最大長度等）的資訊。

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.validity);
})
```

- **`patternMismatch` 屬性**：如果值不符合指定的正則表達式樣式，這將是 `true`。

## `preventDefault()` 方法

- **定義**：每個在 DOM 中觸發的事件都有某種預設行為。勾選框的 click 事件預設會切換該勾選框的狀態。按下空白鍵在聚焦的按鈕上會作用該按鈕。這些 `Event` 物件上的 `preventDefault()` 方法會阻止該行為發生。

```js
button.addEventListener('click', (event) => {
  // Prevent the default button click behavior  
  event.preventDefault(); 
  alert('Button click prevented!');
});
```

## 提交表單

- **定義**：表單可以透過三種方式提交。第一種是使用者點擊表單中 `type` 屬性設定為 `submit` 的按鈕。第二種是使用者在表單中任何可編輯的 `input` 欄位按下 `Enter` 鍵。第三種是透過 JavaScript 呼叫 `form` 元素的 `requestSubmit()` 或 `submit()` 方法。
- **`action` 屬性**：`action` 屬性應包含 URL 或當前網域的相對路徑。此值決定表單嘗試將資料傳送到哪裡－如果你沒有設定 `action` 屬性，表單將會將資料傳送到當前頁面的 URL。

```html
<form action="https://freecodecamp.org">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`method` 屬性**：此屬性接受標準的 `HTTP` 方法，例如 `GET` 或 `POST`，並在向 action URL 發出請求時使用該方法。當未設定方法時，表單將預設為 `GET` 請求。表單中的資料將以 `name=value` 對組的形式進行 URL 編碼，並作為查詢參數附加到 action URL。

```html
<form action="/data" method="POST">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`enctype` 屬性**：`form` 元素接受一個 `enctype` 屬性，用來表述資料的編碼型別。此屬性只接受三個值：`application/x-www-form-urlencoded`（預設值，將資料以 URL 編碼的表單主體傳送）、`text/plain`（以純文字形式傳送資料，使用以換行符號分隔的 `name=value` 對組），或 `multipart/form-data`，專門用於處理含有檔案上傳的表單。

## `date()` 物件和常用方法

- **定義**：`date()` 物件用於在 JavaScript 中創建、操作和格式化日期與時間。在以下範例中，使用 `new` 關鍵字來創建 `Date` 物件的新實體，然後將 `Date` 物件指定給變數 `now`。如果你將 `now` 的值記錄到主控台，你會看到根據執行程式碼的電腦系統時鐘所顯示的當前日期和時間。

```js
const now = new Date();
```

- **`Date.now()` 方法**：此方法用於取得目前的日期和時間。`Date.now()` 傳回自 1970 年 1 月 1 日 00:00:00 UTC 起的毫秒數。這稱為 Unix 紀元時間。Unix 紀元時間是在電腦系統中常用來表述日期和時間的方式，因為它是一個整數，能夠輕鬆儲存和操作。UTC 代表協調世界時，是全球調整時鐘和時間的主要時間標準。
- **`getDate()` 方法**：此方法用於根據當前日期取得一個月份中的日期。`getDate()` 會傳回介於 1 和 31 之間的整數值，取決於當天的日期。如果日期無效，則會傳回 `NaN`（非數字）。

```js
const now = new Date();
const date = now.getDate();
console.log(date); // 15
```

- **`getMonth()` 方法**：此方法用於取得月份。月份是從零開始計算，因此一月是 0，二月是 1，依此類推。在此範例中，輸出為 2，對應三月。如果月份無效，將傳回 `NaN`。

```js
const now = new Date();
const month = now.getMonth();
console.log(month); // 2
```

- **`getFullYear()` 方法**：此方法用於取得完整年份。如果年份無效，將傳回 `NaN`。

```js
const now = new Date();
const year = now.getFullYear();
console.log(year); // 2024
```

## 不同的日期格式化方式

- **`toISOString()` 方法**：此方法用於將日期格式化為擴展的 `ISO`（ISO 8601）格式。ISO 8601 是一個用於表述日期和時間的國際標準。格式為 `YYYY-MM-DDTHH:mm:ss.sssZ`。

```js
const date = new Date();
console.log(date.toISOString());
```

- **`toLocaleDateString()` 方法**：此方法用於根據使用者的區域格式化日期。

```js
const date = new Date();
console.log(date.toLocaleDateString());  // 11/23/2024
```

`toLocaleDateString()` 方法接受兩個選用參數：locales 和 options。

`locales` 參數是一個表述要使用的語言環境的字串。例如，你可以傳入 `"en-US"` 代表英文（美國）或 `"fr-FR"` 代表法文（法國）。如果你沒有傳入 `locales` 參數，則會使用預設的語言環境。第二個選用參數是 `options` 參數。這個參數是一個物件，允許你指定日期字串的格式。

```js
const date = new Date();
const options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(date.toLocaleDateString("en-GB", options)); // Saturday, November 23, 2024
```

## `Audio` 建構式和常用方法

- **定義**：`Audio` 建構式，像其他建構式一樣，是一個使用 `new` 關鍵字呼叫的特殊函式（程式）。它會傳回一個 `HTMLAudioElement`，你可以用來為使用者播放音訊，或附加到 DOM 讓使用者自行控制。當你呼叫建構式時，可以選用傳入一個 URL 作為（唯一）引數。這個 URL 應該指向你想播放的音訊檔案的來源。或者，如果你需要動態變更來源，可以將 URL 指定給傳回的音訊元素的 `src` 屬性。
- **`play()` 方法**：此方法用於 `audio` 或 `video` 元素，以開始播放媒體。

```js
const audio = document.getElementById('audio');

// Starts playing the audio
audio.play();  
```

- **`pause()` 方法**：此方法用於 `audio` 或 `video` 元素，以暫停媒體的播放。

```js
function pauseAudio() {
  const audio = document.getElementById('myAudio');
  audio.pause();  // Pauses the audio playback
}
```

- **`addTextTrack()` 方法**：此方法允許你指定一個文字軌道以關聯到媒體元素－這對於為影片添加字幕特別有幫助。
- **`fastSeek()` 方法**：此方法允許你將播放位置移動到媒體中的特定時間。

## 不同的音訊和影片格式

- **MIME type**：MIME type，代表多用途網際網路郵件擴充，是一種以程式方式標準化顯示檔案型別的方法。MIME type 可以告訴應用程式，例如你的瀏覽器，如何控制特定的檔案。以音訊和影片為例，MIME type 顯示它是一種可以嵌入網頁的多媒體格式。
- **`source` 元素**：此元素用於指定檔案型別和來源－並且可以透過使用多個 `source` 元素來包含多種不同的型別。當你這麼做時，瀏覽器會根據使用者目前的環境判斷最佳格式。
- **MP3**：這是一種用來儲存音樂、音訊或聲音的數位檔案格式。它是聲音錄音的壓縮版本，使檔案大小變小，因此更容易儲存和分享。MP3 檔案的 MIME 型別為 `audio/mpeg`。
- **MP4**：MP4 是一種用來儲存影片和音訊的數位檔案格式。它作為一個容器，將影片（影像）和聲音（音樂或語音）存放在同一個檔案中。MP4 的 MIME 型別可以是 `audio/mp4` 或 `video/mp4`，取決於它是影片檔案還是僅有音訊。

## 編解碼器

- **定義**：codec 是「編碼器/解碼器」的縮寫，是一種可以在類比和數位格式之間轉換音訊和影片的演算法或軟體。codec 可以被指定為 MIME 型別的部分。定義 codec 的基本語法是在媒體型別後加上分號，然後是 `codecs=` 和 codec。

## HTMLMediaElement API

- **定義**：`HTMLMediaElement` API 用於控制你頁面上音訊和影片元素的行為。它擴充了基底的 `HTMLElement` 介面，因此你可以存取基底屬性以及這些有用的方法。這些方法的範例包括 `play()`、`fastSeek()` 和 `pause()`。

## 媒體擷取與資料流 API

- **定義**：Media Capture and Streams API，或稱 MediaStream API，用於從你的裝置擷取音訊和影片。為了使用該 API，你需要創建 `MediaStream` 物件。你可以使用建構式來做到這點，但它不會與使用者的硬體綁定。相反地，`global` navigator 物件的 `mediaDevices` 屬性有一個 `getUserMedia()` 方法供你使用。

```js
window.navigator.mediaDevices.getUserMedia({
  audio: true,
  video: {
    width: {
      min: 1280,
      ideal: 1920,
      max: 3840
    },
    height: {
      min: 720,
      ideal: 1080,
      max: 2160
    }
  }
});
```

## 螢幕擷取 API

- **定義**：螢幕擷取 API 用於記錄使用者的螢幕。此 API 是透過呼叫 `mediaDevices` 物件的 `getDisplayMedia()` 方法並使用傳回的媒體資料流來暴露。

## MediaStream 記錄 API

- **定義**：MediaStream Recording API 與 MediaStreams API 協同運作，讓你能夠錄製 MediaStream（甚至直接錄製 `HTMLMediaElement`）。

## 媒體原始碼擴充套件 API

- **主題**：Media Source Extensions API 讓你能夠直接將使用者的網路攝影機串流傳遞給具有 `srcObject` 屬性的影片元素。

## Web Audio API

- **定義**：Web Audio API 是驅動網路上所有可聽見內容的核心。此 API 包含重要的物件，如 `AudioBuffer`（表述專門包含音訊資料的 Buffer）或 `AudioContext`。

## JavaScript 中的集合

- `Set` 是用於管理資料群集的內建選項。
- 集合確保其中的每個值只出現一次，使其在從陣列中消除重複項或處理不同值的群集時非常有用。
- 你可以使用 `Set()` 建構式來創建 `Set`：

```js
const set = new Set([1, 2, 3, 4, 5]);
console.log(set); // Set { 1, 2, 3, 4, 5 }
```

- 集合可以使用這些方法操作：
  
  - `add()`: 為 `Set` 添加一個新元素。
  - `delete()`：從 `Set` 中移除一個元素。
  - `has()`：檢查元素是否存在於 `Set` 中。
  - `clear()`：從 `Set` 中移除所有元素。

## JavaScript 中的 Weaksets

- `WeakSet` 是一個允許你儲存弱參考物件的物件群集。

## 集合與 WeakSet

- 與 Set 不同，`WeakSet` 不支援像數字或字串這類的原始值。
- `WeakSet` 僅儲存物件，且對這些物件的引用是「弱引用」，表示如果該物件在你的程式碼中沒有被其他地方使用，則會自動移除以釋放記憶體。

## JavaScript 中的 Maps

- `Map` 是一個內建物件，用來儲存像物件一樣的鍵值配對。
- Map 與標準的 JavaScript 物件不同，因為它允許任何型別的鍵，包括物件和函式（程式）。
- 當頻繁新增和移除鍵值配對時，`Map` 比標準物件提供更好的效率。
- 你可以使用 `Map()` 建構式來創建 `Map`：

```js
const map = new Map([
  ['flower', 'rose'],
  ['fruit', 'apple'],
  ['vegetable', 'carrot']
]);
console.log(map); // Map(3) { 'flower' => 'rose', 'fruit' => 'apple', 'vegetable' => 'carrot' }
```

- 地圖可以使用這些方法操作：

  - `set()`：為 `Map` 添加新的鍵值配對。
  - `get()`：從 `Map` 中取得鍵的值。
  - `delete()`：從 `Map` 中移除一個鍵值配對。
  - `has()`: 檢查 `Map` 中是否存在某個鍵。
  - `clear()`：從 `Map` 中移除所有鍵值配對。

## JavaScript 中的 WeakMaps

- `WeakMap` 是一個與 `Map` 類似的鍵值配對群集，但對鍵採用弱引用。鍵必須是物件，而值可以是你想要的任何東西。

## Maps 與 WeakMaps

- WeakMap 類似於 WeakSet，因為它們只儲存物件，且對這些物件的引用是「弱」的。

## 持久儲存

- **定義**：持久性儲存是指一種儲存資料的方式，即使在關閉電源或重新啟動裝置後，資料仍然可用。

## 創建、讀取、更新、刪除（CRUD）

- **創建**：這是指創建新資料的處理程序。例如，在網頁應用程式中，這可能是當使用者為部落格添加新文章時。
- **讀取**：這是從資料庫擷取資料的操作行為。例如，當你瀏覽部落格文章或查看網站上的評測時，你正在執行讀取操作行為以擷取並顯示儲存在資料庫中的資料。
- **更新**：這涉及修改資料庫中現有的資料。範例包括編輯部落格文章或更新你的評測資訊。
- **刪除**：這是從資料庫中移除資料的操作行為。例如，當你刪除一篇部落格文章或帳號時，你正在執行刪除操作行為。

## HTTP 方法

- **定義**：HTTP 代表超文字傳輸協定，它是網路上資料通訊的基礎。有 HTTP 方法定義了可以對網路上的資源執行的動作。常見的方法有 GET、POST、PUT、PATCH、DELETE。
- **`GET` 方法**：這用於從伺服器擷取資料。
- **`POST` 方法**：這用於將資料提交到伺服器，該伺服器會創建一個新的資源。
- **`PUT` 方法**：這用於透過完全取代來更新資源。
- **`PATCH` 方法**：這用於部分更新資源。
- **`DELETE` 方法**：這用於從資料庫中移除記錄。

## `localStorage` 和 `sessionStorage` 屬性

- **Web Storage API**：此 API 提供瀏覽器在瀏覽器內部儲存鍵值對的機制，讓開發者能夠儲存可跨不同頁面重新載入和工作階段使用的資訊。Web Storage API 的兩個主要組件是 `localStorage` 和 `sessionStorage` 屬性。
- **`localStorage` 屬性**：`localStorage` 是 Web Storage API 的零件，允許資料即使在瀏覽器視窗關閉或頁面重新整理後仍然持續存在。這些資料會一直保留，直到應用程式或使用者明確地將其移除。
- **`localStorage.setItem()` 方法**：此方法用於在 `localStorage` 中儲存一組鍵值配對。

```js
localStorage.setItem('username', 'Jessica');
```

- **`localStorage.getItem()` 方法**：此方法用於從 `localStorage` 取得指定鍵的值。

```js
localStorage.setItem('username', 'codingRules');

let username = localStorage.getItem('username');
console.log(username); // codingRules
```

- **`localStorage.removeItem()` 方法**：此方法用於使用其鍵從 `localStorage` 中移除特定項目。

```js
localStorage.removeItem('username');
```

- **`localStorage.clear()` 方法**：此方法用於清除 `localStorage` 中所有儲存的資料。

```js
localStorage.clear();
```

- **`sessionStorage` 屬性**：儲存只在當前工作階段持續的資料，並且在瀏覽器分頁或視窗關閉時清除。
- **`sessionStorage.setItem()` 方法**：此方法用於在 `sessionStorage` 中儲存一個鍵值對組。

```js
sessionStorage.setItem('cart', '3 items');
```

- **`sessionStorage.getItem()` 方法**：此方法用於從 `sessionStorage` 中取得指定鍵的值。

```js
sessionStorage.setItem('cart', '3 items');

let cart = sessionStorage.getItem('cart');
console.log(cart); // '3 items'
```

- **`sessionStorage.removeItem()` 方法**：此方法用於使用其鍵從 `sessionStorage` 中移除特定項目。

```js
sessionStorage.removeItem('cart');
```

- **`sessionStorage.clear()` 方法**：此方法用於清除儲存在 `sessionStorage` 中的所有資料。

```js
sessionStorage.clear();
```

## 操作 Cookies

- **定義**：Cookies，也稱為網頁 Cookies 或瀏覽器 Cookies，是伺端傳送給使用者網頁瀏覽器的小塊資料。這些 Cookies 會儲存在使用者的裝置上，並在後續請求時回傳給伺端。Cookies 對於協助網頁應用程式維護狀態並記住使用者資訊至關重要，這在 HTTP 是無狀態協定的情況下尤其重要。
- **工作階段 Cookie**：這些 Cookie 僅在使用者於網站上的工作階段期間有效。一旦使用者關閉瀏覽器或分頁，工作階段 Cookie 即會被刪除。這些 Cookie 通常用於在使用者訪問期間保持登入狀態等任務。
- **安全 Cookie**：這些 Cookie 僅會透過 HTTPS 傳送，確保它們在傳輸過程中不會被攻擊者攔截。
- **HttpOnly Cookies**：這些 cookies 無法被瀏覽器中執行的 JavaScript 存取或修改，使它們在防範跨站腳本攻擊（XSS）方面更為安全。
- **Set-Cookie 標頭**：當你造訪網站時，伺服端可以在 HTTP 回應中傳送 Set-Cookie 標頭。此標頭會告訴你的瀏覽器存檔一個帶有特定資訊的 cookie。例如，它可能會儲存一個唯一 ID，幫助網站在你下次造訪時辨識你。  
你可以使用 `document.cookie` 在 JavaScript 中手動設定 cookie：

```js
document.cookie = "organization=freeCodeCamp; expires=Fri, 31 Dec 2021 23:59:59 GMT; path=/";
```

要刪除 cookie，你可以將其過期時間設定為過去的時間。

```js
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
```

## 快取 API

- **定義**：快取是將檔案的副本儲存在暫存位置的過程，以便能更快速地存取。`Cache API` 用於儲存網路請求和回應，使網頁應用程式能更高效地運作，甚至能離線運作。它是更廣泛的 `Service Worker API` 的一部分，對於建立能在不穩定或緩慢網路條件下運作的漸進式網頁應用程式（PWA）至關重要。  
`Cache API` 是一種儲存機制，用於儲存 `Request` 和 `Response` 物件。當向伺服器發出請求時，應用程式可以將回應儲存起來，之後從快取中取回，而不必重新發出網路請求。這樣可以減少載入時間、節省頻寬，並提升整體使用者體驗。
- **快取儲存**：這用於儲存 HTTP 請求及其對應回應的鍵值對組。這可啟用高效檢索先前請求的資源，減少後續造訪時從網路擷取的需求，並提升效率。
- **Cache-Control**：開發者可以定義快取資源應該保留多久，以及是否應該重新驗證或直接從快取提供。
- **離線支援**：透過使用 Cache API，你可以創建離線優先的網頁應用程式。舉例來說，PWA 可以在使用者與網路斷線時提供快取的資源。

## 負面樣式和客戶端儲存

- **過度追蹤**：指在未取得明確、知情同意或合法需求的情況下，於客戶端儲存空間（例如 cookies、區域儲存或工作階段儲存）中收集並儲存過多使用者資料的行為。這通常涉及跨多個網站或工作階段追蹤使用者行為、偏好和互動，可能侵犯使用者隱私。
- **瀏覽器指紋辨識**：一種用於追蹤和識別個別使用者的技術，根據其裝置和瀏覽器的獨特特徵，而非依賴 cookie 或其他傳統追蹤方法。與儲存在使用者裝置上的 cookie 不同，指紋辨識涉及收集一系列資訊，用以創建使用者瀏覽器工作階段的獨特「指紋」。
- **在 LocalStorage 中設定密碼**：這看起來可能是一個更明顯的負面樣式，但在區域的儲存中設定任何敏感資料如密碼會帶來安全風險。Local Storage 沒有加密且很容易被存取。因此你絕不應該將任何類型的敏感資料儲存在那裡。

## IndexedDB

- **定義**：IndexedDB 用於在瀏覽器中儲存結構化資料。這是內建於現代網頁瀏覽器中，允許網頁應用程式高效地儲存和擷取 JavaScript 物件。

## 快取記憶體／Service Workers

- **定義**：Service Worker 是一個在背景中執行且與你的網頁分離的腳本。它可以攔截網路請求、存取快取，並使網頁應用程式能離線運作。這是漸進式網頁應用程式的重要組件。

## 使用類別的基礎知識

- **定義**：JavaScript 中的類別用於定義用來創建物件和封裝資料的藍圖。類別包含一個建構式，這是一個特殊的方法，當從類別創建新物件時會自動呼叫。它用於初始化物件的屬性。這裡使用 `this` 關鍵字來取用類別的當前實體。在建構式下面，你可以有稱為方法的方法。方法是在類別內定義的函式（程式），用來對類別的資料或狀態執行動作或操作行為。它們用於定義類別實體可以執行的行為。

```js
class Dog {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
}
```

要創建該類別的新實體，你將使用 `new` 關鍵字，後面接類別名稱：

```js
const dog = new Dog("Gino");
```

你也可以將類別創建為類別表達式。這是指類別是匿名的並且被指定給一個變數。 

```js
const Dog = class {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
};
```

## 類別繼承

- **定義**：在程式設計中，繼承允許你定義從父類別繼承屬性和方法的類別。這促進程式碼重複使用並建立類別之間的階層關係。父類別是一個作為其他類別藍圖的類別。它定義其他類別會繼承的屬性和方法。子類別是繼承另一個類別屬性和方法的類別。子類別也可以透過添加新的屬性和方法來擴充其父類別的功能。在 JavaScript 中，我們使用 `extends` 關鍵字來實作繼承。此關鍵字顯示一個類別是另一個類別的子類別。

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

`super` 關鍵字用於存取父類別的方法、建構式和欄位。


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

## 使用靜態方法和靜態屬性

- **靜態方法**：這些方法通常用於不需要存取特定物件狀態的工具函式（程式）。它們定義在類別中以封裝相關功能。靜態方法也有助於實作「工廠」方法。工廠方法是你除了建構式之外，根據特定條件定義用來創建物件的方法。

```js
class Movie {
  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }
}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);

Movie.compareMovies(movieA, movieB);
```

- **靜態屬性**：這些屬性用於定義與類別本身相關的值或屬性，而非與類別的實體相關。靜態屬性在所有類別實體之間共享，且可以在不建立類別實體的情況下存取。

```js
class Car {
  // Static property
  static numberOfWheels = 4;

  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  // Instance method
  getCarInfo() {
    return `${this.make} ${this.model}`;
  }

  // Static method
  static getNumberOfWheels() {
    return Car.numberOfWheels;
  }
}

// Accessing static property directly from the class
console.log(Car.numberOfWheels); 
```

## 遞迴

- 遞迴是程式設計概念，允許你重複呼叫一個函式，直到達到基底案例為止。

這是一個計算數字階乘的遞迴函式（程式）範例：

```js
function findFactorial(n) {
  if (n === 0) {
    return 1;
  }
  return n * findFactorial(n - 1);
}
```

在上述範例中，`findFactorial` 函式（程式）會遞迴呼叫直到 `n` 達到 `0`。當 `n` 是 `0` 時，達到基底情況，函式（程式）傳回 `1`。接著函式（程式）傳回 `n` 與遞迴呼叫 `findFactorial(n - 1)` 結果的乘積。

- 遞迴允許你處理深度未知的事物，例如深度巢狀的物件/陣列，或檔案樹。
- 呼叫堆疊用於追蹤遞迴函式中的函式呼叫。每次呼叫函式時，該函式會被添加到呼叫堆疊中。當達到基底案例時，函式呼叫會從堆疊中移除。
- 你應該仔細定義基底案例，因為無限次呼叫它可能會導致你的程式碼當機。這是因為遞迴會持續堆疊越來越多的函式呼叫，直到系統耗盡記憶體。
- 遞迴用於解決數學問題，例如階乘和 Fibonacci、遍歷樹和圖、產生排列組合等等。

## 純函式與非純函式

- 純函式（程式）是指對相同輸入總是產生相同輸出且沒有任何副作用的函式（程式）。它的輸出僅依賴於輸入，且不會修改任何外部狀態。
- 不純函式具有副作用，這些副作用是函式外部可觀察到的程式狀態變化。

## 函式式程式設計

- 函式式程式設計是一種軟體開發方法，強調使用函式來解決問題，著重於需要完成的事情，而非如何完成。
- 函式式程式設計鼓勵使用有助於避免副作用的技術，例如使用不可變的資料結構和高階函式。
- 當正確使用時，函式程式設計原則能帶來更乾淨且更易維護的程式碼

## 柯里化

- Currying 是一種函式程式設計技術，將具有多個引數的函式轉換成一連串每次只接受一個引數的函式。

以下是一般函式（程式）與柯里化函式（程式）的範例：

```js
// Regular function

function average(a, b, c) {
  return (a + b + c) / 3;
}

// Curried function

function curriedAverage(a) {
  return function(b) {
    return function(c) {
      return (a + b + c) / 3;
    };
  };
}

// Usage of curried function

const avg = curriedAverage(2)(3)(4);
```

- 當處理接受多個引數的函式（程式）時，Currying 特別強大。
- 柯里化讓你的程式碼更靈活且更容易重複使用。
- 你可以使用箭頭函式（arrow functions）更簡潔地創建柯里化函式（curried functions）：

```js
const curriedAverage = a => b => c => (a + b + c) / 3;
```

- 雖然 currying 可以讓程式碼更靈活且可重複使用，但如果過度使用，也會讓程式碼更難閱讀。

## 非同步 JavaScript

- **同步 JavaScript** 是依序執行，並且會等待前一個操作完成後才繼續下一個操作。
- **非同步 JavaScript** 允許多個操作在背景中執行，而不會阻塞主執行緒。
- **執行緒** 是一連串可以獨立於主程式流程執行的指令。
- **回呼函式** 是作為引數傳遞給其他函式，並在操作完成後或因事件而執行的函式。

## JavaScript 引擎和 JavaScript 執行期

- **JavaScript 引擎** 是一個在網頁瀏覽器中執行 JavaScript 程式碼的程式。它像一個轉換器，將你的程式碼轉換成電腦能理解並依此運作的指令。
- V8 是 Google 開發的 JavaScript 引擎範例。
- **JavaScript runtime** 是執行 JavaScript 程式碼的環境。它包含處理並執行程式碼的 JavaScript 引擎，以及像是網頁瀏覽器或 Node.js 等額外的特性。

## Fetch API

- Fetch API 允許網頁應用程式進行網路請求，通常用於從伺端擷取或傳送資料。它提供一個 `fetch()` 方法，讓你可以用來進行這些請求。
- 你可以使用 Fetch API 取得文字、影像、音訊、JSON 和其他型別的資料。

## Fetch API 的 HTTP 方法

Fetch API 支援各種 HTTP 方法來與伺服端互動。最常見的方法有：

- **GET**：用於從伺端擷取資料。Fetch API 預設使用 `GET` 方法來擷取資料。

```js
fetch('https://api.example.com/data')
```

要使用擷取的資料，必須使用 `.json()` 方法將其轉換為 JSON 格式：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

在這段程式碼中，來自 Fetch API 的回應是一個 promise，而 `.then` 處理常式將回應轉換為 JSON 格式。

- **POST**：用於將資料傳送到伺服器。`POST` 方法用於在伺服器上創建新資源。

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

在這個範例中，我們正在發送一個 `POST` 請求以創建一個新的使用者。我們已將行為指定為 `POST`，設定了適當的標頭，並包含了我們想要傳送的資料的主體。主體需要是一個字串，因此我們使用 `JSON.stringify()` 將我們的物件轉換成 JSON 字串。

- **PUT**：用於更新伺服端上的資料。`PUT` 方法用於更新伺服端上現有的資源。

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

在此範例中，我們正在更新 URL 結尾處指定的 ID `45`。我們在程式碼中使用了 `PUT` 方法，並且也將資料指定為主體，該主體將用於更新已識別的資料。 

- **DELETE**：用於刪除伺端上的資料。`DELETE` 方法用於刪除伺端上的資源。

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

在這個範例中，我們正在發送 `DELETE` 請求以移除 ID 為 `45` 的使用者。

## Promise 和 promise 串鏈

- **Promises** 是表述非同步操作最終完成或失敗及其結果值的物件。只有在 `async` 操作完成後，才會知道 promise 的值。
- 這裡有一個創建簡單 promise 的範例：

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- `.then()` 方法用於 Promise 中指定當 Promise 完成時應該發生的事情，而 `.catch()` 用於處理發生的任何錯誤。
- 以下是使用 `.then()` 和 `.catch()` 搭配 Promise 的範例：

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

在上述範例中，使用 `.then()` 方法來記錄從 Promise 接收到的資料，而使用 `.catch()` 方法來記錄發生的任何錯誤。

- **Promise 串鏈**：Promise 的強大特性之一是我們可以將多個非同步操作串鏈在一起。每個 `.then()` 都可以傳回一個新的 Promise，讓你能夠依序執行一連串的非同步操作。
- 這裡是一個 Promise 串鏈的範例：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

在上述範例中，我們首先從一個 URL 取得資料，然後根據第一個回應從另一個 URL 取得資料，最後記錄收到的第二筆資料。 

`catch` 方法會控制代碼中在處理程序期間發生的任何錯誤。這表示你不需要為每個單獨步驟添加錯誤控制代碼，這可以大大簡化你的程式碼。

## 使用 `async/await` 來控制代碼 promises

Async/await 使撰寫和閱讀非同步程式碼更容易，它是建立在 Promises 之上的。

- **async**：`async` 關鍵字用於定義非同步函式（程式）。`async` 函式會傳回一個 Promise，該 Promise 會以 `async` 函式傳回的值來決議。
- **await**：`await` 關鍵字用於 `async` 函式（程式）內，以暫停函式（程式）的執行直到 Promise 被決議。它只能用在 `async` 函式（程式）內。
- 這裡是一個使用 `async/await` 的範例：

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

在上述範例中，`delayedGreeting` 函式（程式）是一個 `async` 函式（程式），會暫停 2 秒後才列印問候訊息。`await` 關鍵字用來暫停函式（程式）執行，直到 `Promise` 被決議。

- `async/await` 最大的優點之一是透過 `try/catch` 區塊進行錯誤處理。以下是一個範例：

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

在上述範例中，`try` 區塊包含可能會丟出錯誤的程式碼，而 `catch` 區塊則在錯誤發生時控制代碼。這使得錯誤處理更加簡單且易讀。

## `async` 屬性

- `async` 屬性告訴瀏覽器在繼續解析 HTML 文件的同時非同步下載腳本檔案。
- 腳本下載完成後，HTML 解析會暫停，腳本會執行，然後 HTML 解析會繼續。
- 你應該為執行順序不重要的獨立腳本使用 `async`。

## `defer` 屬性

- `defer` 屬性也會非同步下載腳本，但會延緩腳本的執行直到 HTML 文件完全解析之後。
- `defer` 腳本維護它們在 HTML 文件中出現的執行順序。

- 重要的是要注意，`async` 和 `defer` 屬性對行內腳本會被忽略，且僅對外部腳本檔案有效。

- 當同時存在 `async` 和 `defer` 屬性時，`async` 屬性具有優先權。

## 地理位置 API

- Geolocation API 提供網站請求使用者位置的方法。

- 以下範例示範了 API 的 `getCurrentPosition()` 方法，用於取得使用者的當前位置。

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

在這段程式碼中，我們正在呼叫 `getCurrentPosition` 並傳入一個函式（程式），當成功取得位置時該函式（程式）將會被呼叫。 

`position` 物件包含各種資訊，但這裡我們只選擇了 `latitude` 和 `longitude`。

如果取得 `position` 時發生問題，錯誤將會記錄到主控台。尊重使用者的隱私非常重要，且只在必要時請求他們的位置。


# --assignment--

檢視 JavaScript 主題和概念。
