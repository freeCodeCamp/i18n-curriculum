---
id: 6724e24864b0771a4c4c9dc9
title: 测试审查
challengeType: 31
dashedName: review-testing
---

# --description--

## 手动和自动化测试

- **手动测试**：在手动测试中，测试人员将手动检查应用的每个部分并测试不同的特色，以确保其正常工作。如果在测试过程中发现任何错误，测试人员将向软件团队报告这些错误，以便修复。
- **自动化测试**：在自动化测试中，你可以通过编写一个单独的程序来自动化你的测试，以查看你的应用是否按预期运行。

## 单元测试

- **单元测试**：在单元测试中，你测试每个函数以确保一切按预期工作。单元测试也可以作为你的应用的文档形式，因为它们旨在表现你的代码的预期行为。
- **单一职责原则**：单一职责原则建议保持每个函数小且只负责一件事。
- **常见的 JavaScript 测试框架**：一些常见的测试框架包括 Jest、Mocha 和 Vitest。Jest 是一个流行的单元测试框架。

这是使用 Jest 的单元测试示例。

首先，你可以创建一个负责返回新格式化字串的函数：

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

在单独的 `getFormattedWord.test.js` 文件中，你可以编写一些测试来验证该函数是否按预期工作。`getFormattedWord.test.js` 文件将如下所示：

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **`expect` 函数**：`expect` 函数用于测试一个值。
- **Matcher**：Matcher 是一个函数，用于查看值是否符合预期。在上述示例中，matcher 是 `toBe()`。Jest 有多种 matcher。

要使用 Jest，首先需要通过 `npm i jest` 安装 `jest` 包。你还需要为你的 `package.json` 文件添加一个脚本，如下所示：

```js
"scripts": {
  "test": "jest"
},
```

然后，你可以运行命令 `npm run test` 来运行你的测试。

## 软件开发生命周期

- **软件开发生命周期的不同阶段**：
  - **计划阶段**：开发团队从利益相关者处收集拟议工作的需求。
  - **设计阶段**：软件团队分解需求并决定最佳的方案方法。
  - **实现阶段**：软件团队将需求分解为可管理的任务并实现它们。
  - **测试阶段**：这包括对新建工作的手动和自动测试。有时，团队会在整个开发阶段测试应用，以发现并修复出现的任何问题。
  - **部署阶段**：团队将新建的更改部署到构建或测试环境。
  - **维护阶段**：这涉及修复生产应用中客户出现的任何问题。

- **软件开发生命周期的不同模型**：
  - **瀑布模型**：瀑布模型是指生命周期的每个阶段都需要完成后，才能开始下一个阶段。
  - **敏捷模型**：敏捷模型专注于通过将工作分解为冲刺来进行迭代的开发。

## BDD 和 TDD

- **TDD**：测试驱动开发是一种强调先编写测试的开发方法。在创建特色之前编写测试，为开发者在开发进程中提供实时反馈。
- **BDD**：行为驱动开发是一种将一系列测试与业务目标对齐的方法。BDD 中的测试场景应使用技术人员和非技术人员都能理解的语言编写。此类语法的一个示例是 Gherkin。
- **BDD 测试框架**：BDD 测试框架的示例包括 Cucumber、JBehave 和 SpecFlow。

## 单元测试中的断言

- **断言**：断言用于测试代码是否按预期运行。
- **断言库**：Chai 是一个常用的断言库。其他常见的 JavaScript 断言库有 `should.js` 和 `expect.js`。

下面是一个使用 Chai 的断言示例，用于查看 `addThreeAndFour` 函数的返回值是否相等于数字 7：

```js
assert.equal(addThreeAndFour(), 7);
```

- **最佳实践**：无论你使用哪个断言库，都应编写清晰的断言和失败消息，以帮助你了解哪些测试失败以及原因。

## 模拟、伪造和存根

- **模拟**：模拟是用模拟真实组件行为的虚假数据替换真实数据的过程。例如，你可以在测试中模拟 API `Response`，而不是持续调用 API 来获取数据。
- **存根**：存根是返回预定义响应或虚拟数据的对象，用于模拟应用中的预期行为。例如，你可以在测试中为数据库连接存根行为，而无需依赖实际的数据库连接。
- **伪造**：伪造是简化版本的真实组件，没有复杂度或副作用。例如，你可以通过将数据存储在内存中而不是与真实数据库交互来伪造数据库。这将允许你在内存中模拟数据库操作，这比处理真实数据库要快得多。

## 功能测试

- **功能测试**：功能测试检查应用的特色和函数是否按预期工作。功能测试的目标是针对多个场景对系统整体进行测试。
- **非功能测试**：非功能测试关注性能和可靠性等方面。
- **冒烟测试**：冒烟测试是在开始更广泛的测试之前，对系统进行的基本或关键问题的初步查看。

## 端到端测试

- **端到端测试**：端到端测试，或称 E2E，从用户的角度测试真实场景。端到端测试有助于确保你的应用表现正确且对用户可预测。然而，设置、设计和维护耗时。
- **端到端测试框架**：Playwright 是微软开发的流行端到端测试框架。其他端到端测试工具的例子包括 Cypress、Selenium 和 Puppeteer。

这是一个使用 Playwright 的 freeCodeCamp 代码库中的端到端测试示例。`beforeEach` 钩子将在每个测试之前运行。测试查看捐赠者在菜单栏中是否有支持者链接，以及他们的头像周围是否有特殊样式的边框：

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## 可用性测试

- **可用性测试**：可用性测试是指让真实用户与应用交互，以发现应用中是否存在任何设计、用户体验或功能性问题。可用性测试侧重于用户对应用的直观感受。
- **四种常见的可用性测试类型**：
  - **探索性**：探索性可用性测试涉及用户与应用的不同特色交互，以更好地理解它们的工作原理。
  - **比较**：比较测试是指将你的应用的用户体验与市场上类似应用进行比较。
  - **评估**：评估测试是研究应用的使用直观性的过程。
  - **验证**：验证测试是识别任何会阻止用户有效使用该应用的重大问题的过程。
- **可用性测试工具**：可用性测试的工具示例包括 Loop11、Maze、Userbrain、UserTesting 和 UXTweak。

## 兼容性测试

- **兼容性测试**：兼容性测试的目标是确保你的应用在不同的计算环境中正常运行。
- **不同类型的兼容性测试**：
  - **向后兼容性**：向后兼容性是指软件与早期版本兼容。
  - **向前兼容性**：向前兼容性是指软件和系统能够与未来版本一起工作。
  - **硬件兼容性**：硬件兼容性是软件在不同硬件配置中正常工作的能力。
  - **操作系统兼容性**：操作系统兼容性是指软件在不同操作系统上运行的能力，例如 macOS、Windows 以及像 Ubuntu 和 Fedora 这样的 Linux 发行（版本）。
  - **网络兼容性**：网络兼容性意味着软件能够在不同的网络条件下工作，例如不同的网络速度、协议、安全性设置等。
  - **浏览器兼容性**：浏览器兼容性意味着网页应用可以在不同浏览器（例如 Google Chrome、Safari、Firefox 等）中一致地工作。
  - **移动兼容性**：确保你的软件应用能在各种 Android 和 iOS 设备上运行，包括手机和平板电脑，这一点非常重要。

## 性能测试

- **性能测试**：在性能测试中，你测试一个应用的速度、响应性、可扩展性和在不同工作负载下的稳定性。目标是解析任何类型的性能瓶颈。
- **不同类型的性能测试**：
  - **装载测试**：装载测试确定系统在正常和峰值装载时间的行为。
  - **压力测试**：压力测试是指在极端负载下测试你的 `application`，观察你的系统对更高负载的响应能力。
  - **浸泡测试（耐力测试）**：浸泡测试或耐力测试是一种装载测试，你用较高的装载对系统进行长时间测试。
  - **突发测试**：突发测试是指你剧烈增加和减少负载，并分析系统对这些变化的反应。
  - **断点测试（容量测试）**：断点测试或容量测试是指你随着时间缓慢增加 `load`，直到系统开始失败或性能下降。

## 安全性测试

- **安全性测试**：安全性测试有助于识别漏洞和弱点。
- **安全性原则**：
  - **保密性**：这可以防止敏感信息泄露给非预期的接收者。
  - **完整性**：这涉及防止恶意用户修改用户信息。
  - **认证**：这涉及验证用户的同一性，以确保他们被允许使用该系统。
  - **授权**：这是确定经过身份验证的用户被允许执行哪些操作或被允许访问系统哪些部分的进程。
  - **可用性**：这确保信息和服务在授权用户需要时可用。
  - **不可否认性**：这确保发送方和接收方都拥有交付证明和发送方身份的验证。它防止发送方否认已发送该信息。
- **常见安全性威胁**：
  - **跨站脚本攻击（XSS）**：当攻击者将恶意脚本注入网页并在受害者浏览器的上下文中执行时，就会发生 XSS 攻击。
  - **SQL 注入**：SQL 注入允许恶意用户将恶意代码注入到数据库中。
  - **拒绝服务（DoS）攻击**：DoS 攻击是指恶意用户向网站发送大量请求或流量，导致服务器变慢甚至崩溃，使网站对用户不可用。
- **安全性测试工具的类别**：
  - **静态应用安全性测试**：这些工具评估应用的源代码以识别安全漏洞。
  - **动态应用安全性测试**：这些工具与应用的前端接口，以发现潜在的安全性弱点。DAST 工具无法访问源代码。
- **渗透测试 (pentest)**：渗透测试是一种安全性测试，涉及对应用进行模拟网络攻击，以识别系统中的任何漏洞。

## A/B 测试

- **A/B 测试**：A/B 测试涉及比较页面或应用的两个版本，并研究哪个版本执行得更好。它也被称为桶测试或分割测试。A/B 测试使你能够做出更多数据驱动的决策，并持续改进用户体验。
- **A/B 测试工具**：用于 A/B 测试的工具示例包括 GrowthBook 和 LaunchDarkly。

## Alpha 和 Beta 测试

一旦初步开发和软件测试完成，重要的是让测试人员和真实用户对应用进行测试。这就是 alpha 测试和 beta 测试的作用。

- **Alpha 测试**：Alpha 测试由一组精选的测试人员进行，他们通过应用程序以确保在发布到市场之前没有错误。Alpha 测试是验收测试的一部分，采用白盒和黑盒测试技术。
- **Beta 测试**：Beta 测试是将应用提供给真实用户的阶段。用户可以与应用交互并提供反馈。Beta 测试也是一种用户验收测试的形式。
- **验收测试**：验收测试确保软件应用在发布前满足业务需求和用户需求。
- **黑盒测试**：黑盒测试只关注应用的预期行为。
- **白盒测试**：白盒测试涉及测试者了解内部组件并对其执行测试。

## 回归测试

- **回归**：回归指的是新更改无意中破坏现有功能性的情况。
- **回归测试**：回归测试有助于捕捉回归问题。在回归测试中，你会对应用的部分功能重新运行功能测试，以确保一切仍按预期工作。
- **回归测试工具**：你可以使用的回归测试工具包括 Puppeteer、Playwright、Selenium 和 Cypress。
- **回归测试的技术**：
  - **单元回归测试**：这是指你有一个需要在每次对应用程序实现重大更改或修复时进行测试的项列表。
  - **部分回归测试**：这涉及有针对性的方法，以确保新建更改未破坏应用的特定方面。
  - **完整回归测试**：这会针对代码库中的所有功能运行测试。这是最耗时且最详细的选项。
- **重新测试**：重新测试用于查看已知问题并确保它们已被解析。相比之下，回归测试查找可能因代码库最近更改而产生的未知问题。

# --assignment--

查看测试主题和概念。
