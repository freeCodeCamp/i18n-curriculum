---
id: 67336956340e8a34fbd5d9f3
title: 什么是 `requestAnimationFrame()` API，如何用它来设置动画循环？
challengeType: 19
dashedName: what-is-the-requestanimationframe-api-and-how-can-it-be-used-to-set-up-an-animation-loop
---

# --interactive--

在网页上创建流畅动画可能很棘手，尤其是当你不确定如何正确处理时间时。好消息是，`requestAnimationFrame()` API 使这变得更简单。 

`requestAnimationFrame()` 是一种方法，允许你在下一次屏幕重绘之前调度动画的下一步，从而实现流畅且视觉上吸引人的体验。

下一次屏幕重绘是指浏览器刷新网页视觉显示的时刻。这通常每秒发生多次，在大多数显示器上大约为 60 次（或每秒 60 帧）。

要使用 `requestAnimationFrame()` 方法，你只需调用它并传入一个回调函数：

```js
requestAnimationFrame(callback);
```

调用 `requestAnimationFrame()` 必须首先发生在处理动画的函数内，例如 `animate()`，以及一个用于更新动画的函数，传统上称为 `update()`：

```js
function animate() {
 // Update the animation...
 // for example, move an element, change a style, and more.
 update();
 // Request the next frame
 requestAnimationFrame(animate);
}
```

`update()` 函数是魔法发生的地方。在其中，你可以更改任何你想要动画化的内容。例如，更新样式或更改元素的位置：

```js
function update() {
 element.style.transform = `translateX(${position}px)`;
 position += 2;
}
```

最终启动动画的是调用 `requestAnimationFrame()` 并传入 `animate` 函数，这次是在 `animate` 函数外部：

```js
requestAnimationFrame(animate);
```

循环将继续，直到你停止它。

现在，让我们看另一个例子。这个例子的超文本标记语言是一个带有文本 `freeCodeCamp is Awesome` 的 `div` 元素。CSS 使 `div` 成为一个矩形，并隐藏任何超出视口左右的内容。JavaScript 代码在每次调用带有 `animate` 函数作为回调的 `requestAnimationFrame(animate)` 时，将矩形向右移动 `2px`：

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css" />
<div id="rect" class="rect">freeCodeCamp is Awesome</div>
<script src="index.js"></script>
```

```css
body {
  overflow-x: hidden;
}

.rect {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 400px;
  height: 250px;
  border-radius: 5px;
  background-color: #1b1b32;
  color: #f5f6f7;
  font-size: 2rem;
  position: absolute;
}
```

```js
const rect = document.getElementById("rect");

let position = 0;

function update() {
  // Move the rectangle 2px to the right
  rect.style.left = position + "px";
  position += 2;

  if (position > window.innerWidth) {
    // Move the rectangle just outside the left side of the screen
    position = -rect.offsetWidth;
  }
}

function animate() {
  update();

  //request the next frame
  requestAnimationFrame(animate);
}

// Start the animation
requestAnimationFrame(animate);
```

:::

浏览器中的结果将是一个在屏幕上漂浮的动画标题卡。

# --questions--

## --text--

`requestAnimationFrame()` 方法的作用是什么？

## --answers--

它阻止动画运行。

### --feedback--

考虑这个方法如何帮助创建流畅的动画。

---

它立即运行动画，无延迟。

### --feedback--

考虑这个方法如何帮助创建流畅的动画。

---

它加快动画速度。

### --feedback--

考虑这个方法如何帮助创建流畅的动画。

---

它在下一次屏幕重绘之前调度动画的下一步，以实现更流畅的视觉效果。

## --video-solution--

4

## --text--

使用 `requestAnimationFrame()` 时，是什么启动了动画？

## --answers--

在 `requestAnimationFrame()` 方法内调用 `animate` 函数。

### --feedback--

考虑 `requestAnimationFrame()` 方法如何触发动画。

---

使用 `setTimeout()` 设置超时。

### --feedback--

考虑 `requestAnimationFrame()` 方法如何触发动画。

---

使用 `setInterval()` 重复动画。

### --feedback--

考虑 `requestAnimationFrame()` 方法如何触发动画。

---

在 animate 函数外调用 `requestAnimationFrame()` 并传入 animate 函数。

## --video-solution--

4

## --text--

`"next screen repaint"`是什么意思？

## --answers--

浏览器更新 HTML 结构的时刻。

### --feedback--

考虑浏览器多久更新一次你在屏幕上看到的内容。

---

浏览器刷新网页视觉显示的时刻，通常每秒约 60 次。

---

浏览器重新装载整个页面的时刻。

### --feedback--

考虑浏览器多久更新一次你在屏幕上看到的内容。

---

浏览器更新 CSS 样式的时刻。

### --feedback--

考虑浏览器多久更新一次你在屏幕上看到的内容。

## --video-solution--

2
