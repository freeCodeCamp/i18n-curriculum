---
id: 687ea8eba2a8b119f2ad9f8c
title: 连接表格的不同方式有哪些？
challengeType: 19
dashedName: what-are-the-different-ways-to-join-tables
---

# --description--

尽管关系数据库将数据组织到独立的表格中，SQL 的 `JOIN` 操作允许你将表格中的相关信息组合起来进行查询数据。

`JOIN` 操作有几种变体，包括：

- `INNER JOIN`
- `FULL OUTER JOIN`
- `LEFT OUTER JOIN`
- `RIGHT OUTER JOIN`
- `SELF JOIN`
- `CROSS JOIN`

让我们从 `INNER JOIN` 开始。

`INNER JOIN` 会过滤结果，仅包含你指定的连接列在两个表格中值相等的行。基本上，它为你提供了数据的交集。

为了说明这一点，假设我们有两个表格。

第一个是这个包含多个产品的 `products` 表格。它包括它们的 ID、名称、类别、价格和产地。

```sql
| product_id | product_name     | category    | price (USD) | origin        |
| ---------- | ---------------- | ----------- | ----------- | ------------- |
| 1          | Ice Cream        | Food        | 2.50        | India         |
| 2          | Pizza Margherita | Food        | 12.00       | Italy         |
| 3          | Sushi            | Food        | 18.75       | Japan         |
| 4          | T-Shirt          | Clothing    | 25.00       | USA           |
| 5          | Jeans            | Clothing    | 60.00       | Argentina     |
| 6          | Coffee           | Beverages   | 35.00       | France        |
| 7          | Juice            | Beverages   | 5.00        | Colombia      |
```

其次，我们有一个 `sales` 表格，包含销售 ID、产品 ID、数量和销售日期。

```sql
| sale_id | product_id | quantity | sale_date  |
| ------- | ---------- | -------- | ---------- |
| 101     | 1          | 2        | 2025-07-18 |
| 102     | 2          | 3        | 2025-02-13 |
| 103     | 6          | 10       | 2025-06-08 |
| 104     | 5          | 8        | 2025-01-10 |
| 105     | 2          | 1        | 2025-05-15 |
```

我们可以基于 `product_id` 执行一个 `INNER JOIN`，如下所示：

```sql
SELECT *
FROM products
INNER JOIN sales
  ON products.product_id = sales.product_id;
```

这将只获取两个表格中具有相同 `product_id` 的行。所以如果某个产品不在销售表格或产品表格中，它将不会被包含。

这是结果：

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
     1     | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
     2     | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
     2     | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
     5     | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
     6     | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
```

我们只看到已售出产品的行。例如，`'Pizza Margherita'` 在 `sales` 表格中，`product_id` 为 `2`，所以我们在结果中得到该产品。

但是，`'T-Shirts'` 的 `product_id` 为 `4` 的商品未售出，因此该商品不在 `sales` 表格中。它们不在两个表格中，因此不包含在结果中。

连接表格的作用正如其名称所示。它将两个或多个表格合并为一个，这就是为什么我们会看到两个表格中的所有列，包括两次出现的 `product_id`。

`FULL OUTER JOIN` 返回两个表格中的所有行。

如果在指定的列中找到匹配，数据将被合并，你将获得每个匹配记录的所有列。

如果在任一表格的指定列中没有匹配，则缺失的列将填充为 `NULL` 值。

让我们在示例中基于 `product_id` 列执行一个 `FULL OUTER JOIN`。该列将决定是否存在匹配。

```sql
SELECT *
FROM products
FULL OUTER JOIN sales
  ON products.product_id = sales.product_id;
```

这是结果：

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
         1 | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
         3 | Sushi            | Food      | 18.75 | Japan     |         |            |          |
         4 | T-Shirt          | Clothing  | 25.00 | USA       |         |            |          |
         5 | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
         6 | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
         7 | Juice            | Beverages |  5.00 | Colombia  |         |            |          |
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
```

注意 `'Pizza Margherita'` 拥有所有数据，包括来自 `sales` 表格的列，因为存在匹配。

但是 `'T-Shirt'` 有空的（`NULL`）列，因为在 `sales` 表格中没有找到匹配（该产品未售出）。

`LEFT OUTER JOIN` 用于获取左表的所有记录以及左表每一行对应的右表匹配信息。

如果未找到匹配，则右表的列将填充为 `NULL` 值。

让我们在示例中执行一个 `LEFT OUTER JOIN`。

```sql
SELECT *
FROM products
LEFT JOIN sales
  ON products.product_id = sales.product_id;
```

这是结果：

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
         1 | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
         3 | Sushi            | Food      | 18.75 | Japan     |         |            |          |
         4 | T-Shirt          | Clothing  | 25.00 | USA       |         |            |          |
         5 | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
         6 | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
         7 | Juice            | Beverages |  5.00 | Colombia  |         |            |          |
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
```

在这种分支中，它与 `FULL OUTER JOIN` 相同，因为它包含了第一个表格 `products` 的所有行。

`RIGHT OUTER JOIN` 非常相似，但现在我们获取右表的所有记录以及右表每一行对应的左表匹配信息。

如果没有匹配，则左侧表格的列将填充为 `NULL` 值。

让我们在示例中执行一个 `RIGHT OUTER JOIN`。

```sql
SELECT *
FROM products
RIGHT JOIN sales
  ON products.product_id = sales.product_id;
```

结果如下：

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
         1 | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
         6 | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
         5 | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
```

你会注意到它的行数更少。这是因为它取了右侧表格（在此例中为 `sales`）中的所有记录，而该表格的行数少于 `products` 表格。

如果在 `products` 表格中找到匹配项，它会用数据填充那些列。但如果没有匹配项，列则填充为 `NULL`。

在这个分支中，每个已售出的产品在 `products` 表格中都有一条记录，所以数据是完整的。

这些是最常用的 `JOIN` 操作，但还有另外两个你应该了解的。

`SELF JOIN` 允许你将表格与其自身连接。你可以将其视为连接同一表格的两个副本。这对于比较同一表格中的不同行非常有用。

`CROSS JOIN`，也称为笛卡尔连接，将第一个表格的每一行与第二个表格的每一行连接。因此，它生成所有可能的行组合。此操作不需要任何条件来连接表格。

这些 `JOIN` 操作是使用 SQL 的基础。通过选择合适的操作，你可以尽可能高效地查询所需的数据。

# --questions--

## --text--

哪种 SQL `JOIN` 操作仅返回基于连接条件在两个表格中都有匹配的行？

## --answers--

`LEFT JOIN`

### --feedback--

考虑哪种连接 `type` 在仅包含匹配两个表格的记录方面最严格。

---

`INNER JOIN`

---

`RIGHT JOIN`

### --feedback--

考虑哪种连接 `type` 在仅包含匹配两个表格的记录方面最严格。

---

`FULL JOIN`

### --feedback--

考虑哪种连接 `type` 在仅包含匹配两个表格的记录方面最严格。

## --video-solution--

2

## --text--

如果你需要检索所有客户（左表）以及每个客户可能下的任何订单（右表），并且即使客户没有订单也应包含在结果中，你会使用哪种 SQL `JOIN` 操作？

## --answers--

`LEFT JOIN`

---

`INNER JOIN`

### --feedback--

考虑哪种连接确保所有来自 customers `table` 的 `record` 都包含在输出中。

---

`RIGHT JOIN`

### --feedback--

考虑哪种连接确保所有来自 customers `table` 的 `record` 都包含在输出中。

---

`FULL JOIN`

### --feedback--

考虑哪种连接确保所有来自 customers `table` 的 `record` 都包含在输出中。

## --video-solution--

1

## --text--

哪种 SQL `JOIN` 操作返回两个表格中的所有行，包括未匹配的行（对于没有匹配的表格列使用 `NULL`）？

## --answers--

`LEFT JOIN`

### --feedback--

此连接旨在最具包容性，包含两个表格中的所有记录。

---

`INNER JOIN`

### --feedback--

此连接旨在最具包容性，包含两个表格中的所有记录。

---

`RIGHT JOIN`

### --feedback--

此连接旨在最具包容性，包含两个表格中的所有记录。

---

`FULL JOIN`

## --video-solution--

4
