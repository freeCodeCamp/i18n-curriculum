---
id: 67d1ec87b34cee1d9219f7e9
title: ¿Cómo puedes crear Hooks personalizados en React?
challengeType: 19
dashedName: how-can-you-create-custom-hooks-in-react
---

# --description--

React proporciona muchos hooks incorporados que te permiten implementar diferentes características en tus proyectos. Estos incluyen `useState`, `useEffect`, `useContext` y otros.

Pero a veces, necesitas agregar una característica que ninguno de los hooks incorporados pueda ayudar. Afortunadamente, puedes crear tus propios hooks personalizados en React.

Los hooks personalizados no son tan complicados como podrían parecer. Son solo funciones reutilizables que te permiten compartir lógica entre múltiples componentes. Eso significa que la reutilización es otra razón por la que querrías construir tu propio hook.

Con un hook personalizado, puedes extraer lógica de cualquier componente que los utilice, como obtención de datos, gestión de estado, alternancia, efectos secundarios, como verificar el estado en línea o fuera de línea de los usuarios, y así sucesivamente. 

Luego puedes importar el hook para usar en cualquier componente, para que puedas centrarte en la representación y presentación dentro de esos componentes. Eso significa menos repeticiones y menos duplicaciones, lo que significa menos lugares para hacer cambios cuando desees realizar actualizaciones.

Ahora, vamos a ver cómo puedes crear tu propio hook personalizado.

En React, todos los hooks incorporados comienzan con la palabra `use`, por lo que tu hook personalizado debe seguir la misma convención. El nombre de tu hook personalizado también debe comunicar claramente lo que hace.

Así que, si tu hook personalizado...

- obtiene datos, puedes llamarlo `useFetch`

- alterna algo encendido y apagado, puedes llamarlo `useToggle`

- o si implementa retraso en la ejecución, `useDebounce` es un buen nombre

Supongamos que deseas construir un hook personalizado para agregar retraso en la ejecución a tu aplicación.

El retraso en la ejecución es una técnica de programación que limita la frecuencia con la que se ejecuta una función. Funciona esperando hasta que un usuario deje de realizar una acción durante un período de tiempo especificado antes de ejecutar la función. Por ejemplo, en un cuadro de búsqueda, en lugar de hacer una llamada API por cada pulsación de tecla, el retraso en la ejecución espera hasta que el usuario haga una pausa al escribir, por ejemplo, durante 500 milisegundos.

Para crear un hook personalizado de retraso en la ejecución, primero necesitas crear un archivo `useDebounce.jsx` o `useDebounce.js`. Convencionalmente, los archivos para cualquier hook personalizado que crees se guardan en una carpeta `hooks`.

Puedes usar algunos hooks incorporados dentro de tu propio hook personalizado. Para el retraso en la ejecución, necesitas los hooks `useState` y `useEffect`, así que impórtalos en la parte superior de tu archivo:

```js
import { useState, useEffect } from "react";
```

A continuación, crea una función `useDebounce` que tome `value` y `delay` como parámetros. `value` es el recurso por el que quieres esperar, y `delay` es el período de tiempo que quieres esperar. Dado que quieres esperar un período de tiempo, las funciones `setTimeout` y `clearTimeout` serían útiles:

```js
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

El estado `debouncedValue` mantiene y devuelve el valor retrasado, que solo se actualiza después del período de tiempo especificado.

`useEffect` es donde realmente sucede la magia. Si recuerdas de la lección anterior, cualquier cosa que exista fuera del ciclo de renderizado de React, como establecer y limpiar un temporizador, es un efecto secundario, y debes usar el hook `useEffect` para manejarlos.

Dentro del hook `useEffect` aquí, se utiliza `setTimeout` para establecer el `debouncedValue`. Luego, debes devolver una función de limpieza que utilice `clearTimeout` para limpiar el tiempo de espera anterior cada vez que cambie el `value` o el `delay`, o cuando el componente se desmonte.

Para utilizar este hook, hemos preparado un arreglo `footballers` para filtrar a través de una simple barra de búsqueda:

```js
const footballers = [
  'Lionel Messi', 'Cristiano Ronaldo', 'Neymar Jr',
  'Kylian Mbappe', 'Mohamed Salah', 'Sadio Mane',
  'Kevin De Bruyne', 'Robert Lewandowski', 'Harry Kane',
  'Sergio Ramos', 'Virgil van Dijk', 'Alisson Becker', 
  'Joshua Kimmich', 'Manuel Neuer', 'Karim Benzema', 
  'Thibaut Courtois', 'Eden Hazard', 'Raheem Sterling',
  'Bruno Fernandes', 'Trent Alexander-Arnold', 'Son Heung-min',
  'Pierre-Emerick Aubameyang','Sergio Aguero', 'Luis Suarez', 
  'Luka Modric', 'Casemiro', 'Frenkie de Jong', 'Gerard Pique',
  'Marc-Andre ter Stegen', 'Keylor Navas', 'Angel Di Maria', 
  "N'Golo Kante", 'Kai Havertz', 'Timo Werner', 'Hakim Ziyech', 
  'Christian Pulisic', 'Mason Mount', 'Olivier Giroud', 'Tammy Abraham', 
  'Kepa Arrizabalaga', 'Ben Chilwell', 'Thiago Silva', 'Kurt Zouma', 
  'John Terry', 'Didier Drogba', 'Frank Lampard', 'Ashley Cole', 'Petr Cech',
];

export default footballers;
```

Y aquí tienes un componente `FootballerSearch` que utiliza el hook `useDebounce` para demorar la búsqueda 1 segundo después de que el usuario deja de escribir.

```jsx
import { useState, useEffect } from "react";
import { useDebounce } from "./hooks/useDebounce";
import footballers from "./footballers";

const FootballerSearch = () => {
  const [query, setQuery] = useState("");
  const debouncedQuery = useDebounce(query, 1000); // Start searching 1 second after the user stops typing

  useEffect(() => {
    if (debouncedQuery) {
      const results = footballers.filter((footballer) =>
        footballer.toLowerCase().includes(debouncedQuery.toLowerCase()),
      );
      console.log("Search results:", results);
    } else {
      console.log("Search results: []");
    }
  }, [debouncedQuery]);

  return (
    <>
      <h1 style={{ textAlign: "center" }}>Footballer Search App</h1>
      <div style={{ textAlign: "center" }}>
        <input
          style={{ padding: "0.5rem", width: "30%" }}
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search for a footballer..."
        />
      </div>
    </>
  );
};

export default FootballerSearch;
```

Como puedes ver, la variable `debouncedQuery` es la que inicializa el hook `useDebounce` con el estado de consulta (lo que el usuario escribe), y el retraso de 1,000 milisegundos, o 1 segundo. La búsqueda en sí se maneja dentro del hook `useEffect`, y los resultados de la búsqueda se registran en la consola.

# --questions--

## --text--

¿Cuál es un beneficio notable de crear un hook personalizado en React?

## --answers--

Hace que los componentes se rendericen más rápido.

### --feedback--

Los hooks personalizados evitan repetir la misma lógica en diferentes componentes.

---

Permite reutilizar la lógica en múltiples componentes.

---

Sustituye la necesidad de hooks incorporados.

### --feedback--

Los hooks personalizados evitan repetir la misma lógica en diferentes componentes.

---

Obliga a los componentes a compartir el mismo estado.

### --feedback--

Los hooks personalizados evitan repetir la misma lógica en diferentes componentes.

## --video-solution--

2

## --text--

¿Cuál es la convención de nomenclatura correcta para un hook personalizado en React?

## --answers--

Debe comenzar con "`use`".

---

Puede tener cualquier nombre.

### --feedback--

Piensa en un prefijo específico para los hooks.

---

Debe terminar con "`Hook`".

### --feedback--

Piensa en un prefijo específico para los hooks.

---

Debe coincidir con un nombre de hook incorporado.

### --feedback--

Piensa en un prefijo específico para los hooks.

## --video-solution--

1

## --text--

¿Cómo llamarías a un hook personalizado que alterna un valor encendido y apagado?

## --answers--

`useSwitch`

### --feedback--

Los hooks personalizados deben seguir la convención de nomenclatura de React y describir su propósito claramente.

---

`useToggle`

---

`toggleHook`

### --feedback--

Los hooks personalizados deben seguir la convención de nomenclatura de React y describir su propósito claramente.

---

`useBoolean`

### --feedback--

Los hooks personalizados deben seguir la convención de nomenclatura de React y describir su propósito claramente.

## --video-solution--

2
