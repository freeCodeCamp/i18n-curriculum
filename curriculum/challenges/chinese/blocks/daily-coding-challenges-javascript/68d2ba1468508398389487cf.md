---
id: 68d2ba1468508398389487cf
title: "挑战 74：最喜欢的歌曲"
challengeType: 28
dashedName: challenge-74
---

# --description--

还记得 iPod 吗？第一款模型是在 2001 年 10 月 23 日，也就是今天，发布的，距今已有 24 年。

给定一个表现你 iPod 播放列表的歌曲对象数组，返回一个包含播放次数最多的两首歌曲标题的数组，播放次数最多的歌曲排在第一位。

- 每个对象都会有一个 `"title"` 属性（字串），和一个 `"plays"` 属性（整数）。

# --hints--

`favoriteSongs([{"title": "Sync or Swim", "plays": 3}, {"title": "Byte Me", "plays": 1}, {"title": "Earbud Blues", "plays": 2} ])` 应该返回 `["Sync or Swim", "Earbud Blues"]`。

```js
assert.deepEqual(favoriteSongs([{"title": "Sync or Swim", "plays": 3}, {"title": "Byte Me", "plays": 1}, {"title": "Earbud Blues", "plays": 2} ]), ["Sync or Swim", "Earbud Blues"]);
```

`favoriteSongs([{"title": "Skip Track", "plays": 98}, {"title": "99 Downloads", "plays": 99}, {"title": "Clickwheel Love", "plays": 100} ])` 应该返回 `["Clickwheel Love", "99 Downloads"]`。

```js
assert.deepEqual(favoriteSongs([{"title": "Skip Track", "plays": 98}, {"title": "99 Downloads", "plays": 99}, {"title": "Clickwheel Love", "plays": 100} ]), ["Clickwheel Love", "99 Downloads"]);
```

`favoriteSongs([{"title": "Song A", "plays": 42}, {"title": "Song B", "plays": 99}, {"title": "Song C", "plays": 75} ])` 应该返回 `["Song B", "Song C"]`。

```js
assert.deepEqual(favoriteSongs([{"title": "Song A", "plays": 42}, {"title": "Song B", "plays": 99}, {"title": "Song C", "plays": 75} ]), ["Song B", "Song C"]);
```

# --seed--

## --seed-contents--

```js
function favoriteSongs(playlist) {

  return playlist;
}
```

# --solutions--

```js
function favoriteSongs(playlist) {
  const sorted = [...playlist].sort((a, b) => b.plays - a.plays);
  return sorted.slice(0, 2).map(song => song.title);
}
```
