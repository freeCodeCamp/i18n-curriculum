---
id: 68ca71c3f0ee7ece4ea1e286
title: 什么是 Name Mangling 及其工作原理？
challengeType: 19
dashedName: what-is-name-mangling-and-how-does-it-work
---

# --description--

在之前的课程中，你学习了如何在属性前加单下划线和双下划线。

为了提醒你它们之间的区别，单个下划线是一种约定，表示该属性是类的内部使用，不应从类外部直接访问。另一方面，双下划线则防止该属性被类外部直接访问。

这是一个演示两者如何协同工作的示例：

```py
class Example:
    def __init__(self):
        self._internal = 'I can be accessed from outside the class, but should not'
        self.__private = 'You cannot access me directly from outside the class'

obj = Example()

print(obj._internal) # I can be accessed from outside the class, but should not
print(obj.__private)  # AttributeError: 'Example' object has no attribute '__private'
```

在属性前加双下划线会触发 Python 的名称重整进程，其中 Python 会在内部通过添加下划线和类名作为前缀来重命名该属性，将 `__attribute` 变为 `_ClassName__attribute`。

要看到这个效果，你需要创建该类的一个实例，并使用该实例的 `__dict__` 特殊属性，该属性是一个包含对象属性的字典：

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    'I can be accessed from outside the class, but should not',
    'I cannot be accessed directly from outside the class'
)

print(example1.__dict__)
```

结果将是：

```py
{
  '_internal': 'I can be accessed from outside the class, but should not',
  '_Example__private': 'I cannot be accessed directly from outside the class'
}
```

如你所见，`__private` 属性被保存为 `_Example__private`。这意味着你仍然可以通过这种方式在类外访问该属性：

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    'I can be accessed from outside the class, but should not',
    'I cannot be accessed directly from outside the class'
)
example2 = Example(
    'I should not be accessed from outside the class',
    'But I can be accessed from outside the class with name mangling'
)

print(example1._Example__private) # I cannot be accessed directly from outside the class
print(example2._Example__private) # But I can be accessed from outside the class with name mangling
```

那么，为什么 Python 要进行名称重整？

名称改编的主要目的是防止在使用继承时意外覆盖属性和方法。下面是一个能清楚说明这一点的例子：

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

你可以看到 `Parent` 类和继承自它的 `Child` 都有各自独立的 `_class__data` 属性。这是通过名称重整实现的。否则，`Child` 会意外覆盖 Parent 的数据。

如果不允许 Python 进行名称重整，也就是说如果你不在两个类中的属性前加双下划线，情况将会是这样的：

```py
class Parent:
   def __init__(self):
       self.data = 'Parent data'

class Child(Parent):
   def __init__(self):
       super().__init__()
       self.data = 'Child data'

c = Child()
print(c.__dict__)  # {'data': 'Child data'}
```

那么，你应该使用单下划线（`_`）还是双下划线（`__`）来作为属性的前缀？这取决于情况。如果一个属性仅用于类的内部，使用单下划线即可。 

但是如果你正在处理一个将被继承的类，你应该使用双下划线，以免父类的属性被覆盖。 

# --questions--

## --text--

单个下划线和双下划线有什么区别？

## --answers--

单个下划线和双下划线在 Python 中被视为相同。

### --feedback--

重点关注 Python 如何处理以 `_` 和 `__` 开头的属性。

---

单个下划线使属性完全私有，而双下划线使它们受保护。

### --feedback--

重点关注 Python 如何处理以 `_` 和 `__` 开头的属性。

---

单个下划线防止直接访问，而双下划线允许直接访问。

### --feedback--

重点关注 Python 如何处理以 `_` 和 `__` 开头的属性。

---

单个下划线只是一个约定，而双下划线会触发名称改编。

## --video-solution--

4

## --text--

什么是名称改编？

## --answers--

Python 将所有属性转换为方法以便更容易访问的进程。

### --feedback--

考虑 Python 如何在内部重命名双下划线属性。

---

Python 删除带单下划线的属性以保持其隐藏的一个进程。

### --feedback--

考虑 Python 如何在内部重命名双下划线属性。

---

Python 将 `__attribute` 转换为 `_ClassName__attribute` 的进程，以避免在子类中意外覆盖。

---

Python 加密私有数据以使其无法从类外部访问的进程。

### --feedback--

考虑 Python 如何在内部重命名双下划线属性。

## --video-solution--

3

## --text--

当你不在父类和子类中的属性前加双下划线时会发生什么？

## --answers--

两个类各自保留自己的属性副本，互不干扰。

### --feedback--

想想当两个类都使用相同的属性名且没有 `__` 时，`print(c.__dict__)` 显示的内容。

---

子类完全覆写了父类的属性，父类的数据丢失。

---

父类属性变为只读，子类无法更改。

### --feedback--

想想当两个类都使用相同的属性名且没有 `__` 时，`print(c.__dict__)` 显示的内容。

---

Python 引起误差，因为属性必须始终以双下划线作为前缀。

### --feedback--

想想当两个类都使用相同的属性名且没有 `__` 时，`print(c.__dict__)` 显示的内容。

## --video-solution--

2
