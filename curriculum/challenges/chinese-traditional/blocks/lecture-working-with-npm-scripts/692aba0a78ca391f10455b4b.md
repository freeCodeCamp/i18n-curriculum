---
id: 692aba0a78ca391f10455b4b
title: CommonJS 模組的匯入和匯出如何運作？
challengeType: 19
dashedName: how-do-imports-and-exports-work-with-commonjs-modules
---

# --description--

在現代網頁開發中，你可以將你的程式碼拆分成多個稱為「模組」的檔案。

你可以將模組視為一個自包含且可重複使用的程式碼區塊。

透過將模組匯入到其他模組中，你可以重複使用它們的功能，同時仍將程式碼保存在不同的檔案中，這樣更容易維護，特別是對於大型且複雜的網頁應用程式。

在 Node.js 中，每個檔案都被視為一個模組。

Node 有兩種不同的系統來處理模組：CommonJS 和 ES。

CommonJS 是 Node.js 中使用軟體包的原始且預設的方式。它同步載入模組，這表示它必須等待一個模組完全載入後，才能開始載入下一個模組或繼續執行程式碼。

它仍然被廣泛使用，但正逐漸被較新的 ES 語法取代。

CommonJS 使用 `require()` 函式（程式）來匯入模組，並將其相對路徑作為引數。

例如，假設我們有一個名為 `math.js` 的模組，在那裡我們定義基本的數學操作。

這裡我們只會使用一個乘法函式（程式），以保持此範例簡單且專注：

```js
function multiply(a, b) {
  return a * b;
}
```

我們如何在目前模組之外重複使用這個函式？預設情況下，在 Node.js 模組中定義的函式和變數是**私有的**——其他模組無法存取它們，除非我們明確地匯出它們。有幾種方法可以做到這一點。

一種常見的方法是為 `module.exports` 指定值。這個物件表述模組在被其他地方匯入時會傳回的內容，使其他模組能存取你選擇公開的函式、變數或物件。

在此範例中，我們將一個具有 `multiply` 屬性的物件指定給 `module.exports`。該屬性的值是我們先前定義的 `multiply` 函式的引用。這將匯出該函式，因此如果需要，我們可以從其他模組呼叫它。

```javascript
function multiply(a, b) {
  return a * b;
}

module.exports = {
  multiply: multiply
};
```

假設我們嘗試將 `math.js` 模組匯入到另一個模組中。我們呼叫 `require()` 函式，並將相對路徑作為引數傳入。然後，我們將 `require()` 傳回的物件指定給 `math` 變數。

```javascript
const math = require('./math');
```

讓我們透過使用 `console.log()` 在主控台中列印它，來檢查 `math` 的值：

```javascript
console.log(math);
```

這是輸出。它是一個具有 `multiply` 屬性且該屬性值為函式的物件：

```javascript
{ multiply: [Function: multiply] }
```

如果我們使用 `math.multiply()` 呼叫這個函式，並將數字 `6` 和 `7` 作為引數傳入，輸出結果是 `42`。函式成功執行，然而它在另一個檔案中！所以我們的匯入述語運作正常。

```javascript
const math = require('./math');

console.log(math.multiply(6, 7)); // 42
```

但還有其他方式可以匯出 `function`、`variable` 或 `object`。

例如，如果你只需要匯出單一函式（程式）、變數或物件，你可以直接將它指定為 `module.exports` 的值：

```javascript
function multiply(a, b) {
  return a * b;
}

module.exports = multiply;
```

如果你需要匯出多個函式（程式），你只需要將它們添加到 `module.exports` 物件中，並以逗號分隔。

在這裡，你可以看到匯出的物件有兩個屬性：`subtract` 和 `multiply`。它們的值是對應函式的引用，因此在任何匯入 `math.js` 的模組中，你都可以存取這兩者。

```javascript
function subtract(a, b) {
  return a - b;
}

function multiply(a, b) {
  return a * b;
}

module.exports = {
  subtract: subtract,
  multiply: multiply
};
```

當 `module.exports` 物件有多個屬性時，你將有選項，可選擇是要匯入全部還是單獨匯入各個屬性。

在此範例中，我們正在匯入由 `math.js` 匯出的整個物件，因此我們將能存取 `subtract` 和 `multiply`。

```javascript
const math = require('./math');

console.log(math.subtract(6, 7));  // -1
console.log(math.multiply(6, 7));  // 42
```

如果我們只想匯入 `multiply`，只需要在 `const` 關鍵字後的花括號內寫它的名稱。基本上，你是使用解構指派語法從匯出的物件中取得它的值。然後，我們可以在程式碼中直接以它的名稱取用它：

```javascript
const { multiply } = require('./math');

console.log(multiply(6, 7));
```

這也適用於多個元素。你只需要在大括號內用逗號分隔它們。這裡，我們同時匯入了 `subtract` 和 `multiply` 函式（程式）：

```javascript
const { subtract, multiply } = require('./math');
```

預設，Node.js 將以下視為 CommonJS 模組：

* 具有 `.cjs` 擴充套件的檔案。
    
* 當最近的父層 `package.json` 檔案包含頂層欄位 `"type"` 且值為 `"commonjs"` 時，具有 `.js` 擴充套件的檔案。
    
* 具有 `.js` 擴充套件的檔案或沒有擴充套件的檔案，當最近的父層 `package.json` 檔案不包含頂層欄位 `"type"`，或任何父資料夾中都沒有 `package.json`。
    
* 具有非 `.mjs`、`.cjs`、`.json`、`.node` 或 `.js` 擴充套件的檔案。
    

雖然 ES Modules 正逐漸取代 CommonJS 模組，但對於處理現有 Node.js 程式碼庫和許多 npm 軟體包的開發者來說，理解它們仍然是必要的。

# --questions--

## --text--

在 CommonJS 中，哪個函式（程式）用於匯入模組？

## --answers--

`import()`

### --feedback--

思考在 Node.js 環境中使用哪個關鍵字來引入外部程式碼。

---

`require()`

---

`export()`

### --feedback--

思考在 Node.js 環境中使用哪個關鍵字來引入外部程式碼。

---

`include()`

### --feedback--

思考在 Node.js 環境中使用哪個關鍵字來引入外部程式碼。

## --video-solution--

2

## --text--

以下哪一項是 CommonJS 中匯出模組的主要方式？

## --answers--

`export default`

### --feedback--

思考哪個物件用來定義模組對其他檔案所提供的內容。

---

`module.exports`

---

`export const`

### --feedback--

思考哪個物件用來定義模組對其他檔案所提供的內容。

---

`import from`

### --feedback--

思考哪個物件用來定義模組對其他檔案所提供的內容。

## --video-solution--

2

## --text--

CommonJS 使用什麼型別的載入？

## --answers--

非同步載入

### --feedback--

程式碼是否會在繼續執行之前等待模組完全載入？

---

延遲載入

### --feedback--

程式碼是否會在繼續執行之前等待模組完全載入？

---

同步載入

---

條件載入

### --feedback--

程式碼是否會在繼續執行之前等待模組完全載入？

## --video-solution--

3
