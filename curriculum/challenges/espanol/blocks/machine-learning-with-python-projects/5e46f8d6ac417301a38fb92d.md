---
id: 5e46f8d6ac417301a38fb92d
title: Piedra, papel y tijeras
challengeType: 10
forumTopicId: 462376
dashedName: rock-paper-scissors
---

# --description--

Para este desafío, crearás un programa para jugar Piedra, Papel o Tijeras. Un programa que elige al azar generalmente ganará el 50% de las veces. Para pasar este desafío, tu programa debe jugar partidas contra cuatro bots diferentes, ganando al menos el 60% de los juegos en cada partida.

Vas a <a href="https://app.ona.com/?autostart=true#https://github.com/freeCodeCamp/boilerplate-rock-paper-scissors/" target="_blank" rel="noopener noreferrer nofollow">trabajar en este proyecto con nuestro código inicial de Ona</a>.

Todavía estamos desarrollando la parte interactiva e instructiva del plan de estudios de machine learning. Por ahora, tendrás que usar otros recursos para aprender cómo superar este desafío.

# --instructions--

En el archivo `RPS.py` se te proporciona una función llamada `player`. La función recibe un argumento que es una cadena que describe la última jugada del oponente ("R", "P" o "S"). La función debe devolver una cadena que represente la siguiente jugada que debe realizar ("R", "P" o "S").

Una función de jugador recibirá una cadena vacía como argumento para el primer juego en una partida, ya que no hay jugada previa.

El archivo `RPS.py` muestra una función de ejemplo que necesitarás actualizar. La función de ejemplo está definida con dos argumentos (`player(prev_play, opponent_history = [])`). La función nunca se llama con un segundo argumento, por lo que ese es completamente opcional. La razón por la que la función de ejemplo contiene un segundo argumento (`opponent_history = []`) es porque esa es la única manera de guardar el estado entre llamadas consecutivas de la función `player`. Solo necesitas el argumento `opponent_history` si quieres llevar un registro del opponent_history.

*Consejo: Para derrotar a los cuatro oponentes, tu programa puede necesitar tener múltiples estrategias que cambien dependiendo de las jugadas del oponente.*

## Desarrollo

No modifiques `RPS_game.py`. Escribe todo tu código en `RPS.py`. Para el desarrollo, puedes usar `main.py` para probar tu código. 

`main.py` importa la función del juego y los bots desde `RPS_game.py`.

Para probar tu código, juega un juego con la función `play`. La función `play` toma cuatro argumentos:

- dos jugadores para jugar entre sí (los jugadores son en realidad funciones)
- el número de juegos para jugar en el match
- un argumento opcional para ver un registro de cada juego. Ponlo en `True` para ver estos mensajes.

```py
play(player1, player2, num_games[, verbose])
```

Por ejemplo, aquí está cómo llamarías a la función si quieres que `player` y `quincy` jueguen 1000 partidas entre sí y quieres ver los resultados de cada partida:

```py
play(player, quincy, 1000, verbose=True)
```

## Pruebas

Las pruebas unitarias para este proyecto están en `test_module.py`. Por defecto las pruebas del archivo `test_module.py` ya están importadas en el archivo `main.py` para su comodidad.  If you uncomment the last line in `main.py`, the tests will run automatically whenever you run `python main.py` in the console.

## Envío

Copia la URL de tu proyecto y envíalo a freeCodeCamp.

# --hints--

Debe pasar todas las pruebas de Python.

```js

```

# --solutions--

```py
  # Python challenges don't need solutions,
  # because they would need to be tested against a full working project.
  # Please check our contributing guidelines to learn more.
```
