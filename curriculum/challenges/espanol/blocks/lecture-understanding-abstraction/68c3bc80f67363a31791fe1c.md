---
id: 68c3bc80f67363a31791fe1c
title: ¿Qué es la abstracción y cómo ayuda a mantener organizados los sistemas complejos?
challengeType: 19
dashedName: what-is-abstraction-and-how-does-it-help-keep-complex-systems-organized
---

# --description--

Ahora que hemos visto encapsulación, herencia y polimorfismo, hablemos del siguiente concepto clave de la programación orientada a objetos: la abstracción.

La abstracción es el proceso de ocultar detalles complejos de implementación y mostrar solo las características esenciales de un objeto o sistema. Piensa en ello como enfocarte en qué hace algo en lugar de cómo lo hace.

La abstracción no se limita a Python. Es un concepto de programación que se puede implementar en muchos lenguajes que soportan la programación orientada a objetos.

Para ilustrar la abstracción, imagina que estás conduciendo un coche. Cuando estás en el asiento del conductor, interactúas con partes esenciales como el volante, la palanca de cambios y los pedales del acelerador y freno. No necesitas conocer los detalles intrincados de cómo funciona el motor, cómo la transmisión cambia de marcha o la física detrás del sistema de frenos, ya que todos esos son los detalles complejos de la implementación.

¡Eso es una abstracción en acción! Te proporciona una interfaz simplificada para interactuar con un sistema complejo.

En el caso de un coche nuevamente, la interfaz simplificada es el volante, los frenos y el acelerador, mientras que el sistema complejo es el coche mismo.

En cuanto a cómo Python implementa la abstracción, lo hace a través del módulo `abc`.

Este módulo proporciona la clase `ABC` (que significa “abstract base class”) y el decorador `@abstractmethod`.

`ABC` es la clase de la que se debe heredar, pero no puedes crear objetos directos a partir de ella. Es lo que define una interfaz común de métodos y propiedades que sus subclases deben implementar.

Por otro lado, un método abstracto es un método declarado en una Clase Base Abstracta (ABC) usando el decorador `@abstractmethod`. Puede no tener implementación o tener una básica por defecto. Sin embargo, cualquier subclase debe sobrescribirlo para ser considerada concreta e instanciable, incluso si se proporciona una implementación por defecto.

Aquí está la sintaxis básica de la clase abstracta en Python:

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

Aquí tienes un ejemplo básico:

```py
from abc import ABC, abstractmethod

class Animal(ABC): # Inherits from abstract base class
   @abstractmethod # Abstract method decorator
   def make_sound(self):  # The method subclasses must override
       pass

# Concrete class that will override the abstract method
class Dog(Animal):
   def make_sound(self):
       print('Woof!')

# Another concrete class that will override the abstract method
class Cat(Animal):
   def make_sound(self):
       print('Meow!')

# Another concrete class that will override the abstract method
class Monkey(Animal):
   def make_sound(self):
       print('Ooh ooh aah aah!')

# Create instances of each concrete class
animals = [Dog(), Cat(), Monkey()]

# Loop through the instances to call the make_sound method
for animal in animals:
   animal.make_sound()

# Output:
# Woof!
# Meow!
# Ooh ooh aah aah!
```

En este ejemplo:

- Estamos importando la clase `ABC` y `abstractmethod` del módulo `abc`.
- Luego creamos una clase `Animal` que hereda de `ABC`, y creamos un método abstracto `make_sound` en ella que cada subclase de `Animal` debe sobrescribir.
- Creamos las clases concretas `Dog`, `Cat` y `Monkey`, que deben sobrescribir el método abstracto `make_sound`.
- Instanciamos las clases concretas y llamamos a su método `make_sound` para mostrar cómo cada una implementa el método abstracto `make_sound` a su manera.

Recuerda que no puedes crear una instancia de la clase Animal. Esto es lo que sucede si intentas hacerlo:

```py
dog = Animal() 
# TypeError: Can't instantiate abstract class Animal 
# without an implementation for abstract method 'make_sound'
```

La misma regla se aplica a las subclases que no proporcionan una implementación para el método abstracto. Incluso si defines una subclase de Animal, no puedes instanciarla hasta que sobrescriba `make_sound`. Aquí tienes un ejemplo que muestra eso:

```py
class Bird(Animal):
    pass

bird = Bird()
# TypeError: Can't instantiate abstract class Bird 
# without an implementation for abstract method 'make_sound'
```

Aquí tienes otro ejemplo, esta vez con un atributo de instancia que puedes pasar a las instancias de los métodos concretos:

```py
from abc import ABC, abstractmethod

# The blueprint for any toy that can speak
class TalkingToy(ABC):
   def __init__(self, name):
       self.name = name
   @abstractmethod
   def speak(self):
       pass

class RobotToy(TalkingToy):
   def speak(self):
       print(f'{self.name} says beep boop! I am a robot!')

class TeddyBearToy(TalkingToy):
   def speak(self):
       print(f"{self.name} says hug me! I'm cuddly!")

class DinosaurToy(TalkingToy):
   def speak(self):
       print(f'{self.name} says ROOOOAR!')

# Create toys
rusty = RobotToy('Rusty')
fluffy = TeddyBearToy('Fluffy')
rex = DinosaurToy('Rex')

toys = [rusty, fluffy, rex]
for toy in toys:
   toy.speak()

# Output:
# Rusty says beep boop! I am a robot!
# Fluffy says hug me! I'm cuddly!
# Rex says ROOOOAR!
```

En este ejemplo: 

- Tenemos una clase base abstracta `TalkingToy` que define una estructura para cualquier juguete que pueda hablar.
- Las subclases `RobotToy`, `TeddyBearToy` y `DinosaurToy` implementan el método `speak` a su manera.
- Cuando creamos instancias de estas subclases y llamamos al método `speak`, cada juguete habla de una manera única.

En conclusión, la abstracción en Python simplifica sistemas complejos al aumentar la reutilización.

Has visto cómo puedes reutilizar un solo método de una clase abstracta en múltiples subclases mientras fuerzas a cada subclase a proporcionar su comportamiento específico.

Este enfoque mantiene tu código organizado, flexible y más fácil de mantener, especialmente a medida que tu aplicación crece.

# --questions--

## --text--

¿Cuál es el objetivo principal de la abstracción en la programación orientada a objetos?

## --answers--

Para exponer todos los detalles internos de implementación a los usuarios.

### --feedback--

Piensa en cómo la abstracción simplifica la interacción con sistemas complejos.

---

Para fusionar múltiples clases en una sola.

### --feedback--

Piensa en cómo la abstracción simplifica la interacción con sistemas complejos.

---

Para evitar que los métodos sean sobrescritos en las clases hijas.

### --feedback--

Piensa en cómo la abstracción simplifica la interacción con sistemas complejos.

---

Para ocultar la lógica compleja y mostrar solo las características esenciales

## --video-solution--

4

## --text--

¿Cómo implementa Python la abstracción a través de su módulo `ABC`?

## --answers--

Al permitir la instanciación directa de clases abstractas.

### --feedback--

El módulo ABC obliga a la implementación de métodos en las clases hijas.

---

Al usar decoradores y herencia para definir métodos abstractos que las subclases deben implementar.

---

Ocultando automáticamente todos los métodos con doble guion bajo.

### --feedback--

El módulo ABC obliga a la implementación de métodos en las clases hijas.

---

Al convertir clases en funciones.

### --feedback--

El módulo ABC obliga a la implementación de métodos en las clases hijas.

## --video-solution--

2

## --text--

En la analogía del coche para la abstracción, ¿qué representa la interfaz simplificada y el sistema complejo?

## --answers--

La interfaz es los pistones del motor, y el sistema complejo es el volante.

### --feedback--

Piensa en cómo la interfaz es con lo que interactúas directamente, mientras que el sistema complejo es cómo funciona.

---

La interfaz es el volante, los frenos y el acelerador, y el sistema complejo es el motor, la transmisión y la física de frenado.

---

La interfaz es el manual del coche, y el sistema complejo son los controles del tablero.

### --feedback--

Piensa en cómo la interfaz es con lo que interactúas directamente, mientras que el sistema complejo es cómo funciona.

---

La interfaz es el tipo de combustible, y el sistema complejo son los neumáticos.

### --feedback--

Piensa en cómo la interfaz es con lo que interactúas directamente, mientras que el sistema complejo es cómo funciona.

## --video-solution--

2
