---
id: 697dc755c709772fad37de9e
title: 矩陣和鄰接列表如何運作？
challengeType: 19
dashedName: how-do-matrices-and-adjacency-lists-work
---

# --description--

圖形是非常強大的資料結構，由一組節點（也稱為頂點）和連接它們的邊所組成。

在你的程式碼中實作圖形有兩種常見方式：

* 鄰接矩陣
    
* 鄰接列表
    

讓我們更深入了解這些，並探討它們的優點和限制。

## 鄰接矩陣

我們將從鄰接矩陣開始。

鄰接矩陣是一個二維陣列，其中列和行表述圖的頂點。

矩陣中的數值表述節點之間的邊或連接。

例如，如果你有一個儲存在名為 `matrix` 的變數中的矩陣，儲存在 `matrix[i][j]` 的值，其中 `i` 是列而 `j` 是行，表述節點 `i` 和節點 `j` 之間的邊或連接。

這些值的意義可能會因圖形是加權還是非加權而有所不同：

* 如果圖是無權重的，`1` 的值表示這些節點之間有邊相連，而 `0` 的值表示它們之間沒有邊。
    
* 如果圖是加權的，該值將表述連接節點的邊的權重。

使用鄰接矩陣的一大優點是檢查兩個節點之間是否有邊的時間為常數時間 `O(1)`。這是因為程式只需要在二維陣列中找到該特定值。

然而，這種尋找邊的效率是有代價的。鄰接矩陣需要大量的二次空間 `O(V²)`，其中 `V` 是圖中節點的數量。

這對於稀疏圖來說是低效的，稀疏圖是指只有少數邊的圖。為什麼？因為如果圖是稀疏的，你將會在矩陣中儲存許多 0 來表述節點之間缺少邊，而這些 0 仍然會佔用記憶體空間。

鄰接矩陣在尋找節點的鄰居時也不高效，因為程式必須迭代整個列或行以尋找表現邊的 0 和 1。在最壞情況下，這個處理程序可能需要 `O(V)` 時間，其中 `V` 是圖中節點的數量。

讓我們來看這個特定圖形的鄰接矩陣範例：

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png" alt="A graph with four nodes labeled A, B, C, and D. Node A connects to B, C, and D. Node B connects to A and D. Node C connects to A. Node D connects to A and B.">

在鄰接矩陣中：

* 每一列表述一個節點。第一列表述節點 A，第二列表述節點 B，依此類推。
    
* 每一行也表述一個節點。
    
* 矩陣中的每個值表述每對節點之間是否存在邊。值為 0 表示這些節點之間沒有邊相連，而值為 1 表示存在邊。
    
對角線上的值表述每個節點是否有自我迴圈，即連接節點自身的邊。在我們的範例中，它們全都是 0，因為圖形沒有任何自我迴圈。

這是鄰接矩陣的視覺表述，向你展示列和行如何表述對應的節點。

例如，第一列是 `[0, 1, 1, 1]`，因為節點 A 有邊連接到節點 B、C 和 D：

```markdown
#      A  B  C  D
# A   [0, 1, 1, 1],
# B   [1, 0, 0, 1],
# C   [1, 0, 0, 0],
# D   [1, 1, 0, 0]
```

這是相同的鄰接矩陣，但以 JavaScript 程式碼實作：

```javascript
const adjacencyMatrix = [
  [0, 1, 1, 1], // The neighbors of A are B, C, and D
  [1, 0, 0, 1], // The neighbors of B are A and D
  [1, 0, 0, 0], // The only neighbor of C is A
  [1, 1, 0, 0]  // The neighbors of D are A and B
];
```

## 鄰接列表

另一種常見的圖形表述方式是使用鄰接列表。

鄰接列表是用來儲存每個節點所有鄰居的陣列或物件（或 `Map`）。

實作鄰接列表有兩種常見方式：

* 作為一個陣列，其中每個索引表述一個節點，而該索引處儲存的陣列包含其鄰居。
* 作為一個物件（或 `Map`），其中每個鍵表述一個節點，而與該鍵相關的值（陣列）包含其鄰居。

鄰接列表在空間需求方面比鄰接矩陣更高效。它們具有 `O(V + E)` 的空間複雜度，其中 `V` 是頂點（節點）數量，`E` 是邊的數量。

這對於尋找所有鄰近節點也很高效，因為這個操作只需要存取與該節點相關的列表。

然而，也存在權衡。

在判斷兩個節點之間是否存在邊時，鄰接列表比鄰接矩陣的效率較低。

搜尋處理程序通常需要 `O(deg(v))` 時間（其中 `deg(v)` 是你正在檢查的節點的鄰居數量），在最壞情況下，如果一個節點與圖中所有其他節點相連，則可能是 `O(V)`。

這是此圖的鄰接列表範例：

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png" alt="A graph with four nodes labeled A, B, C, and D. Node A connects to B, C, and D. Node B connects to A and D. Node C connects to A. Node D connects to A and B. It's the same image as before.">

這個鄰接列表是以物件實作的。物件中的每個鍵表述一個節點，而該鍵相關的值是一個包含對應節點所有鄰居的陣列：

```javascript
const adjacencyList = {
  A: ["B", "C", "D"],
  B: ["A", "D"],
  C: ["A"],
  D: ["A", "B"]
};
```

或者，我們可以將它實作為一個二維陣列，其中每個索引表述一個節點。例如，索引 0 表述節點 A，索引 1 表述節點 B，依此類推：

```javascript
const adjacencyList = [
  ["B", "C", "D"], // Neighbors of A (index 0)
  ["A", "D"],      // Neighbors of B (index 1)
  ["A"],           // Neighbors of C (index 2)
  ["A", "B"]       // Neighbors of D (index 3)
];
```

請注意，即使這個 2D 陣列看起來與鄰接矩陣相似，它們其實相當不同。

* 鄰接矩陣儲存 0、1 或其他表述圖中邊或邊權重的值。

* 鄰接列表儲存每個節點所有鄰居的實際列表。

這是一個你應該熟悉的非常重要的差異。

鄰接矩陣和鄰接列表對於實作圖形都非常重要。選擇使用哪一種取決於圖形的大小以及你如何需要使用資料。鄰接矩陣對於邊很多的密集圖形很有幫助，而鄰接列表通常是現實情況中較常見的稀疏圖形的首選。

# --questions--

## --text--

在以下哪種情境中，使用鄰接矩陣來表述圖形是最高效的選擇？

## --answers--

一個擁有數十億人且每人只有極少數連接的社交網路。

### --feedback--

思考一個矩陣使用多少記憶體，以及這個數量如何根據連接數量而改變。

---

只有五個連接的電腦網路。

### --feedback--

思考一個矩陣使用多少記憶體，以及這個數量如何根據連接數量而改變。

---

一個稠密圖，其中每個節點都連接到大多數其他節點。

---

一個圖，其主要操作是尋找特定節點的所有鄰居。

### --feedback--

思考一個矩陣使用多少記憶體，以及這個數量如何根據連接數量而改變。

## --video-solution--

3

## --text--

在什麼情況下使用鄰接列表會比使用鄰接矩陣更高效？

## --answers--

當圖形密集且有許多邊時。

### --feedback--

想想當圖形連接不多時，鄰接列表如何節省記憶體。

---

當你需要非常快速地檢查兩個節點之間是否存在邊。

### --feedback--

想想當圖形連接不多時，鄰接列表如何節省記憶體。

---

當圖形有大量頂點和許多連線時。

### --feedback--

想想當圖形連接不多時，鄰接列表如何節省記憶體。

---

當圖形稀疏，頂點數量多且邊數量少時。

## --video-solution--

4

## --text--

在鄰接矩陣中，以下哪一種操作比在鄰接列表中更快？

## --answers--

尋找單一節點的所有鄰居。

### --feedback--

思考你將如何在網格和基於列表的結構中執行每一個這些操作。

---

檢查兩個特定節點之間是否存在直接邊。

---

遍歷圖中所有節點。

### --feedback--

思考你將如何在網格和基於列表的結構中執行每一個這些操作。

---

將新節點添加到圖中。

### --feedback--

思考你將如何在網格和基於列表的結構中執行每一個這些操作。

## --video-solution--

2
