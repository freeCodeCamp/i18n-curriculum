---
id: 5cd9a70215d3c4e65518328f
title: 构建倒计时
challengeType: 26
dashedName: build-a-countdown
---

# --description--

在本实验中，你将构建一个 `countdown` 函数，该函数接受一个起始数字并生成一个倒计时列表。

当你调用 `countdown(n)` 时，它应返回一个从 `n` 开始并以 1 递减直到达到 1 的数组。

例如：

- `countdown(5)` 应该返回 `[5, 4, 3, 2, 1]`。
- `countdown(1)` 应该返回 `[1]`

如果起始数字小于 `1`，则没有倒计时内容，因此返回一个空数组：

- `countdown(0)` 应该返回 `[]`
- `countdown(-3)` 应该返回 `[]`

要完成实验，你必须使用递归构建结果，且不得使用循环（`for`、`while`）或数组迭代方法（`forEach`、`map`、`filter`、`reduce`）。每次调用都应生成自己的结果数组（不要使用全局变量来保存倒计时）。

**目标：**实现以下用户需求并通过所有测试以完成实验。

**用户故事：**

1. 你应该创建一个名为 `countdown` 的函数。
2. `countdown` 函数应接受一个参数 `n`（数字）。
3. 如果 `n` 小于 `1`，`countdown` 应该返回一个空数组。
4. 否则，`countdown` 应该返回一个包含从 `n` 到 `1` 的整数的降序数组。
5. 你必须使用递归（函数应调用自身），且不得使用任何形式的循环（`for`、`while`，或像 `forEach`、`map`、`filter`、`reduce` 这样的高阶方法）。
6. 每个递归的调用都应使用比上一次调用更小的值（例如，`n - 1`），以便函数达到其基本情形。
7. 该方案不应使用全局的变量来保存或缓存结果数组。
8. 多次调用 `countdown` 并使用不同的输入应始终返回正确且独立的结果。

# --hints--

你应该有一个名为 `countdown` 的函数。

```js
assert.isFunction(countdown);
```

`countdown(-1)` 应该返回一个空数组。

```js
assert.isEmpty(countdown(-1));
```

`countdown(10)` 应该返回 `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`。

```js
assert.deepStrictEqual(countdown(10), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
```

`countdown(5)` 应该返回 `[5, 4, 3, 2, 1]`。

```js
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

代码不能包含任意形式的循环（`for`、`while` 或者高阶函数如：`forEach`、`map`、`filter` 以及 `reduce`）。

```js
assert(
  !__helpers.removeJSComments(code).match(/for|while|forEach|map|filter|reduce/g)
);
```

应该用递归解决这个问题。

```js
assert(
  countdown.toString().match(/countdown\s*\(.+\)/)
);
```

不应使用全局变量来缓存数组。

```js
countdown(1)
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
function countdown(n) {
  if (n < 1) {
    return [];
  }

  return [n, ...countdown(n - 1)];
}
```
