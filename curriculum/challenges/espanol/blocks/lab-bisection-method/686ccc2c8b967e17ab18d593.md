---
id: 686ccc2c8b967e17ab18d593
title: Implementa el Metodo de Bisección
challengeType: 27
dashedName: implement-the-bisection-method
---

# --description--

El método de bisección, también conocido como el método de búsqueda binaria, utiliza una búsqueda binaria para encontrar las raíces de una función de valor real. Funciona reduciendo un intervalo donde se encuentra la raíz cuadrada hasta que converge a un valor dentro de una tolerancia especificada.

Por ejemplo, si la tolerancia es `0.01`, el método de bisección seguirá dividiendo el intervalo a la mitad hasta que la diferencia entre los límites superior e inferior sea menor o igual a `0.01`.

En este laboratorio, implementarás una función que usa el método de bisección para encontrar la raíz cuadrada de un número.

**Objetivo:** Cumplir con las historias de usuario a continuación y pasar todas las pruebas para completar el laboratorio.

**Historias de usuario:**

1. You should define a function named `square_root_bisection` with three parameters:
    - El número para el que quieres encontrar la raíz cuadrada.
    - La tolerancia es el margen de error aceptable para el resultado. Debes establecer un valor de tolerancia predeterminado.
    - El número máximo de iteraciones a realizar. Debes establecer un número predeterminado de iteraciones.

1. The `square_root_bisection` function should:
    - Lanza un `ValueError` con el mensaje `Square root of negative number is not defined in real numbers` si el número pasado a la función es negativo.
    - Para los números `0` y `1`, imprime el mensaje: `The square root of [number] is [number]` y devuelve el número mismo como la raíz cuadrada.
    - Para cualquier otro número positivo, imprime la raíz cuadrada aproximada con el mensaje: `The square root of [square_target] is approximately [root]` y devuelve el valor de la raíz calculada.
    - Si ningún valor cumple con la condición de tolerancia, imprime un mensaje de error: `Failed to converge within the [maximum] iterations` y devuelve `None`.

**Nota**: No puedes importar ningún módulo para este laboratorio.

# --hints--

No debes importar ningún módulo.

```js
({ test: () => assert(runPython(`len(_Node(_code).find_imports()) == 0`)) })
```

Debes tener una función llamada `square_root_bisection`.

```js
({ test: () => assert(runPython(`_Node(_code).has_function("square_root_bisection")`)) })
```

Tu función `square_root_bisection` debe tener tres parámetros.

```js
({ test: () => runPython(`
    import inspect 
    sig = inspect.signature(square_root_bisection)
    assert len(sig.parameters) == 3
`) })
```

Debes establecer un valor predeterminado para la tolerancia y el número máximo de iteraciones.

```js
({ test: () => runPython(`
try:
  import inspect 
  sig = inspect.signature(square_root_bisection)
  assert len(sig.parameters) == 3
  square_root_bisection(4)
except TypeError:
  assert False
`) })
```

Tu función `square_root_bisection` debe lanzar un `ValueError` con el mensaje `Square root of negative number is not defined in real numbers` cuando el número pasado a la función sea negativo.

```js
({ test: () => runPython(`
try:
  square_root_bisection(-6)
except ValueError as e:
  assert str(e) == "Square root of negative number is not defined in real numbers"
else:
  assert False
`) })
```

`square_root_bisection(0)` debería devolver `0`.

```js
({ test: () => runPython(`assert square_root_bisection(0) == 0`) })
```

`square_root_bisection(0)` debería imprimir `The square root of 0 is 0`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print
square_root_bisection(0)
assert "The square root of 0 is 0" in _out
`) })
```

`square_root_bisection(0.001, 1e-7, 50)` debería devolver un número entre `0.03162267660168379` y `0.031622876601683794`.

```js
({ test: () => runPython(`assert 0.03162267660168379 <= square_root_bisection(0.001, 1e-7, 50) <= 0.031622876601683794`) })
```

`square_root_bisection(0.001, 1e-7, 50)` debería imprimir `The square root of 0.001 is approximately X`, donde `X` es un número entre `0.03162267660168379` y `0.031622876601683794`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(0.001, 1e-7, 50)

assert 0.03162267660168379 <= _root <= 0.031622876601683794
assert f"The square root of 0.001 is approximately {_root}" in _out
`) })
```

`square_root_bisection(0.25, 1e-7, 50)` debería devolver un número entre `0.4999999` y `0.5000001`.

```js
({ test: () => runPython(`assert 0.4999999 <= square_root_bisection(0.25, 1e-7, 50) <= 0.5000001`) })
```

`square_root_bisection(0.25, 1e-7, 50)` debería imprimir `The square root of 0.25 is approximately X`, donde `X` es un número entre `0.4999999` y `0.5000001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(0.25, 1e-7, 50)

assert 0.4999999 <= _root <= 0.5000001
assert f"The square root of 0.25 is approximately {_root}" in _out
`) })
```

`square_root_bisection(1)` debería devolver `1`.

```js
({ test: () => runPython(`assert square_root_bisection(1) == 1`) })
```

`square_root_bisection(1)` debería imprimir `The square root of 1 is 1`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print
square_root_bisection(1)
assert "The square root of 1 is 1" in _out
`) })
```

`square_root_bisection(81, 1e-3, 50)` debería devolver un número entre `8.999` y `9.001`.

```js
({ test: () => runPython(`assert 8.999 <= square_root_bisection(81, 1e-3, 50) <= 9.001`) })
```

`square_root_bisection(81, 1e-3, 50)` debería imprimir `The square root of 81 is approximately X`, donde `X` es un número entre `8.999` y `9.001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(81, 1e-3, 50)

assert 8.999 <= _root <= 9.001
assert f"The square root of 81 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-3, 100)` debería devolver un número entre `14.999` y `15.001`.

```js
({ test: () => runPython(`assert 14.999 <= square_root_bisection(225, 1e-3, 100) <= 15.001`) })
```

`square_root_bisection(225, 1e-3, 100)` debería imprimir `The square root of 225 is approximately X`, donde `X` es un número entre `14.999` y `15.001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(225, 1e-3, 100)

assert 14.999 <= _root <= 15.001
assert f"The square root of 225 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-5, 100)` debería devolver un número entre `14.99999` y `15.00001`.

```js
({ test: () => runPython(`assert 14.99999 <= square_root_bisection(225, 1e-5, 100) <= 15.00001`) })
```

`square_root_bisection(225, 1e-5, 100)` debería imprimir `The square root of 225 is approximately X`, donde `X` es un número entre `14.99999` y `15.00001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(225, 1e-5, 100)

assert 14.99999 <= _root <= 15.00001
assert f"The square root of 225 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-7, 100)` debería devolver un número entre `14.9999999` y `15.0000001`.

```js
({ test: () => runPython(`assert 14.9999999 <= square_root_bisection(225, 1e-7, 100) <= 15.0000001`) })
```

`square_root_bisection(225, 1e-7, 100)` debería imprimir `The square root of 225 is approximately X`, donde `X` es un número entre `14.9999999` y `15.0000001`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(225, 1e-7, 100)

assert 14.9999999 <= _root <= 15.0000001
assert f"The square root of 225 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-7, 10)` debería devolver `None`.

```js
({ test: () => runPython(`assert square_root_bisection(225, 1e-7, 10) is None`) })
```

`square_root_bisection(225, 1e-7, 10)` debería imprimir `Failed to converge within 10 iterations`.

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print
square_root_bisection(225, 1e-7, 10)
assert "Failed to converge within 10 iterations" in _out
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):
    if square_target < 0:
        raise ValueError('Square root of negative number is not defined in real numbers')
    if square_target == 1:
        root = 1
        print(f'The square root of {square_target} is 1')
    elif square_target == 0:
        root = 0
        print(f'The square root of {square_target} is 0')

    else:
        low = square_target if square_target < 1 else 1
        high = 1 if square_target < 1 else square_target
        root = None

        for _ in range(max_iterations):
            mid = (low + high) / 2
            square_mid = mid**2

            if high - low <= tolerance:
                root = mid
                break

            elif square_mid < square_target:
                low = mid
            else:
                high = mid

        if root is None:
            print(f"Failed to converge within {max_iterations} iterations")

        else:   
            print(f'The square root of {square_target} is approximately {root}')

    return root
```
