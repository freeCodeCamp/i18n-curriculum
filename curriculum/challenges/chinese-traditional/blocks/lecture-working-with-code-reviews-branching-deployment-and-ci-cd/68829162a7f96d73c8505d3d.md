---
id: 68829162a7f96d73c8505d3d
title: 什麼是合併衝突，以及你如何決議它們？
challengeType: 19
dashedName: what-are-merge-conflicts-and-how-can-you-resolve-them
---

# --description--

如果你曾經接觸過有經驗的開發者，無論是在線上社群還是面對面，你大概聽過「可怕的合併衝突」。但它們到底是什麼？

當你使用像我們在之前課程中討論過的適當分支策略時，你可能會同時在兩個不同分支上處理兩個不同的特性。或者你正在處理某件事，而同事正在另一個分支上工作。不管是哪種情況，你都有兩個獨立的變更進行中。但有時，這兩個分支會編輯同一個 `file`。如果另一個分支先合併到 `main`，你分支的變更就會落後。

大多數情況下，這可以透過將 `main` 合併回你的特性分支來修復。但當另一個分支的變更與你的分支衝突時，Git 無法判斷你想在合併期間保留哪些變更。這稱為「合併衝突」。

但是你要如何修正它？對於較小且較簡單的衝突，GitHub 會提供一個網頁介面讓你修正它。如果有衝突，PR 底部會出現一個「Resolve conflicts」按鈕。如果你點擊它，你會看到包含你的程式碼和衝突程式碼的衝突檔案。Git 會在你的程式碼和衝突程式碼周圍加入「merge conflict markers」來協助識別問題。它看起來像這樣：

```sh
1 <<<<<<< feat/conflict
2 Here's some code from my first PR :)
3 =======
4 Here's some code that was merged to main that conflicts with the code on my PR
5 >>>>>>> main
```

開頭標記是 `<<<<<<< feat/conflict`，並顯示我們目前分支所做更改的開始。接著我們看到 `Here's some code from my first PR :)`。之後是 `=======` 標記，顯示我們更改的結束以及 `main` 分支更改的開始。我們可以看到 `main` 上所做的更改是那行 `Here's some code that was merged to main that conflicts with the code on my PR`。最後是結尾的 `>>>>>> main` 標記，顯示衝突的結束。

但是我們要如何修正它？你需要決定想保留哪些變更作為合併衝突的零件。如果你想保留兩個變更，你可以只移除衝突標記並保持變更不變。或者，如果你只想保留其中一個分支的變更，你需要刪除衝突標記以及另一個分支的變更（那些你不想保留的）。最後，如果你完全不喜歡任何變更，你可以從開啟標記到關閉標記（包含標記本身）全部移除。

讓我們移除 `main` 分支的變更，但保留我們的。以下是我們現在的狀況：

```sh
1 Here's some code from my first PR :)
```

點擊「Mark as resolved」按鈕，這會告訴 GitHub 你對你的決議感到滿意。若有其他檔案，GitHub 會切換到下一個檔案。但由於這是我們唯一有衝突的檔案，你會看到「Commit merge」按鈕出現。點擊該按鈕，GitHub 就會為你創建一個合併提交。你將被帶回拉取請求頁面，在那裡你會看到你的新合併提交以及已解決的衝突。這樣就完成了！

但是如果你無法直接在 GitHub 上編輯衝突，因為它們太複雜了怎麼辦？

如果你的分支有少量提交，或只有幾個提交修改了該檔案，你可能能將 `main` 合併到你的分支：

```sh
git checkout feat/conflict
git fetch origin
git merge origin/main
```

當 Git 處理這次合併時，你會遇到需要手動決議的衝突。Git 會通知你哪些檔案需要修正。當我們在編輯器中打開有衝突的檔案時，我們會看到相同的衝突標記，並且因為 VSCode 的幫助介面有一些額外的輔助。請繼續以相同的方式修正檔案中的衝突。但這次，我們需要手動創建提交。這與創建任何其他提交相同：

```sh
git add .
git commit -m "chore: resolve conflicts"
```

在執行這些指令後，我們可以看到 Git 已接受我們的決議程序。

有時候，當你有許多提交或衝突時，使用 rebase 會很有幫助。rebase 不同於合併變更，它會將你分支上的所有提交重新套用，使它們位於 `main` 上的最新變更之後。以 Git 術語來說，這實際上是將你分支的基底「重設」到 `main` 上的最新提交。

為了進行此實驗，我們需要一個新的分支：

```sh
git checkout main
git pull
git checkout -b feat/rebase
```

讓我們繼續為我們的分支產生一堆提交，以便我們練習 rebase：

```sh
echo "change one" > README.md
git add .
git commit -m "change one"
echo "change two" > README.md
git add .
git commit -m "change two"
echo "change three" > README.md
git add .
git commit -m "change three"
```

現在，讓我們在 `main` 上再做一次更改以產生衝突：

```sh
git checkout main
echo "change four" > README.md
git add .
git commit -m "change four"
```

並查看我們的 rebase 分支：

```sh
git checkout feat/rebase
```

接著，執行 `git rebase -i main`。它會將我們的分支重新基底到 `main` 分支的作用中狀態。`-i` 旗標告訴 Git 以互動模式執行重新基底。你會看到你的提交旁邊有 `pick` 這個字。`pick` 告訴 Git 在重新基底時使用該提交的原始內容。存檔並關閉檔案，我們會收到一則告訴我們有衝突的錯誤訊息。

我們的 `change one` 提交與 `change four` 提交發生衝突，我們需要決議該衝突。在你的編輯器中打開該檔案，你會看到與之前衝突時相同的使用者介面。讓我們保留 `change one` 的變更。接著，你需要執行 `git add .` 將變更添加進去，並執行 `git rebase --continue` 告訴 Git 我們準備好繼續執行 rebase。由於我們已經在第一個提交中決議了衝突，Git 可以自動控制代碼後續提交的 rebase。

現在，作為最後一點清理，讓我們將三個變更提交合併成一個提交，以保持歷史紀錄的整潔。再次執行 `git rebase -i main` 以進入編輯器。然後，保留第一個指令為 `pick`，但將接下來的兩個改為 `squash`。你可能會再次遇到相同的衝突。如果遇到，請用之前相同的方式決議。當你解決並繼續 rebase（或如果沒有衝突，則立即）後，你會看到一個新的提交訊息編輯器彈出。這個訊息將成為你的新提交，包含我們合併的三個提交的變更。讓我們將這個命名為 `change three complete`。存檔並關閉編輯器，Git 將完成 rebase。

如果我們現在檢查你的提交歷史，我們可以看到我們現在有一個單一的 `change three complete` 提交，並且它正確地基於 `change four` 提交。這表示你已成功完成帶有壓縮提交的 rebase！現在你擁有成為合併衝突冠軍所需的工具！

# --questions--

## --text--

Git 添加的合併衝突標記是什麼，用來幫助識別衝突的變更？

## --answers--

`<<< current branch`、`=== separator`、`>>> other branch`

### --feedback--

思考 Git 用來標示衝突開始、中間和結束的特定語法。

---

`[[ current branch`、`|| separator`、`]] other branch`

### --feedback--

思考 Git 用來標示衝突開始、中間和結束的特定語法。

---

`<<<<<<< current branch`、`======= separator`、`>>>>>>> other branch`

---

`--- current branch`、`+++ separator`、`--- other branch`

### --feedback--

思考 Git 用來標示衝突開始、中間和結束的特定語法。

## --video-solution--

3

## --text--

在你的區域的儲存庫中手動解決合併衝突後，你需要執行哪些指令來完成合併？

## --answers--

`git push origin main` 和 `git rebase -i origin/main`

### --feedback--

在修正衝突後，你需要像其他提交一樣將已決議的變更加入暫存區並提交。

---

`git add` 和 `git commit`

---

`git merge --abort` 和 `git commit`

### --feedback--

在修正衝突後，你需要像其他提交一樣將已決議的變更加入暫存區並提交。

---

`git reset --hard` 和 `git push -f`

### --feedback--

在修正衝突後，你需要像其他提交一樣將已決議的變更加入暫存區並提交。

## --video-solution--

2

## --text--

在處理分支衝突時，合併與變基的主要差異是什麼？

## --answers--

合併會創建一個新的提交，而變基會重寫歷史，將你的提交放在另一個分支的提交之後。

---

Rebasing 比合併更快。

### --feedback--

考慮每個操作行為如何影響提交歷史。

---

合併只能在 GitHub 上進行，重置基底必須在區域的完成。

### --feedback--

考慮每個操作行為如何影響提交歷史。

---

沒有差別，它們是相同的操作。

### --feedback--

考慮每個操作行為如何影響提交歷史。

## --video-solution--

1
