---
id: 68420c7fb5b9e36eefb9e98f
title: 什麼是動態規劃以及有哪些常見的演算法？
challengeType: 19
dashedName: what-is-dynamic-programming-and-what-are-some-common-algorithms
---

# --description--
  
動態規劃是一種演算法技術，透過將複雜問題拆解成較簡單的子問題並儲存結果以避免重複計算來解決問題。這種方法將通常需要指數時間的問題轉變為可以在多項式時間內解決的問題。

## 動態規劃的核心原則

當問題中存在兩個關鍵條件時，動態規劃才有效。

- **重疊子問題**：在解決較大問題時，相同的較小問題會出現多次。與其反覆重新計算這些子問題，不如將它們的解決方案儲存起來。
    
- **最佳子結構**：問題的最佳解法包含其子問題的最佳解法。這表示我們可以透過結合較小零件的最佳解法來建置最佳解法。
    

讓我們使用經典的「爬樓梯」問題來檢視這些概念。

## 遞迴的問題

考慮爬樓梯問題：你正在爬一個有 `n` 階的樓梯，每次可以爬 1 階或 2 階。你有多少種不同的方法可以到達頂端？

```python
def climb_stairs_recursive(n):
    """Recursive approach"""
    if n <= 2:
        return n  # Base cases: 1 way for 1 step, 2 ways for 2 steps
    # To reach step n, we can come from step (n-1) or step (n-2)
    return climb_stairs_recursive(n-1) + climb_stairs_recursive(n-2)
```

此實作具有指數時間複雜度，因為大量重複計算。當計算 `climb_stairs(5)` 時，會發生以下情況：

- `climb_stairs(5)` 呼叫 `climb_stairs(4)` 和 `climb_stairs(3)`
    
- `climb_stairs(4)` 呼叫 `climb_stairs(3)` 和 `climb_stairs(2)`
    
- 現在 `climb_stairs(3)` 被計算了 **兩次**
    
- `climb_stairs(3)` 呼叫 `climb_stairs(2)` 和 `climb_stairs(1)`
    
- `climb_stairs(2)` 總共計算了 **3 次**
    

僅對 `n=5`，我們進行了 9 次函式呼叫，而實際只需要 5 次獨特的計算。隨著 `n` 增加，這種冗餘會呈指數爆炸式增長——`climb_stairs(30)` 將需要超過 10 億次函式呼叫！時間複雜度變成 `O(2^n)`，使其對較大 `n` 值來說既低效又不實用。

## 動態規劃解法

動態規劃透過兩種主要方法消除這種多餘的計算：

### 備忘錄法（自頂向下方法）

記憶化會儲存昂貴函式（程式）的結果，並在相同輸入再次出現時傳回快取結果：

```python
def climb_stairs_memo(n, memo={}):
    """Dynamic programming with memoization"""
    # Check if we've already calculated this value
    if n in memo:
        return memo[n]  # Return cached result - O(1) lookup!
    
    # Base cases
    if n <= 2:
        return n
    
    # Calculate once and store in memo for future use
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    return memo[n]
```

備忘錄化更加高效，因為從 `1` 到 `n` 的每個唯一值只計算一次。當我們再次需要 `climb_stairs(3)` 時，不是重新計算它（這會觸發更多遞迴呼叫），而是直接在我們的備忘錄字典中以 `O(1)` 時間查找。

讓我們透過自頂向下的方法追蹤 `climb_stairs(5)` 的執行，看看備忘錄如何消除重複工作：

```md
Call: climb_stairs_memo(5)
  memo = {} (empty)
  
  Call: climb_stairs_memo(4) 
    memo = {} (empty)
    
    Call: climb_stairs_memo(3)
      memo = {} (empty)
      
      Call: climb_stairs_memo(2) → returns 2 (base case)
      Call: climb_stairs_memo(1) → returns 1 (base case)
      
      Result: 2 + 1 = 3
      memo = {3: 3} (stored!)
    
    Call: climb_stairs_memo(2) → returns 2 (base case)
    
    Result: 3 + 2 = 5
    memo = {3: 3, 4: 5} (stored!)
  
  Call: climb_stairs_memo(3) → returns 3 (FROM MEMO - no recursion!)
  
  Result: 5 + 3 = 8
  memo = {3: 3, 4: 5, 5: 8}
```

**效率比較**

- **天真的遞迴**：進行 9 次函式呼叫並重複計算
    
- **備忘錄化**：只進行 5 次獨特計算，然後重複使用已儲存的結果
    
- **時間複雜度**：由於我們只進行 `n` 次獨特計算，從 `O(2^n)` 降低到 `O(n)`
    
- **空間複雜度**：用於備忘錄儲存和呼叫堆疊的 `O(n)`
    
- **實際影響**：`climb_stairs(30)` 從超過 10 億次呼叫降至僅 30 次呼叫！
    

### 表格法（自底向上方法）

表格法從頭開始建置解決方案，並以子問題的解決方案填滿表格：

```python
def climb_stairs_tabulation(n):
    """Dynamic programming with tabulation"""
    if n <= 2:
        return n
    
    # Create array to store results for all steps from 0 to n
    dp = [0] * (n + 1)
    dp[1] = 1  # 1 way to reach step 1
    dp[2] = 2  # 2 ways to reach step 2
    
    # Build up the solution iteratively
    for i in range(3, n + 1):
        # Ways to reach step i = ways to reach (i-1) + ways to reach (i-2)
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

表格法透過從最小的子問題開始，反覆地建置解法直到標的，完全消除遞迴。

讓我們看看自底向上的方法如何運作，了解我們如何系統性地建置解決方案。以下是 `climb_stairs(5)` 的反覆構件：

```md
Initial state:
dp = [0, 1, 2, 0, 0, 0]
     [0, 1, 2, 3, 4, 5] ← indices (step numbers)

Step by step construction:

i = 3:
  dp[3] = dp[2] + dp[1] = 2 + 1 = 3
  dp = [0, 1, 2, 3, 0, 0]
  
i = 4:
  dp[4] = dp[3] + dp[2] = 3 + 2 = 5
  dp = [0, 1, 2, 3, 5, 0]
  
i = 5:
  dp[5] = dp[4] + dp[3] = 5 + 3 = 8
  dp = [0, 1, 2, 3, 5, 8]

Final result: dp[5] = 8
```

**頁籤的主要優勢**

- **沒有遞迴額外開銷**：不像備忘錄法，沒有遞迴呼叫堆疊。
    
- **可預測的執行**：我們以預定的順序（1、2、3、4、5……）計算數值。
    
- **快取友善**：連續的陣列存取最佳化記憶體使用。
    
- **易於最佳化**：可以將空間複雜度降低到 `O(1)`，因為我們只需要最後兩個值。
    

```python
def climb_stairs_optimized(n):
    if n <= 2:
        return n
    
    prev2, prev1 = 1, 2  # Only store last two values
    for i in range(3, n + 1):
        current = prev1 + prev2
        prev2, prev1 = prev1, current
    return prev1
```

**效率比較**

- **天真的遞迴**：`n=5` 時有 9 次函式呼叫，呈指數成長。
    
- **製表**：對於 `n=5`，3 個簡單的加法，線性增長。
    
- **時間複雜度**：`O(n)` 而非 `O(2^n)`。
    
- **空間複雜度**：陣列為 `O(n)`，優化後為 `O(1)`。
    
- **可預測的效率**：對於大型輸入，沒有堆疊上限溢位的風險。
    

這兩種方法都將時間複雜度從指數級的 `O(2^n)` 降低到線性級的 `O(n)`，這是巨大的改進，使得解決問題的時間從毫秒級變成等待多年以處理較大輸入的差異。

## 實際應用

動態規劃在電腦科學及其他領域有廣泛的應用：

- **路徑優化**：GPS 系統使用動態規劃演算法來尋找位置之間的最短路徑。
    
- **文字處理**：拼字檢查器和自動完成特性通常依賴動態程式設計來計算字與字之間的編輯距離。
    
- **財務模式化**：投資策略和投資組合優化經常使用動態程式設計技術。
    
- **資源分配**：背包問題及其變體出現在排程、預算編列和資源管理中。
    

## 實作範例：找零問題

硬幣找零問題是一個經典的程式挑戰，當使用動態規劃解決時，展示了動態規劃的兩個關鍵原則：最佳子結構和重疊子問題。

硬幣找零問題問：「製作標的金額所需的最少硬幣數量是多少？」

這裡有一個使用動態規劃的解法：

```python
def min_coins(amount, coins):
    """Find minimum number of coins needed to make the given amount"""
    # Initialize dp array with "infinity" - represents impossible to make
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins needed for amount 0
    
    # For each amount from 1 to target amount
    for i in range(1, amount + 1):
        # Try each coin denomination
        for coin in coins:
            if coin <= i:  # Can only use coin if it doesn't exceed current amount
                # Update minimum: current minimum vs (coins for remaining amount + 1)
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    # Return result if possible, -1 if impossible
    return dp[amount] if dp[amount] != float('inf') else -1

# Example usage:
# coins = [1, 3, 4], amount = 6
# dp[6] = min(dp[5]+1, dp[3]+1, dp[2]+1) = min(3+1, 1+1, 2+1) = 2
# Result: 2 coins (3 + 3)
```

以下是動態規劃找零演算法針對 `coins = [1, 3, 4]`、`amount = 6` 的逐步運作方式：

```md
Initial state:
dp = [0, ∞, ∞, ∞, ∞, ∞, ∞]
     [0, 1, 2, 3, 4, 5, 6] ← amounts

Building up the solution:

For amount = 1:
  Try coin 1: dp[1] = min(∞, dp[0] + 1) = min(∞, 0 + 1) = 1
  dp = [0, 1, ∞, ∞, ∞, ∞, ∞]

For amount = 2:
  Try coin 1: dp[2] = min(∞, dp[1] + 1) = min(∞, 1 + 1) = 2
  dp = [0, 1, 2, ∞, ∞, ∞, ∞]

For amount = 3:
  Try coin 1: dp[3] = min(∞, dp[2] + 1) = min(∞, 2 + 1) = 3
  Try coin 3: dp[3] = min(3, dp[0] + 1) = min(3, 0 + 1) = 1
  dp = [0, 1, 2, 1, ∞, ∞, ∞]

For amount = 4:
  Try coin 1: dp[4] = min(∞, dp[3] + 1) = min(∞, 1 + 1) = 2
  Try coin 3: dp[4] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2
  Try coin 4: dp[4] = min(2, dp[0] + 1) = min(2, 0 + 1) = 1
  dp = [0, 1, 2, 1, 1, ∞, ∞]

For amount = 5:
  Try coin 1: dp[5] = min(∞, dp[4] + 1) = min(∞, 1 + 1) = 2
  Try coin 3: dp[5] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2
  Try coin 4: dp[5] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2
  dp = [0, 1, 2, 1, 1, 2, ∞]

For amount = 6:
  Try coin 1: dp[6] = min(∞, dp[5] + 1) = min(∞, 2 + 1) = 3
  Try coin 3: dp[6] = min(3, dp[3] + 1) = min(3, 1 + 1) = 2
  Try coin 4: dp[6] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2
  dp = [0, 1, 2, 1, 1, 2, 2]

Final result: dp[6] = 2 (achieved with coins 3 + 3)
```

這個解決方案展示了動態程式設計的兩個關鍵原則。它具有重疊子問題，因為找到金額 6 的最小硬幣數需要知道金額 5、3 和 2 的解法。這些相同的子問題在計算其他金額時也會出現。它具有最佳子結構，因為任何金額的最佳解法都包含較小金額的最佳解法。如果我們知道金額 3 的最小硬幣數是 1，則製作金額 6 的一種方法是使用該解法加上一個面額為 3 的硬幣。

如果沒有 DP，我們需要嘗試每一種可能的硬幣組合－指數級數量的可能性。有了 DP，我們系統性地建置解決方案：

- **時間複雜度**：`O(amount × number of coins)`，而非指數級。
    
- **空間複雜度**：`dp` 陣列的 `O(amount)`。
    
- **沒有多餘的工作**：每個子問題（尋找每個金額的最小硬幣數量）只解決一次。
    
- **可重複使用的結果**：一旦我們知道金額 3 的最小硬幣數量，我們就會將此知識用於所有可以從中獲得利益的較大金額。
    

## 何時使用動態規劃

當符合以下條件時，動態規劃是有效的：

- 這個問題可以拆解成重疊的子問題。
    
- 該問題展現最佳子結構。
    
- 一個天真的遞迴解法會涉及重複計算。
    
- 你需要以空間複雜度為代價來最佳化時間複雜度。
    

常見的動態程式設計樣式包括優化問題（尋找最小值／最大值）、計數問題（達成某事的方法數量）以及可以拆解成較小決策的決策問題。

動態規劃透過系統性地儲存並重複使用子問題的解決方案，將複雜問題轉化為可管理的問題。理解這項技術能為你開啟高效解決各種計算挑戰的大門。

# --questions--

## --text--

動態規劃適用時必須具備的兩個關鍵條件是什麼？

## --answers--

快速執行和低記憶體使用率。

### --feedback--

思考什麼因素使問題適合使用動態規劃優化。

---

重疊子問題和最優子結構。

---

遞迴呼叫和反覆的，迭代的迴圈。

### --feedback--

思考什麼因素使問題適合使用動態規劃優化。

---

備忘錄化和表格法。

### --feedback--

思考什麼因素使問題適合使用動態規劃優化。

## --video-solution--

2

## --text--

在動態規劃中，備忘錄法與表格法的主要差異是什麼？

## --answers--

備忘錄化使用比表格法更多的記憶體。

### --feedback--

考慮每種方法建置解決方案的方向。

---

表格法總是比備忘錄法更快。

### --feedback--

考慮每種方法建置解決方案的方向。

---

備忘錄法是自頂向下，而表格法是自底向上。

---

備忘錄化只適用於遞迴函式（程式）。

### --feedback--

考慮每種方法建置解決方案的方向。

## --video-solution--

3

## --text--

在天真的遞迴爬樓梯實作中，時間複雜度是多少？為什麼它是低效的？

## --answers--

`O(n)` 因為它只計算每個步驟一次。

### --feedback--

想想在遞迴樹中相同的階梯計數被計算了多少次。

---

`O(n²)` 因為它使用巢狀迴圈。

### --feedback--

想想在遞迴樹中相同的階梯計數被計算了多少次。

---

`O(2^n)`，因為它多次重新計算相同的子問題。

---

`O(log n)` 因為它將問題分成一半。

### --feedback--

想想在遞迴樹中相同的階梯計數被計算了多少次。

## --video-solution--

3
