---
id: 6881705cd9860639e98d639d
title: O que é o problema N+1?
challengeType: 19
dashedName: what-is-the-n-plus-1-problem
---

# --description--

O problema N+1 é um gargalo comum de desempenho em aplicações baseadas em banco de dados.Se você já experimentou um tempo de carregamento muito longo ao usar um aplicativo, é muito provável que esteja relacionado ao problema N+1.Esse problema ocorre quando muitas pequenas consultas estão sendo realizadas em sequência para obter os dados que você solicitou.

Mas por que você faria muitas consultas em sequência?Você pode fazer isso para consultar uma lista de registros e informações adicionais sobre esses registros.Você realizaria uma consulta inicial para obter a lista de registros e depois realizaria uma consulta adicional para cada um desses registros, para obter informações adicionais sobre eles.

Mesmo que você intuitivamente ache que realizar muitas consultas pequenas e simples será mais eficiente do que realizar apenas uma consulta grande e complexa, geralmente não é o caso.Quanto mais consultas você realizar, mais longo será todo o processo porque você precisa enviar cada consulta para o servidor, encontrar os dados no banco de dados e então receber os dados enviados pelo servidor para essa consulta.Isso pode ter um impacto de desempenho muito significativo na sua aplicação.

Para mostrar um exemplo prático, digamos que você está desenvolvendo um aplicativo para um serviço de entrega de comida e executa uma consulta para obter os primeiros 50 pedidos no banco de dados.Primeiro, você obterá uma lista com esses pedidos de uma tabela `orders`, como esta:

```sql
order_id | product   | quantity | customer_id
1        | pizza     | 2        | 3422
2        | salad     | 1        | 1255
3        | ice cream | 4        | 2344
4        | donuts    | 10       | 3455
.        | .         | .        | .
.        | .         | .        | .
.        | .         | .        | .
```

Mas e se você também precisar obter os dados dos clientes que enviaram esses pedidos?Estas informações seriam armazenadas em uma tabela `customers` diferente.

Uma forma de abordar isso seria obter a lista de pedidos primeiro e depois executar uma consulta por pedido para obter as informações dos clientes.Para obter a lista de pedidos, você pode executar uma consulta como esta, para obter os primeiros 50 registros da tabela `orders`:

```sql
SELECT * FROM orders LIMIT 50;
```

É aqui que vem o 1 em N+1.É a consulta inicial que fornece a lista de registros.Então, você precisará realizar outra consulta para cada um desses registros para obter as informações do cliente que enviou o pedido.Para isso, você pode escrever um loop em uma função assíncrona para processar tanto `orders` e `customers`.A função `getCustomerData()` executará uma consulta SQL para obter os dados do cliente que fez um pedido específico.Ele fará isso em sequência para cada pedido que foi realizado:

```js
for (const order of orders) {
  const customerId = order.customer_id;
  const customerData = await getCustomerData(customerId);
  // Process the customer's data.
}
```

É daí que vem o N em N+1.N representa o número de consultas que serão realizadas para obter dados adicionais para cada um dos registros.

Essa abordagem pode parecer simples e intuitiva, mas você pode se surpreender ao saber que é exatamente isso que você não deve fazer.Você deve evitar fazer consultas em um loop porque fazer várias consultas pequenas levará muito mais tempo do que executar uma única consulta maior para obter todos os dados.

Você deve tentar usar as ferramentas que o SQL oferece para reduzir o número de consultas o máximo possível.Neste caso, poderíamos usar uma operação `JOIN` para unir as tabelas `orders` e `customers`.

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name AS customer_name,
  customers.email AS customer_email,
  customers.address AS customer_address
FROM orders
JOIN customers ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50)
```

Com a operação `JOIN`, podemos recuperar os dados dos primeiros 50 pedidos no banco de dados, incluindo os dados dos clientes, seus nomes, e-mails e endereços, com apenas uma consulta.Pode parecer mais complexo, mas na verdade é mais eficiente dessa forma.

Agora você sabe do que o problema N+1 envolve, para que possa identificá-lo e preveni-lo, a fim de interagir com seu banco de dados de forma eficiente.

# --questions--

## --text--

Qual é a característica principal do problema N+1 no contexto de SQL?

## --answers--

Dados excessivos sendo retornados em uma única consulta.

### --feedback--

Pense na quantidade de consultas normalmente envolvidas e no que aciona as consultas adicionais após a primeira.

---

Executando uma consulta inicial seguida por N consultas adicionais para dados relacionados.

---

Uso ineficiente de índices de banco de dados.

### --feedback--

Pense na quantidade de consultas normalmente envolvidas e no que aciona as consultas adicionais após a primeira.

---

Conflitos decorrentes de transações concorrentes no banco de dados.

### --feedback--

Pense na quantidade de consultas normalmente envolvidas e no que aciona as consultas adicionais após a primeira.

## --video-solution--

2

## --text--

Qual é a principal implicação de desempenho do problema N+1?

## --answers--

Uso aumentado de CPU no servidor de banco de dados devido a joins complexos.

### --feedback--

Pense na sobrecarga associada à comunicação entre a aplicação e o banco de dados.

---

Integridade de dados reduzida devido a inconsistências em dados relacionados.

### --feedback--

Pense na sobrecarga associada à comunicação entre a aplicação e o banco de dados.

---

Maior consumo de memória no servidor de aplicação devido a grandes conjuntos de resultados.

### --feedback--

Pense na sobrecarga associada à comunicação entre a aplicação e o banco de dados.

---

Número aumentado de viagens de ida e volta ao banco de dados, levando a um tempo de carregamento maior.

## --video-solution--

4

## --text--

Uma estratégia para reduzir o número de consultas ao banco de dados ao recuperar dados relacionados e evitar o problema N+1 envolve:

## --answers--

Aumentando o tamanho do pool de conexões do banco de dados.

### --feedback--

Pense em como você pode combinar a recuperação dos dados principais e suas informações relacionadas em uma única interação com o banco de dados.

---

Otimização de consultas SQL individuais para velocidade.

### --feedback--

Pense em como você pode combinar a recuperação dos dados principais e suas informações relacionadas em uma única interação com o banco de dados.

---

Buscando dados relacionados dentro da consulta inicial usando cláusulas JOIN.

---

Implementando filtragem e ordenação de dados no lado do cliente.

### --feedback--

Pense em como você pode combinar a recuperação dos dados principais e suas informações relacionadas em uma única interação com o banco de dados.

## --video-solution--

3
