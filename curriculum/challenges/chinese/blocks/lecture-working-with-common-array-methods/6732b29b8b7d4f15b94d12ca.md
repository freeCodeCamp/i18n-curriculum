---
id: 6732b29b8b7d4f15b94d12ca
title: 什么是数组的浅拷贝？
challengeType: 19
dashedName: what-is-a-shallow-copy-of-an-array-and-what-are-some-ways-to-create-these-copies
---

# --interactive--

数组的浅拷贝是一个新数组，具有与原数组相同的项。如果数组只包含像数字或字串这样的原语值，则新数组是完全独立的。但如果数组内部包含其他数组，原数组和拷贝都会引用相同的内部数组。这意味着如果你更改共享内部数组中的某些内容，你将在两个数组中看到该更改。

浅拷贝在你需要修改顶层结构时非常有用，例如为你的数组添加、移除或重新排序元素，而不修改原始数组或内部数组。

有几种方法可以创建数组的浅拷贝，我们将探讨其中最常见的几种：`concat()`、`slice()` 和展开运算符。

让我们从 `concat()` 方法开始。 该方法通过合并两个或多个数组来创建一个新数组。 当与单个数组一起使用时，它可以有效地创建一个浅拷贝。 这是一个示例：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = [].concat(originalArray);

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

:::

在本例中，我们使用 `concat()` 方法将一个空数组连接到 `originalArray`。 这将创建一个新数组，它是 `originalArray` 的浅拷贝。 

`copyArray` 包含与 `originalArray` 相同的元素，但它是一个不同的数组对象，这就是严格相等检查（ `===`）返回 `false` 的原因。

另一种创建浅拷贝的方法是 `slice()` 方法。 在不带参数的情况下，`slice()` 返回整个数组的浅拷贝。 具体操作如下：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = originalArray.slice();

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

:::

在这种情况下，`originalArray.slice()` 将创建一个新数组，该数组是 `originalArray` 的浅拷贝。 同样，`copyArray` 包含相同的元素，但却是一个不同的数组对象。

ES6 中引入的展开运算符（`...`）提供了另一种创建数组浅拷贝的简洁方法。 这是一个示例：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = [...originalArray];

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

:::

展开运算符（`...`）会将 `originalArray` 中的元素展开到一个新数组中，从而有效地创建一个浅拷贝。 值得注意的是，所有这些方法都会创建新的数组对象，这意味着你可以修改副本而不影响原始数组。 例如：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = [...originalArray];

copyArray.push(4);
console.log(originalArray); // [1, 2, 3]
console.log(copyArray);     // [1, 2, 3, 4]
```

:::

在此示例中，向 `copyArray` 添加元素不会影响 `originalArray`。

总之，使用 `concat()`、`slice()` 方法或展开运算符，可以轻松创建数组的浅拷贝。 这些方法对于创建新数组非常有用，新数组可以独立于原始数组进行操作。

# --questions--

## --text--

下面代码的输出是什么？

```js
const arr1 = [1, 2, 3];
const arr2 = arr1.slice();
arr2.push(4);
console.log(arr1, arr2);
```

## --answers--

`[1, 2, 3] [1, 2, 3, 4]`

---

`[1, 2, 3, 4] [1, 2, 3, 4]`

### --feedback--

`slice()` 方法会创建数组的浅拷贝。

---

`[1, 2, 3] [1, 2, 3]`

### --feedback--

`slice()` 方法会创建数组的浅拷贝。

---

会报错。

### --feedback--

`slice()` 方法会创建数组的浅拷贝。

## --video-solution--

1

## --text--

下面代码的输出是什么？

```js
const fruits = ["apple", "banana", "orange"];
const fruitsCopy = [...fruits];
console.log(fruitsCopy.length);
```

## --answers--

`0`

### --feedback--

展开运算符（`...`）创建整个数组的浅拷贝。

---

`2`

### --feedback--

展开运算符（`...`）创建整个数组的浅拷贝。

---

`3`

---

`undefined`

### --feedback--

展开运算符（`...`）创建整个数组的浅拷贝。

## --video-solution--

3

## --text--

下面代码的输出是什么？

```js
const arr1 = [1, 2, 3];
const arr2 = [].concat(arr1);
console.log(arr1 === arr2);
```

## --answers--

`true`

### --feedback--

`concat()` 方法会创建一个新数组，即使是与一个空数组连接。

---

`false`

---

`undefined`

### --feedback--

`concat()` 方法会创建一个新数组，即使是与一个空数组连接。

---

会报错。

### --feedback--

`concat()` 方法会创建一个新数组，即使是与一个空数组连接。

## --video-solution--

2
