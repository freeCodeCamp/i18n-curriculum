---
id: 6724e2dbf723fe1c8883cc69
title: 前端函式庫回顧
challengeType: 31
dashedName: review-front-end-libraries
---

# --description--

## JavaScript 函式庫和框架

- JavaScript 函式庫和框架透過提供預先建置的程式碼，為常見問題提供快速解決方案並加快開發速度。
- 函式庫通常更專注於為特定任務提供解決方案，例如操作 DOM、處理事件或管理 AJAX 請求。
- JavaScript 函式庫的幾個範例是 jQuery 和 React。
- 另一方面，框架提供了更明確的結構來建置應用程式。它們通常附帶一套開發者需要遵循的規則和慣例。
- 框架的範例包括 Angular 和 Next.js，一個用於 React 的元框架。
- **單頁應用程式**（SPAs）是載入單一 HTML 頁面並在使用者與應用程式交談時動態更新該頁面的網頁應用程式，而不重新載入整個頁面。
- SPA 使用 JavaScript 來管理應用程式的狀態並呈現內容。這通常是使用提供強大工具以建置複雜使用者介面的框架來完成的。
- 有關 SPA 的一些問題包括：

  - 螢幕閱讀器難以處理動態更新的內容。
  - 當使用者在應用程式內導航時，URL 不會改變，這可能會使書籤、回溯或分享特定頁面變得困難。
  - 如果應用程式很大，初始載入時間可能會很慢，因為所有資產都需要事先載入。

## React

- React 是一個用於建置使用者介面和網頁應用程式的熱門 JavaScript 函式庫。
- React 的核心概念是產生可重複使用的 UI 組件，這些組件能在資料變更時獨立更新和呈現。
- React 允許開發者根據應用程式狀態描述 UI 應該呈現的樣子。當資料或狀態改變時，React 會更新並呈現正確的組件。

## React 組件

- 組件是 React 應用程式的建造區塊，允許開發者將複雜的使用者介面拆解成較小且易於管理的部分。
- 使用 JSX 描述使用者介面，JSX 是 JavaScript 語法的擴充套件，允許開發者在 JavaScript 中撰寫類似 HTML 的程式碼。
- 組件基本上是傳回一段 UI 的 JS 函式（程式）或類別。

這是一個簡單 React 組件的範例，該組件呈現一則問候訊息：

```jsx
function Greeting() {
  const name = 'Anna';
  return <h1>Welcome, {name}!</h1>;
}
```

要使用該組件，你只需呼叫：
    
```jsx
  <Greeting />
```

## 匯入和匯出 React 組件

- React 組件可以從一個檔案匯出並匯入到另一個檔案。
- 假設你有一個名為 `City` 的組件，在一個名為 `City.js` 的檔案中。你可以使用 `export` 關鍵字匯出該組件：

```jsx
// City.js
function City() {
  return <p>New York</p>;
}

export default City;
```

- 要將 `City` 組件匯入到另一個檔案中，你可以使用 `import` 關鍵字：

```jsx
// App.js
import City from './City';

function App() {
  return (
    <div>
      <h1>My favorite city is:</h1>
      <City />
    </div>
  );
}
```

- `default` 關鍵字是用來作為從 `City.js` 檔案的預設匯出。

- 你也可以選擇在組件定義的同一行匯出該組件，如下所示：

```jsx
export default function City() {
  return <p>New York</p>;
}
```

## 使用 Vite 設定 React 專案

- 專案設定工具和 CLI 提供快速且簡單的方式來啟動新專案，讓開發者能專注於撰寫程式碼，而非處理設定。
- Vite 是一個流行的專案設定工具，並且可以與 React 一起使用。
- 要使用 Vite 創建一個新的專案，你可以在你的終端機中使用以下指令：

```bash
npm create vite@latest my-react-app -- --template react
```

此指令使用 Vite 的 React 範本創建一個名為 `my-react-app` 的新 React 專案。在專案目錄中，你會看到一個包含專案相依性和指令的 `package.json` 檔案。

- 要執行專案，請切換到專案目錄並執行以下指令：

```bash
cd my-react-app # path to the project directory
npm install # installs the dependencies listed in the package.json file
```

- 安裝完相依性後，你應該會在你的專案中看到一個名為 `node_modules` 的新資料夾。

- `node_modules` 資料夾是儲存你的專案所需所有軟體包和函式庫的地方。

- 要執行你的專案，請使用以下指令：

```bash
npm run dev
```

- 之後，打開你的瀏覽器並導覽至 `http://localhost:5173` 以查看你的 React 應用程式正在執行。

- 若要實際查看起始模板的程式碼，你可以進入專案中的 `src` 資料夾，並且你應該會看到 `App.jsx` 檔案。

## 在 React 組件中傳遞 props

- 在 React 中，props（屬性的縮寫）是一種將資料從父組件傳遞到子組件的方式。這種機制是為了創建可重複使用且動態的 UI 元素所需的。
- Props 可以是任何 JavaScript 值。若要從父組件傳遞 props 到子組件，你需要在父組件的 JSX 中使用子組件時，將 props 作為屬性添加。以下是一個簡單的範例：

```jsx
// Parent component
function Parent() {
  const name = 'Anna';
  return <Child name={name} />;
}

// Child component
function Child(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

你可以在將多個 props 轉換為物件後，使用展開運算子 `(...)` 傳遞它們。以下是一個範例：
    
```jsx
// Parent component
function Parent() {
  const person = {
    name: 'Anna',
    age: 25,
    city: 'New York'
  };
  return <Child {...person} />;
}
```

在這段程式碼中，展開運算子 `{...person}` 將 person 物件轉換成個別的 props，並傳遞給 Child 組件。

## React 中的條件式呈現

- React 中的條件式算繪允許你創建動態使用者介面。它用於根據應用程式中的特定條件或狀態顯示不同的內容。
- 在 React 中，有幾種方法可以有條件地呈現內容。一個常見的方法是使用三元運算子。以下是一個範例：

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please log in</h1>}
    </div>
  );
}
```

- 另一種有條件地呈現內容的方法是使用邏輯 AND (`&&`) 運算子。當你只想在符合特定條件時呈現內容，這非常有用。以下是一個範例：

```jsx
function Greeting({ user }) {
  return (
    <div>
      {user && <h1>Welcome, {user.name}!</h1>}
    </div>
  );
}
```

在上述程式碼中，只有當使用者物件為真值時，才會呈現 `h1` 元素。

你也可以這樣使用直接的 `if` 述語：

```js
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  }
  return <h1>Please sign in</h1>;
}
```

## 在 React 中呈現列表

- 在建置使用者介面時，於 React 中呈現列表是一項常見任務。
- 列表可以使用 JS 陣列的 `map()` 方法來迭代陣列中的項目，並傳回新的 JSX 元素陣列。
- 例如，如果你有一個想要呈現為列表的名字陣列，你可以這樣做：

```jsx
function NameList({ names }) {
  return (
    <ul>
      {names.map((name, index) => (
        <li key={`${name}-${index}`}>{name}</li>
      ))}
    </ul>
  );
}
```

- 請務必為每個列表項目提供唯一的鍵，以協助 React 管理更新和呈現的角色。透過這些技術，你可以在你的 React 應用程式中創建靈活、高效且動態的列表。

## React 中的行內樣式

- React 中的行內樣式允許你使用 JavaScript 物件直接套用 CSS 樣式到 JSX 元素。
- 要在 React 中套用行內樣式，你可以在 JSX 元素上使用 style 屬性。style 屬性接受一個物件，該物件的鍵是駝峰式命名的 CSS 屬性，值則是對應的值。以下是一個範例：

```js
function Greeting() {
  return (
    <h1
      style={{ color: 'blue', fontSize: '24px', backgroundColor: 'lightgray' }}
    >
      Hello, world!
    </h1>
  );
}

export default Greeting;
```

你也可以將樣式抽取到一個獨立的物件中，並以這種方式在 `style` 屬性中取用它：

```jsx
function Greeting() {

  const styles = {
    color: 'blue',
    fontSize: '24px',
    backgroundColor: 'lightgray'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- 行內樣式支援動態樣式，允許你根據 props 或 state 有條件地套用樣式。以下是一個範例，示範如何根據 prop 有條件地套用樣式：

```jsx
function Greeting({ isImportant }) {

  const styles = {
    color: isImportant ? 'red' : 'black',
    fontSize: isImportant ? '24px' : '16px'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- 在上述程式碼中，`color` 和 `fontSize` 樣式會根據 `isImportant` prop 有條件地設定。

## 在 React 中處理事件

- **合成事件系統**：這是 React 處理事件的方式。它作為原生的 `click`、`keydown` 和 `submit` 事件的外覆。React 中的事件處理常式使用駝峰式命名慣例。（例如 `onClick`、`onSubmit` 等）

以下是使用 React 中 `button` 元素的 `onClick` 屬性的範例：

```jsx
function handleClick() {
  console.log("Button clicked!");
}

<button onClick={handleClick}>Click Me</button>;
```

在 React 中，事件處理常式函式通常以前置式 `handle` 開頭，以顯示它們負責控制事件，例如 `handleClick` 或 `handleSubmit`。

當使用者動作觸發一個事件時，React 會將一個 Synthetic Event 物件傳遞給你的處理常式。這個物件的行為類似於原生的 Event 物件，提供像是 `type`、`target` 和 `currentTarget` 等屬性。

為了防止像瀏覽器重新整理這類的預設行為，例如在 `onSubmit` 事件期間，你可以呼叫 `preventDefault()` 方法：

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("Form submitted!");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>Submit</button>
</form>;
```

你也可以像這樣將處理常式函式包裝在箭頭函式中：

```jsx
function handleDelete(id) {
  console.log("Deleting item:", id);
}

<button onClick={() => handleDelete(1)}>Delete Item</button>;
```

## 使用狀態與 `useState` 掛鉤

- **狀態的定義**：在 React 中，狀態是一個包含組件資料的物件。當狀態更新時，組件將重新呈現。React 將狀態視為不可變的，這表示你不應該直接修改它。
- **`useState()` 掛鉤**：`useState` 掛鉤是一個讓你在函式組件中宣告狀態變數的函式（程式）。以下是基本語法：

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

在狀態變數中你有以下內容：

- `stateVariable` 保存目前的狀態值
- `setStateFunction`（設值函式）會更新狀態變數
- `initialValue` 設定初始狀態

這裡是一個完整的 `Counter` 組件範例：

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

## 算繪與 React 組件

- **定義**：在 React 中，算繪是組件出現在使用者介面（UI）中的處理程序，通常是瀏覽器。算繪處理程序包含三個階段：觸發、算繪和提交。

觸發階段發生在 React 偵測到某些東西已改變且使用者介面（UI）可能需要更新時。這種改變通常是由於 state 或 props 的更新。

一旦觸發發生，React 就會進入呈現階段。在這裡，React 會重新評估你的組件並決定要呈現什麼。為了做到這點，React 使用一個稱為虛擬 DOM 的輕量級「真實」DOM 複本。透過虛擬 DOM，React 可以快速檢查組件中需要變更的部分。

提交階段是 React 從虛擬 DOM 取得準備好的變更並將它們套用到真實 DOM 的階段。換句話說，這是你在螢幕上看到最終結果的階段。

## 在狀態中更新物件和陣列

- **更新狀態中的物件**：如果你需要更新狀態中的物件，則應該先建立一個新的物件或複製一個現有的物件，然後為該新物件設定狀態。任何放入狀態中的物件都應視為唯讀。以下是一個設定使用者姓名、年齡和城市的範例。`handleChange` 函式用於控制使用者資訊的更新：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **在狀態中更新陣列**：當在狀態中更新陣列時，重要的是不要使用像 `push()` 或 `pop()` 這類方法直接修改陣列。相反地，你應該在更新狀態時創建一個新的陣列：

```jsx
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

如果你想從陣列中移除條款，你應該使用 `filter()` 方法，該方法會在過濾掉你想移除的內容後傳回一個新的陣列：

```jsx
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## 使用 Refs 取用值

- **`ref` 屬性**：你可以透過使用 `ref` 屬性來存取 React 中的 DOM 節點。以下是一個示範如何使用 `ref` 來聚焦 `input` 元素的範例。`current` 屬性用於存取該 `ref` 的當前值：

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Focus;
```

## 使用 `useEffect` 掛鉤

- **`useEffect()` 掛鉤**：在 React 中，效果是指發生在組件算繪程序之外的任何事情。也就是說，任何 React 不會直接作為 UI 呈現一部分來控制的事情。常見範例包括擷取資料、更新瀏覽器分頁的標題、從瀏覽器的區域儲存讀取或寫入、取得使用者的位置，還有更多。這些操作會與外部世界互動，被稱為副作用。React 提供 `useEffect` 掛鉤，讓你控制這些副作用。`useEffect` 讓你在組件呈現或更新後執行一個函式。

```js
import { useEffect } from "react";

useEffect(() => {
 // Your side effect logic (usually a function) goes here
}, [dependencies]);
```

當組件呈現後，effect 函式（程式）會執行，而選用的 `dependencies` 引數控制 effect 執行的時機。

請注意，`dependencies` 可以是「反應值」（狀態、屬性、函式、變數等等）的陣列、空陣列，或完全省略。以下說明所有這些選項如何控制 `useEffect` 的運作方式：

- 如果 `dependencies` 是包含一個或多個反應值的陣列，則每當它們改變時，該 effect 就會執行。

- 如果 `dependencies` 是空陣列，`useEffect` 僅在組件首次呈現時執行一次。

- 如果你省略 `dependencies`，該效果會在組件每次呈現或更新時執行。

## 如何創建訂製掛鉤

- **訂製掛鉤**：訂製掛鉤允許你從組件中抽取可重複使用的邏輯，例如資料擷取、狀態管理、切換，以及像追蹤線上狀態這類的副作用。在 React 中，所有內建掛鉤都以字 `use` 開頭，因此你的訂製掛鉤也應該遵循相同的慣例。

這裡是一個建立 `useDebounce` 掛鉤的範例：

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

## 在 React 中使用表單

- **受控輸入**：這是指你將輸入欄位的值儲存在狀態中，並透過 `onChange` 事件更新它。這讓你能完全控制表單資料，並允許即時驗證和條件呈現。

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form>
    </>
  );
}

export default App;
```

- **非受控輸入**：非透過 `useState` 掛鉤處理輸入，HTML 中的非受控輸入會在 DOM 的協助下維護其自身的內部狀態。由於 DOM 控制輸入值，你需要使用 `ref` 取得輸入欄位的值。

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">Your</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">Submit</button>
   </form>
 );
}

export default App;
```

## 使用 `useActionState` 掛鉤

- **伺服端動作**：這些是會在伺服端執行的函式（程式），允許直接在伺服端處理表單，而不需要 API 端點。以下是一個來自 Next.js 應用程式的範例：

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `Hello, ${name}!` };
}
```

`"use server"` 指令將函式標記為伺服端動作。

- **`useActionState` 掛鉤**：此掛鉤會根據表單提交的結果更新狀態。以下是 `useActionState` 掛鉤的基本語法：

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` 是該動作傳回的當前狀態。
- `action` 是觸發伺服端動作的函式（程式）。
- `isPending` 是一個布林值，用來顯示該動作目前是否正在執行。
- `actionFunction` 參數就是伺服器動作本身。
- `initialState` 是表述動作執行前狀態起點的參數。
- `permalink` 是包含表單所修改的唯一頁面 URL 的選用字串。

## React 中的資料擷取

- **取得資料的選項**：在 React 中有許多不同的方法來取得資料。你可以使用原生的 Fetch API，或第三方工具如 Axios 或 SWR。
- **取得資料時常用的狀態變數**：無論你選擇哪種方式在 React 中取得你的資料，都有一些狀態你需要追蹤。第一個是資料本身。第二個會追蹤資料是否仍在取得中。第三個是用來捕捉在資料取得過程中可能發生的任何錯誤的狀態變數。

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

由於資料擷取是副作用，最好在 `useEffect` 掛鉤內使用 `Fetch API`。

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      
      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

然後，如果資料擷取尚未完成，你可以呈現載入訊息；如果擷取資料時發生錯誤，你可以呈現錯誤訊息；或者呈現結果。

```jsx
if (loading) {
  return <p>Loading...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

如果你想使用 Axios，你需要安裝並匯入它：

```bash
npm i axios
```

```js
import axios from "axios";
```

然後你可以使用 `axios.get` 來取得資料：

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

要使用 `useSWR` 掛鉤來擷取資料，你需要先安裝並匯入它。

```bash
npm i swr
```

```js
import useSWR from "swr";
```

以下是你如何使用該掛鉤來擷取資料：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>Loading...</h2>;
 }
 if (error) {
   return <h2>Error: {error.message}</h2>;
 }

 return (
   <>
     <h2>Todos</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## 使用 `useOptimistic` 掛鉤

- **`useOptimistic` 掛鉤**：此掛鉤用於在等待非同步動作在背景完成時保持使用者介面回應迅速。它有助於管理 UI 中的「樂觀更新」，這是一種根據動作的預期結果（例如等待伺服端回應）立即更新 UI 的策略。

這是基本語法：

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` 是立即更新的暫時狀態，以提供更好的使用者體驗。
- `addOptimistic` 是在實際狀態變更之前套用樂觀更新的函式（程式）。
- `actualState` 是來自動作結果的真實狀態值，例如從伺服器擷取資料。
- `updateFunction` 是決定在被呼叫時樂觀狀態應如何更新的函式（程式）。

以下是如何在 `TaskList` 組件中使用 `useOptimistic` 掛鉤的範例：

```js
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**：這用於呈現 UI 的零件，並將狀態更新標記為非緊急的過渡。這讓 UI 在耗費資源的更新期間保持回應。以下是基本語法：

```js
startTransition(action)
```

`action` 執行狀態更新或觸發某些與轉換相關的邏輯。這確保緊急的 UI 更新（例如輸入或點擊）不會被阻擋。

## 使用 `useMemo` 掛鉤

- **備忘錄化**：這是一種優化技術，根據特定的引數將昂貴函式（程式）呼叫的結果快取（記憶）。當再次提供相同的引數時，會傳回快取的結果，而非重新計算函式。
- **`useMemo` 掛鉤**：此掛鉤用於記憶計算後的值。以下是一個記憶排序大型陣列結果的範例。只有當 `largeArray` 改變時，`expensiveSortFunction` 才會執行：

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## 使用 `useCallback` 掛鉤

- **`useCallback` 掛鉤**：這用於記憶函式（程式）引用。

```js
const handleClick = useCallback(() => {
 // code goes here
}, [dependency]);
``` 

- **`React.memo`**：這用於將組件記憶化，以防止當其 prop 未改變時發生不必要的重新呈現。

```js
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* Presentation */}
   </>
 )
});
``` 

## 相依性管理工具

- **相依性定義**：在軟體中，相依性是指應用程式中的一個組件或模組依賴另一個組件或模組才能正常運作。相依性在軟體應用程式中很常見，因為它們允許開發者使用其他人創建的預先建置函式或工具。React 專案所需的兩個核心相依項將是 `react` 和 `react-dom` 軟體包：

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **軟體包管理器定義**：為了管理專案中的軟體依賴性，你需要使用軟體包管理器。軟體包管理器是一種用於安裝、更新和移除依賴性的工具。許多流行的程式設計語言如 JavaScript、Python、Ruby 和 Java 都使用軟體包管理器。JavaScript 的熱門軟體包管理器包括 npm、Yarn 和 pnpm。
- **`package.json` 檔案**：這是在專案中一個關鍵的設定檔案，包含有關你的專案的詮釋資料，包括其名稱、版本和相依性。它也定義了腳本、授權資訊以及其他有助於管理專案及其相依性的設定。
- **`package-lock.json` 檔案**：此檔案會鎖定你的專案所使用的所有軟體包的確切版本。當你更新軟體包時，新的版本也會在鎖定檔案中更新。
- **`node_modules` 資料夾**：此資料夾包含你在 `package.json` 檔案中列出的相依性實際程式碼，包括你專案的直接相依性以及那些相依性的任何相依性。
- **開發相依性**：這些是只用於開發而非生產環境的軟體包。舉例來說，像 Jest 這樣的測試函式庫就是一個例子。你會將 Jest 安裝為開發相依性，因為它是用來在區域測試你的應用程式所需，但在生產環境執行應用程式時不需要。

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **介紹**：React Router 是一個第三方函式庫，允許你為你的 React 應用程式添加路由。要開始，你需要在現有的 React 專案中安裝 React Router，如下所示：

```bash
npm i react-router
```

然後在 `main.jsx` 或 `index.jsx` 檔案內，你需要像這樣設定路由結構：

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

`path` 和 `element` 用於將 URL 與 UI 組件連結在一起。在這種情況下，我們正在為首頁設定一條指向 `App` 組件的路由。 

- **多重視圖與路由設定**：在較大型的應用程式中，常見會像這樣設定多個視圖與路由：

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

這些範例中的 `index` prop 是用來表述給定路徑段的預設路由。因此，`Home` 組件會在根目錄 `/` 路徑顯示，而 `ProductsHome` 組件會在 `/products` 路徑顯示。

- **巢狀路由**：你可以將路由巢狀在其他路由內，這會導致子路由的路徑附加到父路由的路徑上。

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

在上述範例中，熱門商品的路徑將會是 products/trending。

- **動態區段**：動態區段是 URL 路徑中任何零件是動態的部分。

```jsx
<Route path=":category" element={<Category />} />
```

在此範例中，我們有一個名為 `category` 的動態區段。當使用者導覽到像 products/brass-instruments 這樣的 URL 時，畫面將切換到 `Category` 組件，並且你可以根據該區段動態擷取適當的資料。

- **`useParams` 掛鉤**：此掛鉤用於存取 URL 路徑中的動態參數。

```js
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
   {/* Accessing the category param: params.category */}
   {/* rest of code goes here */}
}
```

## React 框架

- **介紹**：React 框架提供路由、影像優化、資料擷取、身份驗證等特性。這表示在某些使用情境下，你可能不需要設定獨立的前端和後端應用程式。React 框架的範例包括 Next.js 和 Remix。
- **Next.js 路由**：此路由系統包含對動態路由、平行路由、路由處理常式、重新導向、國際化等的支援。

以下是建立訂製請求處理常式的範例：

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Next.js 影像優化**：`Image` 組件擴充了原生的 HTML `img` 元素，並允許更快速的頁面載入和大小優化。這表示影像只有在進入視窗時才會載入，且 `Image` 組件會自動為每個裝置提供正確尺寸的影像。

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
``` 

## 屬性傳遞

- **定義**：Prop drilling 是將 props 從父組件傳遞到深層巢狀子組件的處理程序，即使某些子組件不需要這些 props。

## 狀態管理

- **Context API**：背景關係指的是當父組件讓資訊可供子組件使用，而不需要透過 props 明確地傳遞。`createContext` 用於創建一個背景關係物件，該物件表述其他組件將會讀取的背景關係。`Provider` 用於將背景關係值提供給子組件。

```js
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**：Redux 透過提供一個中央儲存庫和對狀態更新的嚴格控制來處理狀態管理。它使用一個可預測的樣式，包含 actions、reducers 和 middleware。Actions 是將資料從你的應用程式傳送到 Redux 儲存庫的資訊有效負載，通常由使用者互動觸發。Reducers 是指定狀態應如何因應這些 actions 而改變的函式（程式），確保狀態以不可變的方式更新。另一方面，Middleware 則充當 action 分派與 reducer 之間的橋樑，允許你擴充 Redux 的功能（例如，記錄、控制非同步操作），而不修改核心流程。

- **Zustand**：這個狀態管理解決方案非常適合中小型應用程式。它透過使用 `useStore` 掛鉤直接在組件和頁面中存取狀態。這讓你可以在不需要 actions、reducers 或 provider 的情況下修改和存取資料。

## 使用 React DevTools 偵錯 React 組件

- **React Developer Tools**：這是一個瀏覽器擴充套件，你可以在 Chrome、Firefox 和 Edge 中使用它來檢查 React 組件並識別效率問題。對於 Safari，你需要安裝 `react-devtools` npm 軟體包。安裝 React DevTools 並在瀏覽器中開啟 React 應用程式後，開啟瀏覽器開發者工具即可存取為偵錯 React 所提供的兩個額外分頁－Components 和 Profiler。
- **組件 標籤**：此標籤以樹狀檢視格式顯示每個組件給你。在此標籤中你可以執行以下操作：
  - 檢視應用程式的組件階層體系
  - 即時檢查並修改 props、states 和 context 值
  - 檢查每個所選組件的原始碼
  - 將組件資料記錄到主控台
  - 檢查該組件的 DOM 元素
- **效能(效率)評測器分頁**：此分頁可協助你分析組件效率。你可以記錄組件效率，以便識別不必要的重新呈現、查看提交持續時間，並隨後最佳化緩慢的組件。

## React 伺服端組件

- **定義**：React Server Components 是只在伺服端呈現的 React 組件，僅將最終的 HTML 傳送到客戶端。這表示那些組件可以直接存取伺服端資源，並大幅減少傳送到瀏覽器的 JavaScript 數量。

## 實際效率與感知效率之間的差異

- **感知效率**：這是使用者對網站效率的感受。這是他們在回應速度和可靠性方面對網站的評估。這是一種主觀的衡量方式，因此很難量化，但非常重要，因為使用者體驗決定網站的成敗。
- **真實效率**：這是網站的客觀且可衡量的效率。它是使用像是頁面載入時間、伺服端回應時間和呈現時間等指標來衡量。這些測量受到多種與網路及程式碼本身相關的因素影響。

## 提升感知效率的技巧

- **Lazy Loading**：此技術透過在背景載入非必要資源，盡可能減少初始載入時間。
- **最小化字型延遲**：如果你的網站有訂製字型，你也應該嘗試最小化字型載入延遲，因為這可能導致閃爍或在訂製字型載入時顯示替代字型。建議使用與訂製字型相似的替代字型，這樣如果發生此情況，變化會比較細微。
- **載入指示器的使用**：當使用者點擊元素後立即顯示長時間執行的處理程序的載入指示器，可以幫助使用者感受到與處理程序的連結與參與，讓等待時間感覺較短。

## 核心效率、性能概念

- **原始碼順序**：這是指 HTML 元素在文件中的結構方式。這決定了什麼先載入，並且會顯著影響效率和存取。

有關原始碼順序的一些最佳實踐包括：

- 將標題、導覽或主要文字等關鍵內容置於 HTML 結構的較高位置。
- 延緩非必要的腳本，例如用於分析或第三方小工具的腳本，以免它們阻礙呈現。
- 使用漸進式增強，以確保即使在樣式和腳本載入之前，核心體驗仍能運作。漸進式增強是一種建置網站和應用程式的方法，基於你應該先讓你的頁面能夠使用 HTML 運作的理念。

這裡是一個良好原始碼順序的範例，使用我們剛剛介紹的最佳實踐：

```html
<h1>Welcome to FastSite!</h1>
<p>Critical information loads first.</p>
<script src="slow-script.js" defer></script>
```

- **關鍵呈現路徑**：這是瀏覽器將程式碼轉換成螢幕上像素所遵循的步驟序列。
- **延遲**：這是請求在瀏覽器和伺服器之間傳輸所需的時間。換句話說，延遲高代表頁面載入緩慢。

減少延遲的一些方法包括：

- 使用 CDN，或內容傳遞網路，從較近的位置提供檔案。
- 啟用壓縮，例如使用 Gzip，以減少檔案大小。
- 優化影像並使用延遲載入。

```html
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
```

## 改善 INP

- **定義**：INP（Interaction to Next Paint）透過測量使用者交談（例如點擊或按鍵）到瀏覽器下一次更新顯示的時間，評估頁面的整體回應速度。較低的 INP 表示頁面回應更迅速。

以下是改善 INP 的一些方法：

- 透過拆分冗長的 JavaScript 任務來減少主執行緒工作量。
- 為非關鍵腳本使用 `requestIdleCallback()`。這將將函式（程式）加入佇列，以便在瀏覽器閒置期間被呼叫。
- 延緩或延遲載入先前涵蓋的龐大資產。
- 最佳化事件處理常式。如果這些處理常式執行過於頻繁或執行繁重的操作，可能會使頁面變慢並增加 INP。這個解法是使用防彈跳（debouncing）。防彈跳確保函式只會在使用者停止輸入後經過短暫延遲才執行－例如 300 毫秒。這可以避免不必要的計算並提升效率。

## 瀏覽器中呈現的運作方式

- **呈現的運作方式**：瀏覽器首先解析 HTML 並建置 DOM。接著，瀏覽器處理 CSS，構築 CSS 物件模型（CSSOM）。這是另一個樹狀結構，用以決定元素應該如何被樣式化。最後，瀏覽器將像素繪製到螢幕上，根據計算出的樣式和版面配置呈現每個元素。在複雜的頁面中，這可能涉及多個圖層，這些圖層會被合成在一起以形成最終的視覺輸出。

## 效率、性能如何影響永續性

- **背景資訊**：網際網路約佔全球碳排放量的 2％——這與航空業相同！每個傳輸的位元組都需要電力，從資料中心到使用者裝置。較大的檔案和低效的腳本意味著更多的電力消耗。高效率的網站不僅更快，還能減少不必要的處理程序和能源使用。

## 減少頁面載入時間的方法

- **最佳化媒體資產**：大型影像和影片是造成載入速度緩慢的常見原因。透過最佳化這些資產，你可以大幅提升網站速度。這包括壓縮影像、使用像是 WebP 這類現代格式，以及對資產使用延遲載入。
- **利用瀏覽器快取**：快取允許瀏覽器將你網站的零件區域的儲存，減少回訪者的載入時間。
- **縮小與壓縮檔案**：減少你的檔案大小可以加快下載速度。這包括減少傳輸檔案的大小以及縮小 CSS 和 JavaScript 檔案。

## 改善「可用時間」

- **定義**：「time to usable」是指從使用者請求頁面到他們能有意義地互動之間的時間間隔。為了改善「time to usable」，你可以延遲載入你的資源或最小化阻礙算繪的資源。

## 衡量效率的關鍵指標

- **First Contentful Paint 或 FCP**：它衡量第一個內容—文字或影像—在螢幕上出現的速度。良好的 FCP 被視為在 1.8 秒以下，差的 FCP 則超過 3 秒。你可以使用 Chrome DevTools 並檢查效率標籤來查看你的 FCP。
- **總阻塞時間**：這顯示主執行緒被大量 JavaScript 任務阻塞的時間長度。如果總阻塞時間（TBT）很高，使用者會感受到互動遲緩。為了改善 TBT，請將長任務拆分並延緩非必要的腳本。
- **跳出率**：這是沒有互動就離開的訪客百分比。如果你的網站跳出率很高，可能是因為你的頁面太慢。
- **獨立使用者**：此指標追蹤有多少個別訪客造訪你的網站。若要查看跳出率和獨立使用者，你可以使用 Google Analytics。它將允許你監控這些指標並提升互動率。

## 常見的效率測量工具

- **Chrome DevTools**：Chrome DevTools 是 Google Chrome 內建的工具，讓你可以即時分析和偵錯效率。DevTools 會顯示載入時間、CPU 使用率和算繪延遲。它對於測量 First Contentful Paint（FCP）特別有用，FCP 是使用者看到第一個可見內容的速度。如果你的网站感覺緩慢，DevTools 將幫助你找出瓶頸。
- **Lighthouse**：這是一個自動化工具，用來檢查效率、SEO 和存取。
- **WebPageTest**：這個工具讓你測試你的網站從不同地點和裝置載入的情況。這個工具會詳細分解你網站的 Speed Index、Total Blocking Time 以及其他關鍵效率指標。如果你想知道真實使用者在全球範圍內如何體驗你的網站，WebPageTest 就是適合的工具。
- **PageSpeed Insights**：此工具會分析你的網站，並針對行動裝置和桌面裝置提出快速改進建議。它會告訴你是什麼因素拖慢你的網站，並提供具體建議，例如優化影像、移除阻礙呈現的腳本，以及減少伺服器回應時間。PageSpeed Insights 是檢查 Google 如何看待你網站效率的快速且簡單的方法。
- **真實使用者監控**：RUM 工具追蹤實際使用者行為，顯示真實訪客如何體驗你的網站。常見的 RUM 工具包括 Google Analytics，它追蹤頁面載入時間和跳出率，以及 New Relic 或 Datadog，它們監控即時效率問題。如果你想要來自實際使用者的資料，RUM 工具是必不可少的。

## 使用效率、性能 Web API

- **定義**：Performance Web APIs 讓開發者能直接在程式碼中追蹤網頁載入和回應的效率。這些 APIs 允許你測量頁面載入時間、追蹤呈現和互動延遲，以及分析 JavaScript 執行時間。
- **`performance.now()`**：此 API 提供高精度時間戳（以毫秒為單位），用來測量你網站不同零件載入所需的時間。

```js
const start = performance.now();  
// Run some code here  
const end = performance.now();  

console.log(`Execution time: ${end - start}ms`);
```

- **效率 Timing API**：此 API 提供從 DNS 查詢到 `DOMContentLoaded` 的每個頁面載入階段的詳細分析。

```js
const timing = performance.timing;  

const pageLoadTime = timing.loadEventEnd - timing.navigationStart;  
console.log(`Page load time: ${pageLoadTime}ms`);
```

- **`PerformanceObserver`**：此 API 監聽效能事件，例如版面配置移動、長時間任務和使用者互動。

```js
const observer = new PerformanceObserver((list) => {  
  list.getEntries().forEach((entry) => {  
    console.log(`Long task detected: ${entry.duration}ms`);  
  });  
});  

observer.observe({ type: "longtask", buffered: true });
```

## 提升 CSS 效率、性能的技術

- **CSS 動畫**：動畫化某些 CSS 屬性，例如尺寸、位置和佈局，會觸發一個稱為「reflow」的處理程序，在此期間瀏覽器會重新計算頁面上某些元素的位置和幾何形狀。這需要重新繪製，這在計算上相當昂貴。因此，建議盡可能減少 CSS 動畫的數量，或至少為使用者提供一個選項，可切換開啟或關閉它們。

## 提升 JavaScript 效率、性能的技巧

- **程式碼分割**：將你的 JavaScript 程式碼拆分成執行關鍵和非關鍵任務的模組也很有幫助。這樣，你就能盡快預先載入關鍵模組，並延緩非關鍵模組，以盡可能快速地呈現頁面。
- **DOM 操作**：請記住，DOM 操作是指透過與文件物件模型（DOM）互動，使用 JavaScript 動態變更頁面內容的處理程序。操作 DOM 是計算成本高昂的。透過減少你在 JavaScript 程式碼中進行的 DOM 操作量，將提升效率。

## CSS 框架

- **CSS 框架**：CSS 框架可以加快你的工作流程，為整個網站創建統一的視覺風格，使你的設計在多個瀏覽器中保持一致，並讓你的 CSS 程式碼更有條理。
- **熱門的 CSS 框架**：一些熱門的 CSS 框架有 Tailwind CSS、Bootstrap、Materialize 和 Foundation。
- **潛在缺點**：
  - 框架提供的 CSS 可能會與你的訂製 CSS 衝突。
  - 你的網站可能看起來與使用相同框架的其他網站相似。
  - 大型框架可能會導致效率問題。

## 兩種 CSS 框架型別

- **以工具為先的 CSS 框架**：這些框架具有具有特定用途的小類別，例如設定邊距、內距或背景顏色。你可以根據需要將這些小類別直接指定到 HTML 元素。Tailwind CSS 被歸類為以工具為先的 CSS 框架。

這裡是一個使用 Tailwind CSS 來設計按鈕的範例。

```html
<button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700">
  Button
</button>
```

- **基於組件的 CSS 框架**：這些框架具有預先建置且帶有預定義樣式的組件，你可以將它們添加到你的網站中。這些組件可在 CSS 框架的官方文件中取得，你可以將它們複製並貼上到你的專案中。Bootstrap 被歸類為基於組件的 CSS 框架。

這裡是一個使用 Bootstrap 來建立列表群組的範例。你將為你的 HTML 元素添加整個組件，包括 HTML 結構，而不是套用小型類別。

```html
<div class="card" style="width: 25rem;">
  <ul class="list-group list-group-flush">
    <li class="list-group-item">HTML</li>
    <li class="list-group-item">CSS</li>
    <li class="list-group-item">JavaScript</li>
  </ul>
</div>
```

## Tailwind CSS

Tailwind 是一個以工具為先的 CSS 框架。你不需要撰寫訂製的 CSS 規則，而是透過直接在你的 HTML 中組合小型工具類別來建置你的設計。

### 響應式設計工具

Tailwind 使用像是 `sm:`、`md:` 和 `lg:` 這樣的前置式，在不同的螢幕尺寸套用樣式。

```html
<div class="w-full md:w-1/2 lg:flex-row">
  Responsive layout
</div>
```

### Flexbox 工具

像 `flex`、`flex-col`、`justify-around` 和 `items-center` 這類的類別讓創建彈性佈局變得簡單。

```html
<div class="flex flex-col md:flex-row justify-around items-center">
  <p>Column on small screens</p>
  <p>Row on medium and larger screens</p>
</div>
```

### 網格工具

Tailwind 包含用於 CSS Grid 的工具類別，例如 `grid`、`grid-cols-1` 和 `md:grid-cols-3`。

```html
<div class="grid grid-cols-1 md:grid-cols-3 gap-8">
  <div class="bg-gray-100 p-4">Column 1</div>
  <div class="bg-gray-100 p-4">Column 2</div>
  <div class="bg-gray-100 p-4">Column 3</div>
</div>
```

### 間距工具

像 `mt-8`、`mx-auto`、`p-4` 和 `gap-4` 這樣的工具類別有助於在不撰寫 CSS 的情況下創建一致的間距。

```html
<div class="mt-8 p-4 bg-indigo-600 text-white">
  Spaced content
</div>
```

### 排版工具

像 `uppercase`、`font-bold`、`font-semibold` 和 `text-4xl` 這類工具可控制文字外觀。

你可以設定會在中斷點調整的字型大小，例如 `text-3xl` 和 `md:text-5xl`。

```html
<h1 class="text-3xl md:text-5xl font-semibold text-center">
  Responsive Heading
</h1>
```

### 顏色和暫留狀態

Tailwind 提供了廣泛的顏色調色盤，例如 `text-red-700`、`bg-indigo-600` 和 `bg-gray-100`。

像 `hover:bg-pink-600` 這樣的類別讓互動效果變得簡單。

```html
<a href="#" class="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-md">
  Hover Me
</a>
```

### 邊框、環形和效果

- **邊框**：`border-2 border-red-300` 添加具有指定厚度和顏色的邊框。
- **Rings**：`ring-1 ring-gray-300` 產生類似輪廓的效果，常用於聚焦或卡片。
- **圓角和縮放**：像 `rounded-md`、`rounded-xl` 和 `scale-105` 這類的類別添加了精緻感。

```html
<div class="p-6 rounded-xl ring-2 ring-fuchsia-500 scale-105">
  Highlighted card
</div>
```

### 漸層

Tailwind 支援（某功能）像是 `bg-gradient-to-r from-fuchsia-500 to-indigo-600` 的漸層工具。

```html
<div class="p-4 text-white bg-gradient-to-r from-fuchsia-500 to-indigo-600">
  Gradient background
</div>
```

## CSS 前處理器

- **CSS 前處理器**：CSS 前處理器是一種擴充標準 CSS 的工具。它會將具有擴充語法的程式碼編譯成原生的 CSS 檔案。它有助於為複雜的專案撰寫更乾淨、可重複使用、較少重複且可擴充的 CSS。
- **特性**：CSS 預處理器可以提供的一些特性包括 `variables`、`mixins`、巢狀結構，以及選擇器 `inheritance`。
- **熱門的 CSS 前處理器**：一些熱門的 CSS 前處理器有 Sass、Less 和 Stylus。
- **潛在缺點**：
  - 將 CSS 規則編譯成標準 CSS 可能會造成額外負擔。
  - 編譯後的程式碼可能難以偵錯。

## Sass

- **Sass**：它是最受歡迎的 CSS 預處理器之一。Sass 代表「語法超棒的樣式表」。
- **Sass 支援的特性**：Sass 支援像是變數、巢狀 CSS 規則、模組、混入、繼承，以及用於基本數學運算的運算子等特性。

## Sass 支援的兩種語法

- **SCSS 語法**：SCSS（Sassy CSS）擴充了 CSS 的基本語法。它是 Sass 最廣泛使用的語法。SCSS 檔案具有 `.scss` 擴充套件。

這裡是一個在 SCSS 中定義和使用變數的範例。

```scss
$primary-color: #3498eb;

header {
  background-color: $primary-color;
}
```

- **縮排語法**：縮排語法是 Sass 最初的語法，也被稱為「Sass 語法」。

這裡是一個在縮排語法中定義和使用變數的範例。

```sass
$primary-color: #3498eb

header
  background-color: $primary-color
```

### 混入物

- **Mixins**：Mixins 允許你將多個 CSS 屬性及其值群組在名稱下，並在你的樣式表中重複使用該區塊的 CSS 程式碼。

這裡是一個使用 SCSS 語法定義 mixin 的範例。在此案例中，mixin 名為 `center-flex`。它有三個 CSS 屬性，用於使用 flexbox 將元素置中。

```scss
@mixin center-flex {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

這裡是一個使用你定義的 mixin 的範例。

```scss
section {
  @include center-flex;
  height: 500px;
  background-color: #3289a8;
}
```

## 手動與自動化測試

- **手動測試**：在手動測試中，測試人員會手動檢查應用程式的每個零件並測試不同的特性，以確保其正常運作。如果在測試過程中發現任何錯誤，測試人員會將這些錯誤回報給軟體團隊，以便修正。
- **自動化測試**：在自動化測試中，你可以透過撰寫獨立的程式來自動化你的測試，以檢查你的應用程式是否如預期般運作。

## 單元測試

- **單元測試**：在單元測試中，你會測試每個函式（程式）以確保一切如預期般運作。單元測試也可以作為你的應用程式的文件形式，因為它們旨在表述你的程式碼的預期行為。
- **單一職責原則**：單一職責原則建議保持每個函式（程式）小且只負責一件事。
- **常見的 JavaScript 測試框架**：一些常見的測試框架包括 Jest、Mocha 和 Vitest。Jest 是一個用於單元測試的熱門測試框架。

這裡是一個使用 Jest 的單元測試範例。

首先，你可以創建一個負責傳回新格式化字串的函式（程式）：

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

在一個獨立的 `getFormattedWord.test.js` 檔案中，你可以撰寫一些測試來驗證該函式是否如預期運作。`getFormattedWord.test.js` 檔案會長這樣：

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **`expect` 函式（程式）**：`expect` 函式（程式）用於測試一個值。
- **Matcher**：Matcher 是一個用來檢查值是否符合預期行為的函式（程式）。在上述範例中，matcher 是 `toBe()`。Jest 有各種不同的 matcher。

要使用 Jest，你首先需要使用 `npm i jest` 安裝 `jest` 軟體包。你還需要在你的 `package.json` 檔案中添加像這樣的腳本：

```js
"scripts": {
  "test": "jest"
},
```

然後，你可以執行指令 `npm run test` 來執行你的測試。

## 軟體開發生命週期

- **軟體開發生命週期的不同階段**：
  - **規劃階段**：開發團隊從利害關係人收集擬議工作的需求。
  - **設計階段**：軟體團隊將需求拆解並決定最佳的解決方案方法。
  - **實作階段**：軟體團隊將需求拆解成可管理的任務並加以實作。
  - **測試階段**：這包括對新工作進行手動和自動測試。有時，團隊會在整個開發階段中測試應用程式，以捕捉並修正任何出現的問題。
  - **部署階段**：團隊將新的變更部署到建置或測試環境。
  - **維護階段**：這涉及修復生產應用程式中客戶所提出的任何問題。

- **軟體開發生命週期的不同模型**：
  - **瀑布模型**：瀑布模型是指必須在下一階段開始之前完成生命週期的每個階段。
  - **敏捷模型**：敏捷模型專注於透過將工作拆分為衝刺來進行反覆的開發。

## BDD 和 TDD

- **TDD**：測試驅動開發是一種強調先撰寫測試的開發方法。在建置特性之前撰寫測試，能在開發過程中為開發者提供即時回授。
- **BDD**：行為驅動開發是一種將一系列測試與商務目標對齊的方法。BDD 中的測試情境應該使用技術人員和非技術人員都能理解的語言撰寫。這種語法的範例是 Gherkin。
- **BDD 測試框架**：BDD 測試框架的範例包括 Cucumber、JBehave 和 SpecFlow。

## 單元測試中的斷言

- **斷言**：斷言用於測試程式碼是否如預期般運作。
- **斷言函式庫**：Chai 是一個常用的斷言函式庫。其他常見的 JavaScript 斷言函式庫有 `should.js` 和 `expect.js`。

以下是使用 Chai 的斷言範例，檢查 `addThreeAndFour` 函式的返回值是否相等於數字 7：

```js
assert.equal(addThreeAndFour(), 7);
```

- **最佳實務**：無論你使用哪個斷言函式庫，都應該撰寫清楚的 assert 和 failure 訊息，以幫助你了解哪些測試失敗以及原因。

## 模擬、偽造和存根

- **模擬**：模擬是用假資料取代真實資料以模擬真實組件行為的過程。<dfn>例如</dfn>，你可以在測試中模擬 API 回應，而不是持續呼叫 API 來取得資料。
- **Stubbing**：Stub 是會傳回預先定義回應或虛擬資料的物件，用於應用程式中預期行為。<dfn>例如</dfn>，你可以在測試中為資料庫連接的行為建立 stub，而不必依賴實際的資料庫連接。
- **Faking**：Fakes 是真實組件的簡化版本，沒有複雜性或副作用。<dfn>例如</dfn>，你可以透過將資料儲存在記憶體中，而非與真實資料庫互動，來假造一個資料庫。這將允許你在記憶體中模擬資料庫操作，速度會比處理真實資料庫快得多。

## 功能測試

- **功能測試**：功能測試檢查應用程式的特性和函式（程式）是否如預期運作。功能測試的目標是針對多個情境測試整個系統。
- **非功能性測試**：非功能性測試專注於效率、性能和可靠性等方面。
- **冒煙測試**：冒煙測試是在開始更廣泛測試之前，對系統進行基本或關鍵問題的初步檢查。

## 端對端測試

- **端對端測試**：端對端測試，或稱 E2E，從使用者的角度測試真實世界的情境。端對端測試有助於確保你的應用程式行為正確且對使用者可預測。然而，設定、設計和維護需要花費大量時間。
- **端對端測試框架**：Playwright 是由 Microsoft 開發的熱門端對端測試框架。其他端對端測試工具的例子包括 Cypress、Selenium 和 Puppeteer。

這裡是一個來自 freeCodeCamp 程式碼庫使用 Playwright 的 E2E 測試範例。`beforeEach` 掛鉤會在每個測試之前執行。這些測試會檢查捐贈者在選單列中是否有支持者聯結，以及他們的頭像周圍是否有特殊樣式的邊框：

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## 可用性測試

- **可用性測試**：可用性測試是指讓真實使用者與應用程式互動，以發現應用程式中是否存在任何設計、使用者體驗或功能問題。可用性測試著重於使用者對應用程式直覺性的評估。
- **四種常見的可用性測試型別**：
  - **探索性**：探索性可用性測試涉及使用者與應用程式的不同特性互動，以更好地了解它們的運作方式。
  - **比較測試**：比較測試是指你將你的應用程式的使用者體驗與市場上類似的應用程式進行比較。
  - **評估**：評估測試是研究應用程式使用直覺性的過程。
  - **驗證**：驗證測試是用來識別任何會阻止使用者有效使用應用程式的重大問題。
- **可用性測試工具**：可用性測試的工具範例包括 Loop11、Maze、Userbrain、UserTesting 和 UXTweak。

## 相容性測試

- **相容性測試**：相容性測試的目標是確保你的應用程式能在不同的運算環境中運作。
- **不同型別的相容性測試**：
  - **向後相容性**：向後相容性是指軟體與較早版本相容。
  - **向前相容性**：向前相容性是指軟體和系統能與未來版本一起運作。
  - **硬體相容性**：硬體相容性是軟體在不同硬體組態中正常運作的能力。
  - **作業系統相容性**：作業系統相容性是指軟體能在不同作業系統上運作的能力，例如 macOS、Windows 以及像 Ubuntu 和 Fedora 這樣的 Linux 發行版。
  - **網路相容性**：網路相容性表示軟體能在不同的網路條件下運作，例如不同的網路速度、協定、安全設定等。
  - **瀏覽器相容性**：瀏覽器相容性是指網頁應用程式能在不同瀏覽器（例如 Google Chrome、Safari、Firefox 等）中一致運作。
  - **行動相容性**：確保你的軟體應用程式能在各種 Android 和 iOS 裝置（包括手機和平板電腦）上運作非常重要。

## 效率測試

- **效率測試**：在效率測試中，你會測試應用程式在不同工作負載下的速度、回應能力、可擴充性和穩定性。目標是決議任何型別的效率瓶頸。
- **不同型別的效率測試**：
  - **載入測試**：載入測試用來判斷系統在正常及高峰載入時間的行為。
  - **壓力測試**：壓力測試是指在極端負載下測試你的應用程式，並觀察你的系統對較高負載的反應能力。
  - **浸泡測試（耐力測試）**：浸泡測試或耐力測試是一種載入測試，透過在較長時間內以較高載入測試系統。
  - **尖峰測試**：尖峰測試是指你劇烈增加和減少負載，並分析系統對這些變化的反應。
  - **中斷點測試（容量測試）**：中斷點測試或容量測試是指你隨著時間慢慢增加載入，直到系統開始失效或降級的過程。

## 安全測試

- **安全測試**：安全測試有助於識別漏洞和弱點。
- **安全原則**：
  - **機密性**：這可防止敏感資訊洩漏給非預期的收件者。
  - **完整性**：這涉及防止惡意使用者修改使用者資訊。
  - **身份驗證**：這涉及驗證使用者的身分，以確保他們被允許使用該系統。
  - **授權**：這是決定已驗證使用者被允許執行哪些動作或被允許存取系統哪些零件的處理程序。
  - **可用性**：這確保資訊和服務在使用者需要時可供授權使用者使用。
  - **不可否認性**：這確保寄件者和收件者雙方都有交付證明及寄件者身份的驗證。它防止寄件者否認曾經傳送過該資訊。
- **常見的安全威脅**：
  - **跨站指令碼攻擊（XSS）**：當攻擊者將惡意指令碼注入網頁，並在受害者瀏覽器的上下文中執行時，就會發生 XSS 攻擊。
  - **SQL 注入**：SQL 注入允許惡意使用者將惡意程式碼注入到資料庫中。
  - **拒絕服務攻擊（DoS）**：DoS 攻擊是指惡意使用者以大量請求或流量淹沒網站，導致伺服器變慢甚至當機，使網站無法提供服務給使用者。
- **安全測試工具的類別**：
  - **靜態應用程式安全測試**：這些工具會評估應用程式的原始碼以識別安全漏洞。
  - **動態應用程式安全測試**：這些工具與應用程式的前端介面互動，以發現潛在的安全弱點。DAST 工具無法存取原始碼。
- **滲透測試 (pentest)**：滲透測試是一種安全測試，涉及對應用程式進行模擬的網路攻擊，以識別系統中的任何弱點。

## A/B 測試

- **A/B 測試**：A/B 測試涉及比較頁面或應用程式的兩個版本，並研究哪個版本表現較佳。它也被稱為桶測試或分割測試。A/B 測試讓你能夠做出更多以資料為依據的決策，並持續改善使用者體驗。
- **A/B 測試工具**：用於 A/B 測試的工具範例包括 GrowthBook 和 LaunchDarkly。

## Alpha 測試和 Beta 測試

當初始開發和軟體測試完成後，讓測試人員和真實使用者測試應用程式是很重要的。這就是 alpha 測試和 beta 測試的用途。

- **Alpha 測試**：Alpha 測試由一組特定的測試者進行，他們會檢查應用程式以確保在發布到市場之前沒有錯誤。Alpha 測試是驗收測試的一部分，並且同時使用白箱和黑箱測試技術。
- **Beta 測試**：Beta 測試是將應用程式提供給真實使用者的階段。使用者可以與應用程式互動並提供回授。Beta 測試也是一種使用者驗收測試。
- **驗收測試**：驗收測試確保軟體應用程式在發佈前符合商務需求和使用者需求。
- **黑盒測試**：黑盒測試僅關注應用程式的預期行為。
- **白箱測試**：白箱測試涉及測試者了解內部組件並對其進行測試。

## 回歸測試

- **回歸**：回歸指的是新變更無意中破壞現有功能的情況。
- **回歸測試**：回歸測試有助於捕捉回歸問題。在回歸測試中，你會對應用程式的零件重新執行功能測試，以確保一切仍然如預期般運作。
- **迴歸測試工具**：你可以使用的迴歸測試工具包括 Puppeteer、Playwright、Selenium 和 Cypress。
- **迴歸測試技術**：
  - **單元回歸測試**：這是指每次在應用程式中實作重大變更或修正時，都需要測試的一個項目列表。
  - **部分回歸測試**：這涉及標的方式，以確保新的變更沒有破壞應用程式的特定零件。
  - **完整回歸測試**：這會對程式碼庫中的所有功能執行測試。這是最耗時且最詳細的選項。
- **重新測試**：重新測試用於檢查已知問題並確保它們已被決議。相較之下，回歸測試則是搜尋可能因程式碼庫最近變更而產生的未知問題。

## 什麼是 TypeScript

- **JavaScript**：JavaScript 是一種動態型別語言。這表示變數可以在執行時接收任何值。動態型別語言的挑戰在於缺乏型別安全性，可能會引入錯誤。

例如，即使你的 JavaScript 函式（程式）期望一個陣列，你仍然可以用一個數字來呼叫它：

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

上述範例的 `console` 輸出將會是 `undefined`。

- **TypeScript**：TypeScript 擴充了 JavaScript 語言，加入靜態型別，幫助你在執行程式碼之前捕捉因型別不匹配而產生的錯誤。

例如，你可以為 `array` 參數定義一個型別，如下所示：

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

這個型別定義告訴 TypeScript，`array` 參數必須是字串的陣列。然後，當你呼叫 `getRandomValue` 並傳入一個數字時，你會得到一個稱為編譯器錯誤的錯誤。

- **編譯器**：你首先需要將 TypeScript 程式碼編譯成一般的 JavaScript。當你執行編譯器時，TypeScript 會評估你的程式碼，並在任何型別不匹配的問題上發出錯誤。

## TypeScript 中的資料型別

- **TypeScript 中的原始資料型別**：對於原始資料型別 `string`、`null`、`undefined`、`number`、`boolean` 和 `bigint`，TypeScript 提供相應的型別關鍵字。

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **陣列**：你可以用兩種不同的語法定義特定型別的陣列。

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **物件**：你可以定義物件的精確結構。

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

如果你想要一個具有任意鍵，但所有值必須是字串的物件，有兩種定義方式：

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **TypeScript 中的其他有用型別**：
  - **`any`**：`any` 顯示一個值可以有任何型別。它告訴編譯器停止關注該變數的型別。
  - **`unknown`**：`unknown` 告訴 TypeScript 你*確實*在意該值的型別，但你實際上不知道它是什麼。`unknown` 通常比 `any` 更受推薦。
  - **`void`**：這是一種特殊的型別，你通常只會在定義函式時使用。沒有返回值的函式使用 `void` 作為返回型別。
  - **`never`**：它表述一種永遠不會存在的型別。

- **`type` 關鍵字**：這個關鍵字類似於 `const`，但不是宣告變數，而是宣告一個型別。

它對於宣告訂製型別非常有用，例如聯集（數學）型別或只包含特定值的型別：

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interface`**：介面就像型別的類別。它們可以實作或擴充其他介面，特別是物件型別，且通常會被優先使用，除非你需要 `type` 宣告所提供的特定功能。

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **定義返回類型**：你也可以定義函式的*返回類型*。

以下範例將返回值定義為字串。如果你嘗試返回其他任何東西，TypeScript 將會產生編譯器錯誤。

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## 泛型

- **定義泛型**：你可以定義一個泛型並在你的函式中取用它。它可以被視為你提供給函式的一個特殊參數，用來控制函式型別定義的行為。

這裡是一個為函式定義泛型型別的範例：

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

`<T>` 語法告訴 TypeScript 你正在為函式定義一個泛型型別 `T`。`T` 是泛型型別的常用名稱，但你可以使用任何名稱。

然後，你告訴 TypeScript `array` 參數是符合泛型型別的值的陣列，且傳回值是相同型別的單一元素。

- **在函式呼叫中指定型別引數**：你可以在函式名稱和其參數之間使用尖括號傳遞型別引數。

這裡是一個將型別引數傳遞給函式呼叫的範例：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

這告訴 TypeScript 你預期找到的元素將會是輸入元素。

## 型別縮小

- **以真值進行縮小**：在以下範例中，你嘗試存取 `email` 的 `value` 屬性時會得到編譯器錯誤，因為 `email` *可能* 是 `null`。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

你可以使用條件述語來確認 `email` 是 *truthy*，然後再存取該屬性：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

真值檢查也可以反向運作：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

發出錯誤會結束此程式碼的邏輯執行，這表示當你到達 `console.log()` 呼叫時，TypeScript 知道 `email` *不可能* 是 `null`。

- **選用串鏈**：選用串鏈 `?.` 也是一種型別縮小，前提是如果 `email` 值為 `null`，則不會發生該屬性的存取。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **`typeof` 運算子**：你可以使用條件判斷來檢查變數的型別，方法是使用 `typeof` 運算子。

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **`instanceof` 關鍵字**：如果物件來自某個類別，你可以使用 `instanceof` 關鍵字來縮小型別。

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **類型轉換**：當 TypeScript 無法自動判斷一個值的型別，例如下面範例中 `request.json()` 方法的結果，你會遇到編譯器錯誤。解決此問題的一種方法是進行類型轉換，但這樣會削弱 TypeScript 偵測潛在錯誤的能力。

```typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **型別守衛**：你可以撰寫型別守衛，而不是進行型別轉換：

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

`user is User` 語法指出你的函式傳回布林值，當為 true 時表示 `user` 值符合 `User` 介面。

## `tsconfig` 檔案

- **`tsconfig.json`**：TypeScript 的編譯器設定存放在你的專案根目錄中的 `tsconfig.json` 檔案內。

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

以下是上述範例中使用的編譯器選項的說明：

- **`compilerOptions`**：`compilerOptions` 屬性是你控制 TypeScript 編譯器行為的地方。
- **`rootDir` 和 `outDir`**：`rootDir` 和 `outDir` 告訴 TypeScript 哪個目錄包含你的原始碼檔案，以及哪個目錄應該包含轉譯後的 JavaScript 程式碼。
- **`lib`**：`lib` 屬性決定編譯器使用哪些型別定義，並允許你包含對特定 ES 版本、DOM 等的支援。
- **`module` 和 `moduleResolution`**：`module` 和 `moduleResolution` 協同運作，以管理你的軟體包如何使用模組－無論是 CommonJS 還是 ECMAScript。
- **`esModuleInterop`**：`esModuleInterop` 允許 CommonJS 和 ES 模組之間更順暢的互通，方法是自動為匯入建立命名空間物件。
- **`skipLibCheck`**：`skipLibCheck` 選項會跳過驗證未被你的程式碼中匯入取用的 `.d.ts` 檔案。
- **`strict`**：`strict` 旗標會啟用多項檢查，例如確保正確處理可為 null 的型別，並在 TypeScript 回退到 `any` 時發出警告。
- **`exclude`**：頂層的 `exclude` 屬性告訴編譯器在編譯期間忽略這些 TypeScript 檔案。


# --assignment--

檢視 Frontend Libraries 主題和概念。
