---
id: 680b3ef395479b0e449ecb6e
title: 实现选择排序算法
challengeType: 27
dashedName: implement-selection-sort-algorithm
---

# --description--

选择排序是大多数计算机科学课程中教授的另一种流行排序算法。

该算法通过反复查找列表中未排序部分的最小元素，并将其与第一个未排序元素交换来工作。它首先选择整个列表中的最小值，并将其与第一个元素交换。然后移动到第二个位置，查找剩余未排序元素中的最小值，并将其与第二个元素交换。该过程继续进行，每次移动一个元素，直到整个列表排序完成。

选择排序在最佳、平均和最坏分支中都会导致二次时间复杂度。空间复杂度将是常量 `O(1)`，因为排序是在原地完成的，并且无论列表大小如何，都使用了常量量的内存。

**目标：**实现以下用户需求并通过所有测试以完成实验。

**用户故事：**

1. 你应该定义一个名为 `selection_sort` 的函数。
1. 你的 `selection_sort` 函数应有一个参数，表现该项的列表。
1. 你的 `selection_sort` 函数应接受一个列表，并将项就地从小到大排序。
1. 你的 `selection_sort` 函数应就地修改输入列表，并在排序完成后返回它。
1. 你的 `selection_sort` 函数应遵循选择排序算法，将列表未排序部分中最小的元素与第一个未排序元素交换。
1. 你的 `selection_sort` 函数在最小元素已经处于正确位置时不应执行不必要的交换。
1. 你的 `selection_sort` 函数不应使用内置的 `sort()` 方法或 `sorted()` 函数。

# --hints--

你应该有一个名为 `selection_sort` 的函数。

```js
({test: () => {
    runPython(`
assert _Node(_code).has_function('selection_sort')
    `)
}})
```

你的 `selection_sort` 函数应有一个参数。

```js
(
    {test: () => {
        runPython(`
            import inspect
            sig = inspect.signature(selection_sort)
            assert len(sig.parameters) == 1
        `)
    }}
)
```

你不应该在你的代码中导入任何模块或使用内置排序方法。

```js
(
    {
        test: () => runPython(`
            assert len(_Node(_code).find_imports()) == 0
            assert not _Node(_code).block_has_call("sort")
            assert not _Node(_code).block_has_call("sorted")
        `)
    }
)
```

你的 `selection_sort` 应该返回与输入列表相同的列表。

```js
(
    {
        test: () => runPython(`
            input_list = [32, 0, 88, 1, 203]
            assert selection_sort(input_list) is input_list
        `)
    }
)
```

你的 `selection_sort` 应该就地修改输入列表。你不应该使用任何添加或移除列表项的方法。

```js
(
    {
        test: () => runPython(`
            from collections import UserList

            class CustomList(UserList):
                def __init__(self, *args, **kwargs):
                    self._record = []
                    super().__init__(*args, **kwargs)

                def __setitem__(self, key, value):
                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')
                    super().__setitem__(key, value)

                def append(self, *args, **kwargs):
                    self._record.append(f'Appending to list: {args}, {kwargs}')
                    super().append(*args, **kwargs)

                def insert(self, *args, **kwargs):
                    self._record.append(f'Inserting to list: {args}, {kwargs}')
                    super().insert(*args, **kwargs)

                def pop(self, *args, **kwargs):
                    self._record.append(f'Popping from list: {args}, {kwargs}')
                    super().pop(*args, **kwargs)

                def remove(self, *args, **kwargs):
                    self._record.append(f'Removing from list: {args}, {kwargs}')
                    super().remove(*args, **kwargs)


            list_to_sort = CustomList([32, 0, 88, 1, 203])

            selection_sort(list_to_sort)
            assert all(
                'Setting item' in record
                for record in list_to_sort._record
            )
        `)
    }
)
```

你的 `selection_sort` 函数应遵循选择排序算法，将列表中未排序部分的最小值与第一个未排序元素交换。当最小值已经在正确位置时，避免不必要的交换。

```js
(
    {
        test: () => runPython(`
            from collections import UserList

            class CustomList(UserList):
                def __init__(self, *args, **kwargs):
                    self._record = []
                    super().__init__(*args, **kwargs)

                def __setitem__(self, key, value):
                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')
                    super().__setitem__(key, value)


            list_to_sort = CustomList([33, 1, 89, 2, 67, 245])

            swap_pairs = [
                ((0, 1, 33), (1, 33, 1)),
                ((1, 2, 33), (3, 33, 2)),
                ((2, 33, 89), (3, 89, 33)),
                ((3, 67, 89), (4, 89, 67)),
            ]

            selection_sort(list_to_sort)
            record = list_to_sort._record

            actual_pairs = [
                (record[offset * 2], record[offset * 2 + 1])
                for offset, _ in enumerate(record[::2])
            ]
            assert len(swap_pairs) == len(actual_pairs)

            for expected_pair, actual_pair in zip(swap_pairs, actual_pairs):
                assert (
                    set(f'Setting item {key} to {value}. Previous value: {old}' for key, value, old in expected_pair)
                    == set(actual_pair)
                )
        `)
    }
)
```

`selection_sort([33, 1, 89, 2, 67, 245])` 应该返回 `[1, 2, 33, 67, 89, 245]`。

```js
(
    {
        test: () => runPython(`
            assert selection_sort([33, 1, 89, 2, 67, 245]) == [1, 2, 33, 67, 89, 245]
            
        `)
    }
)
```

`selection_sort([5, 16, 99, 12, 567, 23, 15, 72, 3])` 应该返回 `[3, 5, 12, 15, 16, 23, 72, 99, 567]`。

```js
(
    {
        test: () => runPython(`
            assert selection_sort([5, 16, 99, 12, 567, 23, 15, 72, 3]) == [3, 5, 12, 15, 16, 23, 72, 99, 567]
            
        `)
    }
)
```

`selection_sort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92])` 应该返回 `[1, 1, 2, 2, 4, 8, 32, 43, 43, 55, 63, 92, 123, 123, 234, 345, 5643]`。

```js
(
    {
        test: () => runPython(`
            assert selection_sort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]) == [1, 1, 2, 2, 4, 8, 32, 43, 43, 55, 63, 92, 123, 123, 234, 345, 5643]
            
        `)
    }
)
```

你的 `selection_sort` 函数应正确排序任何数字列表。

```js
(
    {
        test: () => runPython(`
            assert selection_sort([42, 17, 93, 8, 61, 29]) == [8, 17, 29, 42, 61, 93]
            assert selection_sort([11, 4, 78, 23, 55, 198, 65, 90, 2]) == [2, 4, 11, 23, 55, 65, 78, 90, 198]
            assert selection_sort([9, 27, 3, 7, 101, 66, 34, 52, 87, 42, 12, 29]) == [3, 7, 9, 12, 27, 29, 34, 42, 52, 66, 87, 101]
            assert selection_sort([5, 14, 33, 77, 2, 18, 92, 1, 100, 45, 73, 64, 28, 56]) == [1, 2, 5, 14, 18, 28, 33, 45, 56, 64, 73, 77, 92, 100]
            
        `)
    }
)     
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def selection_sort(nums):
    for i, _ in enumerate(nums):
        min_index = i

        for j in range(i + 1, len(nums)):
            if nums[j] < nums[min_index]:
                min_index = j

        if min_index != i:
            nums[i], nums[min_index] = nums[min_index], nums[i]

    return nums

```
