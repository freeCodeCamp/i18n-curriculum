---
id: 67c9e932c6c4234532d46394
title: React 表单、数据获取和路由回顾
challengeType: 31
dashedName: review-react-forms-data-fetching-and-routing
---

# --description--

## 在 React 中使用 Forms

- **受控输入**：这是指你将输入字段的值保存在状态中，并通过 `onChange` 事件进行更新。这使你能够完全控制形式数据，并允许即时验证和条件式渲染。

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form>
    </>
  );
}

export default App;
```

- **非受控输入**：非通过 `useState` 钩子处理输入，HTML 中的非受控输入借助 DOM 维护其自身的内部状态。由于 DOM 控制输入值，你需要通过 `ref` 获取输入字段的值。

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">Your</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">Submit</button>
   </form>
 );
}

export default App;
```

## 使用 `useActionState` Hook

- **服务器操作**：这些是在服务器上运行的函数，允许直接在服务器上处理形式，而无需 API 端点。以下是来自 Next.js 应用的示例：

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `Hello, ${name}!` };
}
```

`"user server"` 指令将函数标记为服务器操作。

- **`useActionState` Hook**：此 hook 根据表单提交的结果更新状态。以下是 `useActionState` hook 的基本语法：

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` 是动作返回的当前状态。
- `action` 是触发服务器操作的函数。
- `isPending` 是一个布尔值，表示该操作当前是否正在运行。
- `actionFunction` 参数就是服务器操作本身。
- `initialState` 是表现动作运行前状态起点的参数。
- `permalink` 是一个可选的字串，包含该形式修改的唯一页面链接。

## React 中的数据获取

- **获取数据的选项**：在 React 中有许多不同的方法来获取数据。你可以使用本地的 Fetch API，或者第三方工具如 Axios 或 SWR。
- **获取数据时常用的状态变量**：无论你选择哪种方式在 React 中获取你的数据，都需要跟踪一些状态。第一个是数据本身。第二个用于跟踪数据是否仍在被获取。第三个是一个状态变量，用于捕捉在数据获取进程中可能发生的任何误差。

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

由于获取数据是一个副作用，最好在 `useEffect` 钩子内使用 `Fetch API`。

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      
      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

然后，如果数据获取未完成，你可以渲染一个加载消息；如果获取数据时出现误差，你可以渲染一个错误信息；或者渲染结果。

```jsx
if (loading) {
  return <p>Loading...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

如果你想使用 Axios，你需要安装并导入它：

```bash
npm i axios
```

```js
import axios from "axios";
```

然后你可以使用 `axios.get` 获取数据：

```jsx
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

要使用 `useSWR` 钩子获取数据，你需要先安装并导入它。

```bash
npm i swr
```

```js
import useSWR from "swr";
```

以下是你如何使用该钩子来获取数据的方法：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>Loading...</h2>;
 }
 if (error) {
   return <h2>Error: {error.message}</h2>;
 }

 return (
   <>
     <h2>Todos</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## 使用 `useOptimistic` Hook

- **`useOptimistic` Hook**：此 Hook 用于在等待异步操作在后台完成时保持界面响应。它有助于管理界面中的“乐观更新”，这是一种基于操作预期结果（例如等待服务器响应）立即更新界面的策略。

这是基本语法：

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` 是一种临时状态，会立即更新以提供更好的用户体验。
- `addOptimistic` 是在实际状态更改之前应用乐观更新的函数。
- `actualState` 是来自某个操作结果的真实状态值，比如从服务器获取数据。
- `updateFunction` 是确定在调用时乐观状态应如何更新的函数。

下面是一个在 `TaskList` 组件中使用 `useOptimistic` 钩子的示例：

```jsx
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**：用于渲染部分 UI 并将状态更新标记为非紧急过渡。这允许 UI 在耗时更新期间保持响应。基本语法如下：

```js
startTransition(action);
```

`action` 执行状态更新或触发某些与转换相关的逻辑。这确保了紧急的 UI 更新（如类型指派或点击）不会被阻塞。

## 使用 `useMemo` Hook

- **记忆化**：这是一种优化技术，其中基于特定参数缓存（记住）昂贵函数调用的结果。当再次提供相同参数时，将返回缓存的结果，而不是重新计算函数。
- **`useMemo` Hook**：此 Hook 用于缓存计算值。以下是缓存排序大型数组结果的示例。只有当 `largeArray` 发生变化时，`expensiveSortFunction` 才会运行：

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## 使用 `useCallback` Hook

- **`useCallback` Hook**：用于缓存函数引用。

```js
const handleClick = useCallback(() => {
  // code goes here
}, [dependency]);
``` 

- **`React.memo`**：用于缓存组件，以防止在其 prop 未改变时发生不必要的重新渲染。

```jsx
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* Presentation */}
   </>
 )
});
``` 

## 依赖管理工具

- **依赖定义**：在软件中，依赖是指应用中的一个组件或模块依赖另一个组件或模块才能正常运行。依赖在软件应用中很常见，因为它们允许开发者使用他人创建的预构建函数或工具。React 项目所需的两个核心依赖将是 `react` 和 `react-dom` 包：

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **包管理器定义**：要管理项目中的软件依赖，你需要使用包管理器。包管理器是一种用于安装、更新和移除依赖的工具。许多流行的编程语言如 JavaScript、Python、Ruby 和 Java 都使用包管理器。JavaScript 的流行包管理器包括 npm、Yarn 和 pnpm。
- **`package.json` 文件**：这是项目中的一个关键配置文件，包含有关你的项目的元数据，包括其名称、版本和依赖项。它还定义了脚本、许可信息以及帮助管理项目及其依赖项的其他设置。
- **`package-lock.json` 文件**：此文件将锁定你的项目正在使用的所有包的确切版本。当你更新包时，锁定文件中的新版本也会被更新。
- **`node_modules` 文件夹**：此文件夹包含你 `package.json` 文件中列出的依赖项的实际代码，包括你项目的直接依赖项及这些依赖项的任何依赖项。
- **开发依赖**：这些是仅用于开发而非生产环境的包。一个例子是像 Jest 这样的测试库。你会将 Jest 安装为开发依赖，因为它用于在局部测试你的应用，但在生产环境中运行应用时不需要。

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **介绍**：React Router 是一个第三方库，允许你为你的 React 应用添加路由。要开始，你需要在现有的 React 项目中安装 React Router，方法如下：

```bash
npm i react-router
```

然后在 `main.jsx` 或 `index.jsx` 文件中，你需要像这样设置路由结构：

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

`path` 和 `element` 用于将 URL 和 UI 组件绑定在一起。在这个分支中，我们正在为指向 `App` 组件的主页设置路由。 

- **多个视图和路由设置**：在较大的应用中，通常会像这样设置多个视图和路由：

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

这些示例中的 `index` 属性用于表现给定路径段的默认路由。因此，`Home` 组件将在根路径 `/` 显示，而 `ProductsHome` 组件将在 `/products` 路径显示。

- **嵌套路由**：你可以将路由嵌套在其他路由内，这会导致子路由的路径被追加到父路由的路径中。

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

在上面的示例中，热门产品的路径将是 products/trending。

- **动态段**：动态段是指 URL `path` 中的任何部分是动态的。

```jsx
<Route path=":category" element={<Category />} />
```

在此示例中，我们有一个名为 `category` 的动态段。当用户导航到类似 products/brass-instruments 的 URL 时，视图将切换到 `Category` 组件，你可以根据该段动态获取相应的数据。

- **`useParams` Hook**：此 Hook 用于访问 URL 路径中的动态参数。

```jsx
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
  {/* Accessing the category param: params.category */}
  {/* rest of code goes here */}
}
```

## React 框架

- **介绍**：React 框架提供路由、图像优化、数据获取、认证等特色。这意味着在某些用例中，你可能不需要设置单独的前端和后端应用。React 框架的示例包括 Next.js 和 Remix。
- **Next.js 路由**：该路由系统包括对动态路由、并行路由、路由处理程序、重定向、国际化等的支持。

下面是创建自定义请求处理器的示例：

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Next.js 图像优化**：`Image` 组件扩展了本地的超文本标记语言 `img` 元素，允许更快的页面装载和大小优化。这意味着图像只有在进入视图时才会装载，且 `Image` 组件会自动为每个设备提供正确尺寸的图像。

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
``` 

## 属性传递

- **定义**：Prop drilling 是将 props 从父组件传递到深层嵌套子组件的进程，即使某些子组件不需要这些 props。

## 状态管理

- **Context API**：上下文指的是父组件在不需要通过 props 显式传递的情况下，使信息可用于子组件。`createContext` 用于创建一个上下文对象，该对象表现其他组件将要读取的上下文。`Provider` 用于向子组件提供上下文值。

```jsx
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**：Redux 通过提供一个中央保存和对状态更新的严格控件来处理状态管理。它使用一个可预测的模式，包括 actions、reducers 和 middleware。Actions 是将数据从你的应用发送到 Redux 保存的信息负载，通常由用户交互触发。Reducers 是指定状态应如何响应这些 actions 变化的函数，确保状态以不可变的方式更新。另一方面，middleware 充当 action 分派和 reducer 之间的桥梁，允许你扩展 Redux 的功能性（例如，记录日志、处理异步操作），而无需修改核心流程。

- **Zustand**：这个状态管理方案非常适合中小型应用。它通过使用 `useStore` 钩子直接在组件和页面中访问状态来工作。这样你可以修改和访问数据，而无需使用 actions、reducers 或 provider。

## 使用 React DevTools 调试 React 组件

- **React Developer Tools**：这是一个浏览器扩展（程序、功能），你可以在 Chrome、Firefox 和 Edge 中使用它来检查 React 组件并识别性能问题。对于 Safari，你需要安装 `react-devtools` npm 包。安装 React DevTools 并在浏览器中打开 React 应用后，打开浏览器开发者工具以访问为调试 React 提供的两个额外标签（页）——Components 和 Profiler。
- **组件标签（页）**：此标签（页）以树状视图格式显示每个组件。你可以在此标签（页）中执行以下操作：
  - 查看应用的组件层次结构
  - 实时查看和修改 props、states 和 context 值
  - 查看每个选定组件的源代码
  - 将组件数据记录到控制台
  - 检查组件的 DOM 元素
- **Profiler 标签（页）**：此标签（页）帮助你分析组件性能。你可以记录组件性能，以便识别不必要的重新渲染，查看提交持续时间，进而优化缓慢的组件。

## React 服务器组件

- **定义**：React 服务器端组件是仅在服务器上渲染的 React 组件，只将最终的 HTML 发送到客户。这意味着这些组件可以直接访问服务器端资源，并大幅减少发送到浏览器的 JavaScript 数量。

# --assignment--

复习 React 路由、状态管理、表单和数据获取。
