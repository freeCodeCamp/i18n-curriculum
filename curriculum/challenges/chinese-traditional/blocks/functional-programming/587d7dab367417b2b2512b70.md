---
id: 587d7dab367417b2b2512b70
title: 柯里化與部分應用介紹
challengeType: 1
forumTopicId: 301232
dashedName: introduction-to-currying-and-partial-application
---

# --description--

函式（程式）的 <dfn>arity</dfn> 是它所需的引數數量。將函式（程式）<dfn>Currying</dfn> 意味著將一個 N arity 的函式（程式）轉換成 N 個 arity 為 1 的函式（程式）。

換句話說，它會重新組織一個函式，使其接受一個引數，然後傳回另一個函式，該函式接受下一個引數，依此類推。

這裡有一個範例：

```js
function unCurried(x, y) {
  return x + y;
}

function curried(x) {
  return function(y) {
    return x + y;
  }
}

const curried = x => y => x + y

curried(1)(2)
```

`curried(1)(2)` 會傳回 `3`。

如果你無法一次提供函式的所有引數，這在你的程式中非常有用。你可以將每次函式呼叫存檔到一個變數中，該變數將持有傳回的函式引用，當下一個引數可用時會接收它。以下是使用上述範例中柯里化函式的範例：

```js
const funcForY = curried(1);
console.log(funcForY(2)); // 3
```

類似地，<dfn>partial application</dfn> 可以描述為一次對函式套用少數引數，並傳回另一個函式，該函式會套用更多引數。以下是一個範例：

```js
function impartial(x, y, z) {
  return x + y + z;
}

const partialFn = impartial.bind(this, 1, 2);
partialFn(10); // 13
```

# --instructions--

填寫 `add` 函式（程式）的主體，使其使用柯里化來相加參數 `x`、`y` 和 `z`。

# --hints--

`add(10)(20)(30)` 應該傳回 `60`。

```js
assert(add(10)(20)(30) === 60);
```

`add(1)(2)(3)` 應該傳回 `6`。

```js
assert(add(1)(2)(3) === 6);
```

`add(11)(22)(33)` 應該傳回 `66`。

```js
assert(add(11)(22)(33) === 66);
```

你的程式碼應該包含一個最終述語，傳回 `x + y + z`。

```js
assert(__helpers.removeJSComments(code).match(/[xyz]\s*?\+\s*?[xyz]\s*?\+\s*?[xyz]/g));
```

# --seed--

## --seed-contents--

```js
function add(x) {
  // Only change code below this line


  // Only change code above this line
}

add(10)(20)(30);
```

# --solutions--

```js
const add = x => y => z => x + y + z
```
