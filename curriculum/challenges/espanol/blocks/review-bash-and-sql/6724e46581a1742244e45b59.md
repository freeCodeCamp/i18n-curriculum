---
id: 6724e46581a1742244e45b59
title: Revisión de Bash y SQL
challengeType: 31
dashedName: review-bash-and-sql
---

# --description--

## Normalización de Bases de Datos

Este es el proceso de organizar una base de datos relacional para reducir la redundancia de datos y mejorar la integridad.

Sus beneficios incluyen:

- Minimizar datos duplicados, lo que ahorra espacio de almacenamiento y reduce inconsistencias.
- Aplicando la integridad de datos mediante el uso de claves primarias y foráneas.
- Hacer que las bases de datos sean más fáciles de mantener y entender.

### Formas Normales

- **1NF (Primera Forma Normal)**
  - Cada celda contiene un solo valor (atómico).
  - Cada registro es único (garantizado por una clave primaria).
  - El orden de las filas/columnas es irrelevante.
  - Ejemplo: Mueve múltiples números de teléfono de una tabla `students` a una tabla separada `student_phones`.

- **2NF (Segunda Forma Normal)**
  - Cumple con los requisitos de 1NF.
  - No hay **dependencias parciales**: cada atributo que no es clave debe depender de toda la clave primaria compuesta.
  - Ejemplo: Divide la tabla `orders` en `order_header` y `order_items` para evitar que los atributos dependan solo de una parte de la clave.

- **3NF (Tercera Forma Normal)**
  - Cumple con los requisitos de 2NF.
  - No hay **dependencias transitivas**: los atributos que no son clave no pueden depender de otros atributos que tampoco son clave.
  - Ejemplo: Mueve `city_postal_code` a una tabla `cities` en lugar de almacenarlo con cada orden.

- **BCNF (Forma Normal de Boyce-Codd)**
  - Cumple con los requisitos de 3NF.
  - Cada determinante (lado izquierdo de una dependencia funcional) debe ser una superclave.

**Consejo**: Apunta a 3NF en la mayoría de los diseños para un buen equilibrio entre integridad y rendimiento.

## Conceptos clave de SQL

- SQL es un Lenguaje de Consulta Estructurado para comunicarse con bases de datos relacionales.
- **Comandos básicos** → `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`, `ALTER TABLE`, etc.
- `Joins` → Combina datos de múltiples tablas (`INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`).

## Ejecutando comandos SQL en Bash

Puedes ejecutar comandos SQL directamente desde la línea de comandos usando el cliente de línea de comandos `psql` para PostgreSQL o herramientas similares para otras bases de datos.

Por ejemplo, para ejecutar un archivo SQL en PostgreSQL:

```bash
psql -U username -d database_name -c "SELECT * FROM students;"
```

También puedes ejecutar comandos MySQL directamente:

```bash
mysql -u username -p database_name -e "SELECT * FROM students;"
```

### Ejecuta SQL desde un Archivo

```bash
# PostgreSQL
psql -U username -d database_name -f script.sql

# MySQL
mysql -u username -p database_name < script.sql
```

### Incrusta SQL en un script de Bash

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Insert student data
psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'CS');"
```

### Uso de Variables en SQL

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"
STUDENT_NAME="Bob"
AGE=21

psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age) VALUES ('$STUDENT_NAME', $AGE);"
```

**Consejo**: Sanitiza las variables para evitar la inyección SQL.

## Recuperar y usar resultados de consultas SQL en Bash

Cuando ejecutas consultas SQL a través de `psql`, puedes **capturar** y **procesar** los valores devueltos en tus scripts de Bash.

### Capturando un Valor Único

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get total student count
STUDENT_COUNT=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -c \
"SELECT COUNT(*) FROM students;")

echo "Total students: $STUDENT_COUNT"
```

Salida → 42

### Recuperar Múltiples Columnas

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get top 3 students' names and ages
RESULTS=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, age FROM students LIMIT 3;")

echo "Top 3 students:"
echo "$RESULTS"
```

Resultado

```bash
Alice,20
Bob,21
Charlie,22
```

### Iterando a través de los resultados de la consulta

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get student names and majors
psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, major FROM students;" | while IFS="," read -r name major
do
    echo "Student: $name | Major: $major"
done
```

Forma de la salida

```bash
Student: Alice | Major: CS
Student: Bob   | Major: Math
Student: Carol | Major: Physics
```

## Inyección SQL

Es una vulnerabilidad de seguridad web donde los atacantes insertan código SQL malicioso en los campos de entrada para manipular la base de datos.

Esto puede llevar a acciones arriesgadas como:

- Omitiendo la autenticación.
- Robar datos sensibles.
- Modificando o eliminando registros.

Un ejemplo de un ataque de inyección SQL:

```sql
SELECT * FROM users WHERE username = ' " " OR "1"="1" -- ' AND password = 'anything';
```

Esta consulta devolvería todos los usuarios porque la condición `OR "1"="1"` siempre es verdadera, permitiendo que los atacantes evadan las verificaciones de inicio de sesión.

### Previniendo la inyección SQL

1. **Usa Prepared Statements**: Estos separan el código SQL de los datos, previniendo inyecciones. Aquí tienes un ejemplo (Node.js con pg):

    ```sql
    client.query('SELECT * FROM users WHERE username = $1 AND password = $2', [username, password]);
    ```

2. **Validación de Entrada**: Sanitiza y valida todas las entradas del usuario para asegurar que cumplan con los formatos esperados.

3. **Menor Privilegio**: Usa cuentas de base de datos con los permisos mínimos necesarios para la aplicación.

**Nota**: Nunca otorgues derechos de administrador a las cuentas de aplicación.

## Problema N+1

El problema N+1 ocurre cuando una aplicación hace una consulta para obtener una lista de elementos (N) y luego hace una consulta adicional por cada elemento para obtener datos relacionados, resultando en N+1 consultas.

**Por qué es malo**

- Cada consulta añade sobrecarga de red y procesamiento.
- Varias consultas pequeñas son más lentas que una consulta optimizada.

### Ejemplo del patrón N+1

```sql
-- 1: Get list of orders
SELECT * FROM orders LIMIT 50;

-- N: For each order, get customer
SELECT * FROM customers WHERE customer_id = ...;
```

**Solución**: Usa `JOINs` u otras operaciones basadas en conjuntos.

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name,
  customers.email,
  customers.address
FROM orders
JOIN customers 
  ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50);
```

Siempre busca oportunidades para combinar datos relacionados en una sola consulta.

# --assignment--

Revise los temas y conceptos de Bash y SQL.
