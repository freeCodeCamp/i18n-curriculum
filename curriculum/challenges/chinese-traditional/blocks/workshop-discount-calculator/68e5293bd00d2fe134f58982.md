---
id: 68e5293bd00d2fe134f58982
title: 第 9 步
challengeType: 20
dashedName: step-9
---

# --description--

如同在前一課中討論的，抽象的行為是任何繼承自抽象的基礎類別的類別必須實作的行為。它們作為一種契約，確保所有折扣策略都會有某些必須的行為。

在你的 `DiscountStrategy` 類別中，定義一個名為 `is_applicable` 的方法。 在方法定義上方使用 `@abstractmethod` 裝飾器。 該方法應該有以下參數：`self`、`product` 和 `user_tier`。 在方法主體中使用 `pass` 述語。

為你的方法標記添加型別提示以使標記清晰：`product` 應該是 `Product` 型別，`user_tier` 應該是 `str` 型別。


# --hints--

你的 `DiscountStrategy` 類別應該有一個名為 `is_applicable` 的方法。

```js
({
  test: () => runPython(`assert _Node(_code).find_class("DiscountStrategy").has_function("is_applicable")`)
})
```

你的 `is_applicable` 方法應該有 `@abstractmethod` 裝飾器。

```js
({
  test: () => runPython(`assert _Node(_code).find_class("DiscountStrategy").find_function("is_applicable").has_decorators("abstractmethod")`)
})
```

你的 `is_applicable` 方法應該有參數 `self`、`product: Product` 和 `user_tier: str`。

```js
({
  test: () => runPython(`assert _Node(_code).find_class("DiscountStrategy").find_function("is_applicable").has_args("self,product:Product,user_tier:str")`)
})
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod

class Product:
    def __init__(self, name: str, price: float) -> None:
        self.name = name
        self.price = price

    def __str__(self) -> str:
        return f'{self.name} - ${self.price}'

--fcc-editable-region--
class DiscountStrategy(ABC):
    pass
--fcc-editable-region--
product = Product('Wireless Mouse', 50.0)
print(product)
```
