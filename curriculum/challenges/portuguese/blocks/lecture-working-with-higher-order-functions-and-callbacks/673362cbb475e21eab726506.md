---
id: 673362cbb475e21eab726506
title: O que é Method Chaining e como ele funciona?
challengeType: 19
dashedName: what-is-method-chaining-and-how-does-it-work
---

# --interactive--

Encadeamento de métodos é uma técnica onde você chama vários métodos um após o outro. Você pode usar encadeamento de métodos em muitos tipos de valores em JavaScript incluindo strings, arrays e objetos. Mesmo que strings sejam valores primitivos, o JavaScript as envolve temporariamente em um objeto `String` quando você usa um método de string.

Vamos ver um exemplo usando diferentes métodos de string:

:::interactive_editor

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

:::

Neste exemplo, começamos com uma string e realizamos três operações em sequência: remover espaços em branco, converter para letras minúsculas e substituir a string `world` por `JavaScript`. Cada método retorna uma nova string, que se torna o alvo da próxima chamada de método.

O encadeamento de métodos pode melhorar significativamente a legibilidade do código ao trabalhar com operações complexas.

Por exemplo, considere este exemplo usando os métodos `filter`, `map` e `reduce`:

:::interactive_editor

```js
const transactions = [
  { amount: 100, type: "credit" },
  { amount: 20, type: "cash" },
  { amount: 150, type: "credit" },
  { amount: 50, type: "cash" },
  { amount: 75, type: "credit" }
];

const totalCreditWithBonus = transactions
  .filter((transaction) => transaction.type === "credit")
  .map((transaction) => transaction.amount * 1.1)
  .reduce((sum, amount) => sum + amount, 0);

console.log(totalCreditWithBonus); // 357.5
```

:::

Neste exemplo, temos um array de transações onde cada objeto possui um valor e um tipo cartão de crédito ou dinheiro.

Primeiro filtramos as transações e criamos um novo array apenas com as transações de cartão de crédito. Então, encadeamos o método `map` ao resultado filtrado e para cada valor da transação, multiplicamos por `1.1` que representa um bônus de `10%`.

Então, pegamos esse resultado e encadeamos o método `reduce` para somar cada um dos valores, o que resulta em `357.5`.

Embora o encadeamento de métodos possa tornar o código mais conciso e legível, é importante usá-lo com moderação.

Cadeias muito longas podem se tornar difíceis de depurar, pois não fica imediatamente claro qual etapa da cadeia pode estar causando um problema. Frequentemente é uma boa prática dividir cadeias muito longas em múltiplas etapas para melhor clareza e depuração mais fácil.

# --questions--

## --text--

Como será a saída do seguinte código?

```js
let str = "  HELLO world  ";
let result = str.trim().toLowerCase().split(' ');
console.log(result);
```

## --answers--

`["HELLO", "world"]`

### --feedback--

Considere o efeito de cada método na cadeia: `trim()`, `toLowerCase()` e `split()`.

---

`["hello", "world"]`

---

`"hello world"`

### --feedback--

Considere o efeito de cada método na cadeia: `trim()`, `toLowerCase()` e `split()`.

---

`[" HELLO", "world "]`

### --feedback--

Considere o efeito de cada método na cadeia: `trim()`, `toLowerCase()` e `split()`.

## --video-solution--

2

## --text--

No contexto de encadeamento de métodos, o que um método deve normalmente retornar para permitir um encadeamento adicional?

## --answers--

`undefined`

### --feedback--

Pense no que permite que o próximo método na cadeia seja chamado imediatamente após o atual.

---

`null`

### --feedback--

Pense no que permite que o próximo método na cadeia seja chamado imediatamente após o atual.

---

O próprio objeto (`this`).

---

Um novo objeto.

### --feedback--

Pense no que permite que o próximo método na cadeia seja chamado imediatamente após o atual.

## --video-solution--

3

## --text--

Qual será o resultado do seguinte código?

```js
let obj = {
    value: 1,
    increment: function() {
        this.value++;
        return this;
    },
    double: function() {
        this.value *= 2;
        return this;
    },
    getValue: function() {
        return this.value;
    }
};

let result = obj.increment().double().increment().getValue();
console.log(result);
```

## --answers--

`2`

### --feedback--

Siga a cadeia de chamadas de método e seus efeitos na propriedade `value`.

---

`3`

### --feedback--

Siga a cadeia de chamadas de método e seus efeitos na propriedade `value`.

---

`4`

### --feedback--

Siga a cadeia de chamadas de método e seus efeitos na propriedade `value`.

---

`5`

## --video-solution--

4
