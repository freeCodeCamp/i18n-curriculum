---
id: 6723d35bb07d1bd220d0f28d
title: 异步的 JavaScript 复习
challengeType: 31
dashedName: review-asynchronous-javascript
---

# --description--

- **同步的 JavaScript** 是循序执行的，并且在继续下一个操作之前会等待前一个操作完成。
- **异步的 JavaScript** 允许多个操作在后台执行而不会阻塞主线程。
- **线程** 是一条可以独立于主程序流程执行的指令序列。
- **回调函数** 是作为参数传递给其他函数的函数，并在操作完成后或作为事件的结果执行。

## JavaScript 引擎和 JavaScript 运行期

- **JavaScript 引擎** 是一个在网页浏览器中执行 JavaScript 代码的程序。它就像一个转换器，将你的代码转换成计算机能够理解并据此工作的指令。
- V8 是 Google 开发的一个 JavaScript 引擎示例。
- **JavaScript 运行期** 是执行 JavaScript 代码的环境。它包括处理和执行代码的 JavaScript 引擎，以及像网页浏览器或 Node.js 这样的附加特色。

## Fetch API

- Fetch API 允许网页应用发起网络请求，通常用于从服务器检索或发送数据。它提供了一个 `fetch()` 方法，你可以用来发起这些请求。
- 你可以使用 Fetch API 获取文本、图像、音频、JSON 和其他类型的数据。

## Fetch API 的超文本传输协议方法

Fetch API 支持多种与服务器交互的超文本传输协议方法。最常用的方法有：

- **GET**：用于从服务器检索数据。默认情况下，Fetch API 使用 `GET` 方法来检索数据。

```js
fetch('https://api.example.com/data')
```

要使用获取的 `data`，必须使用 `.json()` `method` 将其转换为 JSON 形式：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

在这段代码中，来自 Fetch API 的响应是一个 promise，`.then` 处理器将响应转换为 JSON 形式。

- **POST**：用于向服务器发送数据。`POST` 方法用于在服务器上创建新资源。

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

在这个示例中，我们正在发送一个 `POST` 请求以创建一个新用户。我们已将方法指定为 `POST`，设置了适当的头部，并包含了我们想要发送的数据体。体需要是一个字串，因此我们使用 `JSON.stringify()` 将我们的对象转换为 JSON 字串。

- **PUT**：用于更新服务器上的数据。`PUT` 方法用于更新服务器上的现有资源。

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

在此示例中，我们正在更新 URL 末尾指定的 ID `45`。我们在代码中使用了 `PUT` 方法，并且将数据指定为体，用于更新所识别的数据。 

- **DELETE**：用于删除服务器上的数据。`DELETE` 方法用于删除服务器上的资源。

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

在此示例中，我们发送一个 `DELETE` 请求以删除 ID 为 `45` 的用户。

## Promise 和 promise 链式调用

- **Promises** 是表现异步操作最终完成或失败及其结果值的对象。只有当 `async` 操作完成时，promise 的值才被知晓。
- 这是一个创建简单 `promise` 的示例：

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- `.then()` 方法用于 Promise 中指定当 Promise 完成时应发生的操作，而 `.catch()` 用于处理任何发生的错误。
- 下面是使用 `.then()` 和 `.catch()` 处理 Promise 的示例：

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

在上述示例中，使用 `.then()` 方法记录从 Promise 接收到的数据，而使用 `.catch()` 方法记录发生的任何误差。

- **Promise 链式调用**：Promise 的强大特色之一是我们可以将多个异步的操作串联在一起。每个 `.then()` 都可以返回一个新的 Promise，使你能够依次执行一系列异步的操作。
- 这是一个 Promise 链式调用的示例：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

在上述示例中，我们首先从一个 URL 获取数据，然后根据第一个响应从另一个 URL 获取数据，最后记录收到的第二个数据。 

`catch` 方法会处理进程中发生的任何误差。这意味着你不需要为每个步骤添加误差处理器，这可以大大简化你的代码。

## 使用 `async/await` 来处理 promises

Async/await 使编写和读取异步的代码更容易，它是建立在 Promise 之上的。

- **async**：`async` 关键字用于定义一个异步的函数。`async` 函数返回一个 Promise，该 Promise 会解析为 `async` 函数返回的值。
- **await**：`await` 关键字用于 `async` 函数内部，暂停函数执行直到 Promise 被解析。它只能在 `async` 函数内部使用。
- 这是使用 `async/await` 的示例：

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

在上述示例中，`delayedGreeting` 函数是一个 `async` 函数，它会暂停 2 秒钟，然后打印问候消息。`await` 关键字用于暂停函数执行，直到 `Promise` 被解析。

- `async/await` 最大的优势之一是通过 `try/catch` 块进行误差处理。以下是一个示例：

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

在上述示例中，`try` 块包含可能抛出误差的代码，而 `catch` 块在发生误差时处理该误差。这使得误差处理更加直接且易读。

## `async` 属性

- `async` 属性告诉浏览器在继续解析超文本标记语言文档的同时异步地下载脚本文件。
- 脚本下载完成后，超文本标记语言解析暂停，脚本执行，然后超文本标记语言解析恢复。
- 你应该为执行顺序无关紧要的独立脚本使用 `async`

## `defer` 属性

- `defer` 属性也会异步地下载脚本，但它会推迟脚本的执行，直到超文本标记语言文档完全解析之后。
- `defer` 脚本维护它们在超文本标记语言文档中出现的执行顺序。

- 重要的是要注意，`async` 和 `defer` 两个属性都会被内联脚本忽略，仅对外部脚本文件有效。

- 当同时存在 `async` 和 `defer` 属性时，`async` 属性具有优先级。

## 地理位置 API

- Geolocation API 提供了一种让网站请求用户位置的方法。

- 下面的示例演示了用于获取用户当前位置的 API `getCurrentPosition()` 方法。

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

在这段代码中，我们调用 `getCurrentPosition` 并传入一个函数，该函数将在成功获取位置时被调用。 

`position` 对象包含各种信息，但这里我们只选择了 `latitude` 和 `longitude`。

如果获取 `position` 出现问题，则该误差将被记录到控制台日志中。 

- 尊重用户的隐私非常重要，只有在必要时才请求他们的位置。

# --assignment--

复习异步的 `JavaScript` 主题和概念。
