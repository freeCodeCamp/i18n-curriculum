---
id: 59667989bf71cf555dd5d2ff
title: S-表達式
challengeType: 1
forumTopicId: 302303
dashedName: s-expressions
---

# --description--

<a href="https://rosettacode.org/wiki/S-expressions" target="_blank" rel="noopener noreferrer nofollow">S-Expressions</a> 是一種方便解析和儲存資料的方式。

# --instructions--

撰寫一個簡單的讀取器/解析器，用於 `S-Expressions`，能控制代碼帶引號和不帶引號的字串、整數和浮點數。

該函式應該從字串中讀取單一但巢狀的 S-Expression，並將其傳回為（巢狀）陣列。

換行符號和其他空白字元可能會被忽略，除非包含在引號字串中。

引號內的 `()` 不會被解讀，而是視為字串的一部分。

處理字串內的跳脫引號是選用的；因此 "`(foo"bar)`" 可能會被視為字串 "`foo"bar`"，或視為錯誤。

為此，讀者不需要識別 `\` 作為跳脫字元，但如果語言具有適當的資料型別，則還應識別數字。

請注意，除了 `()"`（如果支援跳脫則為 `\`）和空白字元外，沒有特殊字元。其他任何字元皆可不加引號。

讀者應該能夠閱讀以下輸入

<pre>((data "quoted data" 123 4.5)
(data (!@# (4.5) "(more" "data)")))
</pre>

並將其轉換成原生的資料結構。

# --hints--

`parseSexpr` 應該是一個函式（程式）。

```js
assert(typeof parseSexpr === 'function');
```

`parseSexpr('(data1 data2 data3)')` 應該傳回 `['data1', 'data2', 'data3']`

```js
assert.deepEqual(parseSexpr(simpleSExpr), simpleSolution);
```

`parseSexpr('((data "quoted data" 123 4.5) (data (!@# (4.5) "(more" "data)")))')` 應該傳回 `[['data', '"quoted data"', 123, 4.5], ['data', ['!@#', [4.5], '"(more"', '"data)"']]]`。

```js
assert.deepEqual(parseSexpr(basicSExpr), basicSolution);
```

# --seed--

## --after-user-code--

```js
const simpleSExpr = '(data1 data2 data3)';
const simpleSolution = ['data1', 'data2', 'data3'];

const basicSExpr = '((data "quoted data" 123 4.5) (data (!@# (4.5) "(more" "data)")))';
const basicSolution = [["data","\"quoted data\"",123,4.5],["data",["!@#",[4.5],"\"(more\"","\"data)\""]]];
```

## --seed-contents--

```js
function parseSexpr(str) {

  return true;
}
```

# --solutions--

```js
function parseSexpr(str) {
  const t = str.match(/\s*("[^"]*"|\(|\)|"|[^\s()"]+)/g);
  for (var o, c = 0, i = t.length - 1; i >= 0; i--) {
    var n,
      ti = t[i].trim();
    if (ti == '"') return;
    else if (ti == '(') t[i] = '[', c += 1;
    else if (ti == ')') t[i] = ']', c -= 1;
    else if ((n = +ti) == ti) t[i] = n;
    else t[i] = `'${ti.replace('\'', '\\\'')}'`;
    if (i > 0 && ti != ']' && t[i - 1].trim() != '(') t.splice(i, 0, ',');
    if (!c) if (!o) o = true; else return;
  }
  return c ? undefined : eval(t.join(''));
}
```
