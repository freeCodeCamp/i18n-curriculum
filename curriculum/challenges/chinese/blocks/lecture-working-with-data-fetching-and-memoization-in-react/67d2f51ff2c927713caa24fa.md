---
id: 67d2f51ff2c927713caa24fa
title: useCallback 钩子和 React.memo 如何工作？
challengeType: 19
dashedName: how-do-the-usecallback-hook-and-react-memo-work
---

# --description--

在上一节课中，你学习了记忆化以及 `useMemo` 钩子的工作原理。

在本课中，你将学习 `useCallback` 钩子和 `React.memo` 的工作原理。

在上一节课中，我们还提到 `useCallback` 用于缓存函数引用。

对于 `React.memo`，它允许你为一个组件添加记忆功能，以防止当其 prop 未改变时发生不必要的重新渲染。

这是 `useCallback` 钩子的基本语法：

```js
const handleClick = useCallback(() => {
  // code goes here
}, [dependency]);
```

下面是 `React.memo` 的基本语法：

```jsx
const MemoizedComponent = React.memo(({ prop }) => {
  return (
    <>
      {/* Presentation */}
    </>
  )
});
```

让我们来看一个 `useCallback` 钩子的例子：

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount((prevCount) => prevCount + 1);
  };

  useEffect(() => {
    console.log("useEffect runs");
  }, [handleClick]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```

在组件中，每当 `handleClick` 发生变化时，effect 就会运行，因为 `handleClick` 函数在每次渲染时都会被重新创建。

为了解决这个问题，你需要通过使用 `useCallback` 钩子将 `handleClick` 函数进行记忆化，告诉 React 在多次渲染中将其视为同一个函数，这样它就不会被重新创建：

```jsx
import { useState, useEffect, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  // Memoize the handleClick function with useCallback
  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  useEffect(() => {
    console.log("useEffect runs");
  }, [handleClick]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```

现在 `handleClick` 函数不会在每次渲染时重新创建。

为了向你展示 `React.memo`（或 `memo`）高阶函数如何工作以及 `useCallback` 钩子如何协同工作，这里有一个带有 `handleClick` 函数的 `Counter` 组件，该函数需要 `useCallback`，但当前未使用它：

```jsx
import { useState, useEffect, useCallback } from "react";
import CounterChild from "./CounterChild";

function Counter() {
  const [count, setCount] = useState(0);
  const [timer, setTimer] = useState(new Date().toLocaleTimeString());

  const handleClick = () => {
    setCount(count + 1);
  };

  useEffect(() => {
    const interval = setInterval(() => {
      setTimer(new Date().toLocaleTimeString());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return (
    <div>
      <h1>Time: {timer}</h1>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
      <CounterChild onClick={handleClick} />
    </div>
  );
}

export default Counter;
```

这个函数的状态中还有一个计时器，每秒更新一次。这使得组件在每次 `timer` 变化时重新渲染，从而使 `handleClick` 函数在每次渲染时都被重新创建。

这就是为什么 `handleClick` 需要用 `useCallback` 进行记忆化。

这是 `CounterChild` 组件：

```jsx
const CounterChild = ({ onClick }) => {
  console.log("CounterChild component rendered");
  return <button onClick={onClick}>Increment from Child</button>;
};

export default CounterChild;
```

这个 `CounterChild` 组件接受一个 `onClick` 属性，使你能够从中递增计数器。

由于 `CounterChild` 组件是 `Counter` 组件的子组件，因此每当 `Counter` 因计时器变化而重新渲染时，它也会重新渲染。所以，`CounterChild` 也需要被记忆化。

没有使用记忆化，因为随着计时器每秒更新，`CounterChild` 组件也会重新渲染。

为防止这种情况，你需要使用 `React.memo` 对 `CounterChild` 组件进行记忆化：

```jsx
import React from "react";

const CounterChild = React.memo(({ onClick }) => {
  console.log("CounterChild component rendered");
  return <button onClick={onClick}>Increment from Child</button>;
});

export default CounterChild;
```

即使使用 `React.memo` 对 `CounterChild` 进行记忆化，事情仍未达到最佳状态。

这是因为 `handleClick` 函数在每次渲染时都会被重新创建，所以它也需要使用 `useCallback` 进行记忆化，以告诉 React 你需要该函数在渲染之间保持不变：

```js
const handleClick = useCallback(() => {
  setCount((prevCount) => prevCount + 1);
}, [count]);
```

现在，组件仅在 `count` 状态更改时重新渲染。

# --questions--

## --text--

`useCallback` 钩子记忆了什么？

## --answers--

计算值。

### --feedback--

它有助于防止在每次 `Render` 时创建新的函数实例。

---

函数引用。

---

组件渲染。

### --feedback--

它有助于防止在每次 `Render` 时创建新的函数实例。

---

状态更新。

### --feedback--

它有助于防止在每次 `Render` 时创建新的函数实例。

## --video-solution--

2

## --text--

以下哪一个是 `useCallback` 钩子的正确语法？

## --answers--

```js
const handleClick = useCallback(() => { /* code */ });
```

### --feedback--

第二个参数应为依赖项数组。

---

```js
const handleClick = useCallback(() => { /* code */ }, dependency);
```

### --feedback--

第二个参数应为依赖项数组。

---

```jsx
const handleClick = useCallback(() => { /* code */ }, [dependency]);
```

---

```js
const handleClick = useCallback(() => { dependency }, {});
```

### --feedback--

第二个参数应为依赖项数组。

## --video-solution--

3

## --text--

`React.memo` 记忆了什么？

## --answers--

函数引用。

### --feedback--

当 `props` 保持不变时，它可以防止重新渲染。

---

组件状态。

### --feedback--

当 `props` 保持不变时，它可以防止重新渲染。

---

组件基于未更改的 props 进行渲染。

---

DOM 元素。

### --feedback--

当 `props` 保持不变时，它可以防止重新渲染。

## --video-solution--

3
