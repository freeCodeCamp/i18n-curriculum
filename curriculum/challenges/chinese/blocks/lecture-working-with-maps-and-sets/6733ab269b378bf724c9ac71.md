---
id: 6733ab269b378bf724c9ac71
title: JavaScript 中的 Set 是什么，它与 WeakSet 有何不同？
challengeType: 19
dashedName: what-are-sets-in-javascript-and-how-does-it-differ-from-weaksets
---

# --description--

在 JavaScript 中，`Set` 是一个用于管理数据集合的内置对象。它允许你保存任何类型的唯一值，无论是原语还是对象引用。`Set` 确保其中的每个值只出现一次，使其在从数组中消除副本或处理不同值的集合时非常有用。

至于 `WeakSet`，它是一种具有较少特色的特殊 `Set` 类型，允许你保存弱引用的对象和符号。与 `Set` 不同，`WeakSet` 不支持数字或字串等原语。

与普通的 `Set` 不同，`WeakSet` 只保存对象，并且对这些对象的引用是“弱引用”，这意味着如果没有其他引用指向这些对象，`WeakSet` 不会阻止它们被垃圾回收。简单来说，如果对象在你的代码中没有被其他地方使用，它会被自动移除以释放内存。

要创建一个 `Set`，你使用 `Set` 构造函数并将其赋值给一个变量：

```js
const myFirstSet = new Set();
```

你也可以用值来初始化 `Set`：

```js
const treeSet = new Set(['Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit']);
```

如果你将 `Set` 记录到控制台，输出看起来是这样的：

```js
/*
Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
  [[Entries]]
  0: "Baobab"
    value: "Baobab"
  1: "Jackalberry"
    value: "Jackalberry"
  2: "Mopane Tree"
    value: "Mopane Tree"
  3: "Breadfruit"
    value: "Breadfruit"
  size: 4
  [[Prototype]]: Set
*/
```

如果你没有用值初始化 `Set`，你可以使用 `add()` 方法为你的 `Set` 添加一项：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
```

结果和控制台中结果的显示保持不变。

别忘了 `Set` 中的副本项将被忽略：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
treeSet.add('Baobab'); //duplicate item will be ignored

console.log(treeSet);
// Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
```

你可以用来操作 `Set` 的其他方法有：

- `delete()`  
- `clear()`
- `has()`
- `entries()`
- `forEach()`
- `keys()`
- `values()`

让我们逐一看看这些方法是如何工作的。`delete()` 从 `Set` 中移除指定的项：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet); // Set(3) {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`has()` 检查指定的值是否存在于 `Set` 中：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.has('Breadfruit')); // false
```

`entries()` 返回一个 `Set` 迭代器，包含以 `[value, value]` 形式的值数组：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.entries());
// SetIterator {'Baobab' => 'Baobab', 'Jackalberry' => 'Jackalberry', 'Mopane Tree' => 'Mopane Tree'}
```

`keys()` 和 `values()` 显示 `Set` 中的值。`keys()` 只是 `values()` 方法的别名：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log('Keys: ', treeSet.keys());
console.log('Values: ', treeSet.values());
// Keys: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
// Values: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`forEach()` 让你迭代 `Set`：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.forEach((tree) => console.log(tree));
/*
Baobab
Jackalberry
Mopane Tree
*/
```

`clear()` 会移除数组中的所有项：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.clear();

console.log(treeSet); // Set(0) {size: 0}
```

还值得一提的是，有一个 `size` 属性返回 `Set` 中项的数量：

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.size); // 3
```

就像 `Set` 一样，也有一个 `WeakSet` 构造函数，你可以用它来创建 `WeakSet`：

```javascript
const treeWeakSet = new WeakSet();
```

`WeakSet` 也有 `add()`、`delete()` 和 `has()` 方法：

```javascript
const treeWeakSet = new WeakSet();

treeWeakSet.add({ name: 'Baobab' });
treeWeakSet.add({ name: 'Jackalberry' });
treeWeakSet.add({ name: 'Mopane Tree' });
treeWeakSet.add({ name: 'Breadfruit' });

treeWeakSet.delete('Jackalberry');
console.log(treeWeakSet.has('Jackalberry')); // false

console.log(treeWeakSet);
```

在输出中，`WeakSet` 的内容看起来像这样：

```javascript
/*
WeakSet {{…}, {…}, {…}, {…}}
  [[Entries]]
    No properties
  [[Prototype]]: WeakSet
    .
    .
    .
*/
```

内容显示为空，因为 WeakSets 不可迭代且不会直接暴露其内容。

不要忘记，只有具有明确定义密钥和值的符号和对象才被支持。添加原语，例如数字或字串，将导致误差：

```js
treeWeakSet.add('Alan Smith');

console.log(treeWeakSet); // Invalid value used in weak set
//    at WeakSet.add (<anonymous>)
```

`Set` 和 `WeakSet` 之间的关键区别在于 `Set` 可以保存任何值，而 `WeakSet` 只能保存对象。

以下是 `Set` 和 `WeakSet` 之间的一些其他显著区别：

| Feature | Set | WeakSet |
| --- | --- | --- |
| Type of Values Stored | Stores any data type | Stores only objects |
| Referencing | Strong referencing | Weak referencing |
| Iteration | Supports iteration with `forEach` and loops | Does not support iteration |
| Methods and Properties | `add()`, `delete()`, `has()`, `keys()`, `values()`, `size`, and more | `add()`, `delete()`, and `has()` only |
| Use case | General-purpose collection of unique values and removing duplicates from arrays | Efficient memory tracking of object references |

你可以看到这两种集合可以保存的值的类型差异、它们对迭代已保存对象的支持以及它们的理想使用分支。请花点时间阅读此表格的内容。

# --questions--

## --text--

`Set` 和 `WeakSet` 在它们都支持的数据方面有何不同？

## --answers--

`Set` 允许弱引用对象引用，而 `WeakSet` 支持对象和原语。

### --feedback--

请记住，`Set` 可以包含多种数据类型。

---

`Set` 可以保存任何类型，包括原语，而 `WeakSet` 只允许弱引用对象引用。

---

`Set` 的特色比 `WeakSet` 少。

### --feedback--

请记住，`Set` 可以包含多种数据类型。

---

`Set` 专用于对象，而 `WeakSet` 用于数字。

### --feedback--

请记住，`Set` 可以包含多种数据类型。

## --video-solution--

2

## --text--

你如何在 JavaScript 中创建 `Set` 或 `WeakSet`？

## --answers--

通过不使用 `new` 关键字调用 `Set()` 或 `WeakSet()`

### --feedback--

考虑需要包含哪个关键字来创建一个 `Set` 或 `WeakSet`。

---

通过使用对象字面值 `{}`

### --feedback--

考虑需要包含哪个关键字来创建一个 `Set` 或 `WeakSet`。

---

通过使用数组字面值 `[]`

### --feedback--

考虑需要包含哪个关键字来创建一个 `Set` 或 `WeakSet`。

---

通过使用带有 `new` 关键字的 `Set` 或 `WeakSet` 构造函数

## --video-solution--

4

## --text--

JavaScript 中哪些方法同时适用于 `Set` 和 `WeakSet`？

## --answers--

`keys()`、`values()`、`size()`

### --feedback--

复习课程结尾处讨论的内容。 

---

`add()`、`delete()`、`has()`

---

`clear()`、`entries()`、`forEach()`

### --feedback--

复习课程结尾处讨论的内容。 

---

`set()`、`get()`、`remove()`

### --feedback--

复习课程结尾处讨论的内容。 

## --video-solution--

2
