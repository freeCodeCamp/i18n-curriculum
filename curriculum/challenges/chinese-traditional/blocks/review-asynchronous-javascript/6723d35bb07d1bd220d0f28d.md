---
id: 6723d35bb07d1bd220d0f28d
title: 非同步 JavaScript 回顧
challengeType: 31
dashedName: review-asynchronous-javascript
---

# --description--

- **同步 JavaScript** 是依序執行，並且會等待前一個操作完成後才繼續下一個操作。
- **非同步 JavaScript** 允許多個操作在背景中執行，而不會阻塞主執行緒。
- **執行緒** 是一連串可以獨立於主程式流程執行的指令。
- **回呼函式** 是作為引數傳遞給其他函式，並在操作完成後或因事件而執行的函式。

## JavaScript 引擎和 JavaScript 執行期

- **JavaScript 引擎** 是一個在網頁瀏覽器中執行 JavaScript 程式碼的程式。它像一個轉換器，將你的程式碼轉換成電腦能理解並依此運作的指令。
- V8 是 Google 開發的 JavaScript 引擎範例。
- **JavaScript runtime** 是執行 JavaScript 程式碼的環境。它包含處理並執行程式碼的 JavaScript 引擎，以及像是網頁瀏覽器或 Node.js 等額外的特性。

## Fetch API

- Fetch API 允許網頁應用程式進行網路請求，通常用於從伺端擷取或傳送資料。它提供一個 `fetch()` 方法，讓你可以用來進行這些請求。
- 你可以使用 Fetch API 取得文字、影像、音訊、JSON 和其他型別的資料。

## Fetch API 的 HTTP 方法

Fetch API 支援各種 HTTP 方法來與伺服端互動。最常見的方法有：

- **GET**：用於從伺端擷取資料。Fetch API 預設使用 `GET` 方法來擷取資料。

```js
fetch('https://api.example.com/data')
```

要使用擷取的資料，必須使用 `.json()` 方法將其轉換為 JSON 格式：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

在這段程式碼中，來自 Fetch API 的回應是一個 promise，而 `.then` 處理常式將回應轉換為 JSON 格式。

- **POST**：用於將資料傳送到伺服器。`POST` 方法用於在伺服器上創建新資源。

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

在這個範例中，我們正在發送一個 `POST` 請求以創建一個新的使用者。我們已將行為指定為 `POST`，設定了適當的標頭，並包含了我們想要傳送的資料的主體。主體需要是一個字串，因此我們使用 `JSON.stringify()` 將我們的物件轉換成 JSON 字串。

- **PUT**：用於更新伺服端上的資料。`PUT` 方法用於更新伺服端上現有的資源。

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

在此範例中，我們正在更新 URL 結尾處指定的 ID `45`。我們在程式碼中使用了 `PUT` 方法，並且也將資料指定為主體，該主體將用於更新已識別的資料。 

- **DELETE**：用於刪除伺端上的資料。`DELETE` 方法用於刪除伺端上的資源。

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

在這個範例中，我們正在發送 `DELETE` 請求以移除 ID 為 `45` 的使用者。

## Promise 和 promise 串鏈

- **Promises** 是表述非同步操作最終完成或失敗及其結果值的物件。只有在 `async` 操作完成後，才會知道 promise 的值。
- 這裡有一個創建簡單 promise 的範例：

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- `.then()` 方法用於 Promise 中指定當 Promise 完成時應該發生的事情，而 `.catch()` 用於處理發生的任何錯誤。
- 以下是使用 `.then()` 和 `.catch()` 搭配 Promise 的範例：

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

在上述範例中，使用 `.then()` 方法來記錄從 Promise 接收到的資料，而使用 `.catch()` 方法來記錄發生的任何錯誤。

- **Promise 串鏈**：Promise 的強大特性之一是我們可以將多個非同步操作串鏈在一起。每個 `.then()` 都可以傳回一個新的 Promise，讓你能夠依序執行一連串的非同步操作。
- 這裡是一個 Promise 串鏈的範例：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

在上述範例中，我們首先從一個 URL 取得資料，然後根據第一個回應從另一個 URL 取得資料，最後記錄收到的第二筆資料。 

`catch` 方法會控制代碼中處理程序期間發生的任何錯誤。這表示你不需要為每個步驟添加錯誤控制代碼，這可以大幅簡化你的程式碼。

## 使用 `async/await` 來控制代碼 promises

Async/await 使撰寫和閱讀非同步程式碼更容易，它是建立在 Promises 之上的。

- **async**：`async` 關鍵字用於定義非同步函式（程式）。`async` 函式會傳回一個 Promise，該 Promise 會以 `async` 函式傳回的值來決議。
- **await**：`await` 關鍵字用於 `async` 函式（程式）內，以暫停函式（程式）的執行直到 Promise 被決議。它只能用在 `async` 函式（程式）內。
- 這裡是一個使用 `async/await` 的範例：

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

在上述範例中，`delayedGreeting` 函式（程式）是一個 `async` 函式（程式），會暫停 2 秒後才列印問候訊息。`await` 關鍵字用來暫停函式（程式）執行，直到 `Promise` 被決議。

- `async/await` 最大的優點之一是透過 `try/catch` 區塊進行錯誤處理。以下是一個範例：

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

在上述範例中，`try` 區塊包含可能會丟出錯誤的程式碼，而 `catch` 區塊則在錯誤發生時控制代碼。這使得錯誤處理更加簡單且易讀。

## `async` 屬性

- `async` 屬性告訴瀏覽器在繼續解析 HTML 文件的同時非同步下載腳本檔案。
- 腳本下載完成後，HTML 解析會暫停，腳本會執行，然後 HTML 解析會繼續。
- 你應該為執行順序不重要的獨立腳本使用 `async`。

## `defer` 屬性

- `defer` 屬性也會非同步下載腳本，但會延緩腳本的執行直到 HTML 文件完全解析之後。
- `defer` 腳本維護它們在 HTML 文件中出現的執行順序。

- 重要的是要注意，`async` 和 `defer` 屬性對行內腳本會被忽略，且僅對外部腳本檔案有效。

- 當同時存在 `async` 和 `defer` 屬性時，`async` 屬性具有優先權。

## 地理位置 API

- Geolocation API 提供網站請求使用者位置的方法。

- 以下範例示範了 API 的 `getCurrentPosition()` 方法，用於取得使用者的當前位置。

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

在這段程式碼中，我們正在呼叫 `getCurrentPosition` 並傳入一個函式（程式），當成功取得位置時該函式（程式）將會被呼叫。 

`position` 物件包含各種資訊，但這裡我們只選擇了 `latitude` 和 `longitude`。

如果取得 `position` 時發生問題，錯誤將會記錄到主控台。 

- 尊重使用者的隱私非常重要，且僅在必要時請求他們的位置。

# --assignment--

檢視非同步 JavaScript 主題和概念。
