---
id: 6564aee9c077774ea49c3faf
title: 步驟 3
challengeType: 20
dashedName: step-3
---

# --description--

歸併排序算法主要執行三個動作：

- 將未排序的列表劃分爲子部分
- 在子部分中排序項目
- 合併已排序的子部分

上述過程遞歸進行，直到子部分合併爲完整的排序序列。 讓我們從劃分序列開始。

首先，使用 `middle_point` 替換 `pass` 關鍵字。 使用整數除法運算符 (`//`) 將 `array` 列表的長度除以 2，並將結果分配給新的 `middle_point` 變量。 記得縮進你的代碼。

# --hints--

函數主體中不應有 `pass`。

```js
({
  test: () => {
    const transformedCode = code.replace(/\r/g, "");
    const merge_sort = __helpers.python.getDef("\n" + transformedCode, "merge_sort");
    const { function_body } = merge_sort;

    assert.notMatch(function_body, /^\s{4}pass/m);
  }
})
```

你應該聲明一個 `middle_point` 變量並將 `len(array) // 2` 分配給它。

```js
({
  test: () => {
    const transformedCode = code.replace(/\r/g, "");
    const merge_sort = __helpers.python.getDef("\n" + transformedCode, "merge_sort");
    const { function_body } = merge_sort;

    assert.match(function_body, /^\s{4}middle_point\s*=\s*len\(\s*array\s*\)\s*\/\/\s*2/m);
  }
})
```

# --seed--

## --seed-contents--

```py
--fcc-editable-region--
def merge_sort(array):
    pass
--fcc-editable-region--
```
