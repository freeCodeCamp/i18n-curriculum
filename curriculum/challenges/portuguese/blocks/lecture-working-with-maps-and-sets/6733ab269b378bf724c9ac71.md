---
id: 6733ab269b378bf724c9ac71
title: O que são Sets em JavaScript e como eles diferem de WeakSets?
challengeType: 19
dashedName: what-are-sets-in-javascript-and-how-does-it-differ-from-weaksets
---

# --description--

Em JavaScript, `Set` é um objeto embutido para gerenciar coleções de dados. Ele permite armazenar valores únicos de qualquer tipo, sejam primitivos ou referências a objetos. `Set` garante que cada valor nele apareça apenas uma vez, tornando-o útil para eliminar duplicatas de um array ou para manipular coleções de valores distintos.

Quanto ao `WeakSet`, é um tipo especial de `Set` com menos recursos que permite armazenar referências de objetos e símbolos mantidos fracamente. Ao contrário de `Set`, `WeakSet` não suporta primitivos como números e strings.

Ao contrário de um `Set` comum, um `WeakSet` armazena apenas objetos e as referências a esses objetos são "fracas", o que significa que os `WeakSets` não impedem que os objetos armazenados sejam coletados pelo garbage collector se não houver outras referências a eles. Em termos mais simples, se o objeto não estiver sendo usado em nenhum outro lugar no seu código, ele é removido automaticamente para liberar memória.

Para criar um `Set`, você usa o construtor `Set` e o atribui a uma variável:

```js
const myFirstSet = new Set();
```

Você também pode inicializar o `Set` com valores:

```js
const treeSet = new Set(['Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit']);
```

Se você registrar o `Set` no console, é assim que a saída aparece:

```js
/*
Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
  [[Entries]]
  0: "Baobab"
    value: "Baobab"
  1: "Jackalberry"
    value: "Jackalberry"
  2: "Mopane Tree"
    value: "Mopane Tree"
  3: "Breadfruit"
    value: "Breadfruit"
  size: 4
  [[Prototype]]: Set
*/
```

Se você não inicializou o `Set` com valores, pode usar o método `add()` para adicionar um item ao `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
```

O resultado e a aparência do resultado no console permanecem os mesmos.

Não esqueça que itens duplicados serão ignorados no `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
treeSet.add('Baobab'); //duplicate item will be ignored

console.log(treeSet);
// Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
```

Os outros métodos que você pode usar para manipular um `Set` são:

- `delete()`  
- `clear()`
- `has()`
- `entries()`
- `forEach()`
- `keys()`
- `values()`

Vamos ver como esses métodos funcionam um por um. `delete()` remove um item especificado do `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet); // Set(3) {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`has()` verifica se um valor especificado existe no `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.has('Breadfruit')); // false
```

`entries()` retorna um iterador `Set` contendo um array dos valores no formato `[value, value]`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.entries());
// SetIterator {'Baobab' => 'Baobab', 'Jackalberry' => 'Jackalberry', 'Mopane Tree' => 'Mopane Tree'}
```

`keys()` e `values()` mostram os valores no `Set`. `keys()` é apenas um alias para o método `values()`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log('Keys: ', treeSet.keys());
console.log('Values: ', treeSet.values());
// Keys: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
// Values: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`forEach()` permite que você itere através do `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.forEach((tree) => console.log(tree));
/*
Baobab
Jackalberry
Mopane Tree
*/
```

`clear()` remove todos os itens do array:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.clear();

console.log(treeSet); // Set(0) {size: 0}
```

Também vale mencionar que existe uma propriedade `size` que retorna o número de itens no `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.size); // 3
```

Assim como `Set`, também existe um construtor `WeakSet` que você pode usar para criar um `WeakSet`:

```javascript
const treeWeakSet = new WeakSet();
```

`WeakSet` também possui os métodos `add()`, `delete()` e `has()`:

```javascript
const treeWeakSet = new WeakSet();

treeWeakSet.add({ name: 'Baobab' });
treeWeakSet.add({ name: 'Jackalberry' });
treeWeakSet.add({ name: 'Mopane Tree' });
treeWeakSet.add({ name: 'Breadfruit' });

treeWeakSet.delete('Jackalberry');
console.log(treeWeakSet.has('Jackalberry')); // false

console.log(treeWeakSet);
```

Na saída, o conteúdo do `WeakSet` aparece assim:

```javascript
/*
WeakSet {{…}, {…}, {…}, {…}}
  [[Entries]]
    No properties
  [[Prototype]]: WeakSet
    .
    .
    .
*/
```

O conteúdo parece vazio porque WeakSets não são iteráveis e não expõem seu conteúdo diretamente.

Não esqueça que apenas símbolos e objetos com chaves e valores bem definidos são suportados. Adicionar um primitivo, como números ou strings, resultará em um erro:

```js
treeWeakSet.add('Alan Smith');

console.log(treeWeakSet); // Invalid value used in weak set
//    at WeakSet.add (<anonymous>)
```

A principal diferença entre um `Set` e um `WeakSet` é que um `Set` armazena qualquer valor, enquanto um `WeakSet` só pode armazenar objetos.

Aqui estão algumas outras diferenças notáveis entre um `Set` e um `WeakSet`:

| Feature | Set | WeakSet |
| --- | --- | --- |
| Type of Values Stored | Stores any data type | Stores only objects |
| Referencing | Strong referencing | Weak referencing |
| Iteration | Supports iteration with `forEach` and loops | Does not support iteration |
| Methods and Properties | `add()`, `delete()`, `has()`, `keys()`, `values()`, `size`, and more | `add()`, `delete()`, and `has()` only |
| Use case | General-purpose collection of unique values and removing duplicates from arrays | Efficient memory tracking of object references |

Você pode ver as diferenças nos tipos de valores que os dois tipos de conjuntos podem armazenar, seu suporte para iterar sobre os objetos armazenados e seus casos de uso ideais. Por favor, reserve um momento para ler o conteúdo desta tabela.

# --questions--

## --text--

Como um `Set` difere de um `WeakSet` quando se trata dos dados que ambos suportam?

## --answers--

Um `Set` permite referências de objeto mantidas fracamente, enquanto um `WeakSet` suporta tanto objetos e primitivos.

### --feedback--

Lembre-se que um `Set` pode conter uma variedade de tipos de dados.

---

Um `Set` armazena qualquer tipo, incluindo primitivos, enquanto um `WeakSet` permite apenas referências a objetos mantidas fracamente.

---

Um `Set` tem menos recursos que um `WeakSet`.

### --feedback--

Lembre-se que um `Set` pode conter uma variedade de tipos de dados.

---

Um `Set` é exclusivamente para objetos enquanto um `WeakSet` é para números.

### --feedback--

Lembre-se que um `Set` pode conter uma variedade de tipos de dados.

## --video-solution--

2

## --text--

Como você cria um `Set` ou um `WeakSet` em JavaScript?

## --answers--

Ao chamar `Set()` ou `WeakSet()` sem a palavra-chave `new`

### --feedback--

Pense em qual palavra-chave precisa ser incluída para criar um `Set` ou `WeakSet`.

---

Ao usar literais de objeto `{}`

### --feedback--

Pense em qual palavra-chave precisa ser incluída para criar um `Set` ou `WeakSet`.

---

Ao usar literais de array `[]`

### --feedback--

Pense em qual palavra-chave precisa ser incluída para criar um `Set` ou `WeakSet`.

---

Ao usar o construtor `Set` ou `WeakSet` com a palavra-chave `new`

## --video-solution--

4

## --text--

Quais métodos estão disponíveis tanto para um `Set` quanto para um `WeakSet` em JavaScript?

## --answers--

`keys()`, `values()` e `size()`

### --feedback--

Revise o final da lição onde isso foi discutido. 

---

`add()`, `delete()`, `has()`

---

`clear()`, `entries()`, `forEach()`

### --feedback--

Revise o final da lição onde isso foi discutido. 

---

`set()`, `get()` e `remove()`

### --feedback--

Revise o final da lição onde isso foi discutido. 

## --video-solution--

2
