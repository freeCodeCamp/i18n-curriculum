---
id: 673407d56c3dce67fa97969b
title: ¿Qué es Async/Await, y cómo funciona?
challengeType: 19
dashedName: what-is-async-await-and-how-does-it-work
---

# --interactive--

En las lecciones anteriores, aprendiste sobre la programación asíncrona que permite que otro código se ejecute mientras esperamos a que algunas tareas que consumen mucho tiempo se completen, como obtener datos de un servidor, leer datos de un archivo, y así sucesivamente.

`async`/`await`, construido sobre promesas, facilita escribir y leer código asincrónico. Cuando pones la palabra clave `async` antes de una función, significa que esa función siempre devolverá una `Promesa`. Solo dentro de una función `async`, puedes usar la palabra clave `await`, que te permite esperar a que se resuelva una `Promesa` antes de pasar a la siguiente línea de código. Aquí tienes un ejemplo para ilustrar cómo funciona `async`/`await`:

:::interactive_editor

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

:::

En este código, definimos una función `async` llamada `delayedGreeting`. Dentro de esta función, usamos `await` para pausar la ejecución por 2 segundos. Después de la demora, imprime un saludo. 

Cuando llamamos a esta función, verás que `¡Primer Mensaje Impreso!` aparece antes del saludo. Esto se debe a que la función es asincrónica, no bloquea el resto del código para que se ejecute.

Una de las mayores ventajas de `async`/`await` es el manejo de errores. Con promesas, a menudo teníamos que usar el método `.catch()` para manejar errores. Con `async`/`await`, podemos usar bloques `try`/`catch`. Aquí tienes un ejemplo:

```js
async function fetchUserData() {
  try {
    let response = await fetch(`https://api.example.com/users`);
    let userData = await response.json();
    console.log(userData);
  } catch (error) {
    console.log("Error fetching user data:", error);
  }
}

fetchUserData();
```

En este ejemplo, estamos usando `async`/`await` para obtener datos de usuario de una API. La palabra clave `await` se utiliza dos veces: una para esperar que la operación de extracción se complete, y otra para esperar que finalice el análisis JSON. Si ocurre algún error durante este proceso, se capturará en el bloque `catch`.

# --questions--

## --text--

¿Cuál es el propósito principal de la palabra clave `async` en JavaScript?

## --answers--

Para hacer que una función se ejecute más rápido.

### --feedback--

Piensa en lo que `async` hace al valor de retorno de la función.

---

Para indicar que una función siempre devolverá una Promesa.

---

Para crear un nuevo hilo para que la función se ejecute.

### --feedback--

Piensa en lo que `async` hace al valor de retorno de la función.

---

Para evitar que una función se llame de manera asincrónica.

### --feedback--

Piensa en lo que `async` hace al valor de retorno de la función.

## --video-solution--

2

## --text--

¿Dónde se puede usar la palabra clave `await` en JavaScript?

## --answers--

En cualquier lugar del código.

### --feedback--

Considera las restricciones sobre dónde se puede colocar `await`.

---

Al principio de su código.

### --feedback--

Considera las restricciones sobre dónde se puede colocar `await`.

---

Dentro de funciones `async`.

---

Solo en bloques `try...catch`.

### --feedback--

Considera las restricciones sobre dónde se puede colocar `await`.

## --video-solution--

3

## --text--

¿Qué ocurre cuando sucede un error en una Promesa que se está esperando?

## --answers--

El programa se bloquea.

### --feedback--

Piensa en cómo el manejo de errores funciona con `async`/`await`.

---

El error se registra automáticamente en la consola.

### --feedback--

Piensa en cómo el manejo de errores funciona con `async`/`await`.

---

Nada, se ignoran los errores en Promesas.

### --feedback--

Piensa en cómo el manejo de errores funciona con `async`/`await`.

---

El error se puede capturar utilizando un bloque `try...catch`.

## --video-solution--

4
