---
id: 594810f028c0303b75339ad4
title: 自動換行
challengeType: 1
forumTopicId: 302344
dashedName: word-wrap
---

# --description--

即使在今天，使用等寬字型和複雜版面配置時，仍然有需要在指定行換行文字的情況。基本任務是以簡單的方式換行一段文字。

# --instructions--

撰寫一個函式（程式），可以將這段文字換行至任意字元數。請注意，輸入的文字已包含換行符號，你的函式（程式）應該適當處理這些換行符號。舉例來說，換行至 80 字元的文字應該如下所示：

<pre>
Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX
algorithm. If your language provides this, you get easy extra credit, but you
must reference documentation indicating that the algorithm is something better
than a simple minimum length algorithm.
</pre>

# --hints--

`wrap` 應該是一個函式（程式）。

```js
assert.equal(typeof wrap, 'function');
```

`wrap` 應該傳回一個字串。

```js
assert.equal(typeof wrap('abc', 10), 'string');
```

`wrap(text,80)` 應該傳回 4 行。

```js
assert(wrapped80.split('\n').length === 4);
```

你的 `wrap` 函式應該傳回預期的文字。

```js
assert.equal(wrapped80.split('\n')[0], firstRow80);
```

`wrap(text,42)` 應該傳回 7 行。

```js
assert(wrapped42.split('\n').length === 7);
```

你的 `wrap` 函式應該傳回預期的文字。

```js
assert.equal(wrapped42.split('\n')[0], firstRow42);
```

# --seed--

## --after-user-code--

```js
const text =
`Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.
If your language provides this, you get easy extra credit,
but you ''must reference documentation'' indicating that the algorithm
is something better than a simple minimum length algorithm.`;

const wrapped80 = wrap(text, 80);
const wrapped42 = wrap(text, 42);

const firstRow80 =
    'Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX';

const firstRow42 = 'Wrap text using a more sophisticated';
```

## --seed-contents--

```js
function wrap(text, limit) {
  return text;
}
```

# --solutions--

```js
function wrap(text, limit) {
  const noNewlines = text.replace('\n', '');
  if (noNewlines.length > limit) {
    // find the last space within limit
    const edge = noNewlines.slice(0, limit).lastIndexOf(' ');
    if (edge > 0) {
      const line = noNewlines.slice(0, edge);
      const remainder = noNewlines.slice(edge + 1);
      return line + '\n' + wrap(remainder, limit);
    }
  }
  return text;
}
```
