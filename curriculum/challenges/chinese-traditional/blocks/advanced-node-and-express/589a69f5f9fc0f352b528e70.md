---
id: 589a69f5f9fc0f352b528e70
title: 社交驗證的實作
challengeType: 2
forumTopicId: 301559
dashedName: implementation-of-social-authentication
---

# --description--

這種類型的驗證在你的應用程式中將遵循的基本路徑是：

1.  使用者點擊按鈕或聯結，將他們導向你的路由以使用特定策略（例如 GitHub）進行驗證。
2.  你的路由會呼叫 `passport.authenticate('github')`，將他們重新導向到 GitHub。
3.  使用者在 GitHub 登入的頁面，如果尚未登入，會允許他們登入。接著會要求他們批准你的應用程式存取他們的評測。
4.  如果使用者獲准，系統會將他們的評測傳回到你的應用程式中指定的回呼 URL。
5.  他們現在已通過驗證，你的應用程式應該檢查是否為返回的評測，若不是，則將其存檔到你的資料庫中。

使用 OAuth 的策略需要你至少擁有一組 *Client ID* 和 *Client Secret*，這是服務用來驗證認證請求來自誰以及是否有效的方法。這些資訊是從你嘗試實作認證的網站取得，例如 GitHub，且對你的應用程式是唯一的——**絕對不可分享**，且絕不應該上傳到公開的版本庫或直接寫在你的程式碼中。常見的做法是將它們放在你的 `.env` 檔案中，並像這樣取用：`process.env.GITHUB_CLIENT_ID`。在這個挑戰中，你將使用 GitHub 策略。

請依照 <a href="https://www.freecodecamp.org/news/how-to-set-up-a-github-oauth-application/" target="_blank" rel="noopener noreferrer nofollow">這些說明</a> 從 GitHub 取得你的 *Client ID and Secret*。將首頁 URL 設為你的首頁（**非專案程式碼的 URL**），並將回呼 URL 設為相同的首頁 URL，後面加上 `/auth/github/callback`。將 client ID 和你的 client secret 以 `GITHUB_CLIENT_ID` 和 `GITHUB_CLIENT_SECRET` 儲存在你的專案 `.env` 檔案中。

在你的 `routes.js` 檔案中，為首頁路由在 `showRegistration: true` 之後添加 `showSocialAuth: true`。現在，創建 2 個接受 GET 請求的路由：`/auth/github` 和 `/auth/github/callback`。第一個路由應該只呼叫 passport 來驗證 `'github'`。第二個路由應該呼叫 passport 來驗證 `'github'`，失敗時重新導向到 `/`，如果成功則重新導向到 `/profile`（類似於你上一個專案）。

`/auth/github/callback` 應該長得像你控制一般登入的方式的範例：

```js
app.route('/login')
  .post(passport.authenticate('local', { failureRedirect: '/' }), (req,res) => {
    res.redirect('/profile');
  });
```

當你認為已經正確完成時，提交你的頁面。如果你遇到錯誤，你可以<a href="https://forum.freecodecamp.org/t/advanced-node-and-express/567135#implementation-of-social-authentication-3" target="_blank" rel="noopener noreferrer nofollow">取用至此為止的專案</a>。

# --hints--

路由 `/auth/github` 應該是正確的。

```js
  try {
    const res = await fetch(code + '/_api/routes.js');
    if (res.ok) {
      const data = await res.text();
      assert.match(
          data.replace(/\s/g, ''),
          /passport.authenticate.*?github/g,
          'Route auth/github should only call passport.authenticate with github'
        );
    } else {
      throw new Error(res.statusText);
    }
    const res2 = await fetch(code + '/_api/app-stack');
    if (res2.ok) {
      const data2 = JSON.parse(await res2.json());
      const dataLayer = data2.find(layer => layer?.route?.path === '/auth/github');
      assert.deepInclude(dataLayer?.route, { methods: {get: true}, path: "/auth/github"});
      assert.deepInclude(dataLayer?.route?.stack?.[0], {method: "get", name: "authenticate"});
    } else {
      throw new Error(res2.statusText);
    }
  } catch (err) {
    throw new Error(err);
  }
```

路由 `/auth/github/callback` 應該是正確的。

```js
  try {
    const res = await fetch(code + '/_api/routes.js');
    if (res.ok) {
      const data = await res.text();
      assert.match(
        data.replace(/\s/g, ''),
        /failureRedirect:("|')\/\1/g,
        'Route auth/github/callback should accept a get request and call passport.authenticate for github with a failure redirect to home'
      );
    } else {
      throw new Error(res.statusText);
    }
    const res2 = await fetch(code + '/_api/app-stack');
    if (res2.ok) {
      const data2 = JSON.parse(await res2.json());
      const dataLayer = data2.find(layer => layer?.route?.path === '/auth/github/callback');
      assert.deepInclude(dataLayer?.route, { methods: {get: true}, path: "/auth/github/callback"});
      assert.deepInclude(dataLayer?.route?.stack?.[0], {method: "get", name: "authenticate"});
    } else {
      throw new Error(res2.statusText);
    }
  } catch (err) {
    throw new Error(err);
  }
```

