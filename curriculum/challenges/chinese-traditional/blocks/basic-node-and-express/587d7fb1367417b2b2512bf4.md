---
id: 587d7fb1367417b2b2512bf4
title: 串鏈中介層以創建時間伺服端
challengeType: 2
forumTopicId: 301510
dashedName: chain-middleware-to-create-a-time-server
---

# --description--

中介層可以使用 `app.METHOD(path, middlewareFunction)` 安裝在特定路由。中介層也可以在路由定義中串鏈。

請看以下範例：

```js
app.get('/user', function(req, res, next) {
  req.user = getTheUserSync();  // Hypothetical synchronous operation
  next();
}, function(req, res) {
  res.send(req.user);
});
```

這種方法有助於將伺服端操作拆分成較小的單元。這會導致更好的應用程式結構，並且可以在不同地方重複使用程式碼。這種方法也可以用來對資料進行某些驗證。在中介層堆疊的每個點，你可以阻止目前串鏈的執行，並將控制權交給專門設計來控制錯誤的函式。或者你可以將控制權交給下一個符合條件的路由，以處理特殊情況。我們將在進階 Express 章節中看到如何操作。

# --instructions--

在路由 `app.get('/now', ...)` 串鏈中串接一個中介層函式和最終處理常式。在中介層函式中，你應該將目前時間添加到請求物件的 `req.time` 鍵中。你可以使用 `new Date().toString()`。在處理常式中，回應一個 JSON 物件，採用結構 `{time: req.time}`。

**注意：** 如果你不串鏈中介層，測試將不會通過。如果你將函式掛載到其他地方，即使輸出結果正確，測試也會失敗。

# --hints--

`/now` 端點應該掛載中介層

```js
  const response = await fetch(code + '/_api/chain-middleware-time');
  if (!response.ok) {
    throw new Error(await response.text());
  }
  const data = await response.json();
  assert.equal(
    data.stackLength,
    2,
    '"/now" route has no mounted middleware'
  );
```

`/now` 端點應該傳回目前時間。

```js
  const response = await fetch(code + '/_api/chain-middleware-time');
  if (!response.ok) {
    throw new Error(await response.text());
  }
  const data = await response.json();
  var now = new Date();
  assert.isAtMost(
    Math.abs(new Date(data.time) - now),
    20000,
    'the returned time is not between +- 20 secs from now'
  );
```

