---
id: 587d7b7b367417b2b2512b16
title: 創建複雜的多維陣列
challengeType: 1
forumTopicId: 301159
dashedName: create-complex-multi-dimensional-arrays
---

# --description--

太棒了！你剛剛學到了很多關於陣列的知識！這是一個相當高層次的概述，還有很多關於操作陣列的內容等待你去學習，這些你會在後面的章節中看到。但在繼續了解 <dfn>Objects</dfn> 之前，讓我們再看一次，看看陣列如何比我們在之前的挑戰中看到的更複雜一些。

當將陣列視為資料結構時，其中一個最強大的特性是陣列可以包含其他陣列，甚至完全由其他陣列組成。我們在先前的挑戰中已經看過包含陣列的陣列，但那些相當簡單。然而，陣列可以包含無限深度的陣列，這些陣列又可以包含其他陣列，每個都有其任意的深度層級，依此類推。透過這種方式，陣列可以非常快速地變成一個非常複雜的資料結構，稱為<dfn>多維</dfn>或巢狀陣列。請參考以下範例：

```js
let nestedArray = [
  ['deep'],
  [
    ['deeper'], ['deeper'] 
  ],
  [
    [
      ['deepest'], ['deepest']
    ],
    [
      [
        ['deepest-est?']
      ]
    ]
  ]
];
```

`deep` 陣列巢狀 2 層深。`deeper` 陣列巢狀 3 層深。`deepest` 陣列巢狀 4 層深，而 `deepest-est?` 是 5 層。

雖然這個範例看起來可能很複雜，但在處理大量資料時，這種層級的複雜性並非罕見，甚至不算不尋常。然而，我們仍然可以非常輕鬆地使用括號表示法存取這麼複雜陣列的最深層次。

```js
console.log(nestedArray[2][1][0][0][0]);
```

這會記錄字串 `deepest-est?`。現在我們知道那筆資料的位置，如果需要，我們可以重設它：

```js
nestedArray[2][1][0][0][0] = 'deeper still';

console.log(nestedArray[2][1][0][0][0]);
```

現在它會記錄 `deeper still`。

# --instructions--

我們已定義一個變數，`myNestedArray`，並將其設定為一個陣列。修改 `myNestedArray`，使用任意組合的 <dfn>字串</dfn>、<dfn>數字</dfn> 和 <dfn>布林值</dfn> 作為資料元素，使其具有正好五個層級的深度（記住，最外層的陣列是層級 1）。在第三層的某處，包含字串 `deep`，在第四層包含字串 `deeper`，在第五層包含字串 `deepest`。

# --hints--

`myNestedArray` 應該只包含數字、布林值和字串作為資料元素

```js
assert.strictEqual(
  (function (arr) {
    let flattened = (function flatten(arr) {
      const flat = [].concat(...arr);
      return flat.some(Array.isArray) ? flatten(flat) : flat;
    })(arr);
    for (let i = 0; i < flattened.length; i++) {
      if (
        typeof flattened[i] !== 'number' &&
        typeof flattened[i] !== 'string' &&
        typeof flattened[i] !== 'boolean'
      ) {
        return false;
      }
    }
    return true;
  })(myNestedArray),
  true
);
```

`myNestedArray` 應該有正好 5 層層次的深度

```js
assert.strictEqual(
  (function (arr) {
    let depth = 0;
    function arrayDepth(array, i, d) {
      if (Array.isArray(array[i])) {
        arrayDepth(array[i], 0, d + 1);
      } else {
        depth = d > depth ? d : depth;
      }
      if (i < array.length) {
        arrayDepth(array, i + 1, d);
      }
    }
    arrayDepth(arr, 0, 0);
    return depth;
  })(myNestedArray),
  4
);
```

`myNestedArray` 應該包含在巢狀 3 層的陣列中，字串 `deep` 的正好一個出現次數。

```js
assert(
  (function howDeep(array, target, depth = 0) {
    return array.reduce((combined, current) => {
      if (Array.isArray(current)) {
        return combined.concat(howDeep(current, target, depth + 1));
      } else if (current === target) {
        return combined.concat(depth);
      } else {
        return combined;
      }
    }, []);
  })(myNestedArray, 'deep').length === 1 &&
    (function howDeep(array, target, depth = 0) {
      return array.reduce((combined, current) => {
        if (Array.isArray(current)) {
          return combined.concat(howDeep(current, target, depth + 1));
        } else if (current === target) {
          return combined.concat(depth);
        } else {
          return combined;
        }
      }, []);
    })(myNestedArray, 'deep')[0] === 2
);
```

`myNestedArray` 應該包含在巢狀 4 層的陣列中，字串 `deeper` 的出現次數正好為一次。

```js
assert(
  (function howDeep(array, target, depth = 0) {
    return array.reduce((combined, current) => {
      if (Array.isArray(current)) {
        return combined.concat(howDeep(current, target, depth + 1));
      } else if (current === target) {
        return combined.concat(depth);
      } else {
        return combined;
      }
    }, []);
  })(myNestedArray, 'deeper').length === 1 &&
    (function howDeep(array, target, depth = 0) {
      return array.reduce((combined, current) => {
        if (Array.isArray(current)) {
          return combined.concat(howDeep(current, target, depth + 1));
        } else if (current === target) {
          return combined.concat(depth);
        } else {
          return combined;
        }
      }, []);
    })(myNestedArray, 'deeper')[0] === 3
);
```

`myNestedArray` 應該包含在巢狀 5 層深的陣列中，字串 `deepest` 僅出現一次。

```js
assert(
  (function howDeep(array, target, depth = 0) {
    return array.reduce((combined, current) => {
      if (Array.isArray(current)) {
        return combined.concat(howDeep(current, target, depth + 1));
      } else if (current === target) {
        return combined.concat(depth);
      } else {
        return combined;
      }
    }, []);
  })(myNestedArray, 'deepest').length === 1 &&
    (function howDeep(array, target, depth = 0) {
      return array.reduce((combined, current) => {
        if (Array.isArray(current)) {
          return combined.concat(howDeep(current, target, depth + 1));
        } else if (current === target) {
          return combined.concat(depth);
        } else {
          return combined;
        }
      }, []);
    })(myNestedArray, 'deepest')[0] === 4
);
```

# --seed--

## --seed-contents--

```js
let myNestedArray = [
  // Only change code below this line
  ['unshift', false, 1, 2, 3, 'complex', 'nested'],
  ['loop', 'shift', 6, 7, 1000, 'method'],
  ['concat', false, true, 'spread', 'array'],
  ['mutate', 1327.98, 'splice', 'slice', 'push'],
  ['iterate', 1.3849, 7, '8.4876', 'arbitrary', 'depth']
  // Only change code above this line
];
```

# --solutions--

```js
let myNestedArray = [
  ['unshift', ['deep', ['deeper', ['deepest']]],false, 1, 2, 3, 'complex', 'nested'],
  ['loop', 'shift', 6, 7, 1000, 'method'],
  ['concat', false, true, 'spread', 'array'],
  ['mutate', 1327.98, 'splice', 'slice', 'push'],
  ['iterate', 1.3849, 7, '8.4876', 'arbitrary', 'depth']
];
```
