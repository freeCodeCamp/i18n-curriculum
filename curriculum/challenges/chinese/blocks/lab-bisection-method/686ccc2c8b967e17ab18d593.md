---
id: 686ccc2c8b967e17ab18d593
title: 实现二分法
challengeType: 27
dashedName: implement-the-bisection-method
---

# --description--

二分法，也称为二分查找法，使用二分查找来查找实值函数的根。它通过缩小平方根所在的区间，直到收敛到指定容差范围内的值。

例如，如果容差是 `0.01`，二分法将不断将区间对半分，直到上边界和下边界之间的差小于或相等于 `0.01`。

在本实验中，你将实现一个使用二分法查找数字平方根的函数。

**目标：**实现以下用户需求并通过所有测试以完成实验。

**用户故事：**

1. 你应该定义一个名为 `square_root_bisection` 的函数，带有三个参数：
    - 你想要查找平方根的数字。
    - 容差是结果可接受的误差范围。你应该设置一个默认容差值。
    - 要执行的最大迭代次数。你应该设置一个默认的迭代次数。

1. `square_root_bisection` 函数应当：
    - 如果传递给函数的数字为负数，则引起带有消息 `Square root of negative number is not defined in real numbers` 的 `ValueError`。
    - 对于数字 `0` 和 `1`，打印消息：`The square root of [number] is [number]` 并返回该数字本身作为平方根。
    - 对于任何其他正数，打印带有消息的近似平方根：`The square root of [square_target] is approximately [root]` 并返回计算出的根值。
    - 如果没有值满足容差条件，打印失败消息：`Failed to converge within [maximum] iterations` 并返回 `None`。

**注意**：你不能为此实验导入任何模块。

# --hints--

你不应该导入任何模块。

```js
({ test: () => assert(runPython(`len(_Node(_code).find_imports()) == 0`)) })
```

你应该有一个名为 `square_root_bisection` 的函数。

```js
({ test: () => assert(runPython(`_Node(_code).has_function("square_root_bisection")`)) })
```

你的 `square_root_bisection` 函数应有三个参数。

```js
({ test: () => runPython(`
    import inspect 
    sig = inspect.signature(square_root_bisection)
    assert len(sig.parameters) == 3
`) })
```

你应该为容差和最大迭代次数设置默认值。

```js
({ test: () => runPython(`
try:
  import inspect 
  sig = inspect.signature(square_root_bisection)
  assert len(sig.parameters) == 3
  square_root_bisection(4)
except TypeError:
  assert False
`) })
```

当传递给函数的数字为负数时，你的 `square_root_bisection` 函数应引起带有消息 `Square root of negative number is not defined in real numbers` 的 `ValueError`。

```js
({ test: () => runPython(`
try:
  square_root_bisection(-6)
except ValueError as e:
  assert str(e) == "Square root of negative number is not defined in real numbers"
else:
  assert False
`) })
```

`square_root_bisection(0)` 应返回 `0`。

```js
({ test: () => runPython(`assert square_root_bisection(0) == 0`) })
```

`square_root_bisection(0)` 应该打印 `The square root of 0 is 0`。

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print
square_root_bisection(0)
assert "The square root of 0 is 0" in _out
`) })
```

`square_root_bisection(0.001, 1e-7, 50)` 应返回介于 `0.03162267660168379` 和 `0.031622876601683794` 之间的数字。

```js
({ test: () => runPython(`assert 0.03162267660168379 <= square_root_bisection(0.001, 1e-7, 50) <= 0.031622876601683794`) })
```

`square_root_bisection(0.001, 1e-7, 50)` 应该打印 `The square root of 0.001 is approximately X`，其中 `X` 是介于 `0.03162267660168379` 和 `0.031622876601683794` 之间的数字。

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(0.001, 1e-7, 50)

assert 0.03162267660168379 <= _root <= 0.031622876601683794
assert f"The square root of 0.001 is approximately {_root}" in _out
`) })
```

`square_root_bisection(0.25, 1e-7, 50)` 应返回一个介于 `0.4999999` 和 `0.5000001` 之间的数字。

```js
({ test: () => runPython(`assert 0.4999999 <= square_root_bisection(0.25, 1e-7, 50) <= 0.5000001`) })
```

`square_root_bisection(0.25, 1e-7, 50)` 应该打印 `The square root of 0.25 is approximately X`，其中 `X` 是介于 `0.4999999` 和 `0.5000001` 之间的数字。

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(0.25, 1e-7, 50)

assert 0.4999999 <= _root <= 0.5000001
assert f"The square root of 0.25 is approximately {_root}" in _out
`) })
```

`square_root_bisection(1)` 应该返回 `1`。

```js
({ test: () => runPython(`assert square_root_bisection(1) == 1`) })
```

`square_root_bisection(1)` 应该打印 `The square root of 1 is 1`。

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print
square_root_bisection(1)
assert "The square root of 1 is 1" in _out
`) })
```

`square_root_bisection(81, 1e-3, 50)` 应返回一个介于 `8.999` 和 `9.001` 之间的数字。

```js
({ test: () => runPython(`assert 8.999 <= square_root_bisection(81, 1e-3, 50) <= 9.001`) })
```

`square_root_bisection(81, 1e-3, 50)` 应该打印 `The square root of 81 is approximately X`，其中 `X` 是介于 `8.999` 和 `9.001` 之间的数字。

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(81, 1e-3, 50)

assert 8.999 <= _root <= 9.001
assert f"The square root of 81 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-3, 100)` 应返回一个介于 `14.999` 和 `15.001` 之间的数字。

```js
({ test: () => runPython(`assert 14.999 <= square_root_bisection(225, 1e-3, 100) <= 15.001`) })
```

`square_root_bisection(225, 1e-3, 100)` 应该打印 `The square root of 225 is approximately X`，其中 `X` 是介于 `14.999` 和 `15.001` 之间的数字。

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(225, 1e-3, 100)

assert 14.999 <= _root <= 15.001
assert f"The square root of 225 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-5, 100)` 应返回一个介于 `14.99999` 和 `15.00001` 之间的数字。

```js
({ test: () => runPython(`assert 14.99999 <= square_root_bisection(225, 1e-5, 100) <= 15.00001`) })
```

`square_root_bisection(225, 1e-5, 100)` 应该打印 `The square root of 225 is approximately X`，其中 `X` 是介于 `14.99999` 和 `15.00001` 之间的数字。

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(225, 1e-5, 100)

assert 14.99999 <= _root <= 15.00001
assert f"The square root of 225 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-7, 100)` 应返回一个介于 `14.9999999` 和 `15.0000001` 之间的数字。

```js
({ test: () => runPython(`assert 14.9999999 <= square_root_bisection(225, 1e-7, 100) <= 15.0000001`) })
```

`square_root_bisection(225, 1e-7, 100)` 应该打印 `The square root of 225 is approximately X`，其中 `X` 是介于 `14.9999999` 和 `15.0000001` 之间的数字。

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print

_root = square_root_bisection(225, 1e-7, 100)

assert 14.9999999 <= _root <= 15.0000001
assert f"The square root of 225 is approximately {_root}" in _out
`) })
```

`square_root_bisection(225, 1e-7, 10)` 应返回 `None`。

```js
({ test: () => runPython(`assert square_root_bisection(225, 1e-7, 10) is None`) })
```

`square_root_bisection(225, 1e-7, 10)` 应打印 `Failed to converge within 10 iterations`。

```js
({ test: () => runPython(`
built_in_print = print
_out = []

def custom_print(*args, **kwargs):
  call_args = [arg for arg in args]
  _out.extend(call_args)

print = custom_print
square_root_bisection(225, 1e-7, 10)
assert "Failed to converge within 10 iterations" in _out
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):
    if square_target < 0:
        raise ValueError('Square root of negative number is not defined in real numbers')
    if square_target == 1:
        root = 1
        print(f'The square root of {square_target} is 1')
    elif square_target == 0:
        root = 0
        print(f'The square root of {square_target} is 0')

    else:
        low = square_target if square_target < 1 else 1
        high = 1 if square_target < 1 else square_target
        root = None

        for _ in range(max_iterations):
            mid = (low + high) / 2
            square_mid = mid**2

            if high - low <= tolerance:
                root = mid
                break

            elif square_mid < square_target:
                low = mid
            else:
                high = mid

        if root is None:
            print(f"Failed to converge within {max_iterations} iterations")

        else:   
            print(f'The square root of {square_target} is approximately {root}')

    return root
```
