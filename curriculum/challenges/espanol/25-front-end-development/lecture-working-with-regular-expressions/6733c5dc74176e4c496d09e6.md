---
id: 6733c5dc74176e4c496d09e6
title: '¿Qué son las aserciones de anticipación y retroceso, y cómo funcionan?'
challengeType: 11
videoId: U-XnBty3JOo
dashedName: what-are-lookaheads-and-lookbehind-assertions-and-how-do-they-work
---

# --description--

Mira el video o lee la transcripción y responde las preguntas a continuación.

# --transcript--

¿Qué son las aserciones de anticipación y retroceso, y cómo funcionan?

Aprendamos sobre las aserciones de anticipación y retroceso en expresiones regulares.

Las aserciones de anticipación y retroceso te permiten coincidir con patrones específicos según la presencia o falta de patrones circundantes. Hay cuatro variaciones de estas aserciones.

La primera es la aserción de anticipación positiva. Esta aserción coincidirá con un patrón cuando el patrón sea seguido por otro patrón.

Para construir una anticipación positiva, necesitas empezar con el patrón que quieres coincidir. Luego, usa paréntesis para envolver el patrón que quieres usar como tu condición. Después del paréntesis de apertura, usa `?=` para definir ese patrón como una anticipación positiva.

Este patrón solo coincidirá con la palabra `free` si está seguida por `code`:

```js
const regex = /free(?=code)/i;
```

Probemos el comportamiento de nuestro patrón:

```js
const regex = /free(?=code)/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

Observe cómo solo la cadena donde `free` es seguida inmediatamente por `code` pasa la prueba.

Pero, ¿qué pasa si quieres coincidir con la presencia de `free` cuando NO va seguida de `code`? Puedes convertir tu anticipación positiva en una anticipación negativa para invertir el comportamiento. Para hacer esto, cambia tu `?=` por `?!`:

```js
const regex = /free(?!code)/i;
```

Probemos esto contra nuestras mismas cadenas:

```js
const regex = /free(?!code)/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

Como era de esperar, los resultados están invertidos. La única cadena que falla es la primera cadena, donde `free` es seguida inmediatamente por `code`.

Las aserciones de retroceso funcionan de manera similar a las de anticipación, excepto que, en lugar de coincidir condicionalmente con un patrón siguiente, coinciden condicionalmente con un patrón anterior. Echemos un vistazo a un retroceso positivo.

Un retroceso positivo se denota con `?<=` en lugar de `?=`. Hagamos que nuestra expresión regular coincida con `code` cuando está precedido por `free`:

```js
const regex = /(?<=free)code/i;
```

Al igual que con nuestra anticipación positiva, nuestro retroceso positivo coincide con la primera cadena porque `code` está precedido inmediatamente por `free`:

```js
const regex = /(?<=free)code/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

Para hacer coincidir `code` cuando NO está precedido por `free`, podemos usar un retroceso negativo. Un retroceso negativo se define reemplazando `?<=` con `?<!`:

```js
const regex = /(?<!free)code/i;
```

Esto coincidiría con cualquier ocurrencia de `code` que NO esté precedida inmediatamente por `free`.

```js
const regex = /(?<!free)code/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

Recuerda que `Regex.prototype.test` solo confirma si una cadena coincide con la expresión regular. Vamos a usar nuestro retroceso negativo con `String.prototype.match` para ver cómo las aserciones afectan eso:

```js
const regex = /(?<!free)code/i;
console.log("freeCodeCamp".match(regex)); // null
console.log("free code camp".match(regex)); // ['code', index: 5, input: 'free code camp', groups: undefined]
console.log(
  "I need someone for free to write code for me".match(regex)
); // ['code', index: 33, input: 'I need someone for free to write code for me', groups: undefined]
```

Observe cómo, aunque nuestra expresión regular usa un retroceso para verificar la presencia de `free`, no coincide con `free`. El único texto incluido en la coincidencia es `code`.

Las anticipaciones y retrocesos son increíblemente útiles para coincidir con texto condicionalmente sin afectar el valor devuelto de tu coincidencia.

# --questions--

## --text--

¿Cuál es la sintaxis para una aserción de anticipación positiva en una expresión regular?

## --answers--

`(?=pattern)`

---

`(?<=pattern)`

### --feedback--

La conferencia describe cómo construir una anticipación positiva usando una sintaxis específica.

---

`(?!pattern)`

### --feedback--

La conferencia describe cómo construir una anticipación positiva usando una sintaxis específica.

---

`(?<!pattern)`

### --feedback--

La conferencia describe cómo construir una anticipación positiva usando una sintaxis específica.

## --video-solution--

1

## --text--

¿Qué aserción usarías para coincidir una palabra solo si NO va seguida de un patrón específico?

## --answers--

Anticipación positiva.

### --feedback--

Piensa en qué aserción "invierte" el comportamiento de una anticipación positiva.

---

Anticipación negativa.

---

Retroceso positivo.

### --feedback--

Piensa en qué aserción "invierte" el comportamiento de una anticipación positiva.

---

Retroceso negativo.

### --feedback--

Piensa en qué aserción "invierte" el comportamiento de una anticipación positiva.

## --video-solution--

2

## --text--

Cuando se usa una aserción de retroceso con `String.prototype.match`, ¿qué parte de la cadena está realmente incluida en el resultado de la coincidencia?

## --answers--

La cadena completa.

### --feedback--

La conferencia demuestra esto con un ejemplo usando un retroceso negativo.

---

El patrón en la aserción de retroceso.

### --feedback--

La conferencia demuestra esto con un ejemplo usando un retroceso negativo.

---

El patrón después de la aserción de retroceso.

---

Tanto el patrón de retroceso como el patrón que le sigue.

### --feedback--

La conferencia demuestra esto con un ejemplo usando un retroceso negativo.

## --video-solution--

3
