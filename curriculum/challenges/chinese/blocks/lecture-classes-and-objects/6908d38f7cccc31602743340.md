---
id: 6908d38f7cccc31602743340
title: 如何动态处理对象属性？
challengeType: 19
dashedName: how-to-handle-object-attributes-dynamically
---

# --description--

在之前的课程中，你学习了属性是属于对象的变量。这意味着它们保存描述对象状态或行为的数据。

例如，一辆汽车通常会有品牌和模型。品牌和模型可以作为 `Car` 类的属性：

```python
class Car: 
    def __init__(self, brand, model): 
        self.brand = brand 
        self.model = model 

my_car = Car('Lamborghini', 'Gallardo') 
print(my_car.brand) # Lamborghini 
print(my_car.model) # Gallardo 
```

但有时，直到你的程序正在运行时，你才可能知道需要哪些属性。想象一下，你正在编写一个脚本，该脚本从用户或配置文件接收属性名称。这些属性不是你可以提前硬编码的。

这就是动态处理属性的用武之地。通过这种方式，你可以使用属性名作为变量来访问、修改、查看甚至删除属性，而不是在你的代码中使用固定的名称。这赋予你的程序在运行中响应不同数据或用户输入的灵活性。

Python 为你提供了四个方便的内置函数，用于动态操作对象属性。它们是 `getattr()`、`setattr()`、`hasattr()` 和 `delattr()`。

它们让你使用变量名来访问、创建、查看和删除属性。让我们来看一下每个操作的实际应用。 

`getattr()` 使你能够在运行期不知道属性名称时从对象中读取属性。如果该属性不存在，它会引起一个 `AttributeError`，除非你提供了一个默认值。

要使用它，你需要传入对象、属性名称和一个可选的默认值： 

```python
getattr(object, attribute_name, default_value) 
```

这是一个示例：

```python
class Person: 
    def __init__(self, name, age): 
        self.name = name 
        self.age = age 

person = Person('John Doe', 30) 
 
print(getattr(person, 'name')) # John Doe 
print(getattr(person, 'age')) # 30 
print(getattr(person, 'city', 'Milano')) # Milano
```

在上面的例子中，`Milano` 是一个默认值，因为 `city` 不存在于 `Person` 类中。 

正如我们之前所说，`getattr()` 的真正威力在于属性名称来自变量时显现出来，比如来自用户输入或某个文件。

在这种情况下，你不能使用常规的 `object.attribute_name` 语法，因为属性名称不是固定的。

```python
class Person: 
    def __init__(self, name, age): 
        self.name = name 
        self.age = age 

person = Person('John Doe', 30)

attr_name = input('Enter the attribute you want to see: ')
print(getattr(person, attr_name, 'Attribute not found'))
```

在这种情况下，如果用户输入 `name`，他们会看到 `John Doe`，如果输入 `age`，他们会看到 `30`。如果他们输入类中不存在的内容，比如 `email`，他们会看到 `Attribute not found`。

这正是动态属性处理的优势所在。它让你的代码能够响应之前未见过的输入和数据。

此外，你可能想查看一个对象拥有的所有属性，而不仅仅是你已经知道的那些。内置的 `dir()` 函数允许你这样做。它返回对象上所有属性名称的列表。用法如下：

```python
class Person: 
    def __init__(self, name, age): 
        self.name = name 
        self.age = age 

person = Person('John Doe', 30)

# Loop through all attributes of the person object with dir() function
for attr in dir(person):
    # Ignore dunder methods like __init__ or __str__ and regular methods
    if not attr.startswith('__') and not callable(getattr(person, attr)): 
        value = getattr(person, attr)
        print(f'{attr}: {value}')

# Output
# age: 30
# name: John Doe
```

`setattr()` 函数允许你动态创建一个新属性或更新一个已有属性。语法如下： 

```python
setattr(object, attribute_name, value) 
```

这是一个示例，演示如何根据某些配置或环境变量文件中的数据设置配置属性： 

```python
class Configuration:
    pass

# Data loaded at runtime (like from a config or env file)
settings_data = {
    'server_url': 'https://api.example.com',
    'timeout_sec': 30,
    'max_retries': 5
}

config_obj = Configuration()

# Dynamically set attributes using dictionary keys and values
for attr_name, attr_value in settings_data.items():
    setattr(config_obj, attr_name, attr_value)

print(config_obj.server_url) # https://api.example.com
print(config_obj.timeout_sec) # 30
```

还有 `hasattr()`。在你对一个属性执行操作或删除它之前，查看它是否存在是一个好习惯。这正是 `hasattr()` 允许你做的。它检查属性是否存在，并根据结果返回 `True` 或 `False`。 

这是基本语法：

```python
hasattr(object, attribute_name)  
```

下面是一个动态查看 `Product` 类实例中属性是否存在的示例：

```python
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price

product_a = Product('T-Shirt', 25)

required_attributes = ['name', 'price', 'inventory_id']

for attr in required_attributes:
    if not hasattr(product_a, attr):
        print(f"ERROR: Product is missing the required attribute: '{attr}'")
    else:
        # Access the attributes dynamically once their existence is confirmed
        print(f'{attr}: {getattr(product_a, attr)}')

# Output:
# name: T-Shirt
# price: 25
# ERROR: Product is missing the required attribute: 'inventory_id'
```

该 `ERROR` 输出是因为 `Product` 类及其实例中缺少 `inventory_id`。

最后，`delattr()` 允许你动态删除一个属性： 

```python
delattr(object, attribute_name) 
```

例如，假设一个对象已经被完全处理，然后你决定在保存最终版本之前清理任何可能存在的敏感或临时属性。之后，你可以使用 `dir()` 来循环遍历剩余的属性：

```python
class UserSession:
    def __init__(self, user_id, token):
        self.user_id = user_id
        self.auth_token = token # sensitive
        self.temp_counter = 0 # temporary

session = UserSession(101, 'a1b2c3d4e5')

# List of attributes to remove dynamically before "saving" the session
attributes_to_clean = ['auth_token', 'temp_counter']

# Dynamically remove specified attributes
for attr in attributes_to_clean:
    if hasattr(session, attr):
        delattr(session, attr)
        print(f'Removed attribute: {attr}')

print('\nFinal attributes remaining:')

# Loop through the remaining attributes with dir()
for attr in dir(session):
    # Ignore dunder methods like __init__ or __str__ and regular methods
    if not attr.startswith('__') and not callable(getattr(session, attr)):
        print(f' - {attr}: {getattr(session, attr)}')

# Output:
# Removed attribute: auth_token
# Removed attribute: temp_counter

# Final attributes remaining:
#  - user_id: 101
```

这就是你如何动态处理属性！

# --questions--

## --text--

**Python 中的** `getattr()` **函数允许你做什么？**

## --answers--

在运行期其名称未知时，从对象读取属性。

---

从对象中删除一个属性。

### --feedback--

考虑哪个函数可以帮助你动态*检索*属性。

---

在对象上设置一个新建属性。

### --feedback--

考虑哪个函数可以帮助你动态*检索*属性。

---

查看 `attribute` 是否存在于 `object` 中。

### --feedback--

考虑哪个函数可以帮助你动态*检索*属性。

## --video-solution--

1

## --text--

为什么你想在 Python 中动态处理对象属性？

## --answers--

自动将属性转换为列表。

### --feedback--

考虑动态响应用户输入或外部数据。

---

使属性在运行期只读。

### --feedback--

考虑动态响应用户输入或外部数据。

---

为了减少创建的类属性数量。

### --feedback--

考虑动态响应用户输入或外部数据。

---

处理名称直到运行期才知道的属性。

## --video-solution--

4

## --text--

在 Python 中查看一个对象是否具有特定属性的正确语法是什么？

## --answers--

`checkattr(object, attribute_name)`

### --feedback--

考虑哪个函数名称字面上表示“具有属性”。

---

`hasattr(object, attribute_name)`

---

`setattr(object, attribute_name)`

### --feedback--

考虑哪个函数名称字面上表示“具有属性”。

---

`getattr(object, attribute_name)`

### --feedback--

考虑哪个函数名称字面上表示“具有属性”。

## --video-solution--

2
