---
id: 673362cbb475e21eab726506
title: 什么是方法链，以及它是如何工作的？
challengeType: 19
dashedName: what-is-method-chaining-and-how-does-it-work
---

# --interactive--

方法链是一种连续调用多个方法的技术。你可以在 JavaScript 中的多种类型的值上使用方法链，包括字串、数组和对象。尽管字串是原语值，但当你使用字串方法时，JavaScript 会临时将它们包装在一个 `String` 对象中。

让我们来看一个使用不同字串方法的例子：

:::interactive_editor

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

:::

在此示例中，我们从一个字串开始，依次执行三个操作：修剪空白、转换为小写，以及将字串 `world` 替换为 `JavaScript`。每个方法都会返回一个新字串，该字串成为下一个方法调用的目标。

当处理复杂操作时，方法链可以显著提高代码的可读性。

例如，考虑使用 `filter`、`map` 和 `reduce` 方法的这个示例：

:::interactive_editor

```js
const transactions = [
  { amount: 100, type: "credit" },
  { amount: 20, type: "cash" },
  { amount: 150, type: "credit" },
  { amount: 50, type: "cash" },
  { amount: 75, type: "credit" }
];

const totalCreditWithBonus = transactions
  .filter((transaction) => transaction.type === "credit")
  .map((transaction) => transaction.amount * 1.1)
  .reduce((sum, amount) => sum + amount, 0);

console.log(totalCreditWithBonus); // 357.5
```

:::

在此示例中，我们有一个事务数组，其中每个对象都有一个金额和一个信用卡或现金类型。

我们首先过滤事务并创建一个仅包含信用卡事务的新数组。然后，我们将 `map` 方法链接到过滤后的结果，对于每个事务金额，我们将其乘以 `1.1`，这表现为 `10%` 的奖金。

然后，我们将该结果与 `reduce` 方法链式调用，以将每个金额相加，结果为 `357.5`。

虽然方法链可以使代码更简洁易读，但重要的是要明智地使用它。

非常长的链条可能难以调试，因为无法立即清楚链条中的哪一步可能导致错误。通常将非常长的链条拆分为多个步骤是一个良好做法，以获得更好的清晰度和更容易的调试。

# --questions--

## --text--

下面代码的输出是什么？

```js
let str = "  HELLO world  ";
let result = str.trim().toLowerCase().split(' ');
console.log(result);
```

## --answers--

`["HELLO", "world"]`

### --feedback--

考虑链中每个方法的效果：`trim()`、`toLowerCase()` 和 `split()`。

---

`["hello", "world"]`

---

`"hello world"`

### --feedback--

考虑链中每个方法的效果：`trim()`、`toLowerCase()` 和 `split()`。

---

`[" HELLO", "world "]`

### --feedback--

考虑链中每个方法的效果：`trim()`、`toLowerCase()` 和 `split()`。

## --video-solution--

2

## --text--

在方法链的上下文中，方法通常应返回什么以允许进一步的链式调用？

## --answers--

`undefined`

### --feedback--

考虑是什么使得可以在当前 `method` 之后立即调用链中的下一个 `method`。

---

`null`

### --feedback--

考虑是什么使得可以在当前 `method` 之后立即调用链中的下一个 `method`。

---

对象本身（`this`）。

---

一个新建对象。

### --feedback--

考虑是什么使得可以在当前 `method` 之后立即调用链中的下一个 `method`。

## --video-solution--

3

## --text--

下面代码的结果是什么？

```js
let obj = {
    value: 1,
    increment: function() {
        this.value++;
        return this;
    },
    double: function() {
        this.value *= 2;
        return this;
    },
    getValue: function() {
        return this.value;
    }
};

let result = obj.increment().double().increment().getValue();
console.log(result);
```

## --answers--

`2`

### --feedback--

跟踪方法调用链及其对 `value` 属性的效果。

---

`3`

### --feedback--

跟踪方法调用链及其对 `value` 属性的效果。

---

`4`

### --feedback--

跟踪方法调用链及其对 `value` 属性的效果。

---

`5`

## --video-solution--

4
