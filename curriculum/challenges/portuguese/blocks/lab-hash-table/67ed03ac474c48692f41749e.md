---
id: 67ed03ac474c48692f41749e
title: Construir uma Tabela Hash
challengeType: 27
dashedName: build-a-hash-table
---

# --description--

Neste laboratório, você construirá uma tabela hash do zero. Uma tabela hash é uma estrutura de dados que armazena pares de chave-valor. Uma tabela hash funciona pegando a chave como entrada e então aplicando uma função de hash específica para essa chave. 

Para o propósito deste laboratório, a função de hashing será simples: ela somará os valores Unicode de cada caractere na chave. O valor do hash será então usado como a chave real para armazenar o valor associado. O mesmo valor de hash também seria usado para recuperar e excluir o valor associado à chave.

**Objetivo:** Cumprir as user stories abaixo e fazer todos os testes passarem para completar o laboratório.

**Histórias de Usuário:**

1. Você deve definir uma classe chamada `HashTable` com um atributo `collection` inicializado como um dicionário vazio quando uma nova instância de `HashTable` for criada. O dicionário `collection` deve armazenar pares chave-valor com base no valor hash da chave.

2. A classe `HashTable` deve ter quatro métodos de instância: `hash`, `add`, `remove` e `lookup`.

3. O método `hash` deve:

    - Receba uma string como parâmetro.
    - Retorna um valor hash calculado como a soma dos valores Unicode (ASCII) de cada caractere na string. Você pode usar a função `ord` para esse cálculo.

4. O método `add` deve:
    - Receba dois argumentos representando um par chave-valor e calcule o hash da chave.
    - Use o valor de hash calculado como chave para armazenar um dicionário contendo o par chave-valor dentro do dicionário `collection`. 
    - Se várias chaves produzirem o mesmo valor de hash, seus pares chave-valor devem ser armazenados no dicionário aninhado existente sob o mesmo valor de hash.

5. O método `remove` deve:

    - Recebe uma chave como argumento e calcula seu hash.
    - Confirme se a chave existe na coleção.
    - Remova o par chave-valor correspondente da tabela hash.
    - Se a chave não existir na coleção, não deve gerar um erro nem remover nada.

6. O método `lookup` deve:

    - Recebe uma chave como seu argumento.
    - Calcule o hash da chave e retorne o valor correspondente armazenado dentro da tabela hash. 
    - Se a chave não existir na coleção, deve retornar `None`.

# --hints--

Você deve definir uma classe `HashTable`.

```js
({ 
    test: () => assert(runPython(`
    _Node(_code).has_class("HashTable")
    `)) 
})
```

Quando uma nova instância da classe `HashTable` é criada, seu atributo `collection` deve ser inicializado como um dicionário vazio.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.collection == {}
    `) 
})
```

A classe `HashTable` deve ter um método `hash`.

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('hash')`))}})
```

O método `hash` deve receber uma string como parâmetro.

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.hash)
    len(sig.parameters) == 1
  `))
})
```

O método `hash` deve receber uma string como argumento e retornar a soma dos valores Unicode de cada caractere na string.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("fcc")
        assert hash_result == 300

        # prevent hardcoding
        assert ht.hash("golf") == 424
        assert ht.hash("read") == 412
`) })
```

A classe `HashTable` deve ter um método `add`.

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('add')`))}})
```

O método `add` deve receber uma chave e um valor como parâmetros.

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.add)
    len(sig.parameters) == 2
  `))
})
```

A classe `HashTable` deve ter um método `remove`.

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('remove')`))}})
```

O método `remove` deve receber uma chave como parâmetro.

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.remove)
    len(sig.parameters) == 1
  `))
})
```

Quando você tenta remover uma chave que não existe na coleção, **não deve** gerar um erro nem remover nada.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        ht.add("rose", "flower")
        index = ht.hash("rose")
        original = ht.collection.copy()

        ht.remove("tulip")

        assert ht.collection == original
        assert "rose" in ht.collection[index]
        assert "tulip" not in ht.collection.get(index, {})
    `) 
})
```

Se várias chaves fizerem hash para o mesmo índice, o método `remove` deve excluir apenas o par chave-valor específico e não todo o dicionário naquele índice.

```js
({
  test: () => runPython(`
    ht = HashTable()
    ht.add("rose", "flower")
    ht.add("sore", "pain")  # "rose" and "sore" both hash to the same index

    index = ht.hash("rose")
    ht.remove("rose")

    assert index in ht.collection
    assert "rose" not in ht.collection[index]
    assert "sore" in ht.collection[index]
    assert ht.collection[index]["sore"] == "pain"
  `)
})
```

A classe `HashTable` deve ter um método `lookup`.

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('lookup')`))}})
```

O método `lookup` deve receber uma chave como parâmetro.

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.lookup)
    len(sig.parameters) == 1
  `))
})
```

`HashTable.hash('golf')` deve retornar `424`.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("golf")
        assert hash_result == 424

        # prevent hardcoding
        assert ht.hash("dear") == 412
        assert ht.hash("cat") == 312
    `) 
})
```

`HashTable.add('golf', 'sport')` deve adicionar o par chave-valor à coleção na chave `424`.

```js

({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")
    expected_value = {424: {'golf': 'sport'}}

    assert ht.collection == expected_value
    `) 
})
```

`HashTable.add('dear', 'friend')` e `HashTable.add('read', 'book')` devem adicionar ambos os pares chave-valor à coleção no índice `412` como um dicionário aninhado.

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("dear", "friend")
    ht.add("read", "book")

    expected_value = {
        "dear": "friend",
        "read": "book"
    }

    assert ht.collection.get(412) == expected_value
    `) 
})
```

Quando uma chave existe na tabela hash, o método `remove()` deve remover a chave fornecida e seu valor correspondente da coleção.

```js
({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")

    expected_value_before_removal = {
        "golf": "sport"
    }

    index = ht.hash("golf")

    assert ht.collection.get(index) == expected_value_before_removal

    ht.remove("golf")

    assert "golf" not in ht.collection.get(index, {})
    `) 
})
```

Quando o par chave-valor `'golf', 'sport'` existir na tabela hash, `HashTable.lookup('golf')` deve retornar `sport`.

```js
({ 
    test: () => runPython(`
    ht = HashTable()

    ht.add("golf", "sport")

    expected_value = "sport"
    assert ht.lookup("golf") == expected_value
    `) 
})

```

Quando o par chave-valor `'golf', 'sport'` não existir na coleção, `HashTable.lookup('golf')` deve retornar `None`.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.lookup("golf") is None
`) })

```

Quando você adiciona `('rose', 'flower')` à tabela hash, seu atributo `collection` deve ficar assim: `{ 441: { 'rose': 'flower' }}`.

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("rose", "flower")

    expected_value = {
        "rose": "flower"
    }

    assert ht.collection.get(441) == expected_value

    # prevent hardcoding

    ht2 = HashTable()

    ht2.add("kebab", "food")
    expected_value = {
        "kebab": "food"
    }

    assert ht2.collection.get(501) == expected_value
    `)
})
```

Quando você adiciona uma chave que gera o mesmo valor de hash que uma chave existente, como `fcc` e `cfc`, a `collection` deve ficar assim: `{ 300: { 'fcc': 'coding', 'cfc':  'chemical' }}`.

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("fcc", "coding")
    ht.add("cfc", "chemical")

    expected_value = {
        "fcc": "coding",
        "cfc": "chemical"
    }

    assert ht.collection.get(300) == expected_value

    # prevent hardcoding

    ht2 = HashTable()
    ht2.add("cat", "animal")
    ht2.add("act", "verb")

    expected_value = {
        "cat": "animal",
        "act": "verb"
    }

    assert ht2.collection.get(312) == expected_value
    `)
})
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
class HashTable:
    def __init__(self):
        self.collection = {}

    def hash(self, string):
        hashed = 0
        for char in string:
            hashed += ord(char)  
        return hashed

    def add(self, key, val):
        the_hash = self.hash(key)
        if the_hash not in self.collection:
            self.collection[the_hash] = {}
        self.collection[the_hash][key] = val

    def remove(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            del self.collection[the_hash][key]
            if not self.collection[the_hash]: 
                del self.collection[the_hash]

    def lookup(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            return self.collection[the_hash][key]
        return None
```
