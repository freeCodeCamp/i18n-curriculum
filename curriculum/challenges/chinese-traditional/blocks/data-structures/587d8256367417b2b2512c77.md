---
id: 587d8256367417b2b2512c77
title: 鄰接列表
challengeType: 1
forumTopicId: 301620
dashedName: adjacency-list
---

# --description--

圖形可以用不同方式表述。這裡我們描述一種方式，稱為 <dfn>鄰接列表</dfn>。鄰接列表本質上是一個項目符號列表，左側是節點，右側列出所有與其相連的其他節點。以下是鄰接列表的表述。

<blockquote>Node1: Node2, Node3<br>Node2: Node1<br>Node3: Node1</blockquote>

上述為無向圖，因為 `Node1` 與 `Node2` 和 `Node3` 有連線，且該資訊與 `Node2` 和 `Node3` 顯示的連線一致。有向圖的鄰接列表表示列表的每一列都顯示方向。如果上述為有向圖，則 `Node2: Node1` 表示有向邊從 `Node2` 指向 `Node1`。我們可以將上述無向圖以鄰接列表的形式表述，方法是將其放入 JavaScript 物件中。

```js
var undirectedG = {
  Node1: ["Node2", "Node3"],
  Node2: ["Node1"],
  Node3: ["Node1"]
};
```

這也可以更簡單地表述為一個陣列，其中節點只有數字而非字串標籤。

```js
var undirectedGArr = [
  [1, 2], // Node1
  [0],    // Node2
  [0]     // Node3
];
```

# --instructions--

將社交網路創建為一個具有 4 個節點／人物的無向圖，節點名稱為 `James`、`Jill`、`Jenny` 和 `Jeff`。`James` 與 `Jeff`、`Jill` 與 `Jenny`、以及 `Jeff` 與 `Jenny` 之間存在邊／關係。

# --hints--

`undirectedAdjList` 應該只包含四個節點。

```js
assert(Object.keys(undirectedAdjList).length === 4);
```

`Jeff` 和 `James` 之間應該有一條邊。

```js
assert(
  undirectedAdjList.James.indexOf('Jeff') !== -1 &&
    undirectedAdjList.Jeff.indexOf('James') !== -1
);
```

`Jill` 和 `Jenny` 之間應該有一條邊。

```js
assert(
  undirectedAdjList.Jill.indexOf('Jenny') !== -1 &&
    undirectedAdjList.Jenny.indexOf('Jill') !== -1
);
```

`Jeff` 和 `Jenny` 之間應該有一條邊。

```js
assert(
  undirectedAdjList.Jeff.indexOf('Jenny') !== -1 &&
    undirectedAdjList.Jenny.indexOf('Jeff') !== -1
);
```

# --seed--

## --seed-contents--

```js
var undirectedAdjList = {};
```

# --solutions--

```js
var undirectedAdjList = {
  James: ['Jeff'],
  Jill: ['Jenny'],
  Jenny: ['Jill', 'Jeff'],
  Jeff: ['James', 'Jenny']
};
```
