---
id: 587d7da9367417b2b2512b6a
title: 傳回排序後的陣列而不更改原始陣列
challengeType: 1
forumTopicId: 301237
dashedName: return-a-sorted-array-without-changing-the-original-array
---

# --description--

`sort` 方法的一個副作用是它會改變原始陣列中元素的順序。換句話說，它會就地變異該陣列。避免這種情況的一種方法是先將一個空陣列串接到要排序的陣列（記住 `slice` 和 `concat` 會傳回一個新的陣列），然後再執行 `sort` 方法。

# --instructions--

在 `nonMutatingSort` 函式中使用 `sort` 方法，將陣列的元素依升冪排序。該函式應傳回一個新的陣列，且不應變更 `globalArray` 變數。

# --hints--

你的程式碼應該使用 `sort` 方法。

```js
assert(nonMutatingSort.toString().match(/\.sort/g));
```

`globalArray` 變數不應該改變。

```js
assert(JSON.stringify(globalArray) === JSON.stringify([5, 6, 3, 2, 9]));
```

`nonMutatingSort(globalArray)` 應該傳回 `[2, 3, 5, 6, 9]`。

```js
assert(
  JSON.stringify(nonMutatingSort(globalArray)) ===
    JSON.stringify([2, 3, 5, 6, 9])
);
```

`nonMutatingSort(globalArray)` 不應該被硬編碼。

```js
assert(!nonMutatingSort.toString().match(/\[.*?[23569].*?\]/gs));
```

該函式應該傳回一個新的陣列，而不是傳入的陣列。

```js
assert(nonMutatingSort(globalArray) !== globalArray);
```

`nonMutatingSort([1, 30, 4, 21, 100000])` 應該傳回 `[1, 4, 21, 30, 100000]`。

```js
assert(JSON.stringify(nonMutatingSort([1, 30, 4, 21, 100000])) ===
    JSON.stringify([1, 4, 21, 30, 100000]))
```

`nonMutatingSort([140000, 104, 99])` 應該傳回 `[99, 104, 140000]`。

```js
assert(JSON.stringify(nonMutatingSort([140000, 104, 99])) ===
    JSON.stringify([99, 104, 140000]))
```

# --seed--

## --seed-contents--

```js
const globalArray = [5, 6, 3, 2, 9];

function nonMutatingSort(arr) {
  // Only change code below this line


  // Only change code above this line
}

nonMutatingSort(globalArray);
```

# --solutions--

```js
const globalArray = [5, 6, 3, 2, 9];
function nonMutatingSort(arr) {
  return [].concat(arr).sort((a,b) => a-b);
}
```
