---
id: 68baa5e4f0e07f079245ca0b
title: ¿Cómo funcionan las colas de prioridad y los heaps?
challengeType: 19
dashedName: how-do-priority-queues-and-heaps-work
---

# --description--

Una **cola de prioridad** es un tipo abstracto de datos (ADT) que funciona de manera similar a una cola o pila, pero con una diferencia clave.

Como ya sabrás, las colas estándar siguen un enfoque FIFO (First-in, First-out), donde el primer elemento agregado a la cola es el primero en ser eliminado de la cola.

Las pilas siguen un enfoque LIFO (Last-in, First-out), donde el último elemento agregado a la pila es el primero en ser removido de la pila.

Las colas y pilas solo consideran el orden de inserción de los elementos.

Sin embargo, las colas de prioridad toman en cuenta la "prioridad" de los elementos. La prioridad se usa para determinar qué elemento debe ser eliminado a continuación.

Normalmente, el elemento con la prioridad más alta se elimina primero, pero algunas implementaciones también pueden elegir eliminar primero el elemento con la prioridad más baja. Esto dependerá de los requisitos de tu programa.

Las colas de prioridad son muy útiles para aplicaciones prácticas como encontrar el camino más corto entre dos ubicaciones, programar tareas en sistemas operativos, simular el tráfico, comprimir datos y gestionar redes.

En la práctica, las colas de prioridad se implementan comúnmente usando una estructura de datos heap.

Un **heap** es una estructura de datos en forma de árbol con una propiedad muy específica llamada **heap property**. Esta propiedad determina la relación entre cada nodo y sus hijos, basada en el tipo de heap.

Hay dos tipos principales de heaps:

* Montículo máximo
    
* Montículo mínimo
    

En un **max-heap**, el valor de cada nodo es mayor o igual que el valor de sus hijos.

En este ejemplo, puedes ver una estructura de árbol con los nodos 8, 7, 5, 2 y 1. Observa que el nodo 7 es mayor que el nodo 2 y el nodo 1, siguiendo la propiedad heap. Esto es cierto para todos los demás nodos también.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-1.png" alt="A max-heap tree structure showing nodes with values 8 at the root, 7 and 5 as children of 8, and 2 and 1 as children of 7, demonstrating that each parent node is greater than its children.">

En contraste, en una **min-heap**, el valor de cada nodo es menor o igual que el valor de sus hijos.

En este ejemplo, tenemos nodos con valores 4, 7, 9, 12 y 15. Por ejemplo, el nodo 7 es menor que el nodo 12 y el nodo 15, siguiendo la propiedad del heap. Esto también es cierto para todos los demás nodos.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-2.png" alt="A min-heap tree structure showing nodes with values 4 at the root, 7 and 9 as children of 4, and 12 and 15 as children of 7, demonstrating that each parent node is less than its children.">

La propiedad heap es clave porque garantiza que el elemento máximo (o mínimo) (dependiendo del tipo de heap) siempre se mantenga en la cima, lo que hace que sea muy fácil de eliminar.

En la práctica, las heaps se implementan típicamente como arrays para acceder eficientemente a los nodos padre e hijo.

Usar arrays simplifica la lógica para acceder a estos valores o "nodos" porque detrás de escena, si el heap mantiene la estructura de un árbol binario completo, la implementación con array solo requiere operaciones matemáticas simples basadas en sus índices para encontrar dónde están ubicados los elementos en la memoria.

Python tiene un módulo incorporado `heapq` que puedes usar para trabajar con una implementación de un min-heap.

Funciona operando directamente sobre listas de Python, siguiendo pasos específicos que trabajan con los elementos como si la lista fuera un heap, preservando la propiedad del heap.

Para usar este módulo, solo necesitas importarlo:

```python
import heapq
```

Luego, necesitas definir una lista vacía. Esta será la estructura de datos subyacente para el heap:

```python
my_heap = []
```

Para agregar elementos al heap, debes llamar a `heappush()`, pasando el nombre del heap y el elemento que quieres agregar como argumentos. Esto añadirá automáticamente el elemento a la lista en el lugar que le corresponde, para preservar la propiedad del heap:

```python
heapq.heappush(my_heap, 9)
```

Para obtener el elemento con la prioridad más baja (en este caso, el valor más pequeño), llamarías a `heappop()`:

```python
heapq.heappop(my_heap)
```

`heappushpop()` combina ambas operaciones en una sola llamada.

Esto es más eficiente que llamarlos en secuencia por separado, especialmente cuando el heap es grande, ya que solo realiza una operación de "heapify" para reordenar la lista como un heap:

```python
heapq.heappushpop(my_heap, 15)
```

Si ya tienes una lista y quieres transformarla en un heap, puedes llamar a `heapify()`, pasando el heap como argumento:

```python
heapq.heapify(my_heap)
```

Pero actualmente, estamos ordenando los elementos por sus valores, ¿verdad?

¿Qué pasa si queremos ordenarlos por su "priority" en su lugar?

Podrías hacer esto almacenando tuplas con esta estructura: `(priority, element)`.

Dado que las tuplas se comparan elemento por elemento de izquierda a derecha, las prioridades se compararán primero y las decisiones se tomarán en función de ellas.

Ten en cuenta que, en este caso, los valores más bajos representarán prioridades más altas. Esto significa que una tupla con prioridad 1 tendrá una prioridad **más alta** que una tupla con prioridad 3:

```python
my_heap = []

heapq.heappush(my_heap, (3, "A"))
heapq.heappush(my_heap, (2, "B"))
heapq.heappush(my_heap, (1, "C"))
```

Si necesitas que los elementos con la misma prioridad se eliminen en el orden en que fueron insertados, podrías considerar incluir un contador único como el segundo elemento de tu tupla para desempatar, así: `(priority, counter, element)`.

Ahora hablemos sobre la eficiencia de los heaps.

Las complejidades de tiempo promedio y en el peor caso para insertar y extraer el valor mínimo o máximo de un heap (dependiendo del tipo de heap) son logarítmicas, `O(log n)`, porque el número de intercambios requeridos suele ser proporcional a la altura del heap, que es log(n).

La complejidad temporal promedio y en el peor caso para la operación "peek" es tiempo constante, O(1). Hacer peek implica obtener el valor mínimo o máximo (dependiendo del tipo de heap) sin eliminarlo.

La operación de "heapify", donde la heap se construye a partir de una lista desordenada, tiene una complejidad de tiempo lineal, O(n), en los casos promedio y peor.

De manera similar, tanto buscar como eliminar un elemento arbitrario tienen complejidades de tiempo promedio y en el peor caso lineales de O(n), ya que potencialmente requieren recorrer todo el heap.

¿Y cuánto espacio requieren?

La complejidad espacial del heap es lineal, O(n), donde `n` es el número de elementos que contiene. Solo necesita almacenar los elementos y una pequeña sobrecarga adicional para el objeto lista en sí.

Las colas de prioridad y los montículos son muy importantes en la informática. Te permiten encontrar y usar rápidamente los elementos más importantes de una lista. Esta eficiencia es crucial para muchos programas de computadora que realizan tareas críticas en el mundo real, como encontrar la ruta más rápida en un mapa.

# --questions--

## --text--

¿Cuál es la característica principal que distingue a una cola de prioridad de una cola o pila estándar?

## --answers--

Permite que los elementos sean accedidos por su índice.

### --feedback--

Piensa en el factor principal que determina qué elemento se elimina a continuación.

---

Siempre procesa los elementos en el orden en que fueron insertados.

### --feedback--

Piensa en el factor principal que determina qué elemento se elimina a continuación.

---

Recupera elementos basándose en una prioridad asignada.

---

Solo almacena elementos del mismo tipo de datos.

### --feedback--

Piensa en el factor principal que determina qué elemento se elimina a continuación.

## --video-solution--

3

## --text--

¿Cuál de las siguientes es una aplicación común en el mundo real donde una cola de prioridad sería útil?

## --answers--

Programación de tareas en un sistema operativo donde algunas tareas son más urgentes.

---

Gestionando una lista de reproducción donde las canciones se reproducen en un orden fijo.

### --feedback--

Piensa en escenarios donde algunos elementos son más importantes y necesitan ser manejados primero.

---

Almacenar una lista de artículos de supermercado.

### --feedback--

Piensa en escenarios donde algunos elementos son más importantes y necesitan ser manejados primero.

---

Llevar un registro de los nombres de clientes en orden alfabético.

### --feedback--

Piensa en escenarios donde algunos elementos son más importantes y necesitan ser manejados primero.

## --video-solution--

1

## --text--

¿Cuál es la razón principal por la que las heaps se implementan típicamente como arrays en la práctica, a pesar de ser conceptualizadas como árboles?

## --answers--

Los arrays siempre son más rápidos que cualquier otra estructura de datos.

### --feedback--

Piensa en cómo la estructura en forma de árbol de un heap puede mapearse eficientemente a una estructura de datos lineal.

---

Los arrays simplifican la lógica para acceder a nodos padre e hijo usando fórmulas matemáticas.

---

Los arrays permiten el acceso aleatorio directo a cualquier elemento, que es una operación fundamental del heap.

### --feedback--

Piensa en cómo la estructura en forma de árbol de un heap puede mapearse eficientemente a una estructura de datos lineal.

---

Los arrays son la única estructura de datos que puede garantizar la propiedad heap.

### --feedback--

Piensa en cómo la estructura en forma de árbol de un heap puede mapearse eficientemente a una estructura de datos lineal.

## --video-solution--

2
