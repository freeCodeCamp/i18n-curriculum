---
id: 67c9e932c6c4234532d46394
title: React 表單、資料擷取與路由回顧
challengeType: 31
dashedName: review-react-forms-data-fetching-and-routing
---

# --description--

## 在 React 中使用表單

- **受控輸入**：這是指你將輸入欄位的值儲存在狀態中，並透過 `onChange` 事件更新它。這讓你能完全控制表單資料，並允許即時驗證和條件呈現。

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form>
    </>
  );
}

export default App;
```

- **非受控輸入**：非透過 `useState` 掛鉤處理輸入，HTML 中的非受控輸入會在 DOM 的協助下維護其自身的內部狀態。由於 DOM 控制輸入值，你需要使用 `ref` 取得輸入欄位的值。

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">Your</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">Submit</button>
   </form>
 );
}

export default App;
```

## 使用 `useActionState` 掛鉤

- **伺服端動作**：這些是會在伺服端執行的函式（程式），允許直接在伺服端處理表單，而不需要 API 端點。以下是一個來自 Next.js 應用程式的範例：

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `Hello, ${name}!` };
}
```

`"user server"` 指令將該函式標記為伺服端動作。

- **`useActionState` 掛鉤**：此掛鉤會根據表單提交的結果更新狀態。以下是 `useActionState` 掛鉤的基本語法：

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` 是該動作傳回的當前狀態。
- `action` 是觸發伺服端動作的函式（程式）。
- `isPending` 是一個布林值，用來顯示該動作目前是否正在執行。
- `actionFunction` 參數就是伺服器動作本身。
- `initialState` 是表述動作執行前狀態起點的參數。
- `permalink` 是包含表單所修改的唯一頁面 URL 的選用字串。

## React 中的資料擷取

- **取得資料的選項**：在 React 中有許多不同的方法來取得資料。你可以使用原生的 Fetch API，或第三方工具如 Axios 或 SWR。
- **取得資料時常用的狀態變數**：無論你選擇哪種方式在 React 中取得你的資料，都有一些狀態你需要追蹤。第一個是資料本身。第二個會追蹤資料是否仍在取得中。第三個是用來捕捉在資料取得過程中可能發生的任何錯誤的狀態變數。

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

由於資料擷取是副作用，最好在 `useEffect` 掛鉤內使用 `Fetch API`。

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      
      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

然後，如果資料擷取尚未完成，你可以呈現載入訊息；如果擷取資料時發生錯誤，你可以呈現錯誤訊息；或者呈現結果。

```jsx
if (loading) {
  return <p>Loading...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

如果你想使用 Axios，你需要安裝並匯入它：

```bash
npm i axios
```

```js
import axios from "axios";
```

然後你可以使用 `axios.get` 來取得資料：

```jsx
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

要使用 `useSWR` 掛鉤來擷取資料，你需要先安裝並匯入它。

```bash
npm i swr
```

```js
import useSWR from "swr";
```

以下是你如何使用該掛鉤來擷取資料：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>Loading...</h2>;
 }
 if (error) {
   return <h2>Error: {error.message}</h2>;
 }

 return (
   <>
     <h2>Todos</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## 使用 `useOptimistic` 掛鉤

- **`useOptimistic` 掛鉤**：此掛鉤用於在等待非同步動作在背景完成時保持使用者介面回應迅速。它有助於管理 UI 中的「樂觀更新」，這是一種根據動作的預期結果（例如等待伺服端回應）立即更新 UI 的策略。

這是基本語法：

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` 是立即更新的暫時狀態，以提供更好的使用者體驗。
- `addOptimistic` 是在實際狀態變更之前套用樂觀更新的函式（程式）。
- `actualState` 是來自動作結果的真實狀態值，例如從伺服器擷取資料。
- `updateFunction` 是決定在被呼叫時樂觀狀態應如何更新的函式（程式）。

以下是如何在 `TaskList` 組件中使用 `useOptimistic` 掛鉤的範例：

```jsx
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**：這用於呈現 UI 的零件，並將狀態更新標記為非緊急的過渡。這讓 UI 在耗費資源的更新期間保持回應。以下是基本語法：

```js
startTransition(action);
```

`action` 執行狀態更新或觸發某些與轉換相關的邏輯。這確保緊急的 UI 更新（例如輸入或點擊）不會被阻擋。

## 使用 `useMemo` 掛鉤

- **備忘錄化**：這是一種優化技術，根據特定的引數將昂貴函式（程式）呼叫的結果快取（記憶）。當再次提供相同的引數時，會傳回快取的結果，而非重新計算函式。
- **`useMemo` 掛鉤**：此掛鉤用於記憶計算後的值。以下是一個記憶排序大型陣列結果的範例。只有當 `largeArray` 改變時，`expensiveSortFunction` 才會執行：

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## 使用 `useCallback` 掛鉤

- **`useCallback` 掛鉤**：這用於記憶函式（程式）引用。

```js
const handleClick = useCallback(() => {
  // code goes here
}, [dependency]);
``` 

- **`React.memo`**：這用於將組件記憶化，以防止當其 prop 未改變時發生不必要的重新呈現。

```jsx
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* Presentation */}
   </>
 )
});
``` 

## 相依性管理工具

- **相依性定義**：在軟體中，相依性是指應用程式中的一個組件或模組依賴另一個組件或模組才能正常運作。相依性在軟體應用程式中很常見，因為它們允許開發者使用其他人創建的預先建置函式或工具。React 專案所需的兩個核心相依項將是 `react` 和 `react-dom` 軟體包：

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **軟體包管理器定義**：為了管理專案中的軟體依賴性，你需要使用軟體包管理器。軟體包管理器是一種用於安裝、更新和移除依賴性的工具。許多流行的程式設計語言如 JavaScript、Python、Ruby 和 Java 都使用軟體包管理器。JavaScript 的熱門軟體包管理器包括 npm、Yarn 和 pnpm。
- **`package.json` 檔案**：這是在專案中一個關鍵的設定檔案，包含有關你的專案的詮釋資料，包括其名稱、版本和相依性。它也定義了腳本、授權資訊以及其他有助於管理專案及其相依性的設定。
- **`package-lock.json` 檔案**：此檔案會鎖定你的專案所使用的所有軟體包的確切版本。當你更新軟體包時，新的版本也會在鎖定檔案中更新。
- **`node_modules` 資料夾**：此資料夾包含你在 `package.json` 檔案中列出的相依性實際程式碼，包括你專案的直接相依性以及那些相依性的任何相依性。
- **開發相依性**：這些是只用於開發而非生產環境的軟體包。舉例來說，像 Jest 這樣的測試函式庫就是一個例子。你會將 Jest 安裝為開發相依性，因為它是用來在區域測試你的應用程式所需，但在生產環境執行應用程式時不需要。

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **介紹**：React Router 是一個第三方函式庫，允許你為你的 React 應用程式添加路由。要開始，你需要在現有的 React 專案中安裝 React Router，如下所示：

```bash
npm i react-router
```

然後在 `main.jsx` 或 `index.jsx` 檔案內，你需要像這樣設定路由結構：

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

`path` 和 `element` 用於將 URL 與 UI 組件連結在一起。在這種情況下，我們正在為首頁設定一條指向 `App` 組件的路由。 

- **多重視圖與路由設定**：在較大型的應用程式中，常見會像這樣設定多個視圖與路由：

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

這些範例中的 `index` prop 是用來表述給定路徑段的預設路由。因此，`Home` 組件會在根目錄 `/` 路徑顯示，而 `ProductsHome` 組件會在 `/products` 路徑顯示。

- **巢狀路由**：你可以將路由巢狀在其他路由內，這會導致子路由的路徑附加到父路由的路徑上。

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

在上述範例中，熱門商品的路徑將會是 products/trending。

- **動態區段**：動態區段是 URL 路徑中任何零件是動態的部分。

```jsx
<Route path=":category" element={<Category />} />
```

在此範例中，我們有一個名為 `category` 的動態區段。當使用者導覽到像 products/brass-instruments 這樣的 URL 時，畫面將切換到 `Category` 組件，並且你可以根據該區段動態擷取適當的資料。

- **`useParams` 掛鉤**：此掛鉤用於存取 URL 路徑中的動態參數。

```jsx
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
  {/* Accessing the category param: params.category */}
  {/* rest of code goes here */}
}
```

## React 框架

- **介紹**：React 框架提供路由、影像優化、資料擷取、身份驗證等特性。這表示在某些使用情境下，你可能不需要設定獨立的前端和後端應用程式。React 框架的範例包括 Next.js 和 Remix。
- **Next.js 路由**：此路由系統包含對動態路由、平行路由、路由處理常式、重新導向、國際化等的支援。

以下是建立訂製請求處理常式的範例：

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Next.js 影像優化**：`Image` 組件擴充了原生的 HTML `img` 元素，並允許更快速的頁面載入和大小優化。這表示影像只有在進入視窗時才會載入，且 `Image` 組件會自動為每個裝置提供正確尺寸的影像。

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
``` 

## 屬性傳遞

- **定義**：Prop drilling 是將 props 從父組件傳遞到深層巢狀子組件的處理程序，即使某些子組件不需要這些 props。

## 狀態管理

- **Context API**：背景關係指的是當父組件讓資訊可供子組件使用，而不需要透過 props 明確地傳遞。`createContext` 用於創建一個背景關係物件，該物件表述其他組件將會讀取的背景關係。`Provider` 用於將背景關係值提供給子組件。

```jsx
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**：Redux 透過提供一個中央儲存庫和對狀態更新的嚴格控制來處理狀態管理。它使用一個可預測的樣式，包含 actions、reducers 和 middleware。Actions 是將資料從你的應用程式傳送到 Redux 儲存庫的資訊有效負載，通常由使用者互動觸發。Reducers 是指定狀態應如何因應這些 actions 而改變的函式（程式），確保狀態以不可變的方式更新。另一方面，Middleware 則充當 action 分派與 reducer 之間的橋樑，允許你擴充 Redux 的功能（例如，記錄、控制非同步操作），而不修改核心流程。

- **Zustand**：這個狀態管理解決方案非常適合中小型應用程式。它透過使用 `useStore` 掛鉤直接在組件和頁面中存取狀態。這讓你可以在不需要 actions、reducers 或 provider 的情況下修改和存取資料。

## 使用 React DevTools 偵錯 React 組件

- **React Developer Tools**：這是一個瀏覽器擴充套件，你可以在 Chrome、Firefox 和 Edge 中使用它來檢查 React 組件並識別效率問題。對於 Safari，你需要安裝 `react-devtools` npm 軟體包。安裝 React DevTools 並在瀏覽器中開啟 React 應用程式後，開啟瀏覽器開發者工具即可存取為偵錯 React 所提供的兩個額外分頁－Components 和 Profiler。
- **組件 標籤**：此標籤以樹狀檢視格式顯示每個組件給你。在此標籤中你可以執行以下操作：
  - 檢視應用程式的組件階層體系
  - 即時檢查並修改 props、states 和 context 值
  - 檢查每個所選組件的原始碼
  - 將組件資料記錄到主控台
  - 檢查該組件的 DOM 元素
- **效能(效率)評測器分頁**：此分頁可協助你分析組件效率。你可以記錄組件效率，以便識別不必要的重新呈現、查看提交持續時間，並隨後最佳化緩慢的組件。

## React 伺服端組件

- **定義**：React Server Components 是只在伺服端呈現的 React 組件，僅將最終的 HTML 傳送到客戶端。這表示那些組件可以直接存取伺服端資源，並大幅減少傳送到瀏覽器的 JavaScript 數量。

# --assignment--

檢視 React 路由、狀態管理、表單和資料擷取。
