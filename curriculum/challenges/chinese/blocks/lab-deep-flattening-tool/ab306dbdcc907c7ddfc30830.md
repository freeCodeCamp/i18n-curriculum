---
id: ab306dbdcc907c7ddfc30830
title: 创建一个深度扁平化工具
challengeType: 26
dashedName: create-a-deep-flattening-tool
---

# --description--

在本实验中，你将实现一个数组扁平化算法。

扁平化数组意味着将任意深度的嵌套数组转换为单一的一维数组。该进程按顺序提取所有元素，仅展开数组。其他类型保持不变。

例如：

| Original | Flattened |
| --- | --- |
| `[[1], [], [2, [3]]]` | `[1, 2, 3]` |
| `[1, {"foo": "bar"}, [2]]` | `[1, {"foo": "bar"}, 2]` |
| `["baz", [1, 2], {}]` | `["baz", 1, 2, {}]` |

**目标：**实现以下用户需求并通过所有测试以完成实验。

**用户故事：**

1. 你应该有一个名为 `steamrollArray` 的函数。
1. `steamrollArray` 函数应接受一个参数：嵌套数组。
1. 该函数应展平嵌套数组，考虑不同层级的嵌套。
1. 代码中不应使用 `Array.prototype.flat()` 或 `Array.prototype.flatMap()` 方法。
1. 不应使用全局变量。

# --hints--

你应该有一个 `steamrollArray` 函数。

```js
assert.isFunction(steamrollArray);
```

`steamrollArray([[["a"]], [["b"]]])` 应返回 `["a", "b"]`。

```js
assert.deepEqual(steamrollArray([[['a']], [['b']]]), ['a', 'b']);
```

`steamrollArray([1, [2], [3, [[4]]]])` 应返回 `[1, 2, 3, 4]`。

```js
assert.deepEqual(steamrollArray([1, [2], [3, [[4]]]]), [1, 2, 3, 4]);
```

`steamrollArray([1, [], [3, [[4]]]])` 应返回 `[1, 3, 4]`。

```js
assert.deepEqual(steamrollArray([1, [], [3, [[4]]]]), [1, 3, 4]);
```

`steamrollArray([1, {}, [3, [[4]]]])` 应返回 `[1, {}, 3, 4]`。

```js
assert.deepEqual(steamrollArray([1, {}, [3, [[4]]]]), [1, {}, 3, 4]);
```

代码中不应使用 `Array.prototype.flat()` 或 `Array.prototype.flatMap()` 方法。

```js
const arr = [1,2,3,[1,2,3,[1,2,3]]];

const spyFlat = __helpers.spyOn(Array.prototype, 'flat');
try {
  steamrollArray(arr);
  assert.isEmpty(spyFlat.calls);
} finally {
  spyFlat.restore();
}

const spyFlatMap = __helpers.spyOn(Array.prototype, 'flatMap');
try {
  steamrollArray(arr);
  assert.isEmpty(spyFlatMap.calls);
} finally {
  spyFlatMap.restore();
}
```

你不应该使用全局的变量。

```js
steamrollArray([1, {}, [3, [[4]]]])
assert.deepEqual(steamrollArray([1, {}, [3, [[4]]]]), [1, {}, 3, 4])
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
function steamrollArray(arr) {
  if (!Array.isArray(arr)) {
    return [arr];
  }
  const out = [];
  arr.forEach(function(e) {
    steamrollArray(e).forEach(function(v) {
      out.push(v);
    });
  });
  return out;
}
```
