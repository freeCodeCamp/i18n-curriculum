---
id: 6733b02d1e556005a544c5e3
title: 什麼是遞迴，以及它如何運作？
challengeType: 19
dashedName: what-is-recursion-and-how-does-it-work
---

# --interactive--

遞迴是一個複雜的特性，允許你重複呼叫一個函式，直到達到基本情況。與傳統的迴圈不同，遞迴允許你控制代碼處理未知深度的事物，例如深度巢狀的物件／陣列，或檔案樹。但你也可以將它用於較基本的任務，例如從給定數字倒數。

讓我們構建一個函式（程式）來精確地完成這件事。我們將呼叫這個函式（程式）為 `recursiveCountdown`，並且它需要接受一個數字。我們將讓它將這個數字列印到主控台：

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  console.log(number);
};

recursiveCountdown(5);
```

:::

現在如果我們呼叫這個並傳入數字 5，我們會看到數字列印到我們的終端機。但除此之外沒有其他事情發生－而且數字 5 絕對不是倒數計時。

在我們開始建置函式的遞迴部分之前，我們需要先建立基底案例。如果你沒有建立基底案例，你的程式碼將會執行直到超出你的記憶體配置並當機。

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  if (number < 1) {
    return;
  }
  console.log(number);
};

recursiveCountdown(5);
```

:::

對於我們的基礎情況，如果數字小於 1，我們希望倒數停止。當我們達到該基礎情況時，我們可以傳回以中斷函式執行。

現在我們已經安全地準備好基底案例，我們可以設定遞迴。使函式成為遞迴的關鍵點是它在執行時會呼叫自己。在這個例子中，我們想在列印數字後呼叫該函式。但為了倒數，我們的新數字需要少 1：

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  if (number < 1) {
    return;
  }
  console.log(number);
  recursiveCountdown(number - 1);
};

recursiveCountdown(5); 
```

:::

這將會將數字 5、4、3、2 和 1 記錄到主控台。

我們確實得到了我們的五個數字！但是如果我們想要改為遞增計數呢？與其撰寫一個全新的函式，不如交換我們的 log 和遞迴呼叫的順序：

:::interactive_editor

```js
const recursiveCountdown = (number) => {
    if (number < 1) {
        return;
    }
    recursiveCountdown(number - 1);
    console.log(number);
  };

recursiveCountdown(5);
```

:::

這會將數字 1、2、3、4 和 5 記錄到主控台。

但是為什麼這樣會有效？嗯，要理解這點你需要了解呼叫堆疊。呼叫堆疊是 JavaScript 如何追蹤和決議函式呼叫的方式。堆疊在某種程度上是以後進先出佇列的形式運作。為了更好地理解這點，讓我們為你的函式添加一些日誌記錄：

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  console.log(`Function execution started for number: ${number}`);
  if (number < 1) {
    console.log(`Base case reached, begin resolving stack`);
    return;
  }
  console.log(`Calling recursiveCountdown with number: ${number - 1}`);
  recursiveCountdown(number - 1);
  console.log(`Function execution completed for number: ${number}`);
};

recursiveCountdown(5);
```

:::

我們在這裡添加了四個關鍵述語。第一個日誌會在函式呼叫開始執行時執行。第三個日誌會在遞迴函式被呼叫之前執行。第四個日誌會在函式執行結束時執行。結果是：

```md
Function execution started for number: 5
Calling recursiveCountdown with number: 4
Function execution started for number: 4
Calling recursiveCountdown with number: 3
Function execution started for number: 3
Calling recursiveCountdown with number: 2
Function execution started for number: 2
Calling recursiveCountdown with number: 1
Function execution started for number: 1
Calling recursiveCountdown with number: 0
Function execution started for number: 0
Base case reached, begin resolving stack
Function execution completed for number: 1
Function execution completed for number: 2
Function execution completed for number: 3
Function execution completed for number: 4
Function execution completed for number: 5
```

但是這是如何發生的呢？這就是呼叫堆疊開始發揮作用的地方。當我們呼叫 `recursiveCountdown(5)` 時，該函式（程式）呼叫會被添加到呼叫堆疊中。 

當那個函式呼叫到需要呼叫 `recursiveCountdown(4)` 的時候，它必須停止並等待該結果。與此同時，我們的 `recursiveCountdown(4)` 被添加到呼叫堆疊中，位於 `recursiveCountdown(5)` 的上方。

當那個函式（程式）呼叫到需要呼叫 `recursiveCountdown(3)` 的時候，它必須停止並等待該結果。與此同時，我們的 `recursiveCountdown(3)` 被添加到呼叫堆疊中，位於 `recursiveCountdown(4)` 的上方。

當那個函式（程式）呼叫到需要呼叫 `recursiveCountdown(2)` 的時候，它必須停止並等待該結果。與此同時，我們的 `recursiveCountdown(2)` 被添加到呼叫堆疊中，位於 `recursiveCountdown(3)` 的上方。

當那個函式（程式）呼叫到需要呼叫 `recursiveCountdown(1)` 的時候，它必須停止並等待該結果。與此同時，我們的 `recursiveCountdown(1)` 被添加到呼叫堆疊中，位於 `recursiveCountdown(2)` 的上方。

最後，當該函式（程式）呼叫到需要呼叫 `recursiveCountdown(0)` 的時候，它必須停止並等待該結果。與此同時，我們的 `recursiveCountdown(0)` 被添加到呼叫堆疊中，位於 `recursiveCountdown(1)` 的上方。

但是 `recursiveCountdown(0)` 不會呼叫另一個函式（程式）－它達到我們的基本案例，並且提前返回。因為該函式（程式）的執行已結束，該函式（程式）呼叫可以被視為「已決議」。當呼叫被決議後，它會從堆疊中移除。

現在我們的 `recursiveCountdown(1)` 不再等待那個呼叫－它位於堆疊頂端，並且可以繼續執行。

`recursiveCountdown(1)` 決議、從堆疊中移除，並允許 `recursiveCountdown(2)` 繼續執行。

`recursiveCountdown(2)` 決議、從堆疊中移除，並允許 `recursiveCountdown(3)` 繼續執行。

`recursiveCountdown(3)` 決議、從堆疊中移除，並允許 `recursiveCountdown(4)` 繼續執行。

`recursiveCountdown(4)` 決議、從堆疊中移除，並允許 `recursiveCountdown(5)` 繼續執行。

然後 `recursiveCountdown(5)` 被決議並從堆疊中移除。我們的呼叫堆疊現在是空的，所以遞迴完成了！

這是 JavaScript 中遞迴如何運作的基本概述。這是一個複雜的概念，你應該多玩一些程式碼和記錄述語，直到你對呼叫堆疊的行為感到熟悉。

有趣的小知識，我們談到缺少基底案例會導致你的程式在記憶體用盡時崩潰。這是因為遞迴不斷將越來越多的函式呼叫堆疊到呼叫堆疊中，直到堆疊上限溢位。就像那個知名程式設計社群的名稱一樣。

# --questions--

## --text--

遞迴函式中基底案例的主要目的為何？

## --answers--

為了啟動遞迴呼叫。

### --feedback--

課程提到如果你沒有建立基底案例會發生什麼情況。

---

為防止無限遞迴和堆疊上限溢位。

---

為了提升該函式（程式）的效率。

### --feedback--

課程提到如果你沒有建立基底案例會發生什麼情況。

---

為了控制錯誤狀況。

### --feedback--

課程提到如果你沒有建立基底案例會發生什麼情況。

## --video-solution--

2

## --text--

在遞迴的背景關係中，`call stack` 用於什麼？

## --answers--

用於儲存區域的變數。

### --feedback--

本課程說明呼叫堆疊如何在遞迴過程中管理函式呼叫。

---

用於追蹤和決議函式呼叫。

---

為了最佳化遞迴函式（程式）。

### --feedback--

本課程說明呼叫堆疊如何在遞迴過程中管理函式呼叫。

---

為非同步操作行為編寫控制代碼。

### --feedback--

本課程說明呼叫堆疊如何在遞迴過程中管理函式呼叫。

## --video-solution--

2

## --text--

當遞迴函式呼叫達到其基底案例時會發生什麼？

## --answers--

它開始一個新的遞迴週期。

### --feedback--

思考當函式（程式）遇到停止遞迴的條件時的行為。

---

它會丟出錯誤。

### --feedback--

思考當函式（程式）遇到停止遞迴的條件時的行為。

---

它傳回並允許先前的呼叫繼續執行。

---

它會無限地呼叫自己。

### --feedback--

思考當函式（程式）遇到停止遞迴的條件時的行為。

## --video-solution--

3
