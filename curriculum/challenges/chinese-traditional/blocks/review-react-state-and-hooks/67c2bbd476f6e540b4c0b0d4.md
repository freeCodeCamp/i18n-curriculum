---
id: 67c2bbd476f6e540b4c0b0d4
title: React 狀態與掛鉤回顧
challengeType: 31
dashedName: review-react-state-and-hooks
---

# --description--

## 在 React 中處理事件

- **合成事件系統**：這是 React 處理事件的方式。它作為原生的 `click`、`keydown` 和 `submit` 事件的外覆。React 中的事件處理常式使用駝峰式命名慣例。（例如 `onClick`、`onSubmit` 等）

以下是使用 React 中 `button` 元素的 `onClick` 屬性的範例：

```jsx
function handleClick() {
  console.log("Button clicked!");
}

<button onClick={handleClick}>Click Me</button>;
```

在 React 中，事件處理常式函式通常以前置式 `handle` 開頭，以顯示它們負責控制事件，例如 `handleClick` 或 `handleSubmit`。

當使用者動作觸發一個事件時，React 會將一個 Synthetic Event 物件傳遞給你的處理常式。這個物件的行為類似於原生的 Event 物件，提供像是 `type`、`target` 和 `currentTarget` 等屬性。

為了防止像瀏覽器重新整理這類的預設行為，例如在 `onSubmit` 事件期間，你可以呼叫 `preventDefault()` 方法：

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("Form submitted!");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>Submit</button>
</form>;
```

你也可以像這樣將處理常式函式包裝在箭頭函式中：

```jsx
function handleDelete(id) {
  console.log("Deleting item:", id);
}

<button onClick={() => handleDelete(1)}>Delete Item</button>;
```

## 使用狀態與 `useState` 掛鉤

- **狀態的定義**：在 React 中，狀態是一個包含組件資料的物件。當狀態更新時，組件將重新呈現。React 將狀態視為不可變的，這表示你不應該直接修改它。
- **`useState()` 掛鉤**：`useState` 掛鉤是一個讓你在函式組件中宣告狀態變數的函式（程式）。以下是基本語法：

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

在狀態變數中你有以下內容：

- `stateVariable` 保存目前的狀態值
- `setStateFunction`（設值函式）會更新狀態變數
- `initialValue` 設定初始狀態

這裡是一個完整的 `Counter` 組件範例：

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

## 算繪與 React 組件

- **定義**：在 React 中，算繪是組件出現在使用者介面（UI）中的處理程序，通常是瀏覽器。算繪處理程序包含三個階段：觸發、算繪和提交。

觸發階段發生在 React 偵測到某些東西已改變且使用者介面（UI）可能需要更新時。這種改變通常是由於 state 或 props 的更新。

一旦觸發發生，React 就會進入呈現階段。在這裡，React 會重新評估你的組件並決定要呈現什麼。為了做到這點，React 使用一個稱為虛擬 DOM 的輕量級「真實」DOM 複本。透過虛擬 DOM，React 可以快速檢查組件中需要變更的部分。

提交階段是 React 從虛擬 DOM 取得準備好的變更並將它們套用到真實 DOM 的階段。換句話說，這是你在螢幕上看到最終結果的階段。

## 在狀態中更新物件和陣列

- **更新狀態中的物件**：如果你需要更新狀態中的物件，則應該先建立一個新的物件或複製一個現有的物件，然後為該新物件設定狀態。任何放入狀態中的物件都應視為唯讀。以下是一個設定使用者姓名、年齡和城市的範例。`handleChange` 函式用於控制使用者資訊的更新：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **在狀態中更新陣列**：當在狀態中更新陣列時，重要的是不要使用像 `push()` 或 `pop()` 這類方法直接修改陣列。相反地，你應該在更新狀態時創建一個新的陣列：

```js
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

如果你想從陣列中移除條款，你應該使用 `filter()` 方法，該方法會在過濾掉你想移除的內容後傳回一個新的陣列：

```js
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## 使用 Refs 取用值

- **`ref` 屬性**：你可以透過使用 `ref` 屬性來存取 React 中的 DOM 節點。以下是一個示範如何使用 `ref` 來聚焦 `input` 元素的範例。`current` 屬性用於存取該 `ref` 的當前值：

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Focus;
```

## 使用 `useEffect` 掛鉤

- **`useEffect()` 掛鉤**：在 React 中，效果是指發生在組件算繪程序之外的任何事情。也就是說，任何 React 不會直接作為 UI 呈現一部分來控制的事情。常見範例包括擷取資料、更新瀏覽器分頁的標題、從瀏覽器的區域儲存讀取或寫入、取得使用者的位置，還有更多。這些操作會與外部世界互動，被稱為副作用。React 提供 `useEffect` 掛鉤，讓你控制這些副作用。`useEffect` 讓你在組件呈現或更新後執行一個函式。

```js
import { useEffect } from "react";

useEffect(() => {
 // Your side effect logic (usually a function) goes here
}, [dependencies]);
```

當組件呈現後，effect 函式（程式）會執行，而選用的 `dependencies` 引數控制 effect 執行的時機。

請注意，`dependencies` 可以是「反應值」（狀態、屬性、函式、變數等等）的陣列、空陣列，或完全省略。以下說明所有這些選項如何控制 `useEffect` 的運作方式：

- 如果 `dependencies` 是包含一個或多個反應值的陣列，則每當它們改變時，該 effect 就會執行。

- 如果 `dependencies` 是空陣列，`useEffect` 僅在組件首次呈現時執行一次。

- 如果你省略 `dependencies`，該效果會在組件每次呈現或更新時執行。

## 如何創建訂製掛鉤

- **訂製掛鉤**：訂製掛鉤允許你從組件中抽取可重複使用的邏輯，例如資料擷取、狀態管理、切換，以及像追蹤線上狀態這類的副作用。在 React 中，所有內建掛鉤都以字 `use` 開頭，因此你的訂製掛鉤也應該遵循相同的慣例。

這裡是一個建立 `useDebounce` 掛鉤的範例：

```js
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

# --assignment--

檢視 React 狀態和掛鉤主題與概念。
