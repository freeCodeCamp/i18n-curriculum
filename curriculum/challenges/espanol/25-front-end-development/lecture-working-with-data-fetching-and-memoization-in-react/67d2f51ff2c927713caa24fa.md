---
id: 67d2f51ff2c927713caa24fa
title: '¿Cómo funcionan el gancho <code>useCallback</code> y <code>React.memo</code>?'
challengeType: 11
videoId: BGK2SLMOthI
dashedName: how-do-the-usecallback-hook-and-react-memo-work
---

# --description--

Mira el video o lee la transcripción y responde las preguntas abajo.

# --transcript--

¿Cómo funcionan el gancho `useCallback` y `React.memo`?

En la última lección, aprendiste sobre la memorización y cómo funciona el gancho `useMemo`.

En esta lección, aprenderás cómo funcionan el gancho `useCallback` y `React.memo`.

En la última lección, también mencionamos que `useCallback` es para memorizar referencias de funciones.

Para `React.memo`, te permite memorizar un componente para prevenir que se vuelva a renderizar innecesariamente cuando su prop no ha cambiado.

Aquí está la sintaxis básica del gancho `useCallback`:

```js
const handleClick = useCallback(() => {
  // code goes here
}, [dependency]);
```

Y aquí está la sintaxis básica de `React.memo`:

```jsx
const MemoizedComponent = React.memo(({ prop }) => {
  return (
    <>
      {/* Presentation */}
    </>
  )
});
```

Veamos un ejemplo del gancho `useCallback`:

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount((prevCount) => prevCount + 1);
  };

  useEffect(() => {
    console.log("useEffect runs");
  }, [handleClick]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```

En el componente, el efecto se ejecuta cada vez que `handleClick` cambia porque la función `handleClick` se está recreando en cada renderizado.

Para solucionar esto, necesitas decirle a React que trate la función `handleClick` como la misma a través de renderizados memorizándola con el gancho `useCallback`, para que no se vuelva a crear:

```jsx
import { useState, useEffect, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  // Memoize the handleClick function with useCallback
  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  useEffect(() => {
    console.log("useEffect runs");
  }, [handleClick]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```

Ahora, la función `handleClick` no se está recreando en cada renderizado.

Para mostrarte cómo funciona la función de orden superior `React.memo` (o `memo`) y el gancho `useCallback` en conjunto, aquí hay un componente `Counter` con una función `handleClick` que necesita `useCallback` pero actualmente no lo está usando:

```jsx
import { useState, useEffect, useCallback } from "react";
import CounterChild from "./CounterChild";

function Counter() {
  const [count, setCount] = useState(0);
  const [timer, setTimer] = useState(new Date().toLocaleTimeString());

  const handleClick = () => {
    setCount(count + 1);
  };

  useEffect(() => {
    const interval = setInterval(() => {
      setTimer(new Date().toLocaleTimeString());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return (
    <div>
      <h1>Time: {timer}</h1>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
      <CounterChild onClick={handleClick} />
    </div>
  );
}

export default Counter;
```

Esta función también tiene un temporizador en estado que se actualiza cada segundo. Esto hace que el componente se vuelva a renderizar cada vez que el `timer` cambia, haciendo que la función `handleClick` se vuelva a recrear en cada renderizado.

Es por eso que la función `handleClick` necesita ser memorizada con `useCallback`.

Aquí está el componente `CounterChild`:

```jsx
const CounterChild = ({ onClick }) => {
  console.log("CounterChild component rendered");
  return <button onClick={onClick}>Increment from Child</button>;
};

export default CounterChild;
```

Este componente `CounterChild` toma una prop `onClick`, dándote la habilidad de también incrementar el contador desde él.

Dado que el componente `CounterChild` es un hijo del componente `Counter`, también se renderizará cada vez que el `Counter` se vuelva a renderizar debido al temporizador cambiante. Así que, el `CounterChild` también necesita ser memorizado.

Sin memorización, porque a medida que el componente se vuelve a renderizar debido a que el temporizador se actualiza cada segundo, el componente `CounterChild` también se vuelve a renderizar.

Para prevenir esto, necesitas memorizar el componente `CounterChild` con `React.memo`:

```jsx
import React from "react";

const CounterChild = React.memo(({ onClick }) => {
  console.log("CounterChild component rendered");
  return <button onClick={onClick}>Increment from Child</button>;
});

export default CounterChild;
```

Las cosas aún no funcionan óptimamente incluso después de memorizar el `CounterChild` con `React.memo`.

Esto ocurre porque la función `handleClick` se está recreando en cada renderizado, por lo que también necesita ser memorizada con `useCallback`, para decirle a React que necesitas que la función permanezca igual a través de renderizados:

```js
const handleClick = useCallback(() => {
  setCount((prevCount) => prevCount + 1);
}, [count]);
```

Ahora, el componente solo se vuelve a renderizar cuando el estado `count` cambia.

# --questions--

## --text--

¿Qué memoriza el gancho `useCallback`?

## --answers--

Valores calculados.

### --feedback--

Ayuda a prevenir que se cree una nueva instancia de función en cada renderizado.

---

Referencias de función.

---

Renderizados de componentes.

### --feedback--

Ayuda a prevenir que se cree una nueva instancia de función en cada renderizado.

---

Actualizaciones de estado.

### --feedback--

Ayuda a prevenir que se cree una nueva instancia de función en cada renderizado.

## --video-solution--

2

## --text--

¿Cuál de estas es la sintaxis correcta para el gancho `useCallback`?

## --answers--

```js
const handleClick = useCallback(() => { /* code */ });
```

### --feedback--

El segundo argumento debe ser una matriz de dependencias.

---

```js
const handleClick = useCallback(() => { /* code */ }, dependency);
```

### --feedback--

El segundo argumento debe ser una matriz de dependencias.

---

```jsx
const handleClick = useCallback(() => { /* code */ }, [dependency]);
```

---

```js
const handleClick = useCallback(() => { dependency }, {});
```

### --feedback--

El segundo argumento debe ser una matriz de dependencias.

## --video-solution--

3

## --text--

¿Qué memoriza `React.memo`?

## --answers--

Referencias de función.

### --feedback--

Previene re-renderizados cuando los props permanecen iguales.

---

Estado del componente.

### --feedback--

Previene re-renderizados cuando los props permanecen iguales.

---

Componentes renderizados basados en props sin cambios.

---

Elementos del DOM.

### --feedback--

Previene re-renderizados cuando los props permanecen iguales.

## --video-solution--

3
