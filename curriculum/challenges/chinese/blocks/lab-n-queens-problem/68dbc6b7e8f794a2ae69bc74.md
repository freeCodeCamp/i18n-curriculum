---
id: 68dbc6b7e8f794a2ae69bc74
title: 实现 N-Queens 算法
challengeType: 27
dashedName: implement-the-n-queens-algorithm
---

# --description--

N 皇后问题要求你在一个 N×N 的棋盘上放置 N 个皇后，使得没有两个皇后互相攻击（没有两个皇后共享同一行、列或对角线）。 

例如，如果有一个 4x4 的棋盘，一个有效的排列是：

```md
[1, 3, 0, 2]
```

这意味着在第 0 行，皇后放置在第 1 列；在第 1 行，皇后放置在第 3 列；在第 2 行，皇后放置在第 0 列；在第 3 行，皇后放置在第 2 列。

从视觉上看，这种排列方式如下：

```md
. Q . .
. . . Q
Q . . .
. . Q .
```

其中 `Q` 表示一个皇后，`.` 表示一个空白格子。

在本实验中，你将使用深度优先搜索方法实现 N 皇后问题求解器。


**目标**：完成以下用户故事并通过所有测试以完成实验。

**用户故事：**

1. 你应该有一个名为 `dfs_n_queens` 的函数。
2. 该函数应接受且仅接受一个参数：整数 `n`。
3. 如果 `n` 小于 `1`，函数应返回一个空列表（`[]`）。
4. 该函数应返回一个方案列表；每个方案本身是一个长度为 `n` 的列表，其中索引为 `i` 的元素是第 `i` 行皇后的列索引（从 0 开始）。

# --hints--

你应该有一个名为 `dfs_n_queens` 的函数，它接受一个参数。

```js
({ test: () => runPython(`
  import inspect
  assert inspect.isfunction(dfs_n_queens)
  sig = inspect.signature(dfs_n_queens)
  assert len(sig.parameters) == 1
`) })
```

如果 `n` 小于 `1`，函数应返回一个空列表。

```js
({ test: () => runPython(`
  assert dfs_n_queens(0) == []
  assert dfs_n_queens(-1) == []
  assert dfs_n_queens(-5) == []
`) })
```

该函数应返回一个方案的列表，其中每个方案都是长度为 `n` 的列表。

```js
({ test: () => runPython(`
  result = dfs_n_queens(4)
  assert isinstance(result, list)
  for solution in result:
    assert isinstance(solution, list)
    assert len(solution) == 4
`) })
```

`dfs_n_queens(1)` 应该返回 `[[0]]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(1) == [[0]]
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(2)` 应返回 `[]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(2) == []
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(3)` 应该返回 `[]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(3) == []
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(4)` 应该返回 `[[1, 3, 0, 2], [2, 0, 3, 1]]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(4) == [[1, 3, 0, 2], [2, 0, 3, 1]]
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(5)` 应该返回 `[[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
  assert dfs_n_queens(3) == []
`) })
```

`len(dfs_n_queens(5))` 应该是 `10`。

```js
({ test: () => runPython(`
  assert len(dfs_n_queens(5)) == 10
  assert len(dfs_n_queens(6)) == 4
`) })
```

`len(dfs_n_queens(8))` 应该是 `92`。

```js
({ test: () => runPython(`
  assert len(dfs_n_queens(8)) == 92
  assert len(dfs_n_queens(5)) == 10

`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def dfs_n_queens(n):
    if n < 1:
        return []

    results = []

    def is_safe(queens, row, col):
        for r, c in enumerate(queens):
            if c == col or abs(row - r) == abs(col - c):
                return False
        return True

    def dfs(queens):
        row = len(queens)
        if row == n:
            results.append(queens[:])
            return
        for col in range(n):
            if is_safe(queens, row, col):
                queens.append(col)
                dfs(queens)
                queens.pop()

    dfs([])
    return results
```
