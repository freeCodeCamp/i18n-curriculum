---
id: 67d1ebcab4e0521a6654bb64
title: '¿Cómo actualizar arreglos en el estado?'
challengeType: 19
dashedName: how-do-you-update-arrays-in-state
---

# --description--

En React, actualizar arreglos en el estado es bastante sencillo, pero es fácil cometer un error, especialmente si vienes de JavaScript estándar donde puedes modificar arreglos directamente.

En React, el estado se trata como inmutable para que pueda reconocer cambios y hacer las actualizaciones adecuadas en la interfaz de usuario.

Veamos cómo puedes actualizar arreglos en el estado en React.

Uno de los errores más comunes al actualizar arreglos en un estado de React es modificar directamente el arreglo utilizando métodos como `push()`, `pop()`, o `splice()`. Estos métodos mutan el arreglo original y React no permite eso.

React se basa en una nueva referencia de arreglo para detectar cambios, por lo tanto, modificar directamente el arreglo puede impedir que el componente se vuelva a renderizar como se espera.

Aquí tienes un ejemplo de usar el método `push()` para agregar a un arreglo en el estado, lo cual no funcionará:

```jsx
import { useState } from "react";

function ItemsList() {
  const [items, setItems] = useState([
    { id: 0, name: "Item 1" },
    { id: 1, name: "Item 2" },
    { id: 2, name: "Item 3" },
  ]);

  const addItem = () => {
    const newItem = { id: items.length + 1, name: `Item ${items.length + 1}` };
    items.push(newItem); // This modifies the original array
    setItems(items); // React will not detect this change
  };

  return (
    <div>
      <button onClick={addItem}>Add Item</button>
      <ul>
        {items.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default ItemsList;
```

Si haces clic en el botón `Add Item`, no sucede nada en la interfaz de usuario.

También puede ser tentador eliminar elementos del arreglo con el método `pop()`:

```js
const removeItem = () => {
  items.pop(); // Modifies the original array
  setItems(items); // React will not detect this change, either
};
```

Para actualizar un arreglo en el estado, la clave es crear un nuevo arreglo, realizar tus operaciones y pasar eso a React, en lugar de mutar el arreglo existente.

Porque es un nuevo arreglo, React sabrá que el estado ha cambiado y desencadenará un re-renderizado.

Aquí tienes cómo puedes agregar a la arreglo `items` usando el operador de propagación:

```js
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

`[...prevItems, newItem]` crea un nuevo arreglo copiando todos los elementos en el arreglo existente `items` mantenido en el estado, luego añade `newItem` al final, lo que incrementa el `id` y el número de elemento.

Si deseas eliminar algo del arreglo, puedes usar el método `filter()`, que devuelve un nuevo arreglo después de filtrar lo que deseas eliminar:

```js
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

Aquí está el código completo:

```jsx
import { useState } from "react";

function ItemsList() {
  const [items, setItems] = useState([
    { id: 0, name: "Item 1" },
    { id: 1, name: "Item 2" },
    { id: 2, name: "Item 3" },
  ]);

  const addItem = () => {
    const newItem = { id: items.length + 1, name: `Item ${items.length + 1}` };
    setItems((prevItems) => [...prevItems, newItem]); // Creates a new array
  };

  const removeItem = (id) => {
    setItems((prevItems) => prevItems.filter((item) => item.id !== id)); // Creates a new array
  };

  return (
    <div>
      <button onClick={addItem}>Add Item</button>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            {item.name}{" "}
            <button onClick={() => removeItem(item.id)}>Remove</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default ItemsList;
```

Esas son algunas formas comunes en que puedes actualizar un arreglo en el estado.

# --questions--

## --text--

¿Cuál de los siguientes es la forma correcta de actualizar el estado y añadir nuevos elementos a un arreglo?

## --answers--

```js
setItems(copy [prevItems, newItem]);
```

### --feedback--

Para actualizar arreglos en el estado necesitas utilizar la función de establecer y la sintaxis adecuada para agregar nuevos elementos a un arreglo.

---

```js
setItems(new Array = [...prevItems, newItem]);
```

### --feedback--

Para actualizar arreglos en el estado necesitas utilizar la función de establecer y la sintaxis adecuada para agregar nuevos elementos a un arreglo.

---

```js
items = (prevItems) => [...prevItems, newItem];
```

### --feedback--

Para actualizar arreglos en el estado necesitas utilizar la función de establecer y la sintaxis adecuada para agregar nuevos elementos a un arreglo.

---

```js
setItems((prevItems) => [...prevItems, newItem]);
```

## --video-solution--

4

## --text--

¿Por qué NO deberías modificar directamente un arreglo en el estado de React?

## --answers--

Despeja automáticamente el arreglo.

### --feedback--

React se basa en la inmutabilidad para detectar cambios en el estado.

---

Añade duplicados no deseados al arreglo.

### --feedback--

React se basa en la inmutabilidad para detectar cambios en el estado.

---

Causa errores en el componente.

### --feedback--

React se basa en la inmutabilidad para detectar cambios en el estado.

---

Impide que React detecte cambios.

## --video-solution--

4

## --text--

¿Cuál es el mejor método para eliminar un elemento de un arreglo en el estado de React?

## --answers--

`splice()`

### --feedback--

Piensa en un método que cree un nuevo arreglo sin modificar el original.

---

`push()`

### --feedback--

Piensa en un método que cree un nuevo arreglo sin modificar el original.

---

`pop()`

### --feedback--

Piensa en un método que cree un nuevo arreglo sin modificar el original.

---

`filter()`

## --video-solution--

4
