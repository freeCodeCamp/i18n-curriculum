---
id: 6724e24864b0771a4c4c9dc9
title: 測試審查
challengeType: 31
dashedName: review-testing
---

# --description--

## 手動與自動化測試

- **手動測試**：在手動測試中，測試人員會手動檢查應用程式的每個零件並測試不同的特性，以確保其正常運作。如果在測試過程中發現任何錯誤，測試人員會將這些錯誤回報給軟體團隊，以便修正。
- **自動化測試**：在自動化測試中，你可以透過撰寫獨立的程式來自動化你的測試，以檢查你的應用程式是否如預期般運作。

## 單元測試

- **單元測試**：在單元測試中，你會測試每個函式（程式）以確保一切如預期般運作。單元測試也可以作為你的應用程式的文件形式，因為它們旨在表述你的程式碼的預期行為。
- **單一職責原則**：單一職責原則建議保持每個函式（程式）小且只負責一件事。
- **常見的 JavaScript 測試框架**：一些常見的測試框架包括 Jest、Mocha 和 Vitest。Jest 是一個用於單元測試的熱門測試框架。

這裡是一個使用 Jest 的單元測試範例。

首先，你可以創建一個負責傳回新格式化字串的函式（程式）：

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

在一個獨立的 `getFormattedWord.test.js` 檔案中，你可以撰寫一些測試來驗證該函式是否如預期運作。`getFormattedWord.test.js` 檔案會長這樣：

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **`expect` 函式（程式）**：`expect` 函式（程式）用於測試一個值。
- **Matcher**：Matcher 是一個用來檢查值是否符合預期行為的函式（程式）。在上述範例中，matcher 是 `toBe()`。Jest 有各種不同的 matcher。

要使用 Jest，你首先需要使用 `npm i jest` 安裝 `jest` 軟體包。你還需要在你的 `package.json` 檔案中添加像這樣的腳本：

```js
"scripts": {
  "test": "jest"
},
```

然後，你可以執行指令 `npm run test` 來執行你的測試。

## 軟體開發生命週期

- **軟體開發生命週期的不同階段**：
  - **規劃階段**：開發團隊從利害關係人收集擬議工作的需求。
  - **設計階段**：軟體團隊將需求拆解並決定最佳的解決方案方法。
  - **實作階段**：軟體團隊將需求拆解成可管理的任務並加以實作。
  - **測試階段**：這包括對新工作進行手動和自動測試。有時，團隊會在整個開發階段中測試應用程式，以捕捉並修正任何出現的問題。
  - **部署階段**：團隊將新的變更部署到建置或測試環境。
  - **維護階段**：這涉及修復生產應用程式中客戶所提出的任何問題。

- **軟體開發生命週期的不同模型**：
  - **瀑布模型**：瀑布模型是指必須在下一階段開始之前完成生命週期的每個階段。
  - **敏捷模型**：敏捷模型專注於透過將工作拆分為衝刺來進行反覆的開發。

## BDD 和 TDD

- **TDD**：測試驅動開發是一種強調先撰寫測試的開發方法。在建置特性之前撰寫測試，能在開發過程中為開發者提供即時回授。
- **BDD**：行為驅動開發是一種將一系列測試與商務目標對齊的方法。BDD 中的測試情境應該使用技術人員和非技術人員都能理解的語言撰寫。這種語法的範例是 Gherkin。
- **BDD 測試框架**：BDD 測試框架的範例包括 Cucumber、JBehave 和 SpecFlow。

## 單元測試中的斷言

- **斷言**：斷言用於測試程式碼是否如預期般運作。
- **斷言函式庫**：Chai 是一個常用的斷言函式庫。其他常見的 JavaScript 斷言函式庫有 `should.js` 和 `expect.js`。

以下是使用 Chai 的斷言範例，檢查 `addThreeAndFour` 函式的返回值是否相等於數字 7：

```js
assert.equal(addThreeAndFour(), 7);
```

- **最佳實務**：無論你使用哪個斷言函式庫，都應該撰寫清楚的 assert 和 failure 訊息，以幫助你了解哪些測試失敗以及原因。

## 模擬、偽造和存根

- **模擬**：模擬是用假資料取代真實資料以模擬真實組件行為的過程。<dfn>例如</dfn>，你可以在測試中模擬 API 回應，而不是持續呼叫 API 來取得資料。
- **Stubbing**：Stub 是會傳回預先定義回應或虛擬資料的物件，用於應用程式中預期行為。<dfn>例如</dfn>，你可以在測試中為資料庫連接的行為建立 stub，而不必依賴實際的資料庫連接。
- **Faking**：Fakes 是真實組件的簡化版本，沒有複雜性或副作用。<dfn>例如</dfn>，你可以透過將資料儲存在記憶體中，而非與真實資料庫互動，來假造一個資料庫。這將允許你在記憶體中模擬資料庫操作，速度會比處理真實資料庫快得多。

## 功能測試

- **功能測試**：功能測試檢查應用程式的特性和函式（程式）是否如預期運作。功能測試的目標是針對多個情境測試整個系統。
- **非功能性測試**：非功能性測試專注於效率、性能和可靠性等方面。
- **冒煙測試**：冒煙測試是在開始更廣泛測試之前，對系統進行基本或關鍵問題的初步檢查。

## 端對端測試

- **端對端測試**：端對端測試，或稱 E2E，從使用者的角度測試真實世界的情境。端對端測試有助於確保你的應用程式行為正確且對使用者可預測。然而，設定、設計和維護需要花費大量時間。
- **端對端測試框架**：Playwright 是由 Microsoft 開發的熱門端對端測試框架。其他端對端測試工具的例子包括 Cypress、Selenium 和 Puppeteer。

這裡是一個來自 freeCodeCamp 程式碼庫使用 Playwright 的 E2E 測試範例。`beforeEach` 掛鉤會在每個測試之前執行。這些測試會檢查捐贈者在選單列中是否有支持者聯結，以及他們的頭像周圍是否有特殊樣式的邊框：

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## 可用性測試

- **可用性測試**：可用性測試是指讓真實使用者與應用程式互動，以發現應用程式中是否存在任何設計、使用者體驗或功能問題。可用性測試著重於使用者對應用程式直覺性的評估。
- **四種常見的可用性測試型別**：
  - **探索性**：探索性可用性測試涉及使用者與應用程式的不同特性互動，以更好地了解它們的運作方式。
  - **比較測試**：比較測試是指你將你的應用程式的使用者體驗與市場上類似的應用程式進行比較。
  - **評估**：評估測試是研究應用程式使用直覺性的過程。
  - **驗證**：驗證測試是用來識別任何會阻止使用者有效使用應用程式的重大問題。
- **可用性測試工具**：可用性測試的工具範例包括 Loop11、Maze、Userbrain、UserTesting 和 UXTweak。

## 相容性測試

- **相容性測試**：相容性測試的目標是確保你的應用程式能在不同的運算環境中運作。
- **不同型別的相容性測試**：
  - **向後相容性**：向後相容性是指軟體與較早版本相容。
  - **向前相容性**：向前相容性是指軟體和系統能與未來版本一起運作。
  - **硬體相容性**：硬體相容性是軟體在不同硬體組態中正常運作的能力。
  - **作業系統相容性**：作業系統相容性是指軟體能在不同作業系統上運作的能力，例如 macOS、Windows 以及像 Ubuntu 和 Fedora 這樣的 Linux 發行版。
  - **網路相容性**：網路相容性表示軟體能在不同的網路條件下運作，例如不同的網路速度、協定、安全設定等。
  - **瀏覽器相容性**：瀏覽器相容性是指網頁應用程式能在不同瀏覽器（例如 Google Chrome、Safari、Firefox 等）中一致運作。
  - **行動相容性**：確保你的軟體應用程式能在各種 Android 和 iOS 裝置（包括手機和平板電腦）上運作非常重要。

## 效率測試

- **效率測試**：在效率測試中，你會測試應用程式在不同工作負載下的速度、回應能力、可擴充性和穩定性。目標是決議任何型別的效率瓶頸。
- **不同型別的效率測試**：
  - **載入測試**：載入測試用來判斷系統在正常及高峰載入時間的行為。
  - **壓力測試**：壓力測試是指在極端負載下測試你的應用程式，並觀察你的系統對較高負載的反應能力。
  - **浸泡測試（耐力測試）**：浸泡測試或耐力測試是一種載入測試，透過在較長時間內以較高載入測試系統。
  - **尖峰測試**：尖峰測試是指你劇烈增加和減少負載，並分析系統對這些變化的反應。
  - **中斷點測試（容量測試）**：中斷點測試或容量測試是指你隨著時間慢慢增加載入，直到系統開始失效或降級的過程。

## 安全測試

- **安全測試**：安全測試有助於識別漏洞和弱點。
- **安全原則**：
  - **機密性**：這可防止敏感資訊洩漏給非預期的收件者。
  - **完整性**：這涉及防止惡意使用者修改使用者資訊。
  - **身份驗證**：這涉及驗證使用者的身分，以確保他們被允許使用該系統。
  - **授權**：這是決定已驗證使用者被允許執行哪些動作或被允許存取系統哪些零件的處理程序。
  - **可用性**：這確保資訊和服務在使用者需要時可供授權使用者使用。
  - **不可否認性**：這確保寄件者和收件者雙方都有交付證明及寄件者身份的驗證。它防止寄件者否認曾經傳送過該資訊。
- **常見的安全威脅**：
  - **跨站指令碼攻擊（XSS）**：當攻擊者將惡意指令碼注入網頁，並在受害者瀏覽器的上下文中執行時，就會發生 XSS 攻擊。
  - **SQL 注入**：SQL 注入允許惡意使用者將惡意程式碼注入到資料庫中。
  - **拒絕服務攻擊（DoS）**：DoS 攻擊是指惡意使用者以大量請求或流量淹沒網站，導致伺服器變慢甚至當機，使網站無法提供服務給使用者。
- **安全測試工具的類別**：
  - **靜態應用程式安全測試**：這些工具會評估應用程式的原始碼以識別安全漏洞。
  - **動態應用程式安全測試**：這些工具與應用程式的前端介面互動，以發現潛在的安全弱點。DAST 工具無法存取原始碼。
- **滲透測試 (pentest)**：滲透測試是一種安全測試，涉及對應用程式進行模擬的網路攻擊，以識別系統中的任何弱點。

## A/B 測試

- **A/B 測試**：A/B 測試涉及比較頁面或應用程式的兩個版本，並研究哪個版本表現較佳。它也被稱為桶測試或分割測試。A/B 測試讓你能夠做出更多以資料為依據的決策，並持續改善使用者體驗。
- **A/B 測試工具**：用於 A/B 測試的工具範例包括 GrowthBook 和 LaunchDarkly。

## Alpha 測試和 Beta 測試

當初始開發和軟體測試完成後，讓測試人員和真實使用者測試應用程式是很重要的。這就是 alpha 測試和 beta 測試的用途。

- **Alpha 測試**：Alpha 測試由一組特定的測試者進行，他們會檢查應用程式以確保在發布到市場之前沒有錯誤。Alpha 測試是驗收測試的一部分，並且同時使用白箱和黑箱測試技術。
- **Beta 測試**：Beta 測試是將應用程式提供給真實使用者的階段。使用者可以與應用程式互動並提供回授。Beta 測試也是一種使用者驗收測試。
- **驗收測試**：驗收測試確保軟體應用程式在發佈前符合商務需求和使用者需求。
- **黑盒測試**：黑盒測試僅關注應用程式的預期行為。
- **白箱測試**：白箱測試涉及測試者了解內部組件並對其進行測試。

## 回歸測試

- **回歸**：回歸指的是新變更無意中破壞現有功能的情況。
- **回歸測試**：回歸測試有助於捕捉回歸問題。在回歸測試中，你會對應用程式的零件重新執行功能測試，以確保一切仍然如預期般運作。
- **迴歸測試工具**：你可以使用的迴歸測試工具包括 Puppeteer、Playwright、Selenium 和 Cypress。
- **迴歸測試技術**：
  - **單元回歸測試**：這是指每次在應用程式中實作重大變更或修正時，都需要測試的一個項目列表。
  - **部分回歸測試**：這涉及標的方式，以確保新的變更沒有破壞應用程式的特定零件。
  - **完整回歸測試**：這會對程式碼庫中的所有功能執行測試。這是最耗時且最詳細的選項。
- **重新測試**：重新測試用於檢查已知問題並確保它們已被決議。相較之下，回歸測試則是搜尋可能因程式碼庫最近變更而產生的未知問題。

# --assignment--

檢視測試主題和概念。
