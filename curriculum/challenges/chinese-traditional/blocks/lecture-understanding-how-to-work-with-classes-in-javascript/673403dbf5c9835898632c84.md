---
id: 673403dbf5c9835898632c84
title: 類別中的靜態屬性和方法是什麼？
challengeType: 19
dashedName: what-are-static-properties-and-methods-in-classes
---

# --interactive--

靜態屬性和方法屬於類別本身，而非類別的個別實體。你可以直接透過類別名稱存取它們，而不需要建立類別的實體。它們是在類別中定義，以封裝相關的功能。

你可以透過在方法名稱前撰寫 `static` 關鍵字來定義靜態方法。

```js
class MyClass {
  static staticMethod() { ... }
}
```

然後，你可以直接在類別上使用點記法呼叫靜態方法，並傳遞任何必要的引數：

```js
MyClass.staticMethod();
```

請注意，你能夠在不建立該類別實體的情況下呼叫該方法。這是靜態方法的主要特性之一。

這裡有一個範例。假設我們正在建立一個電影應用程式，並且我們想要能夠根據評分來比較電影。

我們可以將這個比較方法視為一個較高層級的方法，且不特定於任何電影：

```js
if (movieA.rating < movieB.rating) {
  console.log(`${movieB.title} has a higher rating.`);
} 
```

這就像是與 `Movie` 類別相關的更通用的方法。

為了可讀性和維護性，將它定義在 `Movie` 類別中會很有幫助，以便將所有相關的方法保持相對接近。

因此，這是靜態方法的完美候選。你可以在建構式正下方看到它：

:::interactive_editor

```js
class Movie {

  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }

}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);
console.log(movieA);
```

:::

靜態方法是使用 `static` 關鍵字定義的，並且它的名稱是 `compareMovies`。它有兩個參數：`movieA` 和 `movieB`。這些將會是 `Movie` 類別的實體。

我們將根據它們的評分，在 `0` 到 `100` 的範圍內進行比較。這個邏輯是以條件式實作，並且會根據哪部電影評分較高列印適當的訊息。

一旦方法已被定義，你就可以在類別上呼叫它。但首先，你需要在你的程式中準備並定義好引數。

在這種情況下，該方法接受兩個電影實體作為引數，因此我們在此定義這些實體：

```js
let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);
```

你可以看到 `movieA` 的評分比 `movieB` 高。讓我們看看這個方法的輸出。

要呼叫該方法，你只需要對類別本身使用點記法。你寫下類別的名稱（`Movie`），接著是一個點，然後是靜態方法的名稱（`compareMovies`）。

然後，你在小括弧內傳遞引數。在此情況下，它們是該方法所需的兩個電影實體。

```js
Movie.compareMovies(movieA, movieB);
```

這是更新後的範例：

:::interactive_editor

```js
class Movie {

  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }

}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);
Movie.compareMovies(movieA, movieB);
console.log(movieA);
```

:::

靜態方法對於實作「工廠」方法也很有幫助。工廠方法是在建構式之外定義的行為，用來根據特定條件創建物件。

這裡有一個 `Pizza` 類別的範例。靜態方法 `createMargherita` 是一個工廠方法，你可以呼叫它來創建一個已經設定好型別和價格的 Margherita 披薩實體。

```js
class Pizza {
  constructor(type, price) {
    this.type = type;
    this.price = price;
  }

  static createMargherita() {
    return new this("Margherita", 6.99);
  }
}
```

這也帶出了關於靜態方法的一個非常重要的問題。

靜態方法中 `this` 關鍵字的值是類別本身，因為靜態方法屬於該類別。

這就是為什麼我們可以使用 `this` 來創建 `Pizza` 類別的新實體。

如果你在 `Pizza` 類別本身上呼叫此方法，並將傳回的實體指定給變數，就像這個範例中一樣：

```js
let myPizza = Pizza.createMargherita();
```

你可以在程式碼中任何需要的地方使用它。 例如，你可以將它列印到主控台：

```js
console.log(myPizza);
```

這是輸出：

```js
Pizza { type: 'Margherita', price: 6.99 }
```

你也可以使用點記法來呼叫它的行為並存取它的屬性，像這樣：

```js
console.log(myPizza.type);
```

以下是完整範例：

:::interactive_editor

```js
class Pizza {
  constructor(type, price) {
    this.type = type;
    this.price = price;
  }

  static createMargherita() {
    return new this("Margherita", 6.99);
  }
}

let myPizza = Pizza.createMargherita();
console.log(myPizza);
console.log(myPizza.type);
```

:::

除了方法，你也可以使用 `static` 關鍵字定義靜態屬性。

在這個範例中，我們有一個靜態的 `numberOfPizzasSold` 屬性。

```js
class Pizza {
  static numberOfPizzasSold = 0;

  constructor(type) {
    this.type = type;
    Pizza.numberOfPizzasSold++;
  }
}
```

它是靜態的，因為它不屬於任何特定的 pizza 實體，而是屬於類別本身。

它的初始值為 `0`，並且每次創建新的實體時都會更新。

如果你創建兩個 pizza 實體，該值將被更新兩次：

```js
let pizza1 = new Pizza("Margherita");
let pizza2 = new Pizza("Neapolitan");
```

要存取靜態屬性的值，只需要對類別本身使用點記法，因為該屬性屬於類別。

```js
class Pizza {
  static numberOfPizzasSold = 0;

  constructor(type) {
    this.type = type;
    Pizza.numberOfPizzasSold++;
  }
}

let pizza1 = new Pizza("Margherita");
let pizza2 = new Pizza("Neapolitan");

console.log(Pizza.numberOfPizzasSold);
```

在這種情況下，輸出是 `2`，因為賣出了兩個披薩。

這些是 JavaScript 中靜態屬性和方法的基本原理。理解靜態成員對於建立可重複使用且高效的類別至關重要。

# --questions--

## --text--

JavaScript 類別中靜態方法的主要目的是什麼？

## --answers--

要創建該類別的新實體。

### --feedback--

思考靜態方法如何與類別本身相關，而非與個別物件相關。

---

要存取類別實體的屬性。

### --feedback--

思考靜態方法如何與類別本身相關，而非與個別物件相關。

---

定義可以在不建立該類別實體的情況下存取的方法。

---

繼承父類別的屬性和方法。

### --feedback--

思考靜態方法如何與類別本身相關，而非與個別物件相關。

## --video-solution--

3

## --text--

JavaScript 中靜態方法與實體方法的主要差異是什麼？

## --answers--

靜態方法只能在類別內使用，而實體方法可以在類別外使用。

### --feedback--

思考靜態和實體方法的作用域與存取性。

---

靜態方法可以存取實體屬性，而實體方法無法存取實體屬性。

### --feedback--

思考靜態和實體方法的作用域與存取性。

---

靜態方法與類別本身相關，而實體方法則與類別的特定實體相關。

---

靜態方法總是公開的，而實體方法可以是公開或私有的。

### --feedback--

思考靜態和實體方法的作用域與存取性。

## --video-solution--

3

## --text--

你如何存取 JavaScript 中類別的靜態屬性？

## --answers--

透過使用 `this` 關鍵字。

### --feedback--

思考靜態屬性如何與類別本身相關。

---

透過建立類別的實體並透過該實體存取屬性。

### --feedback--

思考靜態屬性如何與類別本身相關。

---

透過直接使用類別名稱和屬性名稱。

---

透過使用該類別的 prototype 屬性。

### --feedback--

思考靜態屬性如何與類別本身相關。

## --video-solution--

3
