---
id: 6733c5c549775c4be710237c
title: '¿Cómo puedes coincidir y reemplazar todas las apariciones en una cadena?'
challengeType: 19
dashedName: how-can-you-match-and-replace-all-occurrences-in-a-string
---

# --description--

Aprendamos cómo coincidir o reemplazar todas las ocurrencias de un patrón en una cadena.

Anteriormente has aprendido sobre los métodos `replace()` y `match()`, así como el modificador global `g`. Ahora puedes combinar ese conocimiento para manejar todos los patrones en una cadena. Recordemos nuestro código original de coincidencia:

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match);
```

Y nuestro objeto de coincidencia resultante:

```js
// [
//   'freeCodeCamp',
//   index: 0,
//   input: 'freeCodeCamp',
//   groups: undefined
// ]
```

Pero, ¿qué pasa si tenemos una cadena con múltiples ocurrencias de `freecodecamp` para coincidir? Veamos cómo `match()` se comporta con eso. Lanzaremos nuestro viejo ejemplo de `replace()` también, solo para comparar:

```js
const regex = /freecodecamp/;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

Y el resultado es este:

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
// freeCodeCamp is the best we love freecodecamp
```

¡Oh no! `match()` solo devolvió la primera coincidencia, y `replace()` solo reemplazó la primera coincidencia. Esto es porque, por defecto, `match()` y `replace()` solo operan contra la primera aparición del patrón.

Afortunadamente, puedes evitar esto usando el modificador global en tu expresión regular. Agreguemos eso al nuestro:

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

Y confirma el resultado:

```js
// [ 'freecodecamp', 'freecodecamp' ]
// freeCodeCamp is the best we love freeCodeCamp
```

¡Eso funcionó! Nuestra llamada a replace reemplazó todas las cadenas `freecodecamp` en minúsculas, y nuestro método `match()` coincidió con ambas.

Lo interesante aquí es que cuando usas el modificador global con `match()`, pierdes la información extra sobre los grupos de captura e índices de cadena que vendrían en el arreglo de coincidencias.

Afortunadamente, la actualización ECMAScript de 2019 nos trajo dos nuevos métodos: `matchAll()` y `replaceAll()`. Al igual que sus contrapartes singulares, estos métodos aceptan una cadena o expresión regular, y `replaceAll()` también acepta un segundo argumento como la cadena con la que reemplazar.

Pero a diferencia de los métodos anteriores, `replaceAll()` y `matchAll()` lanzarán un error si les das una expresión regular sin el modificador global. Actualicemos nuestro código para usar estos nuevos métodos:

```js
const pattern = "freecodecamp";
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(pattern);
const replaced = str.replaceAll(pattern, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

Y nuestro resultado:

```js
// {}
// freeCodeCamp is the best we love freeCodeCamp
```

¡Buenas noticias! Nuestro `replaceAll()` funcionó exactamente como queríamos: reemplazó todas las apariciones del `freecodecamp` en minúsculas por la versión con mayúsculas y minúsculas correctamente.

Pero, ¿qué es ese objeto vacío? Bueno, `matchAll()` devuelve un tipo especial de objeto llamado un `Iterador`, que la consola de freeCodeCamp no está preparada para manejar.

Si miramos en nuestra consola del navegador, el `Iterador` tiene un método `next()`, que podemos llamar para obtener el siguiente valor:

```js
// RegExpStringIterator {  }
//  <prototype>: RegExp String Iterator {
//    next: ƒ next(),
//    Symbol(Symbol.toStringTag): "RegExp String Iterator"
//    <prototype>: Object { ... }
//  }
```

Continuemos y llamemos a `matched.next()`, y registremos el resultado:

```js
// {
//   "done": false,
//   "value": [
//     0: "freecodecamp"
//     groups: undefined
//     index: 0
//     input: "freecodecamp is the best we love freecodecamp"
//   ]
// }
```

¡Ahí está nuestro arreglo de coincidencias! `next()` nos da un objeto con dos valores: `done`, que es `false` cuando hay más elementos disponibles en el iterador, y `value` que es el valor que acabamos de iterar. Así que, si lo llamamos una vez más:

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
const replaced = str.replaceAll(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
console.log(matched.next());
console.log(matched.next());
```

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
```

Espera, ¿por qué dice que `done` todavía es `false`? Debería haber solo dos coincidencias en el arreglo, ¿verdad? Llamemos una tercera vez y veamos qué obtenemos:

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": true,
//   "value": undefined
// }
```

`done` finalmente es `true`, pero ¿por qué es ese valor `undefined`? Bueno, como resulta, el iterador `matchAll()` es perezoso. No encuentra todas tus coincidencias de una vez. Solo encuentra una coincidencia cuando se le dice llamando a `next()`.

Mientras encuentra una coincidencia, no está `done`. Una vez que no logra encontrar una coincidencia y trae de vuelta `undefined`, está `done`. Esto puede parecer inconveniente, pero puede ser bastante útil cuando tu expresión regular es computacionalmente costosa.

Si tu ejemplo lo es menos, como el nuestro, puedes omitir esa función y extraer todas las coincidencias de una vez convirtiéndolo en un arreglo. Esto se logra llamando a `Array.from()` y pasando tu iterador como el argumento.

Actualicemos nuestro código para usar eso; vamos a limpiar nuestras llamadas a `replaceAll` ya que sabemos que funciona:

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
console.log(Array.from(matched));
```

Y finalmente obtuvimos nuestro arreglo de coincidencias:

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
//
// [
//   'freecodecamp',
//   index: 33,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
```

Estos métodos poderosos pueden ayudarte a manipular y extraer datos de cadenas sin tener que sacrificar rendimiento o legibilidad.

# --questions--

## --text--

¿Qué modificador se debe agregar a una expresión regular para coincidir con todas las ocurrencias de un patrón en una cadena?

## --answers--

`/i`

### --feedback--

La conferencia menciona un modificador específico para coincidencias globales.

---

`/m`

### --feedback--

La conferencia menciona un modificador específico para coincidencias globales.

---

`/g`

---

`/a`

### --feedback--

The lecture mentions a specific modifier for global matching.

## --video-solution--

3

## --text--

¿Cuál es la principal diferencia entre los métodos `match()` y `matchAll()` cuando se usan con una expresión regular global?

## --answers--

`match()` devuelve un arreglo, mientras que `matchAll()` devuelve un Iterador.

---

`matchAll()` es más rápido que `match()`.

### --feedback--

La conferencia describe un tipo especial de objeto devuelto por `matchAll()`.

---

`match()` solo puede encontrar la primera ocurrencia, mientras que `matchAll()` encuentra todas las ocurrencias.

### --feedback--

La conferencia describe un tipo especial de objeto devuelto por `matchAll()`.

---

No hay diferencias, son intercambiables.

### --feedback--

La conferencia describe un tipo especial de objeto devuelto por `matchAll()`.

## --video-solution--

1

## --text--

¿Cómo puedes convertir el resultado de `matchAll()` en un arreglo que contenga todas las coincidencias?

## --answers--

Usando un bucle `for...of`

### --feedback--

La conferencia demuestra un método específico para convertir el `Iterador` en un arreglo.

---

Llamando al método `toArray()` en el resultado.

### --feedback--

La conferencia demuestra un método específico para convertir el `Iterador` en un arreglo.

---

Usando `Array.from()` con el resultado como argumento.

---

Desplegando el resultado en un literal de arreglo.

### --feedback--

La conferencia demuestra un método específico para convertir el Iterador en un arreglo.

## --video-solution--

3
