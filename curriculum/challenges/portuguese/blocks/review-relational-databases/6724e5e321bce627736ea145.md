---
id: 6724e5e321bce627736ea145
title: Revisão de Bancos de Dados Relacionais
challengeType: 31
dashedName: review-relational-databases
---

# --description--

## Terminal, Shell e Noções Básicas da Linha de Comando

- **Linha de comando**: Uma interface de texto onde os usuários digitam comandos.  
- **Terminal**: O aplicativo que fornece acesso à linha de comando.  
- **Emulador de terminal**: Adiciona recursos extras a um terminal.  
- **Shell**: Interpreta os comandos inseridos no terminal (por exemplo, Bash).  
- **PowerShell / Command Prompt / Microsoft Terminal**: Opções para acessar a linha de comando no Windows.  
- **Terminal (macOS)**: Opção integrada no macOS, com alternativas de terceiros como iTerm ou Ghostty.  
- **Terminal (Linux)**: As opções variam conforme a distribuição, com muitos emuladores de terceiros como kitty.  
- **Terminologia**: Embora "terminal", "shell" e "linha de comando" sejam frequentemente usados de forma intercambiável, eles têm significados específicos.  

## Atalhos de Linha de Comando

- **Setas para cima/baixo**: Navegue pelos comandos anteriores/próximos no histórico.
- **Tab**: Autocompletar comandos.
- **`Control+L`** (Linux/macOS) ou digitando `cls` (Windows): Limpar a tela do terminal.
- **`Control+C`**: Interrompe um comando em execução (também usado para copiar no PowerShell se o texto estiver selecionado).
- **`Control+Z`** (somente Linux/macOS): Suspende uma tarefa para o plano de fundo; use `fg` para retomá-la.
- **`!!`**: Reexecuta instantaneamente o último comando executado.

## Noções básicas de Bash

- **Bash** (Bourne Again Shell): Widely used Unix-like shell.  
  Key commands:

  - **`pwd`**: Mostra o diretório atual.
  - **`cd`**: Mudar de diretórios.
    - **`..`** refere-se ao diretório pai (um nível acima).
    - **`.`** refere-se ao diretório atual.
  - **`ls`**: Lista arquivos e pastas.
    - **`-a`**: Mostrar todos os arquivos, incluindo arquivos ocultos.
    - **`-l`**: Mostrar informações detalhadas sobre arquivos.
  - **`less`**: Visualize o conteúdo do arquivo uma página por vez com opções de navegação, incluindo rolagem para trás e busca.
  - **`more`**: Exibe o conteúdo do arquivo uma tela por vez, com rolagem limitada para trás e navegação básica.
  - **`cat`**: Mostra o conteúdo inteiro do arquivo de uma vez sem rolagem ou navegação, útil para arquivos menores.
  - **`mkdir`**: Cria um novo diretório.
  - **`rmdir`**: Remove um diretório vazio.
  - **`touch`**: Cria um novo arquivo.
  - **`mv`**: Mover ou renomear arquivos.
    - Renomear: `mv oldname.txt newname.txt`
    - Mover: `mv filename.txt /path/to/target/`
  - **`cp`**: Copiar arquivos.
    - **`-r`**: Copia recursivamente diretórios e seus conteúdos.
  - **`rm`**: Excluir arquivos.
    - **`-r`**: Exclua recursivamente diretórios e seus conteúdos.
  - **`echo`**: Exibe uma linha de texto ou o valor de uma variável.
    - Use `>` para sobrescrever o conteúdo existente em um arquivo. (ex.: `echo "text" > file.txt`)
    - Use `>>` para adicionar a saída a um arquivo **sem sobrescrever o conteúdo existente** (por exemplo, `echo "text" >> file.txt`).
  - **`exit`**: Encerre a sessão do terminal.
  - **`clear`**: Limpa a tela do terminal.
  - **`find`**: Procura por arquivos e diretórios.
    - **`-name`**: Procure arquivos pelo padrão de nome (por exemplo, `find . -name "*.txt"`).
  - Use **`man`** seguido de um comando (por exemplo, `man ls`) para acessar páginas detalhadas de manual/ajuda.

## Opções e Flags de Comando

- **Opções** ou **flags**: modificam o comportamento de um comando e geralmente são prefixadas com hífens:
  - **Forma longa (dois hífens)**:  
    - Exemplo: `--help` e `--version`
    - Valores são atribuídos usando um sinal de igual, por exemplo, `--width=50`.
  - **Forma curta (um hífen)**:  
    - Exemplo: `-a` e `-l`
    - Os valores são passados com um espaço, por exemplo, `-w 50`.
    - Múltiplas opções curtas podem ser encadeadas juntas, por exemplo, `ls -alh`.
- **`--help`**: Você sempre pode usar um comando com esta flag para entender as opções disponíveis para qualquer comando.

## Introdução a Bancos de Dados Relacionais

- **Bancos de Dados Relacionais**: Organizam dados em tabelas relacionadas compostas por linhas e colunas. Cada linha representa um registro e cada coluna representa um atributo dos dados.
- **Vantagens dos Bancos de Dados Relacionais**: Escaláveis, amplamente aplicáveis em diversos domínios (por exemplo, saúde, negócios, jogos) e estruturados para manter dados confiáveis.
- **Casos de Uso Comuns**: desenvolvimento web, sistemas de inventário, comércio eletrônico, saúde e aplicações empresariais.

## Conceitos-chave

- **Esquema**: Um banco de dados relacional requer um esquema que defina sua estrutura—tabelas, colunas, tipos de dados, restrições e relacionamentos.
- **Chaves Primárias**: Identificadores únicos para cada linha em uma tabela. Eles são essenciais para a integridade dos dados e são usados para relacionar registros entre tabelas por meio de chaves estrangeiras.
- **Chaves Estrangeiras**: Referências a chaves primárias em outra tabela, usadas para vincular dados relacionados entre tabelas.
- **Relacionamentos**: Ao conectar tabelas por meio de chaves primárias e estrangeiras, você pode estruturar dados normalizados e realizar consultas significativas.
- **Diagramas de Relacionamento de Entidades (ERDs)**: Visualize como as entidades (tabelas) se relacionam entre si em um esquema de banco de dados.
- **Integridade de Dados**: Aplicada usando chaves e tipos de dados. Garante consistência e precisão dos dados armazenados.

## Noções básicas de SQL

- **Consultas**: Solicitações para recuperar dados específicos do banco de dados.

```sql
SELECT * FROM dogs WHERE age < 3;
```

- **Cláusula WHERE**: Filtre resultados com base em condições. Use operadores de comparação como `<`, `=`, `>`, etc.
- **Selecione com ORDER BY**: Recupere e ordene os resultados com base em uma coluna.

```sql
SELECT columns FROM table_name ORDER BY column_name;
```

## Operações de Tabela

- **Declaração `CREATE TABLE`**: Esta declaração é usada para criar uma nova tabela em um banco de dados.

```sql
CREATE TABLE first_table();
```

- **Declaração `ALTER TABLE ADD COLUMN`**: Esta declaração é usada para adicionar uma coluna a uma tabela existente.

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE;
```

- **Declaração `ALTER TABLE DROP COLUMN`**: Esta declaração é usada para remover uma coluna de uma tabela existente.

```sql
ALTER TABLE table_name DROP COLUMN column_name;
```

- **Declaração `ALTER TABLE RENAME COLUMN`**: Esta declaração é usada para renomear uma coluna em uma tabela.

```sql
ALTER TABLE table_name RENAME COLUMN column_name TO new_name;
```

- **Instrução `DROP TABLE`**: Esta instrução é usada para remover uma tabela inteira do banco de dados.

```sql
DROP TABLE table_name;
```

- **Declaração `ALTER DATABASE RENAME`**: Esta declaração é usada para renomear um banco de dados.

```sql
ALTER DATABASE database_name RENAME TO new_database_name;
```

- **Declaração `DROP DATABASE`**: Esta declaração é usada para excluir um banco de dados inteiro.

```sql
DROP DATABASE database_name;
```

## Restrições e Integridade de Dados

- **`ALTER TABLE ADD COLUMN` com Restrição**: Esta instrução é usada para adicionar uma coluna com uma restrição a uma tabela existente.

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE CONSTRAINT;
```

- **Restrição `NOT NULL`**: Esta restrição garante que uma coluna não possa ter valores NULL.

```sql
column_name VARCHAR(50) NOT NULL
```

- **Declaração `ALTER TABLE ADD PRIMARY KEY`**: Esta declaração é usada para adicionar uma restrição de chave primária a uma tabela.

```sql
ALTER TABLE table_name ADD PRIMARY KEY(column_name);
```

- **Declaração `ALTER TABLE DROP CONSTRAINT`**: Esta declaração é usada para remover uma restrição de uma tabela.

```sql
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
```

- **`ALTER TABLE ADD COLUMN` com Chave Estrangeira**: Esta instrução é usada para adicionar uma coluna de chave estrangeira que referencia outra tabela.

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE REFERENCES referenced_table_name(referenced_column_name);
```

- **Declaração `ALTER TABLE ADD UNIQUE`**: Esta declaração é usada para adicionar uma restrição UNIQUE a uma coluna.

```sql
ALTER TABLE table_name ADD UNIQUE(column_name);
```

- **Declaração `ALTER TABLE ALTER COLUMN SET NOT NULL`**: Esta declaração é usada para definir uma restrição NOT NULL em uma coluna existente.

```sql
ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL;
```

- **Instrução `INSERT` com Valores NULL**: Esta instrução demonstra como inserir valores NULL em uma tabela.

```sql
INSERT INTO table_name(column_a) VALUES(NULL);
-- or
INSERT INTO table_name(column_b) VALUES('value'); -- if column_a allows nulls
```

- **Chave Primária Composta**: Esta restrição define uma chave primária que consiste em múltiplas colunas.

```sql
CREATE TABLE course_enrollments (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id)
);
```

## Manipulação de Dados (CRUD)

- **Declaração `INSERT`**: Esta declaração é usada para inserir uma única linha em uma tabela.

```sql
INSERT INTO table_name(column_1, column_2) VALUES(value1, value2);
```

- **Instrução `INSERT` com Colunas Omitidas**: Esta instrução mostra como inserir valores sem listar explicitamente os nomes das colunas, confiando na ordem padrão das colunas na tabela.

```sql
INSERT INTO dogs VALUES ('Gino', 3);
```

- **Declaração `INSERT` com Múltiplas Linhas**: Esta declaração é usada para inserir múltiplas linhas em uma tabela em uma única operação.

```sql
INSERT INTO dogs (name, age) VALUES 
('Gino', 3),
('Nora', 2);
```

- **Declaração `UPDATE`**: Esta declaração é usada para atualizar dados existentes em uma tabela com base em uma condição.

```sql
UPDATE table_name SET column_name=new_value WHERE condition;
```

- **Declaração `DELETE`**: Esta declaração é usada para deletar linhas de uma tabela com base em uma condição.

```sql
DELETE FROM table_name WHERE condition;
```

## Tipos de Dados

- **Tipo de Dados `NUMERIC`**: Este tipo de dado é usado para armazenar números decimais precisos com uma precisão e escala especificadas.

```sql
price NUMERIC(10, 2)
```

- **Tipo de Dados `TEXT`**: Este tipo de dado é usado para armazenar strings de caracteres de comprimento variável sem limite específico de tamanho.

```sql
column_name TEXT
```

- **Tipo de Dados `INTEGER`**: Este tipo de dado é usado para armazenar números inteiros sem casas decimais.

```sql
units_sold INTEGER
```

- **Tipos de Dados `SMALLINT` e `BIGINT`**: Estes são variantes de INTEGER com intervalos menores e maiores respectivamente.

- **Tipo de Dados `SERIAL`**: Este tipo de dado é usado para criar colunas inteiras com auto-incremento no PostgreSQL.

```sql
id SERIAL
```

- **Atributo `AUTO_INCREMENT`**: Este atributo é usado no MySQL para criar colunas inteiras com incremento automático.

```sql
id INT AUTO_INCREMENT
```

- **Tipo de Dados `VARCHAR`**: Este tipo de dado é usado para armazenar strings de caracteres de comprimento variável com um comprimento máximo especificado.

```sql
name VARCHAR(50)
```

- **Tipo de Dados `DATE`**: Este tipo de dado é usado para armazenar valores de data (ano, mês, dia).

```sql
event_date DATE
```

- **Tipo de Dados `TIME`**: Este tipo de dado é usado para armazenar valores de tempo (hora, minuto, segundo).

```sql
start_time TIME
```

- **Tipo de Dados `TIMESTAMP`**: Este tipo de dado é usado para armazenar valores de data e hora, opcionalmente com informações de fuso horário.

```sql
event_timestamp TIMESTAMP
event_timestamp TIMESTAMP WITH TIME ZONE
```

- **Tipo de Dados `BOOLEAN`**: Este tipo de dado é usado para armazenar valores verdadeiro/falso.

```sql
is_active BOOLEAN
```

## Relacionamentos de Banco de Dados

- **Tipos de Relacionamentos**: Estas são as diferentes formas como as tabelas podem estar relacionadas entre si em um banco de dados relacional.
  - Um-para-um
  - Um-para-muitos
  - Muitos-para-um
  - Muitos-para-muitos
  - Auto-referência (recursiva)

- **Relacionamento Um-para-Um**: Este tipo de relacionamento significa que cada registro em uma tabela corresponde exatamente a um registro em outra tabela.

```md
One employee is assigned exactly one vehicle.
Tables: employees, vehicles
```

- **Relacionamento Um-para-Muitos**: Este tipo de relacionamento significa que um registro em uma tabela pode estar associado a múltiplos registros em outra tabela.

```md
One customer can have many orders.
Tables: customers → orders
```

- **Relacionamento Muitos-para-Muitos via Tabela de Junção**: Este tipo de relacionamento é implementado usando uma tabela de junção que contém chaves estrangeiras de ambas as tabelas relacionadas.

```sql
CREATE TABLE books_authors (
    author_id INT REFERENCES authors(id),
    book_id INT REFERENCES books(id)
);
```

- **Relacionamentos Auto-Referenciados**: Este tipo de relacionamento ocorre quando uma tabela referencia a si mesma, criando uma estrutura hierárquica.

```md
An employee table where each employee may report to another employee.
```

## SQL Avançado (Joins)

- **Declaração `INNER JOIN`**: Esta junção retorna apenas as linhas que possuem valores correspondentes em ambas as tabelas.

```sql
SELECT *
FROM products
INNER JOIN sales ON products.product_id = sales.product_id;
```

- **Declaração `FULL OUTER JOIN`**: Esta junção retorna todas as linhas de ambas as tabelas, incluindo linhas não correspondentes de qualquer tabela.

```sql
SELECT *
FROM products
FULL OUTER JOIN sales ON products.product_id = sales.product_id;
```

- **Declaração `LEFT OUTER JOIN`**: Esta junção retorna todas as linhas da tabela à esquerda e as linhas correspondentes da tabela à direita.

```sql
SELECT *
FROM products
LEFT JOIN sales ON products.product_id = sales.product_id;
```

- **Declaração `RIGHT OUTER JOIN`**: Esta junção retorna todas as linhas da tabela direita e as linhas correspondentes da tabela esquerda.

```sql
SELECT *
FROM products
RIGHT JOIN sales ON products.product_id = sales.product_id;
```

- **Declaração `SELF JOIN`**: Esta junção é usada para unir uma tabela a ela mesma para comparar linhas dentro da mesma tabela.

```sql
SELECT A.column_name, B.column_name
FROM table_name A
JOIN table_name B ON A.related_column = B.related_column;
```

- **Declaração `CROSS JOIN`**: Esta junção retorna o produto cartesiano de duas tabelas, combinando cada linha da primeira tabela com cada linha da segunda tabela.

```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

## Comandos Específicos do PostgreSQL

- **Comando de Login `psql`**: Este comando é usado para fazer login no PostgreSQL com um nome de usuário e banco de dados específicos.

```bash
psql --username=freecodecamp --dbname=postgres
```

- **Comando `\l`**: Este comando lista todos os bancos de dados na instância do PostgreSQL.

```sql
\l
```

- **Comandos `CREATE DATABASE` e `\c`**: Esses comandos são usados para criar um novo banco de dados e conectar-se a ele.

```sql
CREATE DATABASE database_name;
\c database_name
```

- **Comando `\d`**: Este comando lista todas as tabelas no banco de dados atual.

```sql
\d
```

- **Comando `\d table_name`**: Este comando exibe o esquema/estrutura de uma tabela específica.

```sql
\d table_name
```

- **Comando `\q`**: Este comando sai do cliente PostgreSQL.

```bash
\q
```

## Relacional vs Não Relacional

- **Bancos de Dados Não Relacionais (NoSQL)**: Armazenam dados não estruturados ou semi-estruturados. Não exigem um esquema rígido e são mais flexíveis para modelos de dados em evolução.
- **Escolhendo Entre Relacional e Não Relacional**: Depende da natureza dos seus dados e dos requisitos da aplicação.
- **Relacional vs Não Relacional**: Escolha relacional para dados estruturados e consistência; NoSQL para flexibilidade e dados que mudam rapidamente.

## Sistemas RDBMS Populares

- **MySQL**: Código aberto, confiável, amplamente usado em desenvolvimento web e suportado por uma grande comunidade.
- **PostgreSQL**: Código aberto, avançado, extensível. Suporta tipos de dados personalizados e programação do lado do servidor.
- **SQLite**: Leve, baseado em arquivo, sem servidor. Ideal para aplicações pequenas.
- **Microsoft SQL Server**: Banco de dados proprietário, de nível empresarial.
- **Oracle Database**: RDBMS comercial conhecido por desempenho e escalabilidade em grande escala.

## Melhores Práticas

- **Convenção de Nomenclatura**: Use `snake_case` (por exemplo, `delivery_orders`) para nomes de tabelas e colunas.

## Noções Básicas de Bash Scripting

- **Script Bash**: Escrever uma sequência de comandos Bash em um arquivo, que você pode então executar com Bash para rodar o conteúdo do arquivo.
- **Shebang**: A linha comentada no início de um script (por exemplo, `#!/bin/bash`) que indica qual interpretador deve ser usado para o script.

  ```bash
  #!/bin/bash
  ```

- **Atribuição de variável**: Instancie variáveis usando a sintaxe `variable_name=value`.

  ```bash
  servers=("prod" "dev")
  ```

- **Regras para criação de variáveis**: Crie variáveis com a sintaxe `VARIABLE_NAME=VALUE`. Não são permitidos espaços ao redor do sinal de igual (`=`). Use aspas duplas se o valor contiver espaços.

  ```bash
  NAME=John
  MESSAGE="Hello World"
  COUNT=5
  TEXT="The next number is, "
  ```

- **Uso de variáveis**: Acesse os valores das variáveis colocando `$` na frente do nome da variável.

  ```bash
  echo $NAME
  echo "The message is: $MESSAGE"
  ```

- **Interpolação de variável**: Use `$variable_name` para acessar o valor de uma variável dentro de strings e comandos.

  ```bash
  TEXT="The next number is, "
  NUMBER=42
  echo $TEXT B:$NUMBER
  echo $TEXT I:$NUMBER
  
  echo "Pulling $server"
  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf
  ```

- **Escopo de variável**: Scripts shell são executados de cima para baixo, então variáveis só podem ser usadas abaixo de onde são criadas.

  ```bash
  NAME="Alice"
  echo $NAME
  ```

- **Entrada do usuário**: Use `read` para aceitar entrada dos usuários e armazená-la em uma variável.

  ```bash
  read USERNAME
  echo "Hello $USERNAME"
  ```

- **Comentários**: Adicione comentários aos seus scripts usando `#` seguido do texto do seu comentário.
  - Comentários de linha única começam com `#` e continuam até o final da linha
  - Comentários são ignorados pelo shell e não afetam a execução do script

  ```bash
  # This is a single-line comment
  NAME="John"  # Comment at end of line
  ```

- **Comentários multilinha**: Comente blocos de código usando dois pontos e aspas.

  ```bash
  : '
  This is a multi-line comment
  Everything between the quotes is ignored
  Useful for debugging or documentation
  '
  ```

- **Comandos embutidos e ajuda**: 
  - Use `help` para ver uma lista de comandos bash embutidos
  - Use `help <command>` para obter informações sobre comandos internos específicos
  - Alguns comandos (como `if`) são internos e não possuem páginas de manual
  - Comandos embutidos são executados diretamente pelo shell em vez de como programas externos
  - Use a `help function` para ver informações sobre como criar funções

  ```bash
  help
  help if
  help function
  ```

- **Encontrando localizações de comandos**: Use `which` para localizar onde os executáveis estão instalados.
  - Mostra o caminho completo para arquivos executáveis
  - Útil para encontrar localizações de interpretadores (como bash)
  - Ajuda a verificar qual versão de um comando será executada

  ```bash
  which bash
  which python
  which ls
  ```

- **Páginas de manual**: Use `man` para acessar documentação detalhada de comandos.
  - Fornece informações abrangentes sobre o uso de comandos
  - Mostra todas as opções e exemplos disponíveis
  - Use as teclas de seta para navegar e 'q' para sair
  - Nem todos os comandos têm páginas de manual (built-ins usam `help` em vez disso)

  ```bash
  man echo
  man ls
  man bash
  ```

- **Flags de ajuda**: Muitos comandos suportam `--help` para informações rápidas de ajuda.
  - Alternativa às páginas manuais para referência rápida
  - Mostra a sintaxe do comando e as opções comuns
  - Nem todos os comandos suportam esta flag (alguns podem mostrar erro)

  ```bash
  ls --help
  chmod --help
  mv --help
  ```

- **Opções do comando Echo**: O comando `echo` suporta várias opções:
  - A opção `-e` habilita a interpretação de escapes com barra invertida
  - `\n` cria uma nova linha
  - Linhas vazias são impressas apenas quando os valores estão entre aspas
  - Útil para criar saída formatada e títulos de programas

  ```bash
  echo -e "Line 1\nLine 2"
  echo ""
  echo -e "\n~~ Program Title ~~\n"
  echo "Line 1\nLine 2"
  ```

- **Argumentos do script**: Programas podem aceitar argumentos que são acessíveis usando variáveis `$`.
  - `$*` imprime todos os argumentos passados para o script
  - `$@` imprime todos os argumentos passados para o script como strings separadas entre aspas
  - `$<number>` acessa argumentos específicos pela posição (por exemplo, `$1`, `$2` e `$3`)

  ```bash
  echo $*
  echo $@
  echo $1
  echo $2
  ```

## Expressões de Dupla Colchete `[[ ]]`

- **Sintaxe de colchetes duplos**: Use `[[ ]]` para testes condicionais e correspondência de padrões.
  - Deve haver espaços dentro dos colchetes e ao redor dos operadores
  - Retorna o status de saída 0 (true) ou 1 (false) com base no resultado do teste

  ```bash
  [[ $variable == "value" ]]
  [[ $number -gt 10 ]]
  [[ -f filename.txt ]]
  ```

- **Operadores de comparação de strings**: Compare strings usando vários operadores dentro de `[[ ]]`.
  - `==` (equal): Testa se duas strings são idênticas
  - `!=` (diferente): Testa se duas strings são diferentes
  - `<` (lexicograficamente menor): Comparação de strings em ordem alfabética
  - `>` (lexicograficamente maior): Comparação de strings em ordem alfabética

  ```bash
  [[ "apple" == "apple" ]]
  [[ "apple" != "orange" ]]
  [[ "apple" < "banana" ]]
  [[ "zebra" > "apple" ]]
  ```

- **Operadores de comparação numérica**: Compare números usando operadores numéricos específicos.
  - `-eq` (equal): Comparação de igualdade numérica
  - `-ne` (not equal): Comparação de desigualdade numérica
  - `-lt` (less than): Comparação numérica menor que
  - `-le` (menor ou igual): comparação numérica menor ou igual
  - `-gt` (greater than): Comparação numérica maior que
  - `-ge` (greater than or equal): Comparação numérica maior ou igual

  ```bash
  [[ $number -eq 5 ]]
  [[ $count -ne 0 ]]
  [[ $age -ge 18 ]]
  [[ $score -lt 100 ]]
  ```

- **Operadores lógicos**: Combine múltiplas condições usando operadores lógicos.
  - `&&` (e): Ambas as condições devem ser verdadeiras
  - `||` (ou): Pelo menos uma condição deve ser verdadeira
  - `!` (not): Nega a condição (torna true em false, false em true)

  ```bash
  [[ $age -ge 18 && $age -le 65 ]]
  [[ $name == "John" || $name == "Jane" ]]
  [[ ! -f missing_file.txt ]]
  ```

- **Operadores de teste de arquivo**: Teste propriedades e existência de arquivo.
  - `-e file`: Verdadeiro se o arquivo existir
  - `-f file`: Verdadeiro se o arquivo existir e for um arquivo regular
  - `-d file`: Verdadeiro se o arquivo existir e for um diretório
  - `-r file`: Verdadeiro se o arquivo existir e for legível
  - `-w file`: Verdadeiro se o arquivo existir e for gravável
  - `-x file`: Verdadeiro se o arquivo existir e for executável
  - `-s file`: Verdadeiro se o arquivo existir e tiver tamanho maior que zero

  ```bash
  [[ -e /path/to/file ]]
  [[ -f script.sh ]]
  [[ -d /home/user ]]
  [[ -x program ]]
  ```

- **Correspondência de padrão com `=~`**: Use expressões regulares para correspondência avançada de padrões.
  - O operador `=~` permite correspondência de padrão regex
  - O padrão não deve ser colocado entre aspas ao usar metacaracteres de regex
  - Suporta a sintaxe completa de expressões regulares
  - Sensível a maiúsculas e minúsculas por padrão

  ```bash
  [[ "hello123" =~ [0-9]+ ]]
  [[ "email@domain.com" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
  [[ "filename.txt" =~ \.txt$ ]]
  ```

- **Teste de existência de variável**: Verifique se as variáveis estão definidas ou vazias.
  - Teste se a variável está vazia: `[[ ! $variable ]]`

  ```bash
  [[ ! $undefined_var ]]
  ```

## Expressões de Parênteses Duplos `(( ))`

- **Avaliação aritmética**: Use `(( ))` para cálculos matemáticos e comparações numéricas.
  - Avalia expressões aritméticas usando sintaxe estilo C
  - Variáveis não precisam do prefixo `$` dentro de parênteses duplos
  - Retorna o status de saída 0 se o resultado for diferente de zero, 1 se o resultado for zero
  - Suporta todos os operadores aritméticos padrão

  ```bash
  (( result = 10 + 5 ))
  (( count++ ))
  (( total += value ))
  ```

- **Operadores aritméticos**: Operadores matemáticos disponíveis em `(( ))`.
  - `+` (adição): Soma dois números
  - `-` (subtração): Subtrai o segundo número do primeiro
  - `*` (multiplicação): Multiplica dois números
  - `/` (divisão): Divide o primeiro número pelo segundo (divisão inteira)
  - `%` (modulus): Resto após a divisão
  - `**` (exponenciação): Elevar o primeiro número à potência do segundo

  ```bash
  (( sum = a + b ))
  (( diff = x - y ))
  (( product = width * height ))
  (( remainder = num % 10 ))
  (( power = base ** exponent ))
  ```

- **Operadores de atribuição**: Modifique variáveis usando operadores de atribuição aritmética.
  - `=` (atribuição): Atribuir valor à variável
  - `+=` (adicionar e atribuir): Adiciona valor à variável
  - `-=` (subtrair e atribuir): Subtrai valor da variável
  - `*=` (multiplicar e atribuir): Multiplica a variável pelo valor
  - `/=` (divide e atribui): Divide a variável pelo valor
  - `%=` (módulo e atribuição): Define a variável como o resto

  ```bash
  (( counter = 0 ))
  (( counter += 5 ))
  (( total -= cost ))
  (( area *= 2 ))
  (( value /= 3 ))
  ```

- **Operadores de incremento e decremento**: Modificam variáveis em uma unidade.
  - `++variable` (pré-incremento): Incrementa antes do uso
  - `variable++` (pós-incremento): Incrementa após o uso
  - `--variable` (pré-decremento): Decrementa antes do uso
  - `variable--` (pós-decremento): Decrementa após o uso

  ```bash
  (( ++counter ))
  (( index++ ))
  (( --remaining ))
  (( attempts-- ))
  ```

- **Operadores de comparação**: Compare números usando comparação aritmética.
  - `==` (equal): Números são iguais
  - `!=` (not equal): Números não são iguais
  - `<` (menor que): O primeiro número é menor que o segundo
  - `<=` (menor ou igual): O primeiro número é menor ou igual ao segundo
  - `>` (maior que): O primeiro número é maior que o segundo
  - `>=` (maior ou igual): O primeiro número é maior ou igual ao segundo

  ```bash
  (( age >= 18 ))
  (( score < 100 ))
  (( count == 0 ))
  (( temperature > freezing ))
  ```

- **Operadores lógicos**: Combine condições aritméticas.
  - `&&` (e): Ambas as condições devem ser verdadeiras
  - `||` (ou): Pelo menos uma condição deve ser verdadeira
  - `!` (not): Nega a condição

  ```bash
  (( age >= 18 && age <= 65 ))
  (( score >= 90 || extra_credit > 0 ))
  (( !(count == 0) ))
  ```

- **Operadores bit a bit**: Executam operações em nível de bit em inteiros.
  - `&` (bitwise AND): operação AND em cada bit
  - `|` (bitwise OR): operação OR em cada bit
  - `^` (bitwise XOR): operação XOR em cada bit
  - `~` (bitwise NOT): Inverte todos os bits
  - `<<` (left shift): Desloca os bits para a esquerda
  - `>>` (right shift): Desloca bits para a direita

  ```bash
  (( result = a & b ))
  (( flags |= new_flag ))
  (( shifted = value << 2 ))
  ```

- **Operador condicional (ternário)**: Use a sintaxe `condition ? true_value : false_value`.
  - Fornece uma maneira concisa de atribuir valores com base em condições
  - Semelhante ao operador ternário em linguagens do estilo C
  - Avalia a condição e retorna um dos dois valores

  ```bash
  (( result = (score >= 60) ? 1 : 0 ))
  (( max = (a > b) ? a : b ))
  (( sign = (num >= 0) ? 1 : -1 ))
  ```

- **Substituição de comando com aritmética**: Use `$(( ))` para capturar resultados aritméticos.
  - Retorna o resultado da expressão aritmética como uma string
  - Pode ser usado em atribuições ou argumentos de comando
  - Útil para cálculos que precisam ser usados em outro lugar

  ```bash
  result=$(( 10 + 5 ))
  echo "The answer is $(( a * b ))"
  array_index=$(( RANDOM % array_length ))
  ```

## Fluxo de Controle e Condicionais

- **Instruções condicionais**: Use `if` statements para executar código com base em condições.
  - Sintaxe básica: `if [[ CONDITION ]] then STATEMENTS fi`
  - Sintaxe completa: `if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`
  - Pode usar tanto expressões `[[ ]]` e `(( ))` para diferentes tipos de condições
  - **elif (else if)**: Opcional, pode ser repetido várias vezes para testar condições adicionais em sequência
  - **else**: Opcional, executa quando todas as condições anteriores são falsas
  - Pode misturar parênteses duplos `(( ... ))` e colchetes duplos `[[ ... ]]` na mesma cadeia condicional

  ```bash
  if (( NUMBER <= 15 ))
  then
      echo "B:$NUMBER"
  elif [[ $NUMBER -le 30 ]]
  then
      echo "I:$NUMBER"
  elif (( NUMBER < 46 ))
  then
      echo "N:$NUMBER"
  elif [[ $NUMBER -lt 61 ]]
  then
      echo "G:$NUMBER"
  else
      echo "O:$NUMBER"
  fi
  ```

## Execução de Comandos e Controle de Processos

- **Separação de comandos**: Use ponto e vírgula (`;`) para executar múltiplos comandos em uma única linha.
  - Os comandos são executados sequencialmente da esquerda para a direita
  - O status de saída de cada comando pode ser verificado individualmente

  ```bash
  [[ 4 -ge 5 ]]; echo $?
  ls -l; echo "Done"
  ```

- **Status de saída**: Todo comando tem um status de saída que indica sucesso ou falha.
  - Acesse o status de saída do último comando com `$?`
  - O status de saída `0` significa sucesso (verdadeiro/sem erros)
  - Qualquer status de saída diferente de zero significa falha (ocorreram erros/falso)
  - Códigos de erro comuns: `127` (comando não encontrado) e `1` (erro geral)

  ```bash
  echo $?
  [[ 4 -le 5 ]]; echo $?
  ls; echo $?
  bad_command; echo $?
  ```

- **Subshells e substituição de comando**: Usos diferentes de parênteses para contextos de execução.
  - Parênteses simples `( ... )` criam uma subshell
  - `$( ... )` realiza substituição de comando
  - Subshells são executados em ambientes separados e não afetam as variáveis do shell pai

  ```bash
  ( cd /tmp; echo "Current dir: $(pwd)" )
  current_date=$(date)
  file_count=$(ls | wc -l)
  echo "Today is $current_date"
  echo "Found $file_count files"
  ```

- **Comando Sleep**: Pausa a execução do script por um número especificado de segundos.
  - Útil para criar atrasos em scripts
  - Pode ser usado com valores decimais para atrasos de subsegundos

  ```bash
  sleep 3
  sleep 0.5
  sleep 1
  ```

## Laços

- **Laços while**: Execute o código repetidamente enquanto uma condição for verdadeira.
  - Sintaxe: `while [[ CONDITION ]] do STATEMENTS done`

  ```bash
  I=5
  while [[ $I -ge 0 ]]
  do
      echo $I
      (( I-- ))
      sleep 1
  done
  ```

- **Laços Until**: Execute o código repetidamente até que uma condição se torne verdadeira.
  - Sintaxe: `until [[ CONDITION ]] do STATEMENTS done`

  ```bash
  until [[ $QUESTION =~ \?$ ]]
  do
      echo "Please enter a question ending with ?"
      read QUESTION
  done
  until [[ $QUESTION =~ \?$ ]]
  do
      GET_FORTUNE again
  done
  ```

- **Laços for**: Itere por arrays ou listas usando laços `for` com `do` e `done` para definir o bloco lógico do laço.

  ```bash
  for server in "${servers[@]}"
  do
      echo "Processing $server"
  done
  for (( i = 1; i <= 5; i++ ))
  do
      echo "Number: $i"
  done
  for (( i = 5; i >= 1; i-- ))
  do
      echo "Countdown: $i"
  done
  for i in {1..5}
  do
      echo "Count: $i"
  done
  ```

## Arrays

- **Arrays**: Armazenam múltiplos valores em uma única variável.
  - Crie arrays com parênteses: `ARRAY=("value1" "value2" "value3")`
  - Acesse elementos pelo índice: `${ARRAY[0]}`, `${ARRAY[1]}`
  - Acesse todos os elementos: `${ARRAY[@]}` ou `${ARRAY[*]}`
  - O índice de arrays começa em 0

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Ask again later")

  echo ${RESPONSES[0]}     # Yes          
  echo ${RESPONSES[1]}     # No         
  echo ${RESPONSES[5]}     # Index 5 doesn't exist; empty string              
  echo ${RESPONSES[@]}     # Yes No Maybe Ask again later   
  echo ${RESPONSES[*]}     # Yes No Maybe Ask again later 
  ```

- **Inspeção de array com declare**: Use `declare -p` para visualizar detalhes do array.
  - Mostra o tipo do array com a flag `-a`
  - Exibe todos os elementos do array e sua estrutura

  ```bash
  ARR=("a" "b" "c")
  declare -p ARR # ARR=([0]="a" [1]="b" [2]="c")
  ```

- **Expansão de array**: Use a sintaxe `"${array_name[@]}"` para expandir um array em elementos individuais.

```bash
for server in "${servers[@]}"
```

## Funções

- **Funções**: Crie blocos reutilizáveis de código.
  - Defina com `FUNCTION_NAME() { STATEMENTS }`
  - Chame usando o nome da função
  - Pode aceitar argumentos acessíveis como `$1`, `$2`, etc.

  ```bash
  GET_FORTUNE() {
      echo "Ask a question:"
      read QUESTION
  }
  GET_FORTUNE
  ```

- **Argumentos de função**: Funções podem aceitar argumentos assim como scripts.
  - Os argumentos são passados ao chamar a função
  - Acesse os argumentos dentro da função usando `$1`, `$2`, etc.
  - Use lógica condicional para lidar com diferentes argumentos

  ```bash
  GET_FORTUNE() {
      if [[ ! $1 ]]
      then
          echo "Ask a yes or no question:"
      else
          echo "Try again. Make sure it ends with a question mark:"
      fi
      read QUESTION
  }
  GET_FORTUNE
  GET_FORTUNE again
  ```

## Números Aleatórios e Operações Matemáticas

- **Números aleatórios**: Gere valores aleatórios usando a variável `$RANDOM`.
  - `$RANDOM` gera números entre 0 e 32767
  - Use o operador módulo para limitar o intervalo: `$RANDOM % 75`
  - Adicione 1 para evitar zero: `$(( RANDOM % 75 + 1 ))`
  - Deve usar a sintaxe `$(( ... ))` para cálculos com `$RANDOM`

  ```bash
  NUMBER=$(( RANDOM % 6 ))
  DICE=$(( RANDOM % 6 + 1 ))
  BINGO=$(( RANDOM % 75 + 1 ))
  echo $(( RANDOM % 10 ))
  ```

- **Acesso aleatório a arrays**: Use números aleatórios para acessar elementos do array de forma aleatória.
  - Gerar índice aleatório dentro dos limites do array
  - Use índice aleatório para acessar elementos do array
  - Útil para seleções aleatórias a partir de opções predefinidas

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Outlook good" "Don't count on it" "Ask again later")
  N=$(( RANDOM % 6 ))
  echo ${RESPONSES[$N]}
  ```

- **Operador módulo**: Use `%` para obter o resto das operações de divisão.
  - Essencial para limitar os intervalos de números aleatórios
  - Funciona com `$RANDOM` para criar valores aleatórios limitados
  - `RANDOM % n` gera números de 0 a n-1

  ```bash
  echo $(( 15 % 4 ))
  echo $(( RANDOM % 100 ))
  echo $(( RANDOM % 10 + 1 ))
  ```

## Ambiente e Informações do Sistema

- **Variáveis de ambiente**: Variáveis predefinidas disponíveis no ambiente do shell.
  - `$RANDOM`: Gera números aleatórios entre 0 e 32767
  - `$LANG`: Configuração do idioma do sistema
  - `$HOME`: caminho do diretório home do usuário
  - `$PATH`: Diretórios pesquisados para comandos executáveis
  - Veja todos com `printenv` ou `declare -p`

  ```bash
  echo $RANDOM
  echo $HOME
  echo $LANG
  printenv
  ```

- **Inspeção de variáveis**: Use `declare` para visualizar e trabalhar com variáveis.
  - `declare -p`: Imprime todas as variáveis e seus valores
  - `declare -p VARIABLE`: Exibe detalhes específicos da variável
  - Mostra o tipo da variável (string, array, etc.) e os atributos

  ```bash
  declare -p
  declare -p RANDOM
  declare -p MY_ARRAY
  ```

- **Tipos de comando**: Diferentes categorias de comandos disponíveis no bash.
  - **Comandos embutidos**: Executados diretamente pelo shell (por exemplo, `echo`, `read` e `if`)
  - **Comandos externos**: Arquivos binários em diretórios do sistema (por exemplo, `ls`, `sleep` e `bash`)
  - **Palavras-chave do Shell**: Construções da linguagem (por exemplo, `then`, `do`, `done`)
  - Use `type <command>` para ver qual é o tipo de um comando

  ```bash
  type echo
  type ls
  type if
  type ./script.sh
  ```

## Criação e Gerenciamento de Arquivos

- **Criação de arquivo**: Use `touch` para criar novos arquivos vazios.
  - Cria um novo arquivo se ele não existir
  - Atualiza o carimbo de data/hora se o arquivo já existir
  - Comumente usado para criar arquivos de script antes da edição

  ```bash
  touch script.sh
  touch bingo.sh
  touch filename.txt
  ```

## Criando e Executando Scripts Bash

- **Métodos de execução de script**: Múltiplas formas de executar scripts bash:
  - **`sh scriptname.sh`**: Execute com o interpretador de shell sh.
  - **`bash scriptname.sh`**: Execute com o interpretador de shell bash.
  - **`./scriptname.sh`**: Execute diretamente (requer permissões de execução).

```bash
sh questionnaire.sh
bash questionnaire.sh
./questionnaire.sh
```

## Permissões de Arquivo e Execução de Script

- **Erro de permissão negada**: Ao usar `./scriptname.sh`, você pode receber "permission denied" se o arquivo não tiver permissões de execução.
- **Verificando permissões**: Use `ls -l` para visualizar as permissões do arquivo.

  ```bash
  ls -l questionnaire.sh
  ```

- **Formato de permissão**: A saída mostra as permissões como `-rw-r--r--` onde:
  - Primeiro caractere (`-`): Tipo de arquivo (- para arquivo regular, d para diretório)
  - Próximos 9 caracteres: Permissões para proprietário, grupo e outros
  - `r` = read, `w` = write, `x` = execute
  
- **Adicionando permissões de execução**: Use `chmod +x` para dar permissões de execução a todos.

  ```bash
  chmod +x questionnaire.sh
  ```

- **Organização de script**: Melhores práticas para estruturar scripts bash.
  - Comece com shebang (`#!/bin/bash`)
  - Adicione comentários descritivos sobre o propósito do script
  - Defina variáveis no topo
  - Agrupe funções relacionadas juntas
  - Lógica principal do script na parte inferior

  ```bash
  #!/bin/bash
  NAME="value"
  ARRAY=("item1" "item2")
  my_function() {
      echo "Function code here"
  }
  my_function
  echo "Script complete"
  ```

- **Execução sequencial de scripts**: Crie scripts mestre que executem múltiplos programas em sequência.
  - Útil para automatizar fluxos de trabalho que envolvem múltiplos scripts
  - Cada script é executado até a conclusão antes que o próximo comece
  - Pode combinar diferentes programas em um único fluxo de execução
  - Argumentos podem ser passados para scripts individuais conforme necessário
  - Pode incluir diferentes tipos de programas (interativos, automatizados, etc.)

  ```bash
  #!/bin/bash
  ./setup.sh
  ./interactive.sh
  ./processing.sh
  ./cleanup.sh
  ```

## Normalização de Banco de Dados

Este é o processo de organizar um banco de dados relacional para reduzir a redundância de dados e melhorar a integridade.

Seus benefícios incluem:

- Minimizar dados duplicados, o que economiza armazenamento e reduz inconsistências.
- Garantindo a integridade dos dados por meio do uso de chaves primárias e estrangeiras.
- Tornando bancos de dados mais fáceis de manter e entender.

### Formas Normais

- **1NF (Primeira Forma Normal)**
  - Cada célula contém um único valor (atômico).
  - Cada registro é único (garantido por uma chave primária).
  - A ordem das linhas/colunas é irrelevante.
  - Exemplo: Mova vários números de telefone da tabela `students` para uma tabela separada `student_phones`.

- **2NF (Segunda Forma Normal)**
  - Atende aos requisitos da 1NF.
  - Sem **partial dependencies**: todo atributo não-chave deve depender da chave primária composta inteira.
  - Exemplo: Divida a tabela `orders` em `order_header` e `order_items` para evitar atributos que dependam de apenas parte da chave.

- **3NF (Terceira Forma Normal)**
  - Atende aos requisitos da 2NF.
  - Sem **dependências transitivas**: atributos não-chave não podem depender de outros atributos não-chave.
  - Exemplo: Mova `city_postal_code` para uma tabela `cities` em vez de armazená-lo com cada pedido.

- **BCNF (Boyce-Codd Normal Form)**
  - Atende aos requisitos da 3NF.
  - Todo determinante (lado esquerdo de uma dependência funcional) deve ser uma superchave.

**Dica**: Busque a 3NF na maioria dos designs para um bom equilíbrio entre integridade e desempenho.

## Conceitos-chave de SQL

- SQL é uma Linguagem de Consulta Estruturada para comunicação com bancos de dados relacionais.
- **Comandos básicos** → `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`, `ALTER TABLE`, etc.
- `Joins` → Combina dados de múltiplas tabelas (`INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`).

## Executando Comandos SQL no Bash

Você pode executar comandos SQL diretamente da linha de comando usando o cliente de linha de comando `psql` para PostgreSQL ou ferramentas similares para outros bancos de dados.

Por exemplo, para executar um arquivo SQL no PostgreSQL:

```bash
psql -U username -d database_name -c "SELECT * FROM students;"
```

Você também pode executar comandos MySQL diretamente:

```bash
mysql -u username -p database_name -e "SELECT * FROM students;"
```

### Executar SQL a partir de um Arquivo

```bash
# PostgreSQL
psql -U username -d database_name -f script.sql

# MySQL
mysql -u username -p database_name < script.sql
```

### Incorporar SQL em um Script Bash

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Insert student data
psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'CS');"
```

### Uso de Variáveis em SQL

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"
STUDENT_NAME="Bob"
AGE=21

psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age) VALUES ('$STUDENT_NAME', $AGE);"
```

**Dica**: Sanitizar variáveis para evitar SQL injection.

## Recuperando e Usando Resultados de Consultas SQL no Bash

Quando você executa consultas SQL via `psql`, você pode **capturar** e **processar** os valores retornados em seus scripts Bash.

### Capturando um Valor Único

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get total student count
STUDENT_COUNT=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -c \
"SELECT COUNT(*) FROM students;")

echo "Total students: $STUDENT_COUNT"
```

Saída → 42

### Recuperando Múltiplas Colunas

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get top 3 students' names and ages
RESULTS=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, age FROM students LIMIT 3;")

echo "Top 3 students:"
echo "$RESULTS"
```

Saída

```bash
Alice,20
Bob,21
Charlie,22
```

### Iterando pelos Resultados da Consulta

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get student names and majors
psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, major FROM students;" | while IFS="," read -r name major
do
    echo "Student: $name | Major: $major"
done
```

Formato da Saída

```bash
Student: Alice | Major: CS
Student: Bob   | Major: Math
Student: Carol | Major: Physics
```

## Injeção de SQL

É uma vulnerabilidade de segurança web onde atacantes inserem código SQL malicioso em campos de entrada para manipular o banco de dados.

Isso pode levar a ações arriscadas como:

- Ignorando a autenticação.
- Roubando dados sensíveis.
- Modificando ou excluindo registros.

Um exemplo de ataque de injeção SQL:

```sql
SELECT * FROM users WHERE username = ' " " OR "1"="1" -- ' AND password = 'anything';
```

Esta consulta retornaria todos os usuários porque a condição `OR "1"="1"` é sempre verdadeira, permitindo que atacantes contornem as verificações de login.

### Prevenção de SQL Injection

1. **Use Prepared Statements**: Eles separam o código SQL dos dados, prevenindo injeções. Aqui está um exemplo (Node.js com pg):

    ```sql
    client.query('SELECT * FROM users WHERE username = $1 AND password = $2', [username, password]);
    ```

2. **Validação de Entrada**: Sanitizar e validar todas as entradas do usuário para garantir que elas estejam em conformidade com os formatos esperados.

3. **Privilégio Mínimo**: Use contas de banco de dados com as permissões mínimas necessárias para a aplicação.

**Nota**: Nunca conceda direitos de administrador a contas de aplicação.

## Problema N+1

O problema N+1 ocorre quando uma aplicação faz uma consulta para recuperar uma lista de itens (N) e depois faz uma consulta adicional para cada item para recuperar dados relacionados, resultando em N+1 consultas.

**Por que é ruim**

- Cada consulta adiciona sobrecarga de rede e processamento.
- Múltiplas pequenas consultas são mais lentas do que uma consulta otimizada.

### Exemplo do Padrão N+1

```sql
-- 1: Get list of orders
SELECT * FROM orders LIMIT 50;

-- N: For each order, get customer
SELECT * FROM customers WHERE customer_id = ...;
```

**Solução**: Use `JOINs` ou outras operações baseadas em conjuntos.

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name,
  customers.email,
  customers.address
FROM orders
JOIN customers 
  ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50);
```

Sempre procure oportunidades para combinar dados relacionados em uma única consulta.

## Introdução ao Controle de Versão

- **Definição**: Um sistema de controle de versão permite que você acompanhe e gerencie mudanças no seu projeto. Exemplos de sistemas de controle de versão usados em software são Git, SVN e Mercurial.

## Provedores de Controle de Versão Baseados na Nuvem

- **Lista de Provedores de Controle de Versão Baseados na Nuvem**: GitHub e GitLab são exemplos populares de provedores de controle de versão baseados na nuvem que permitem que equipes de software colaborem e gerenciem repositórios. 

## Instalando e Configurando o Git

- **Instalando Git**: Para verificar se o Git já está instalado na sua máquina você pode executar o seguinte comando no terminal:

```sh
git --version
```

Se você vir um número de versão, isso significa que o Git está instalado. Se não, então você precisará instalá-lo.

Para sistemas Linux, o Git geralmente já vem pré-instalado na maioria das distribuições. Se você não tiver o Git pré-instalado, deverá conseguir instalá-lo com os comandos do seu gerenciador de pacotes, como `sudo apt-get install git` ou `sudo pacman -S git`.

Para usuários de Mac, você pode instalar o Git via Homebrew com `brew install git` ou pode baixar o instalador executável do site do Git.

Para Windows, você pode baixar o instalador executável no site do Git. Ou, se você configurou o Chocolatey, pode executar `choco install git.install` no PowerShell. Note que no Windows, você também pode querer baixar o Git Bash para ter um ambiente de shell semelhante ao Unix disponível.

Para garantir que a instalação funcionou, execute o comando `git --version` novamente no terminal.

- **Configurações do Git**: `git config` é usado para definir variáveis de configuração que são responsáveis por como o Git opera na sua máquina. Para visualizar suas variáveis de configuração atuais e onde elas estão armazenadas no seu sistema, você pode executar o seguinte comando:

```sh
git config --list --show-origin
```

Neste momento você deve estar vendo apenas as configurações de nível de sistema se você acabou de instalar o Git pela primeira vez. 

Para definir seu nome de usuário, você pode executar o seguinte comando:

```sh
git config --global user.name "Jane Doe"
```

A flag `--global` é usada aqui para definir o nome do usuário para todos os projetos no seu sistema que usam Git. Se você precisar substituir o nome do usuário para um projeto específico, então você pode executar o comando nesse diretório de projeto específico sem a flag `--global`.

Para definir o endereço de e-mail do usuário, você pode executar o seguinte comando:

```sh
git config --global user.email janedoe@example.com
```

Outra configuração que você pode definir é o editor preferido que você quer que o Git use. Aqui está um exemplo de como definir seu editor preferido para Emacs:

```sh
git config --global core.editor emacs
```

Se você optar por não definir um editor preferido, então o Git usará o editor padrão do seu sistema.

## Software de Código Aberto vs. Fechado

- **Definição**: "Open-source" significa que as pessoas podem ver o código que você publica, propor mudanças, relatar problemas e até executar uma versão modificada. "Closed-source" significa que as únicas pessoas que podem ver e interagir com o projeto são as pessoas que você autoriza explicitamente.

## GitHub

- **Definição**: GitHub é uma solução baseada na nuvem que oferece armazenamento de projetos com controle de versão em algo chamado "repositories" e possibilita recursos de colaboração para usar com esses projetos.
- **GitHub CLI**: Esta ferramenta é usada para realizar tarefas específicas do GitHub sem sair da linha de comando. Se você não a tiver instalada, pode obter instruções para isso na documentação do GitHub - mas ela deve estar disponível no gerenciador de pacotes do seu sistema.
- **GitHub Pages**: GitHub Pages é uma opção para implantar sites estáticos ou aplicações que não requerem um servidor back-end para lidar com a lógica. Ou seja, aplicações que rodam inteiramente no lado do cliente, ou no navegador do usuário, podem ser totalmente implantadas nesta plataforma.
- **GitHub Actions**: GitHub Actions é um recurso que permite automatizar fluxos de trabalho diretamente no seu repositório GitHub incluindo a construção, o teste e a implantação do seu código.

## Comandos Git Comuns

- **`git init`**: Isso irá inicializar um repositório Git vazio para que o Git possa começar a rastrear alterações deste projeto. Quando você inicializa um repositório Git vazio para um projeto, um novo diretório oculto `.git` será adicionado. Esse diretório `.git` contém informações importantes para o Git gerenciar seu projeto. 
- **`git status`**: Este comando é usado para mostrar o estado atual do seu diretório de trabalho - você usará este comando muito no seu fluxo de trabalho.
- **`git add`**: Este comando é usado para preparar suas alterações. Tudo que estiver na área de preparação será adicionado para o próximo commit. Se você quiser preparar todas as alterações não preparadas, pode usar `git add .` O ponto (`.`) é um alias para o diretório atual em que você está. 
- **`git commit`**: Este comando é usado para confirmar suas alterações. Um commit é uma captura do estado do seu projeto naquele momento. Se você executar `git commit`, ele abrirá o editor preferido que você configurou no Git. Uma vez que o editor estiver aberto, você pode fornecer uma mensagem detalhada sobre suas alterações. Você também pode optar por fornecer uma mensagem mais curta usando o comando `git commit -m` assim:

```sh
git commit -m "short message goes here"
```

- **`git log`**: Isso listará todos os commits anteriores com informações úteis como o autor, data do commit, mensagem do commit e hash do commit. O hash do commit é uma string longa que serve como identificador único para um commit.
- **`git remote add`**: Este comando é usado para configurar a conexão remota com seu repositório remoto.
- **`git push`**: Este comando é usado para enviar suas alterações para um repositório remoto.
- **`git pull`**: Este comando é usado para baixar as alterações mais recentes do seu repositório remoto para o seu repositório local.  
- **`git clone`**: Este comando irá clonar um repositório. Isso significa que você terá uma cópia do repositório. Essa cópia inclui o histórico do repositório, todos os arquivos/pastas e commits no seu dispositivo local.
- **`git remote -v`**: Este comando mostrará a lista de repositórios remotos associados ao seu repositório Git local.
- **`git branch`**: Este comando listará todos os seus branches locais.
- **`git fetch upstream`**: Este comando instrui o Git a buscar as últimas alterações que estão no seu remoto upstream (que é o repositório original).
- **`git merge upstream/main`**: Este comando instrui o Git a mesclar as alterações mais recentes do branch `main` no repositório remoto upstream para o seu branch atual.
- **`git reset`**: Este comando permite que você redefina o estado atual de um branch. Passar a flag `--hard` instrui o Git a forçar os arquivos locais a corresponderem ao estado do branch. Isso garante que você tenha uma base limpa para trabalhar. 
- **`git rebase`**: Um rebase no Git é uma forma de mover ou combinar uma sequência de commits de um branch para outro. 
  
## Trabalhando com Branches

- **Definição**: Um branch no Git é um espaço de trabalho separado onde você pode fazer alterações. O branch `main` frequentemente representará o branch principal ou de produção em uma aplicação do mundo real. Equipes de desenvolvedores criarão múltiplos branches para novas funcionalidades e correções de bugs e então mesclarão essas alterações de volta no branch `main`. 
- **Criando uma Nova Branch**: Para criar uma nova branch você pode executar o seguinte comando:

```sh
git branch feature
```

Para fazer checkout dessa branch, você pode executar o seguinte comando:

```sh
git checkout feature
```

A maioria dos desenvolvedores usará o comando abreviado para criar e fazer checkout de uma branch, que é o seguinte:

```sh
git checkout -b new-branch-name
```

Um comando mais novo e alternativo seria o comando `git switch`. Aqui está um exemplo para criar e mudar para uma nova branch:

```sh
git switch -c new-branch-name
```

- **Estratégias de Ramificação**: Sua branch `main` é sua branch padrão e geralmente é bastante estável. Portanto, é melhor criar ramificações a partir dela para criar novas branches para itens como correções de bugs, novas funcionalidades ou outros trabalhos diversos. 
- **Conflitos de Merge**: Isso acontece quando o Git tenta mesclar automaticamente as alterações de diferentes branches mas não consegue decidir quais alterações manter. Isso geralmente acontece quando há alterações conflitantes na mesma parte do arquivo. 

## Cinco Estados para um Arquivo Rastreado pelo Git

- **"Untracked"**: Isso significa que o arquivo é novo no repositório e o Git não o "viu" antes.
- **"Modified"**: Este arquivo existia no commit anterior e tem alterações que não foram commitadas.
- **"Ignored"**: Você provavelmente não verá arquivos ignorados no Git, mas seu IDE pode ter um indicador para eles. Arquivos ignorados são excluídos das operações do Git, tipicamente porque estão incluídos no arquivo `.gitignore`.
- **"Deleted"**: Um arquivo deletado é o oposto de um arquivo não rastreado - é um arquivo que existia anteriormente e foi removido.
- **"Renamed"**: Um arquivo renomeado é um arquivo cujo conteúdo não foi alterado, mas o nome ou a localização do arquivo foi modificado. Em alguns casos, um arquivo pode ser considerado renomeado mesmo que tenha uma pequena quantidade de alterações.

## Arquivos `.gitignore`

- **Definição**: O arquivo `.gitignore` é um tipo especial de arquivo relacionado às operações do Git. O nome sugere que esse arquivo é usado para dizer ao Git para ignorar coisas e esse é o caso mais comum. Mas o que ele realmente faz é dizer ao Git para parar de rastrear um arquivo.

## Trabalhando com Repositórios

- **Definição**: Um repositório é como um contêiner para um projeto - se você está trabalhando em um app, você manteria os arquivos desse app juntos em um repositório. Repositórios podem ser locais no seu computador ou remotos em um serviço como GitHub. 
- **Repositórios Públicos vs. Privados**: Um repositório público pode ser visualizado e baixado por qualquer pessoa. Um repositório privado só pode ser acessado por você e por qualquer pessoa a quem você conceder acesso explícito.
- **Criando Repositórios no GitHub**: Para criar um novo repositório no GitHub, você pode clicar no botão `"New Repository"` e seguir pela interface do GitHub para configurar um novo repositório.
- **Enviando Repositórios Locais para o GitHub**: Se você tem um projeto local no seu computador, você pode enviar esse repositório para o GitHub. Aqui está uma visão geral passo a passo do processo:

1. Inicialize um repositório git vazio no diretório do projeto (`git init`).
2. Faça alterações no seu projeto.
3. Execute o comando `git status` para ver todas as alterações feitas que estão sendo rastreadas pelo git.
4. Prepare suas alterações (`git add`).
5. Confirme suas alterações (`git commit`).
6. Configure a conexão remota (`git remote add`).
7. Envie suas alterações para o GitHub (`git push`).

## Pull Requests

- **Pull Requests**: Um pull request é uma solicitação para puxar mudanças do seu branch para o branch de destino. Pull requests são o fluxo que você usa quando quer contribuir com alterações de código para um projeto. Essa abordagem permite que os mantenedores do projeto revisem suas mudanças. Eles podem deixar comentários, fazer perguntas e sugerir ajustes. Então, uma vez que o processo de revisão esteja completo, ele pode ser aprovado e mesclado no branch principal.

## Contribuindo para Outros Repositórios

- **Processo**: Existem milhares de projetos para os quais você pode contribuir. Aqui está o processo básico de como contribuir para outro repositório:

1. Leia a documentação de contribuição
2. Encontre uma issue disponível para trabalhar
3. Faça um fork do repositório
4. Clone sua cópia bifurcada do repositório
5. Crie uma nova branch
6. Faça as alterações de acordo com o problema
7. Criar um PR (Pull Request)
8. Aguarde uma revisão para aquele PR

## Trabalhando com chaves SSH e GPG

- **Chaves GPG**: As chaves GPG, ou Gnu Privacy Guard, são tipicamente usadas para assinar arquivos ou commits. Alguém pode então usar sua chave pública GPG para verificar que a assinatura do arquivo é da sua chave e que o conteúdo do arquivo não foi modificado ou adulterado. 

Para gerar uma chave GPG, você precisará executar:

```sh
gpg --full-generate-key
```

- **Chaves SSH**: SSH, ou Secure SHell, chaves são tipicamente usadas para autenticar uma conexão remota a um servidor - via o utilitário `ssh`. Você também pode usar uma chave SSH para assinar commits.

Para uma chave SSH, você executará:

```sh
ssh-keygen -t ed25519 -C "your_email@example.com"
```

`ed25519` é um algoritmo moderno de assinatura de chave pública.

- **Assinando Commits com Chaves GPG**: Para assinar seus commits com sua chave GPG, você precisará enviar sua chave pública, não a chave privada, para sua conta do GitHub. Para listar suas chaves públicas, você precisará executar o seguinte: 

```sh
gpg --list-secret-keys --keyid-format=long
```

Então, para obter a chave pública, use:

```sh
gpg --armor --export "<key id>"
```
  
Então, pegue o ID curto que você obteve ao listar as chaves e execute este comando para defini-lo como sua chave de assinatura git:

```sh
git config --global user.signingkey <your_gpg_key_id>
```

Então, você pode passar a flag `-S` para o seu comando `git commit` para assinar um commit específico - será necessário fornecer sua senha. Alternativamente, se você quiser assinar todos os commits automaticamente, pode configurar o autosign para `true`:

```sh
git config --global commit.gpgsign true
```

- **Assinando Commits com Chaves SSH**: Para assinar com uma chave SSH, que é um recurso relativamente novo no GitHub, você precisará começar enviando a chave para sua conta do GitHub. Depois, será necessário configurar o modo de assinatura para o git usar SSH:

```sh
git config --global gpg.format ssh
```

Então, para definir a chave de assinatura, você passará o caminho do arquivo em vez de um ID:

```sh
git config --global user.signingkey <path_to_your_ssh_keys>
```

# --assignment--

Revise tópicos e conceitos de Bash, SQL e outros Bancos de Dados Relacionais.
