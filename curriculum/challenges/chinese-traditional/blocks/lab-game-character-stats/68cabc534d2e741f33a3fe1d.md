---
id: 68cabc534d2e741f33a3fe1d
title: 建置一個遊戲字元狀態追蹤器
challengeType: 27
dashedName: lab-game-character-stats
---

# --description--

在這個實驗中，你將建置一個遊戲角色屬性追蹤器。這個程式將允許你創建具有特定屬性的角色、更新這些屬性，並取得角色的當前狀態。

**目標：** 完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 創建一個名為 `GameCharacter` 的類別，用來表述遊戲字元並管理字元屬性。
2. 當具現化時，新的 `GameCharacter` 物件應該具有以下屬性：
    - `_name` 設定為具現體時所給定的字串。
    - `_health` 設定為 `100`。
    - `_mana` 設定為 `50`。
    - `_level` 設定為 `1`。
3. 為字元名稱的唯讀存取創建 `name` 屬性。
4. 對於 `health` 屬性：
     - 定義一個取值函式，傳回當前的健康值。
     - 定義一個設值函式，防止 `health` 被設為低於 `0`，並將 `health` 限制在 `100`。
5. 對於 `mana` 屬性：
     - 定義一個取值函式，傳回當前的魔力。
     - 定義一個設值函式，防止魔力被設為低於 `0`，並將魔力上限限制在 `50`。
6. 為你的 `level` 創建取值函式以傳回該字元的當前層級。
7. 定義一個名為 `level_up` 的方法，該方法：
    - 將字元的層次提升 1。
    - 使用對應的屬性設值函式將生命值重設為 `100` 並將魔力重設為 `50`。
    - 列印 `<name> leveled up to <level>!` 形式的訊息（其中 `<name>` 和 `<level>` 應分別被替換為字元的名稱和新層級）。
8. 定義一個 `__str__` 方法，該方法傳回包含以下內容的格式化字串：
    - 字元的名稱。
    - 字元的層次。
    - 該字元的當前生命值。
    - 字元目前的魔力。  
例如，一個名為 `Kratos` 的字元，在具現體後，應該表述為以下內容：

   ```md
   Name: Kratos
   Level: 1
   Health: 100
   Mana: 50
   ```

## 使用範例

```python
hero = GameCharacter('Kratos') # Creates a new character named Kratos
print(hero)  # Displays the character's stats

hero.health -= 30  # Decreases health by 30
hero.mana -= 10    # Decreases mana by 10
print(hero)  # Displays the updated stats

hero.level_up()  # Levels up the character
print(hero)  # Displays the stats after leveling up
```

# --hints--

你應該有一個 `GameCharacter` 類別。

```js
({ test: () => assert(runPython(`_Node(_code).has_class("GameCharacter")`)) })
```

你應該在 `GameCharacter` 類別中有一個 `__init__` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("__init__")`) 
})
```

`__init__` 方法應該有兩個參數，第一個是 `self`。

```js
({ 
    test: () => runPython(`
    import inspect
    params = list(inspect.signature(GameCharacter.__init__).parameters)
    assert params[0] == "self"
    assert len(params) == 2
    `) 
})
```

你應該在 `__init__` 方法內，於具現體時刻將 `self._name` 設定為給定的字串。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._name == "Kratos"
    `) 
})
```

你應該在 `__init__` 方法中將 `100` 指定給 `self._health`。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._health == 100
    `) 
})
```

你應該在 `__init__` 方法中將 `50` 指定給 `self._mana`。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._mana == 50
    `) 
})
```

你應該在 `__init__` 方法內將 `1` 指定給 `self._level`。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._level == 1
    `) 
})
```

你應該在 `GameCharacter` 類別中有一個 `name` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("name")`) 
})
```

`name` 方法應該只有一個參數，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("name").has_args("self")`) 
})
```

你應該在 `name` 方法中傳回 `self._name`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("name").has_return("self._name")`)
})
```

`name` 方法應該有一個 `@property` 裝飾器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("name").has_decorators("property")`) 
})
```

你應該在 `GameCharacter` 類別中有一個 `health` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("health")`) 
})
```

`health` 方法應該只有一個參數，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("health").has_args("self")`) 
})
```

你應該在 `health` 方法中傳回 `self._health`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("health").has_return("self._health")`)
})
```

`health` 方法應該有一個 `@property` 裝飾器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("health").has_decorators("property")`) 
})
```

你應該創建一個 `health` 設值函式。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("health")[1]`) 
})
```

`health` 設值函式應該有一個 `@health.setter` 裝飾器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("health")[1].has_decorators("health.setter")`) 
})
```

`health` 設值函式應該有兩個參數，第一個為 `self`。

```js
({ 
    test: () => runPython(`
    import inspect
    params = list(inspect.signature(GameCharacter.health.fset).parameters)
    assert params[0] == "self"
    assert len(params) == 2`) 
})
```

如果給 `health` 設值函式 的值小於 `0`，你應該將 `self._health` 設為 `0`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.health = -1
    assert char.health == 0
    char.health = -10
    assert char.health == 0
`)})
```

如果給 `health` 設值函式的值大於 `100`，你應該將 `self._health` 設為 `100`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.health = 101
    assert char.health == 100
    char.health = 200
    assert char.health == 100
`)})
```

當值介於 `0` 和 `100` 之間時，你應該將 `self._health` 設為給予 `health` 設值函式的值。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.health = 95
    assert char.health == 95
    char.health = 1
    assert char.health == 1
    char.health = 0
    assert char.health == 0
    char.health = 100
    assert char.health == 100
`)})
```

你應該在 `GameCharacter` 類別中有一個 `mana` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("mana")`) 
})
```

`mana` 方法應該只有一個參數，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("mana").has_args("self")`) 
})
```

你應該在 `mana` 方法中傳回 `self._mana`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("mana").has_return("self._mana")`)
})
```

`mana` 方法應該有一個 `@property` 裝飾器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("mana").has_decorators("property")`) 
})
```

你應該創建一個 `mana` 設值函式。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("mana")[1]`) 
})
```

`mana` 設值函式應該有一個 `@mana.setter` 裝飾器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("mana")[1].has_decorators("mana.setter")`) 
})
```

`mana` 設值函式應該有兩個參數，第一個為 `self`。

```js
({ 
    test: () => runPython(`
    import inspect
    params = list(inspect.signature(GameCharacter.mana.fset).parameters)
    assert params[0] == "self"
    assert len(params) == 2`) 
})
```

如果給 `mana` 設值函式的值小於 `0`，你應該將 `self._mana` 設為 `0`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.mana = -1
    assert char.mana == 0
    char.mana = -10
    assert char.mana == 0
`)})
```

如果給 `mana` 設值函式的值大於 `50`，你應該將 `self._mana` 設為 `50`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.mana = 51
    assert char.mana == 50
    char.mana = 100
    assert char.mana == 50
`)})
```

如果值介於 `0` 和 `50` 之間，你應該將 `self._mana` 設為給 `mana` 設值函式的值。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.mana = 25
    assert char.mana == 25
    char.mana = 0
    assert char.mana == 0
    char.mana = 50
    assert char.mana == 50
`)})
```

你應該在 `GameCharacter` 類別中有一個 `level` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("level")`) 
})
```

`level` 方法應該只有一個參數，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level").has_args("self")`) 
})
```

你應該在 `level` 方法中傳回 `self._level`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level").has_return("self._level")`)
})
```

`level` 方法應該有一個 `@property` 裝飾器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level").has_decorators("property")`) 
})
```

你應該在 `GameCharacter` 類別中有一個 `level_up` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("level_up")`) 
})
```

`level_up` 方法應該只有一個參數，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level_up").has_args("self")`) 
})
```

你應該在 `level_up` 方法中將 `self._level` 增加 1。

```js
({ 
  test: () => runPython(`
    node = _Node(_code).find_class("GameCharacter").find_function("level_up")
    assert (
        node.has_stmt("self._level += 1") or
        node.has_stmt("self._level = self._level + 1")
    )
`)
})
```

你應該在 `level_up` 方法中將 `self.health` 設定為 `100`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level_up").has_stmt("self.health = 100")`) 
})
```

你應該在 `level_up` 方法中將 `self.mana` 設定為 `50`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level_up").has_stmt("self.mana = 50")`) 
})
```

`level_up` 方法應該列印 `<name> leveled up to <level>!`（其中 `<name>` 和 `<level>` 應分別被該字元的名稱和新層次取代）。

```js
({
  test: () => runPython(`
    import io
    import sys
            
    captured_output = io.StringIO()
    sys.stdout = captured_output
            
    gc = GameCharacter("test")
    gc.level_up()
            
    sys.stdout = sys.__stdout__
    output = captured_output.getvalue()
            
    assert "test leveled up to 2!" in output
`)
})
```

你應該在 `GameCharacter` 類別中有一個 `__str__` 方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("__str__")`) 
})
```

`__str__` 方法應該只有一個參數，`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("__str__").has_args("self")`) 
})
```

你的 `__str__` 方法應該傳回一個使用所提供格式的字元屬性字串。

```js
({ 
  test: () => runPython(`
    import io
    import sys
            
    captured_output = io.StringIO()
    sys.stdout = captured_output
            
    gc = GameCharacter("test")
    gc.mana = 15
    gc.health = 77
    print(gc)
            
    sys.stdout = sys.__stdout__
    output = captured_output.getvalue()
    expected = """Name: test
    Level: 1
    Health: 77
    Mana: 15"""
    assert expected in output
`)
})
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
class GameCharacter:
    def __init__(self, name):
        self._name = name
        self._health = 100
        self._mana = 50
        self._level = 1

    @property
    def name(self):
        return self._name

    @property
    def health(self):
        return self._health

    @health.setter
    def health(self, value):
        if value < 0:
            self._health = 0
        elif value > 100:
            self._health = 100
        else:
            self._health = value

    @property
    def mana(self):
        return self._mana

    @mana.setter
    def mana(self, value):
        if value < 0:
            self._mana = 0
        elif value > 50:
            self._mana = 50
        else:
            self._mana = value

    @property
    def level(self):
        return self._level

    def level_up(self):
        self._level += 1
        self.health = 100
        self.mana = 50
        print(f"{self._name} leveled up to {self._level}!")

    def __str__(self):
        return (
            f"Name: {self._name}\n"
            f"Level: {self._level}\n"
            f"Health: {self._health}\n"
            f"Mana: {self._mana}"
        )
```
