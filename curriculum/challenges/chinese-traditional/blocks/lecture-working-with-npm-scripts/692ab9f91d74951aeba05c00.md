---
id: 692ab9f91d74951aeba05c00
title: 什麼是 npm Scripts？
challengeType: 19
dashedName: what-are-npm-scripts
---

# --description--

現在你將學習關於 npm 腳本。

在我們深入之前，讓我們先回顧一些重要的概念：

* **npm** 是一個命令列工具，你可以用來安裝和管理 JavaScript 軟體包。
    
* **軟體包** 是一個目錄，用於將相關的程式碼以邏輯結構群組起來。
    
* **script** 是用腳本程式設計語言撰寫的一連串指令或命令。
    

**npm scripts** 是你可以在應用程式的 `package.json` 檔案中定義的訂製指令。

它們有助於自動化你在專案的開發、測試和部署階段中會反覆使用的任務和工作流程。

例如，npm 腳本的一個使用案例是訂製 `npm start` 來啟動你的整個開發環境。你不需要每次啟動開發環境時手動逐一撰寫所有指令，只要執行 `npm start`，整個行程就會被執行。

你也可以使用 npm 腳本來自動化整個程式碼庫的 linting 以及執行測試套件，還有其他使用情境。

它們非常強大，所以讓我們來看看它們的基本原理。

## 如何創建 `package.json` 檔案

要能夠創建並執行訂製的 npm 腳本，你需要一個 `package.json` 檔案。

`package.json` 檔案對於 Node.js 專案來說是必不可少的。此檔案包含專案的詮釋資料、相依性和腳本。

提醒你，為了創建 `package.json` 檔案，你必須在你的專案根目錄中執行 `npm init` 指令。然後你可以手動輸入軟體包名稱、版本、描述和其他細節，或者將那些欄位留空以使用預設值。

完成此處理程序後，你的專案根目錄中將會有一個 `package.json` 檔案。

如果你保留所有預設值，當你在程式碼編輯器中打開 `package.json` 時，應該會看到這些鍵值對組：

```json
{
  "name": "<project_name>",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": ""
}
```

請注意這邊的鍵值配對：

```json
"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1"
}
```

這裡是你將在 `scripts` 鍵下指定你的 npm 腳本的地方。

你會預設看到那裡有一個腳本，測試腳本：

```json
"test": "echo \"Error: no test specified\" && exit 1"
```

這是 `package.json` 中定義的 npm 腳本範例。

以下是定義 npm 腳本的基本語法：

```json
"<script_name>": "<commands>"
```

冒號左邊是腳本名稱。常見的有 `run`、`start`、`test`、`build`、`dev` 和 `lint`。這些名稱作為其右側底層指令的「捷徑」。

在冒號右側，我們會找到底層的命令本身。

例如：

```json
"scripts": {
  "start": "node app.js"
}
```

要執行腳本，請在命令列輸入這個：

```bash
npm run <script_name>
```

這就是你如何執行在 `package.json` 中定義的任何訂製腳本。

有時你可以使用這個不帶 `run` 字的簡寫版本來執行腳本：

```bash
npm <script_name>
```

但這只適用於名為 `start`、`test`、`stop` 和 `restart` 的特定 npm 腳本。

回到我們的範例，如果我們在 `package.json` 中有這個：

```json
"scripts": {
  "start": "node app.js"
}
```

要執行 npm 腳本，你需要在命令列輸入 `npm run start`。當你這麼做時，實際執行的底層指令是 `node app.js`。

由於這個 npm 腳本有簡寫版本，你也可以使用 `npm start`，結果會一樣。

在這種情況下，你只是將簡單的指令 `node app.js` 替換成另一個指令 `npm start`。但試想如果你有一連串需要依序或平行執行的複雜指令，而你只要使用 `npm start` 就能執行全部指令。那會為你節省很多時間，對吧？這就是 npm 腳本真正強大的地方。

以下是一些最常用的 npm 腳本的快速概覽：

* `npm run`：用於執行訂製的 npm 腳本。
    
* `npm start`：用於啟動主要應用程式或開發伺服端。
    
* `npm lint`：用來執行程式碼風格檢查器，以檢查你的程式碼是否符合程式碼風格標準和最佳實踐。
    
* `npm test`：用於執行專案的測試套件。
    
還有許多其他用於不同目的的 npm 腳本，但這些是你最常見到的一些。

此外，一個常見的慣例是使用冒號將相關的腳本歸類到相同的命名空間下。例如，`start:server` 和 `start:ui`。

## 如何依序執行指令

如果你需要依序執行多個指令，你有兩個選項。你可以使用邏輯 AND 運算子（`&&`）或分號（`;`）。讓我們來看看它們的差異。

邏輯 AND 運算子僅在第一個命令成功執行時才執行下一個命令。

例如：

```json
"scripts": {
  "build": "webpack --mode production",
  "start": "npm run build && node server.js"
}
```

請注意，`start` 指令中有一個邏輯 AND 運算子：

```json
"start": "npm run build && node server.js"
```

在這裡，`npm start` 會先嘗試執行 `npm run build`，只有當此腳本成功執行時，才會執行 `node server.js`。

這是一個非常常見的方法，因為它確保了可靠性，並防止在前一個命令失敗時浪費時間和資源於後續可能失敗或發出錯誤的命令。

或者，你可以使用分號運算子來依序執行命令，無論前一個命令是否成功。

在我們的範例中，這個簡單的變更將對命令的執行方式產生重要影響：

```json
"scripts": {
  "build": "webpack --mode production",
  "start": "npm run build; node server.js"
}
```

再次專注於 `start` 指令：

```json
"start": "npm run build; node server.js"
```

現在，由於我們使用分號取代了 `&&` 運算子，`node server.js` 指令將會在 `npm run build` 之後始終執行，即使 `node server.js` 沒有成功。

```json
"start": "npm run build; node server.js"
```

## 如何並行執行指令

如果你需要並行（平行）執行命令，可以使用 `&` 運算子。

```json
"scripts": {
  "start:server": "node server/index.js",
  "start:client": "npm run build:watch",
  "dev": "npm run start:server & npm run start:client"
}
```

不過，你應該知道這個選項會在背景執行這些處理程序。

這表示，如果你在同一個終端機工作階段中執行它們，你可能會看到它們合併的輸出，這可能難以理解。

其他用於並行執行命令的選項包括像 `concurrently` 和 `npm-run-all` 這類工具。

## 如何將引數傳遞給 npm 腳本

如果你需要將引數直接傳遞給在 npm 腳本中執行的命令，你可以在命令中寫兩個連字號（`--`）後面接引數來指定它們。

`--` 告訴 npm，之後的所有內容都將是 npm 腳本將執行的底層命令的引數。

這是一般語法：

```bash
npm run <script_name> -- <argument_1> <argument_2> <argument_3>
```

例如，假設你定義了這個 `npm start` 腳本：

```json
{
  "name": "project-example",
  "scripts": {
    "start": "node app.js"
  }
}
```

如果你使用 `npm start`，要如何指定你想要執行伺服器的埠？

假設我們想要將埠直接作為命令列引數傳遞。你會這樣寫：

```bash
npm start -- 8000
```

在你的程式碼中，你可以使用索引來存取 `process.argv` 陣列中的這些引數：

```bash
process.argv[0] # The path to the node executable.
process.argv[1] # The script file being executed.
process.argv[2] # The first argument (8000).
```

因此，你可以在任何需要的地方使用 `process.argv[2]` 來存取和使用埠號。這就是命令列引數結合 npm 腳本的強大之處。

如你所見，npm 腳本是簡化開發工作流程的重要工具。它們幫助你自動化並轉換複雜且可重複使用的指令序列，成為你日常工作中可以使用的簡單且一致的捷徑。

# --questions--

## --text--

npm 腳本定義在哪裡的 Node.js 專案中？

## --answers--

在 `.npmignore` 檔案中。

### --feedback--

想想那個作為 Node.js 專案中央清單及其可執行指令的檔案。

---

在 `package.json` 的 `"dependencies"` 物件中。

### --feedback--

想想那個作為 Node.js 專案中央清單及其可執行指令的檔案。

---

在 `package.json` 的 `"scripts"` 物件中。

---

在獨立的 `npm-config.json` 檔案中。

### --feedback--

想想那個作為 Node.js 專案中央清單及其可執行指令的檔案。

## --video-solution--

3

## --text--

你如何執行名為 `build` 的 npm 腳本？

## --answers--

`build npm`

### --feedback--

想想告訴 npm 你想執行 `"scripts"` 區段中訂製指令的命令前置式。

---

`npm run build`

---

`node build`

### --feedback--

想想告訴 npm 你想執行 `"scripts"` 區段中訂製指令的命令前置式。

---

`run build`

### --feedback--

想想告訴 npm 你想執行 `"scripts"` 區段中訂製指令的命令前置式。

## --video-solution--

2

## --text--

在執行像 `npm run start -- 5` 這樣的 npm 腳本時，雙連字元 (`--`) 的目的是什麼？

## --answers--

它表示該腳本應該以靜默模式執行。

### --feedback--

想想當複雜的指令工具（例如 Jest 或 Webpack）透過 npm 快捷方式執行時，如何接收其特定的旗標。

---

它告訴 npm 將剩餘的引數傳遞給底層的 script 指令。

---

這表示該腳本必須以提升的管理員權限執行。

### --feedback--

想想當複雜的指令工具（例如 Jest 或 Webpack）透過 npm 快捷方式執行時，如何接收其特定的旗標。

---

它顯示該腳本應該與其他已定義的腳本平行執行。

### --feedback--

想想當複雜的指令工具（例如 Jest 或 Webpack）透過 npm 快捷方式執行時，如何接收其特定的旗標。

## --video-solution--

2
