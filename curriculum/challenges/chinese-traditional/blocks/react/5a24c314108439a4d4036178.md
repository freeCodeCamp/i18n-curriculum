---
id: 5a24c314108439a4d4036178
title: 創建受控輸入
challengeType: 6
forumTopicId: 301385
dashedName: create-a-controlled-input
---

# --description--

你的應用程式可能在 `state` 和呈現的 UI 之間有更複雜的互動。例如，文字輸入的表單控制元件，如 `input` 和 `textarea`，會在使用者輸入時在 DOM 中維護它們自己的狀態。使用 React，你可以將這個可變的狀態移到 React 組件的 `state` 中。使用者的輸入成為應用程式 `state` 的一部分，因此 React 控制該輸入欄位的值。通常，如果你有帶有使用者可輸入欄位的 React 組件，它將是一個受控輸入表單。

# --instructions--

程式碼編輯器中有一個名為 `ControlledInput` 的組件骨架，用於創建受控的 `input` 元素。該組件的 `state` 已經初始化，包含一個持有空字串的 `input` 屬性。此值表現使用者在 `input` 欄位中輸入的文字。

首先，創建一個名為 `handleChange()` 的方法，該方法有一個名為 `event` 的參數。當呼叫此方法時，它會接收一個包含來自 `input` 元素文字字串的 `event` 物件。你可以在方法內使用 `event.target.value` 存取此字串。使用此新字串更新組件 `state` 的 `input` 屬性。

在 `render` 方法中，於 `h4` 頁籤上方創建 `input` 元素。為你的 `input` 元素添加一個 `value` 屬性，其值與組件的 `state` 的 `input` 屬性相等。然後添加一個 `onChange` 屬性，並設定為 `handleChange()` 事件處理常式方法。

當你在輸入框中輸入時，該文字會被 `handleChange()` 方法處理，設定為區域的 `state` 中的 `input` 屬性，並呈現為頁面上 `input` 輸入框的值。該組件的 `state` 是關於輸入資料的唯一真實來源。

最後但同樣重要的是，別忘了在建構式中添加必要的綁定。

# --hints--

`ControlledInput` 應該傳回一個包含 `input` 和 `p` 頁籤的 `div` 元素。

```js
assert(
  Enzyme.mount(React.createElement(ControlledInput))
    .find('div')
    .children()
    .find('input').length === 1 &&
    Enzyme.mount(React.createElement(ControlledInput))
      .find('div')
      .children()
      .find('p').length === 1
);
```

`ControlledInput` 的狀態應該以 `input` 屬性設定為空字串來初始化。

```js
assert.strictEqual(
  Enzyme.mount(React.createElement(ControlledInput)).state('input'),
  ''
);
```

在輸入元素中輸入時，應該更新狀態和輸入的值，並且 `p` 元素應該在你輸入時呈現這個狀態。

```js
  const waitForIt = (fn) =>
    new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250));
  const mockedComponent = Enzyme.mount(React.createElement(ControlledInput));
  const _1 = () => {
    mockedComponent.setState({ input: '' });
    return waitForIt(() => mockedComponent.state('input'));
  };
  const _2 = () => {
    mockedComponent
      .find('input')
      .simulate('change', { target: { value: 'TestInput' } });
    return waitForIt(() => ({
      state: mockedComponent.state('input'),
      text: mockedComponent.find('p').text(),
      inputVal: mockedComponent.find('input').props().value
    }));
  };
  const before = await _1();
  const after = await _2();
  assert(
    before === '' &&
      after.state === 'TestInput' &&
      after.text === 'TestInput' &&
      after.inputVal === 'TestInput'
  );
```

# --seed--

## --after-user-code--

```jsx
ReactDOM.render(<ControlledInput />, document.getElementById('root'))
```

## --seed-contents--

```jsx
class ControlledInput extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: ''
    };
    // Change code below this line

    // Change code above this line
  }
  // Change code below this line

  // Change code above this line
  render() {
    return (
      <div>
        { /* Change code below this line */}

        { /* Change code above this line */}
        <h4>Controlled Input:</h4>
        <p>{this.state.input}</p>
      </div>
    );
  }
};
```

# --solutions--

```jsx
class ControlledInput extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: ''
    };
    this.handleChange = this.handleChange.bind(this);
  }
  handleChange(event) {
    this.setState({
      input: event.target.value
    });
  }
  render() {
    return (
      <div>
        <input
          value={this.state.input}
          onChange={this.handleChange} />
        <h4>Controlled Input:</h4>

        <p>{this.state.input}</p>
      </div>
    );
  }
};
```
