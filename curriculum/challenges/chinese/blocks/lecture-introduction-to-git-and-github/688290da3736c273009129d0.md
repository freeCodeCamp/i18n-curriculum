---
id: 688290da3736c273009129d0
title: 什么是 `Pull Request`，以及你如何 `创建` 一个？
challengeType: 19
dashedName: what-is-a-pull-request-and-how-do-you-create-one
---

# --description--

在上一课中，我们创建了一个特色分支，将一个新建文件提交到该分支，并将其推送到我们的远程仓库。但接下来的步骤是什么？我们需要在 GitHub 上创建一个拉取请求。

拉取请求实际上是一个请求，将你分支中的更改拉取到目标分支中。当你想为开源项目贡献代码更改时，拉取请求是你使用的流程。这种方法允许项目维护者审查你的更改。他们可以留下评论、提出问题、建议调整，并且（希望）批准你的更改并将其合并！

让我们再次前往 GitHub 上的仓库。

现在，在你推送了你的新建分支之后，你应该会看到一个华丽的横幅，显示你已推送到一个分支，以及一个你可以点击以创建拉取请求的按钮。这个按钮跳过了几个步骤并简化了进程，所以我们暂时忽略它。这样你就为横幅未出现的分支做好了准备。

点击仓库页面顶部的 pull requests 标签（页），然后再次忽略横幅，点击 "New Pull Request"。你将进入一个用于准备你的请求的界面。

现在，我们需要讲解一些术语。首先，我们有“base”和“compare”下拉菜单。“base”是你合并的目标。由于我们想合并到 `main`，所以可以保持不变。

“compare” 是你想要合并的内容。我们想要合并我们的 `feature` 分支，所以我们应该将其更改为 `feature`。这也被称为 head 分支，这是你需要记住的术语。

一旦你完成此操作，UI 将刷新。现在它应显示在 `feature` 上但不在 `main` 上的提交，表示你请求合并的内容。你还会看到所谓的“diff”，这是你所做实际更改的可视化表现。

因为我们所做的只是添加一个文件，所以差异非常清晰。对于更复杂的更改，GitHub 会突出显示诸如行修改、添加、删除等内容。理解如何读取差异可能具有挑战性，但经过一些练习你会变得非常熟练。

现在，让我们回到我们的拉取请求。顶部有一个小链接，显示为“compare across forks”。如果我们是从 freeCodeCamp 仓库的分叉中工作，这将使我们能够将我们的 PR 目标更改为原始的 freeCodeCamp 仓库，而不仅仅是我们分叉中的 `main` 分支。

由于我们没有使用分支，因此可以忽略这一点。然而，非常重要的是要理解，我们在这里所做的主要目的是学习和探索。你不应该向某人的项目提交仅包含练习更改的 PR——这会给维护者带来额外的干扰。

现在，既然我们对更改感到满意且所有配置都已完成，我们可以点击 `"Create Pull Request"` 按钮。这会带我们进入一个新的用户界面。

在底部且视图外的是我们之前看到的相同的提交列表和差异视图。在创建你的 PR 之前最后再查看一遍总是有益的，但对于这次探索，你可以继续前进。

你还会看到几个新建的输入。第一个输入是你的拉取请求的标题。GitHub 会根据你合并的提交自动生成此标题，如果拉取请求中只有一个提交，则使用该提交；如果有多个提交，则使用分支名称。

第二个输入是你的描述。在大多数分支中，这不会为空。相反，项目维护者可以定义一个预先填充的模板。如果他们提供了模板，你应尊重他们的工作流程并完成该模板。

在这两种分支中，你都需要读取该项目的贡献文档，以确保你理解并遵循他们关于如何命名和填写你的 PR 的指南。

由于你拥有此仓库，你将在右侧看到可以设置审阅者、被赋值人、标签、项目和里程碑。当你为别人的项目做出贡献时，除了请求审阅外，你将无法编辑这些内容。但如果你想探索这些特色，由于这是你的仓库，你现在可以随意设置它们。

填写并配置完成后，点击 "Create pull request"。最后，你将看到实际结果！

当你向别人的 `project` 发起 `pull request` 时，需要经过一次“`code review`”。这是一个由维护者评估你的 `pull request`、请求更改、提出问题等的过程。一旦维护者批准，他们就可以合并它。

由于这是你自己的项目，你不需要等待审核。相反，你可以在 `Commits` 标签（页）下查看提交历史，在 `Files changed` 下查看更改，如果你满意，可以合并它。

合并后，你会想将这些更改拉取到你的局部的仓库。

返回你的终端，确保你仍在仓库的文件夹中。然后使用 `git checkout main` 切换到 `main` 分支。

接下来，使用 `git pull` 拉取最新的更改。

现在，如果你使用 `git log` 查看提交历史，你会看到你的提交。但你也会看到一个 `Merge pull request #1` 消息。那是什么？

好吧，当你在 GitHub 上合并一个 pull 请求时，有三种策略可供选择：

默认是 `"Merge"`，它会将所有来自头部分支的提交合并，然后创建另一个提交来处理并记录合并。

另一个选项是 "Squash and Merge"，它将来自头部分支的所有提交合并成一个提交，并将该新提交直接合并到基础分支中，而不创建合并提交。

最后，还有“Rebase and Merge”，它会将所有的提交重置为“位于”基础分支的最新提交之后，然后将头部分支合并进来而不产生合并提交。Rebase 是一个复杂的主题，你稍后会深入学习，所以今天如果你还不太理解也没关系。

每个开源 `project` 都会选择最适合的合并策略。但由于这些行为上的差异，你应该始终创建一个新建 `branch` 来提交你的贡献。切勿直接提交到默认的 `main` `branch`，否则当你需要从原始仓库拉取更改时，情况会变得混乱。

有了这些，你已经成功创建并合并了你的第一个 pull request！

# --questions--

## --text--

GitHub 中的 pull 请求是什么？

## --answers--

一种将代码迫使推送到 `main` 分支的方法。

### --feedback--

考虑你要求项目维护者对你的代码更改做什么。

---

将更改从一个分支拉取到另一个分支的请求。

---

一种直接编辑主仓库中 `文件` 的方法。

### --feedback--

考虑你要求项目维护者对你的代码更改做什么。

---

一个用于将仓库下载到你的局部机器的工具。

### --feedback--

考虑你要求项目维护者对你的代码更改做什么。

## --video-solution--

2

## --text--

在一个拉取请求中，术语 "base" 和 "compare"（或 "head"）指的是什么？

## --answers--

“Base” 是源分支；“compare” 是目标分支。

### --feedback--

考虑哪个分支将接收更改以及哪个分支包含更改。

---

“Base” 是目标分支；“compare” 是源分支。

---

“Base” 是分支；“compare” 是原始仓库。

### --feedback--

考虑哪个分支将接收更改以及哪个分支包含更改。

---

“Base” 是原始仓库；“compare” 是分支。

### --feedback--

考虑哪个分支将接收更改以及哪个分支包含更改。

## --video-solution--

2

## --text--

以下哪项不是在 GitHub 合并拉取请求时提到的合并策略？

## --answers--

合并

### --feedback--

该课程提到了在合并期间处理提交的三种具体策略。

---

碰撞并合并

### --feedback--

该课程提到了在合并期间处理提交的三种具体策略。

---

变基并合并

### --feedback--

该课程提到了在合并期间处理提交的三种具体策略。

---

分叉和合并

## --video-solution--

4
