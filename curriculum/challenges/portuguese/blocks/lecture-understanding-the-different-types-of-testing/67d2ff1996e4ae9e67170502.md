---
id: 67d2ff1996e4ae9e67170502
title: O que é Unit Testing?
challengeType: 19
dashedName: what-is-unit-testing
---

# --description--

À medida que você projeta suas aplicações, frequentemente terá uma série de pequenas funções responsáveis por uma única coisa. Isto é conhecido como o "princípio da responsabilidade única." Quando você tem uma série de pequenas funções, é melhor testar essas funções para garantir que tudo funcione conforme o esperado.  In this lesson, we will take a look at how to create a unit test using the popular Jest testing framework.

Neste exemplo, vamos criar uma função que é responsável por retornar uma string recém formatada:

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

Esta função `getFormattedWord` tem um parâmetro chamado `str` e primeiro verificará se o `str` está vazio. Se for o caso, então uma string vazia é retornada. Caso contrário, uma nova string é retornada onde a primeira letra está em maiúscula. Estamos exportando esta função para que possamos usá-la em um arquivo de teste.

Em um arquivo separado `getFormattedWord.test.js`, podemos escrever alguns testes para verificar se a função está fazendo o que deveria estar fazendo.

No topo do arquivo `getFormattedWord.test.js`, precisamos primeiro importar a função assim:

```js
import { getFormattedWord } from "./getFormattedWord.js";
```

Então precisamos instalar o pacote Jest usando `npm i jest`. Então podemos adicionar um teste para verificar se uma palavra composta por caracteres minúsculos, `hello`, está formatada corretamente para `Hello`, que começa com um `H` maiúsculo:

```js
test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

A função `expect` é usada para testar um valor. É combinado com um matcher, que é uma função que verifica se o valor se comporta conforme o esperado. Neste caso o matcher é `toBe()`. Jest tem uma variedade de matchers para ajudar você a testar truthiness, strings, números e mais.

Uma maneira de executar seus testes é adicionando um script npm ao seu arquivo `package.json`. Aqui está um script de exemplo para o framework Jest:

```js
"scripts": {
  "test": "jest"
},
```

Então basta executar `npm run test` no seu terminal para rodar seus testes. Se seus testes passarem, você deverá ver algo no terminal assim:

```sh
PASS ./getFormattedWord.test.js
  ✓ capitalizes the first letter of a word (1 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.103 s, estimated 1 s
Ran all test suites.
```

Para ver como é um teste que falha, podemos intencionalmente quebrar o teste atualizando a função para o seguinte:

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return "This is incorrect";
}
```

Agora, quando você executar o comando `npm run test`, haverá uma mensagem de erro porque o teste esperava um resultado diferente:

```sh
FAIL ./getFormattedWord.test.js
  ✕ capitalizes the first letter of a word (1 ms)

  ● capitalizes the first letter of a word

  expect(received).toBe(expected) // Object.is equality

  Expected: "Hello"
  Received: "This is incorrect"

    2 |
    3 | test('capitalizes the first letter of a word', () => {
    4 |   expect(getFormattedWord('hello')).toBe('Hello');
                                            ^
    5 | });
    6 |

    at Object.toBe (getFormattedWord.test.js:4:37)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        0.121 s, estimated 1 s
Ran all test suites.
```

Agora podemos atualizar nossa função de volta ao original aqui:

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

Adicione outro teste para verificar casos em que nenhum argumento é fornecido para `getFormattedWord`:

```js
test("returns an empty string when no argument is provided", () => {
  expect(getFormattedWord()).toBe("");
});
```

Existem outros testes que você pode adicionar para tornar as coisas mais robustas, mas esses primeiros testes são uma boa introdução ao teste unitário.

Quando se trata de testar aplicações JavaScript alguns frameworks de teste comuns incluem Jest, Mocha e Vitest.

Testes unitários são importantes porque ajudam você a encontrar mais bugs em seus programas e garantir que tudo funcione conforme o esperado. Também pode servir como uma forma de documentação para sua aplicação porque é destinado a representar o comportamento esperado para seu código.

# --questions--

## --text--

Qual dos seguintes se refere ao princípio onde uma função deve ser responsável por apenas uma coisa?

## --answers--

Princípio da responsabilidade única

---

Princípio da responsabilidade múltipla

### --feedback--

Consulte novamente o início da lição onde isso foi discutido.

---

Princípio da requisição única

### --feedback--

Consulte novamente o início da lição onde isso foi discutido.

---

Princípio da resposta múltipla

### --feedback--

Consulte novamente o início da lição onde isso foi discutido.

## --video-solution--

1

## --text--

Qual dos seguintes NÃO é um framework de teste comumente usado no ecossistema JavaScript?

## --answers--

JUnit

---

Jest

### --feedback--

Consulte novamente o final da lição onde isso foi discutido.

---

Vitest

### --feedback--

Consulte novamente o final da lição onde isso foi discutido.

---

Mocha

### --feedback--

Consulte novamente o final da lição onde isso foi discutido.

## --video-solution--

1

## --text--

O que você pode adicionar a um arquivo `package.json` para executar seus testes no terminal?

## --answers--

```json
"test": {
  "test": "run test"
},
```

### --feedback--

Lembre-se de que você pode criar scripts personalizados no seu arquivo `package.json`.

---

```json
"scriptings": {
  "jest"
},
```

### --feedback--

Lembre-se de que você pode criar scripts personalizados no seu arquivo `package.json`.

---

```json
"run": {
  "test"
},
```

### --feedback--

Lembre-se de que você pode criar scripts personalizados no seu arquivo `package.json`.

---

```json
"scripts": {
  "test": "jest"
}
```

## --video-solution--

4
