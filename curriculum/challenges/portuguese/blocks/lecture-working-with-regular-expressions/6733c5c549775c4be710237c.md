---
id: 6733c5c549775c4be710237c
title: Como você pode corresponder e substituir todas as ocorrências em uma string?
challengeType: 19
dashedName: how-can-you-match-and-replace-all-occurrences-in-a-string
---

# --description--

Vamos aprender como encontrar ou substituir todas as ocorrências de um padrão em uma string.

Você já aprendeu sobre os métodos `replace()` e `match()`, assim como o modificador global `g`. Agora você pode combinar esse conhecimento para lidar com todos os padrões em uma string. Vamos relembrar nosso código de correspondência original:

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match);
```

E nosso objeto de correspondência resultante:

```js
// [
//   'freeCodeCamp',
//   index: 0,
//   input: 'freeCodeCamp',
//   groups: undefined
// ]
```

Mas e se tivermos uma string com múltiplas ocorrências de `freecodecamp` para corresponder? Vamos dar uma olhada em como `match()` se comporta com isso. Também vamos incluir nosso antigo exemplo de `replace()`, só para comparar:

```js
const regex = /freecodecamp/;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

E o resultado é este:

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
// freeCodeCamp is the best we love freecodecamp
```

Ah não! `match()` retornou apenas a primeira correspondência e `replace()` substituiu apenas a primeira correspondência. Isso ocorre porque, por padrão, `match()` e `replace()` operam apenas contra a primeira ocorrência do padrão.

Felizmente, você pode evitar isso usando o modificador global na sua expressão regular. Vamos adicionar isso ao nosso:

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

E confirme o resultado:

```js
// [ 'freecodecamp', 'freecodecamp' ]
// freeCodeCamp is the best we love freeCodeCamp
```

Funcionou! Nossa chamada de replace substituiu todas as strings minúsculas `freecodecamp` e nosso método `match()` correspondeu a ambas.

O que é interessante aqui é que quando você usa o modificador global com `match()`, você perde as informações extras sobre grupos de captura e índices de string que viriam no array de correspondência.

Felizmente, a atualização do ECMAScript de 2019 nos trouxe dois novos métodos: `matchAll()` e `replaceAll()`. Como seus equivalentes no singular, esses métodos aceitam uma string ou expressão regular e `replaceAll()` também aceita um segundo argumento como a string para substituir. 

Mas ao contrário dos métodos anteriores, `replaceAll()` e `matchAll()` lançarão um erro se você passar para eles uma expressão regular sem o modificador global. Vamos atualizar nosso código para usar esses novos métodos:

```js
const pattern = "freecodecamp";
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(pattern);
const replaced = str.replaceAll(pattern, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

E nosso resultado:

```js
// {}
// freeCodeCamp is the best we love freeCodeCamp
```

Boas notícias! Nosso `replaceAll()` funcionou exatamente como queríamos – ele substituiu todas as ocorrências do `freecodecamp` em minúsculas pela versão corretamente camelCase.

Mas o que é aquele objeto vazio? Bem, `matchAll()` retorna um tipo especial de objeto chamado `Iterator`, que o console do freeCodeCamp não está preparado para lidar.

Se olharmos no console do navegador, o `Iterator` tem um método `next()`, que podemos chamar para obter o próximo valor:

```js
// RegExpStringIterator {  }
//  <prototype>: RegExp String Iterator {
//    next: ƒ next(),
//    Symbol(Symbol.toStringTag): "RegExp String Iterator"
//    <prototype>: Object { ... }
//  }
```

Vamos em frente e chamar `matched.next()`, e registrar o resultado:

```js
// {
//   "done": false,
//   "value": [
//     0: "freecodecamp"
//     groups: undefined
//     index: 0
//     input: "freecodecamp is the best we love freecodecamp"
//   ]
// }
```

Aqui está nosso array de correspondência! `next()` nos dá um objeto com dois valores: `done`, que é `false` quando há mais elementos disponíveis no iterador, e `value` que é o valor que acabamos de iterar. Então, se chamarmos isso mais uma vez:

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
const replaced = str.replaceAll(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
console.log(matched.next());
console.log(matched.next());
```

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
```

Espera, por que diz que `done` ainda está `false`? Deveria haver apenas dois matches no array, certo? Vamos chamar pela terceira vez e ver o que obtemos:

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": true,
//   "value": undefined
// }
```

`done` finalmente é `true`, mas por que esse valor é `undefined`? Bem, como acontece, o iterador `matchAll()` é preguiçoso. Ele não encontra todas as suas correspondências de uma vez. Ele só encontra uma correspondência quando você manda chamando `next()`.

Enquanto encontrar uma correspondência, não estará `done`. Uma vez que não encontra uma correspondência e retorna `undefined`, está `done`. Isso pode parecer inconveniente, mas pode ser bastante útil quando sua expressão regular é computacionalmente cara.

Se o seu exemplo for menos assim, como o nosso, você pode pular esse recurso e extrair todas as correspondências de uma vez convertendo-o em um array. Isso é alcançado chamando `Array.from()` e passando seu iterador como argumento.

Vamos atualizar nosso código para usar isso – vamos em frente e limpar nossas chamadas `replaceAll` já que sabemos que isso funciona:

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
console.log(Array.from(matched));
```

E finalmente obtemos nosso array de matches:

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
//
// [
//   'freecodecamp',
//   index: 33,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
```

Esses métodos poderosos podem ajudar você a manipular e extrair dados de strings sem precisar sacrificar desempenho ou legibilidade.

# --questions--

## --text--

Qual modificador deve ser adicionado a uma expressão regular para corresponder a todas as ocorrências de um padrão em uma string?

## --answers--

`/i`

### --feedback--

A lição menciona um modificador específico para correspondência global.

---

`/m`

### --feedback--

A lição menciona um modificador específico para correspondência global.

---

`/g`

---

`/a`

### --feedback--

A lição menciona um modificador específico para correspondência global.

## --video-solution--

3

## --text--

Qual é a principal diferença entre os métodos `match()` e `matchAll()` quando usados com uma expressão regular global?

## --answers--

`match()` retorna um array, enquanto `matchAll()` retorna um Iterator.

---

`matchAll()` é mais rápido que `match()`.

### --feedback--

A lição descreve um tipo especial de objeto retornado por `matchAll()`.

---

`match()` só pode encontrar a primeira ocorrência, enquanto `matchAll()` encontra todas as ocorrências.

### --feedback--

A lição descreve um tipo especial de objeto retornado por `matchAll()`.

---

Não há diferença, eles são intercambiáveis

### --feedback--

A lição descreve um tipo especial de objeto retornado por `matchAll()`.

## --video-solution--

1

## --text--

Como você pode converter o resultado de `matchAll()` em um array contendo todas as correspondências?

## --answers--

Ao usar um loop `for...of`

### --feedback--

A lição demonstra um método específico para converter o `Iterator` em um array.

---

Ao chamar o método `toArray()` no resultado.

### --feedback--

A lição demonstra um método específico para converter o `Iterator` em um array.

---

Ao usar `Array.from()` com o resultado como argumento.

---

Distribuindo o resultado em um literal de array.

### --feedback--

A lição demonstra um método específico para converter o `Iterator` em um array.

## --video-solution--

3
