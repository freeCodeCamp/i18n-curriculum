---
id: 683ec95f2f8781355556ff83
title: Paso 11
challengeType: 20
dashedName: step-11
---

# --description--

Puedes ver que la primera llamada devuelve `[3]`. Eso es porque `3` es el valor medio en `[1, 2, 3, 4, 5]`.

Por otro lado, la segunda llamada devuelve una lista vacía. Esto ocurre porque, después de verificar el valor medio, al bucle le falta la lógica para limitar el rango de búsqueda actualizando las variables `low` o `high`. Solo actúa como una única verificación de punto medio y luego termina sin más búsqueda.

Para permitir que la búsqueda binaria continúe limitando su búsqueda, agrega un bloque `elif` que verifica si el `value` es mayor que `value_at_middle`. Por ahora, añade la palabra clave `pass` dentro del `elif`.

# --hints--

Deberías añadir un bloque `elif` para cuando `value` sea mayor que `value_at_middle`.

```js
({ test: () => runPython(`
_cond = _Node(_code).find_function("binary_search").find_whiles()[0].find_ifs()[0].find_conditions()[1]
assert _cond.is_equivalent("value > value_at_middle") or _cond.is_equivalent("value_at_middle < value")
`) })
```

# --seed--

## --seed-contents--

```py
def binary_search(search_list, value):
    path_to_target = []
    low = 0
    high = len(search_list) - 1
    
    while low <= high:
        mid = (low + high) // 2
        value_at_middle = search_list[mid]
        path_to_target.append(value_at_middle)

--fcc-editable-region--
        if value == value_at_middle:
            return path_to_target

--fcc-editable-region--          
        break
    return []

print(binary_search([1, 2, 3, 4, 5], 3))
print(binary_search([1, 2, 3, 4, 5, 9], 4))
```
