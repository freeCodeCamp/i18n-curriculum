---
id: 6724e3d6e1cb0c1fec3a8e4f
title: Revisão de SQL e PostgreSQL
challengeType: 31
dashedName: review-sql-and-postgresql
---

# --description--

## Introdução a Bancos de Dados Relacionais

- **Bancos de Dados Relacionais**: Organizam dados em tabelas relacionadas compostas por linhas e colunas. Cada linha representa um registro e cada coluna representa um atributo dos dados.
- **Vantagens dos Bancos de Dados Relacionais**: Escaláveis, amplamente aplicáveis em diversos domínios (por exemplo, saúde, negócios, jogos) e estruturados para manter dados confiáveis.
- **Casos de Uso Comuns**: desenvolvimento web, sistemas de inventário, comércio eletrônico, saúde e aplicações empresariais.

## Conceitos-chave

- **Esquema**: Um banco de dados relacional requer um esquema que defina sua estrutura—tabelas, colunas, tipos de dados, restrições e relacionamentos.
- **Chaves Primárias**: Identificadores únicos para cada linha em uma tabela. Eles são essenciais para a integridade dos dados e são usados para relacionar registros entre tabelas por meio de chaves estrangeiras.
- **Chaves Estrangeiras**: Referências a chaves primárias em outra tabela, usadas para vincular dados relacionados entre tabelas.
- **Relacionamentos**: Ao conectar tabelas por meio de chaves primárias e estrangeiras, você pode estruturar dados normalizados e realizar consultas significativas.
- **Diagramas de Relacionamento de Entidades (ERDs)**: Visualize como as entidades (tabelas) se relacionam entre si em um esquema de banco de dados.
- **Integridade de Dados**: Aplicada usando chaves e tipos de dados. Garante consistência e precisão dos dados armazenados.

## Noções básicas de SQL

- **Consultas**: Solicitações para recuperar dados específicos do banco de dados.

```sql
SELECT * FROM dogs WHERE age < 3;
```

- **Cláusula WHERE**: Filtre resultados com base em condições. Use operadores de comparação como `<`, `=`, `>`, etc.
- **Selecione com ORDER BY**: Recupere e ordene os resultados com base em uma coluna.

```sql
SELECT columns FROM table_name ORDER BY column_name;
```

## Operações de Tabela

- **Declaração `CREATE TABLE`**: Esta declaração é usada para criar uma nova tabela em um banco de dados.

```sql
CREATE TABLE first_table();
```

- **Declaração `ALTER TABLE ADD COLUMN`**: Esta declaração é usada para adicionar uma coluna a uma tabela existente.

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE;
```

- **Declaração `ALTER TABLE DROP COLUMN`**: Esta declaração é usada para remover uma coluna de uma tabela existente.

```sql
ALTER TABLE table_name DROP COLUMN column_name;
```

- **Declaração `ALTER TABLE RENAME COLUMN`**: Esta declaração é usada para renomear uma coluna em uma tabela.

```sql
ALTER TABLE table_name RENAME COLUMN column_name TO new_name;
```

- **Instrução `DROP TABLE`**: Esta instrução é usada para remover uma tabela inteira do banco de dados.

```sql
DROP TABLE table_name;
```

- **Declaração `ALTER DATABASE RENAME`**: Esta declaração é usada para renomear um banco de dados.

```sql
ALTER DATABASE database_name RENAME TO new_database_name;
```

- **Declaração `DROP DATABASE`**: Esta declaração é usada para excluir um banco de dados inteiro.

```sql
DROP DATABASE database_name;
```

## Restrições e Integridade de Dados

- **`ALTER TABLE ADD COLUMN` com Restrição**: Esta instrução é usada para adicionar uma coluna com uma restrição a uma tabela existente.

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE CONSTRAINT;
```

- **Restrição `NOT NULL`**: Esta restrição garante que uma coluna não possa ter valores NULL.

```sql
column_name VARCHAR(50) NOT NULL
```

- **Declaração `ALTER TABLE ADD PRIMARY KEY`**: Esta declaração é usada para adicionar uma restrição de chave primária a uma tabela.

```sql
ALTER TABLE table_name ADD PRIMARY KEY(column_name);
```

- **Declaração `ALTER TABLE DROP CONSTRAINT`**: Esta declaração é usada para remover uma restrição de uma tabela.

```sql
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
```

- **`ALTER TABLE ADD COLUMN` com Chave Estrangeira**: Esta instrução é usada para adicionar uma coluna de chave estrangeira que referencia outra tabela.

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE REFERENCES referenced_table_name(referenced_column_name);
```

- **Declaração `ALTER TABLE ADD UNIQUE`**: Esta declaração é usada para adicionar uma restrição UNIQUE a uma coluna.

```sql
ALTER TABLE table_name ADD UNIQUE(column_name);
```

- **Declaração `ALTER TABLE ALTER COLUMN SET NOT NULL`**: Esta declaração é usada para definir uma restrição NOT NULL em uma coluna existente.

```sql
ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL;
```

- **Instrução `INSERT` com Valores NULL**: Esta instrução demonstra como inserir valores NULL em uma tabela.

```sql
INSERT INTO table_name(column_a) VALUES(NULL);
-- or
INSERT INTO table_name(column_b) VALUES('value'); -- if column_a allows nulls
```

- **Chave Primária Composta**: Esta restrição define uma chave primária que consiste em múltiplas colunas.

```sql
CREATE TABLE course_enrollments (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id)
);
```

## Manipulação de Dados (CRUD)

- **Declaração `INSERT`**: Esta declaração é usada para inserir uma única linha em uma tabela.

```sql
INSERT INTO table_name(column_1, column_2) VALUES(value1, value2);
```

- **Instrução `INSERT` com Colunas Omitidas**: Esta instrução mostra como inserir valores sem listar explicitamente os nomes das colunas, confiando na ordem padrão das colunas na tabela.

```sql
INSERT INTO dogs VALUES ('Gino', 3);
```

- **Declaração `INSERT` com Múltiplas Linhas**: Esta declaração é usada para inserir múltiplas linhas em uma tabela em uma única operação.

```sql
INSERT INTO dogs (name, age) VALUES 
('Gino', 3),
('Nora', 2);
```

- **Declaração `UPDATE`**: Esta declaração é usada para atualizar dados existentes em uma tabela com base em uma condição.

```sql
UPDATE table_name SET column_name=new_value WHERE condition;
```

- **Declaração `DELETE`**: Esta declaração é usada para deletar linhas de uma tabela com base em uma condição.

```sql
DELETE FROM table_name WHERE condition;
```

## Tipos de Dados

- **Tipo de Dados `NUMERIC`**: Este tipo de dado é usado para armazenar números decimais precisos com uma precisão e escala especificadas.

```sql
price NUMERIC(10, 2)
```

- **Tipo de Dados `TEXT`**: Este tipo de dado é usado para armazenar strings de caracteres de comprimento variável sem limite específico de tamanho.

```sql
column_name TEXT
```

- **Tipo de Dados `INTEGER`**: Este tipo de dado é usado para armazenar números inteiros sem casas decimais.

```sql
units_sold INTEGER
```

- **Tipos de Dados `SMALLINT` e `BIGINT`**: Estes são variantes de INTEGER com intervalos menores e maiores respectivamente.

- **Tipo de Dados `SERIAL`**: Este tipo de dado é usado para criar colunas inteiras com auto-incremento no PostgreSQL.

```sql
id SERIAL
```

- **Atributo `AUTO_INCREMENT`**: Este atributo é usado no MySQL para criar colunas inteiras com incremento automático.

```sql
id INT AUTO_INCREMENT
```

- **Tipo de Dados `VARCHAR`**: Este tipo de dado é usado para armazenar strings de caracteres de comprimento variável com um comprimento máximo especificado.

```sql
name VARCHAR(50)
```

- **Tipo de Dados `DATE`**: Este tipo de dado é usado para armazenar valores de data (ano, mês, dia).

```sql
event_date DATE
```

- **Tipo de Dados `TIME`**: Este tipo de dado é usado para armazenar valores de tempo (hora, minuto, segundo).

```sql
start_time TIME
```

- **Tipo de Dados `TIMESTAMP`**: Este tipo de dado é usado para armazenar valores de data e hora, opcionalmente com informações de fuso horário.

```sql
event_timestamp TIMESTAMP
event_timestamp TIMESTAMP WITH TIME ZONE
```

- **Tipo de Dados `BOOLEAN`**: Este tipo de dado é usado para armazenar valores verdadeiro/falso.

```sql
is_active BOOLEAN
```

## Relacionamentos de Banco de Dados

- **Tipos de Relacionamentos**: Estas são as diferentes formas como as tabelas podem estar relacionadas entre si em um banco de dados relacional.
  - Um-para-um
  - Um-para-muitos
  - Muitos-para-um
  - Muitos-para-muitos
  - Auto-referência (recursiva)

- **Relacionamento Um-para-Um**: Este tipo de relacionamento significa que cada registro em uma tabela corresponde exatamente a um registro em outra tabela.

```md
One employee is assigned exactly one vehicle.
Tables: employees, vehicles
```

- **Relacionamento Um-para-Muitos**: Este tipo de relacionamento significa que um registro em uma tabela pode estar associado a múltiplos registros em outra tabela.

```md
One customer can have many orders.
Tables: customers → orders
```

- **Relacionamento Muitos-para-Muitos via Tabela de Junção**: Este tipo de relacionamento é implementado usando uma tabela de junção que contém chaves estrangeiras de ambas as tabelas relacionadas.

```sql
CREATE TABLE books_authors (
    author_id INT REFERENCES authors(id),
    book_id INT REFERENCES books(id)
);
```

- **Relacionamentos Auto-Referenciados**: Este tipo de relacionamento ocorre quando uma tabela referencia a si mesma, criando uma estrutura hierárquica.

```md
An employee table where each employee may report to another employee.
```

## SQL Avançado (Joins)

- **Declaração `INNER JOIN`**: Esta junção retorna apenas as linhas que possuem valores correspondentes em ambas as tabelas.

```sql
SELECT *
FROM products
INNER JOIN sales ON products.product_id = sales.product_id;
```

- **Declaração `FULL OUTER JOIN`**: Esta junção retorna todas as linhas de ambas as tabelas, incluindo linhas não correspondentes de qualquer tabela.

```sql
SELECT *
FROM products
FULL OUTER JOIN sales ON products.product_id = sales.product_id;
```

- **Declaração `LEFT OUTER JOIN`**: Esta junção retorna todas as linhas da tabela à esquerda e as linhas correspondentes da tabela à direita.

```sql
SELECT *
FROM products
LEFT JOIN sales ON products.product_id = sales.product_id;
```

- **Declaração `RIGHT OUTER JOIN`**: Esta junção retorna todas as linhas da tabela direita e as linhas correspondentes da tabela esquerda.

```sql
SELECT *
FROM products
RIGHT JOIN sales ON products.product_id = sales.product_id;
```

- **Declaração `SELF JOIN`**: Esta junção é usada para unir uma tabela a ela mesma para comparar linhas dentro da mesma tabela.

```sql
SELECT A.column_name, B.column_name
FROM table_name A
JOIN table_name B ON A.related_column = B.related_column;
```

- **Declaração `CROSS JOIN`**: Esta junção retorna o produto cartesiano de duas tabelas, combinando cada linha da primeira tabela com cada linha da segunda tabela.

```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

## Comandos Específicos do PostgreSQL

- **Comando de Login `psql`**: Este comando é usado para fazer login no PostgreSQL com um nome de usuário e banco de dados específicos.

```bash
psql --username=freecodecamp --dbname=postgres
```

- **Comando `\l`**: Este comando lista todos os bancos de dados na instância do PostgreSQL.

```sql
\l
```

- **Comandos `CREATE DATABASE` e `\c`**: Esses comandos são usados para criar um novo banco de dados e conectar-se a ele.

```sql
CREATE DATABASE database_name;
\c database_name
```

- **Comando `\d`**: Este comando lista todas as tabelas no banco de dados atual.

```sql
\d
```

- **Comando `\d table_name`**: Este comando exibe o esquema/estrutura de uma tabela específica.

```sql
\d table_name
```

- **Comando `\q`**: Este comando sai do cliente PostgreSQL.

```bash
\q
```

## Relacional vs Não Relacional

- **Bancos de Dados Não Relacionais (NoSQL)**: Armazenam dados não estruturados ou semi-estruturados. Não exigem um esquema rígido e são mais flexíveis para modelos de dados em evolução.
- **Escolhendo Entre Relacional e Não Relacional**: Depende da natureza dos seus dados e dos requisitos da aplicação.
- **Relacional vs Não Relacional**: Escolha relacional para dados estruturados e consistência; NoSQL para flexibilidade e dados que mudam rapidamente.

## Sistemas RDBMS Populares

- **MySQL**: Código aberto, confiável, amplamente usado em desenvolvimento web e suportado por uma grande comunidade.
- **PostgreSQL**: Código aberto, avançado, extensível. Suporta tipos de dados personalizados e programação do lado do servidor.
- **SQLite**: Leve, baseado em arquivo, sem servidor. Ideal para aplicações pequenas.
- **Microsoft SQL Server**: Banco de dados proprietário, de nível empresarial.
- **Oracle Database**: RDBMS comercial conhecido por desempenho e escalabilidade em grande escala.

## Melhores Práticas

- **Convenção de Nomenclatura**: Use `snake_case` (por exemplo, `delivery_orders`) para nomes de tabelas e colunas.

# --assignment--

Revise tópicos e conceitos de SQL e PostgreSQL.
