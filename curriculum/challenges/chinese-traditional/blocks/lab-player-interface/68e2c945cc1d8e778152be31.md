---
id: 68e2c945cc1d8e778152be31
title: 建置一個播放器介面
challengeType: 27
dashedName: build-a-player-interface
---

# --description--

**目標：** 完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 你應該定義一個名為 `Player` 的抽象的類別，該類別繼承自 `abc.ABC` 類別。
1. `Player` 類別應該有一個 `__init__` 方法，該方法設定：

   - 將 `moves` 屬性設為空列表。
   - 將 `position` 屬性設為 `(0, 0)`。
   - `path` 屬性為包含初始位置的列表。

1. `Player` 類別應該有一個名為 `make_move` 的方法，該方法：

   - 使用 `random.choice` 從 `moves` 屬性（在具體類別中定義）中取得隨機動作。
   - 將所選移動的值添加到當前位置並更新 `position` 屬性。
   - 將新的 `position` 元組附加到 `path` 屬性。
   - 傳回新的 `position`。

1. `Player` 類別應該有一個名為 `level_up` 的抽象方法，供具體類別實作。
1. 你應該定義一個繼承自 `Player` 類別的 `Pawn` 類別。
1. `Pawn` 類別應該使用 `super()` 來呼叫父類別的 `__init__` 方法，然後將 `moves` 屬性設定為一個表述 `x, y` 座標的元組列表。
1. 每個座標組合應該表述在以下方向上移動 `1` 單位：向上、向下、向左、向右。
1. `Pawn` 類別應該實作一個具體的 `level_up` 方法，透過為 `moves` 屬性添加更多移動。新增的移動應該表述四個對角線方向的移動（例如，向下 1 單位加上向左 1 單位）。

**注意：** 標準程式庫模組應該直接匯入，且不可使用別名。在 `Pawn` 類別可被實例化之前，與 `Player` 類別相關的測試將會失敗。

# --hints--

你應該有一個名為 `Player` 的類別。

```js
({ test: () => runPython(`assert _Node(_code).has_class("Player")`) })
```

`Player` 類別應該繼承自 `abc` 模組的 `ABC` 類別。

```js
({ test: () => runPython(`
from abc import ABC
import ast
cls = _Node(_code).find_class("Player")
assert cls.inherits_from("ABC") or cls.inherits_from("abc.ABC")
`) })
```

`Player` 類別應該有一個 `__init__` 方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("__init__")`) })
```

`Player` 的 `__init__` 方法應該只有一個參數 `self`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("__init__").has_args("self")`) })
```

`Player` 的 `__init__` 方法應該將 `self.moves` 設定為空列表。

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.moves = []") or init.has_stmt("self.moves = list()")
`) })
```

`Player` 的 `__init__` 方法應該將 `self.position` 設定為 `(0, 0)`。

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.position = (0, 0)")
`) })
```

`Player` 的 `__init__` 方法應該將 `self.path` 設定為包含初始位置的列表。

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.path = [self.position]")
`) })
```

`Player` 類別應該有一個 `make_move` 方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("make_move")`) })
```

`Player` 的 `make_move` 方法應該只有一個參數 `self`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("make_move").has_args("self")`) })
```

`Player` 的 `make_move` 方法應該使用 `random.choice` 從 `moves` 屬性中取得隨機移動。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").block_has_call("choice", "make_move")`) })
```

`Player` 的 `make_move` 方法應該透過將隨機選擇的移動座標加到 `position` 屬性上來更新它。

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "Unable to instantiate Pawn"

  p.make_move()
  assert p.position == (1, 2)
  p.make_move()
  assert p.position == (2, 4)

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "missing import"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

`Player` 的 `make_move` 方法應該將新的 `position` 元組附加到 `path` 屬性。

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "Unable to instantiate Pawn"

  p.make_move()
  assert p.path == [(0, 0), (1, 2)]
  p.make_move()
  assert p.path == [(0, 0), (1, 2), (2, 4)]

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "missing import"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

`Player` 的 `make_move` 方法應該傳回更新後的 `position` 屬性。

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "Unable to instantiate Pawn"

  assert p.make_move() == (1, 2)

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "missing import"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

`Player` 類別應該有一個 `level_up` 方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("level_up")`) })
```

`Player` 的 `level_up` 方法應該只有一個參數 `self`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("level_up").has_args("self")`) })
```

`Player` 的 `level_up` 方法應該是抽象的方法。

```js
({ test: () => runPython(`
target = _Node(_code).find_class("Player").find_function("level_up")
assert target.has_decorators("abstractmethod") or target.has_decorators("abc.abstractmethod")
`) })
```

`Player` 類別應該是一個抽象的類別。

```js
({ test: () => runPython(`
try:
  Player()
except TypeError as e:
  assert str(e) == "Can't instantiate abstract class Player with abstract method level_up"
else:
  assert False, "Player class should not be instantiable"
`) })
```

你應該有一個名為 `Pawn` 的類別。

```js
({ test: () => runPython(`assert _Node(_code).has_class("Pawn")`) })
```

`Pawn` 類別應該繼承自 `Player` 類別。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").inherits_from("Player")`) })
```

`Pawn` 類別應該有一個 `__init__` 方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").has_function("__init__")`) })
```

`Pawn` 的 `__init__` 方法應該只有一個參數 `self`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").find_function("__init__").has_args("self")`) })
```

`Pawn` 的 `__init__` 方法應該使用 `super` 函式呼叫父類別的 `__init__`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").find_function("__init__").has_stmt("super().__init__()")`) })
```

`Pawn` 的 `__init__` 方法應該將 `moves` 屬性設為一個元組列表，該列表表述 `x, y` 座標，其中每個座標元組表現向上、向下、向左、向右方向移動 `1` 單位。

```js
({ test: () => runPython(`
p = Pawn()
moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]
assert isinstance(p.moves, list)
assert len(p.moves) == 4
assert all(move in p.moves for move in moves)
`) })
```

`Pawn` 類別應該有一個 `level_up` 方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").has_function("level_up")`) })
```

`Pawn` 的 `level_up` 方法應該為 `moves` 屬性添加四個對角方向移動 `1` 單位。

```js
({ test: () => runPython(`
p = Pawn()
moves = [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
p.level_up()
assert isinstance(p.moves, list)
assert len(p.moves) == 8
assert all(move in p.moves for move in moves)
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
from abc import ABC, abstractmethod
from random import choice


class Player(ABC):
    def __init__(self):
        self.moves = []
        self.position = (0, 0)
        self.path = [self.position]

    def make_move(self):
        x, y = self.position
        move = choice(self.moves)
        new_x = move[0] + x
        new_y = move[1] + y
        self.position = (new_x, new_y)
        self.path.append(self.position)
        return self.position

    @abstractmethod
    def level_up(self):
        pass


class Pawn(Player):
    def __init__(self):
        super().__init__()
        self.moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]

    def level_up(self):
        self.moves.extend([(1, 1), (1, -1), (-1, 1), (-1, -1)])
```
