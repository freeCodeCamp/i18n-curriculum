---
id: 695cc8f280fef0cc3bed02c8
title: ¿Qué es el módulo Crypto y cómo funciona?
challengeType: 19
dashedName: what-is-the-crypto-module-and-how-does-it-work
---

# --description--

Crypto es otro módulo central que está integrado en Node.js. Incluye herramientas para cosas como hashing, encriptación, desencriptación y creación de firmas digitales, todas las cuales se usan para proteger información sensible y mantener segura tu app.

Dicho esto, `crypto` te ofrece bloques de construcción de bajo nivel, no seguridad lista para usar. Escribir tu propio código de encriptación o autenticación puede ser inseguro si no tienes cuidado. En la mayoría de los casos, es mejor usar bibliotecas bien probadas como `bcrypt` para el hash de contraseñas o `jsonwebtoken` (JWT) para manejar inicios de sesión y tokens.

Dicho esto, todavía es útil entender cómo funcionan algunos de los métodos en el módulo crypto.

Para usar estos métodos, necesitas importar el módulo `crypto`:

```js
const crypto = require("crypto");
```

Algunos de los métodos se usan para propósitos de transformación de datos, como los de hashing y encriptación de datos, y otros son para la gestión de claves y seguridad, como los de generación de valores aleatorios y creación de secretos.

Primero, veamos los métodos para hashear y encriptar datos.

El método `createHash()` crea un objeto hash utilizando algoritmos como `sha256`, `sha512` o `md5`. Es una operación unidireccional, por lo que no puedes revertirla.

`createHash()` es útil para hashear contraseñas y obtener la huella digital de archivos. Para usarlo, pasa tu algoritmo, usa el método `update()` para ingresar los datos y finalmente usa `digest()` con una codificación para obtener el valor hash:

```js
const crypto = require("crypto");

const hashedPassword = crypto
  .createHash("sha256")
  .update("myStrongPassword")
  .digest("hex");

console.log("createHash result:", hashedPassword);
// createHash result: f92c9cfa0ead1bcec05ca75888a4074ba994ad237e5e2a8c7cc6a620378c061d
```

`createHmac()` hace casi lo mismo que `createHash()`, pero lleva las cosas al siguiente nivel al aceptar una clave secreta, de modo que solo alguien con esa clave puede verificar el hash. Es ideal para la autenticación y la verificación de la integridad de los datos:

```js
const crypto = require("crypto");

const hashedMessage = crypto
  .createHmac("sha256", "secretkey")
  .update("important-secret-message")
  .digest("hex");

console.log("createHmac result:", hashedMessage);
// createHmac result: da48d6f026b6036286b1fb872c63264130d5cc4271f3a213bb6ddca5a023e77e
```

Los métodos `createCipheriv()` y `createDecipheriv()` cifran y descifran datos. Ambos reciben un algoritmo, una clave y un `iv`, que es un bloque de datos aleatorios o únicos usado al inicio del proceso de cifrado:

```js
createCipheriv(algorithm, key, iv);
createDecipheriv(algorithm, key, iv);
```

Para descifrar los datos, la clave debe ser la misma, de lo contrario, el descifrado fallará y obtendrás un error o un galimatías ilegible en lugar del mensaje original.

Aquí están los dos en acción:

```js
const crypto = require("crypto");

// A key must match the algorithm length. Here AES-256 is 32 bytes
const key = Buffer.from("12345678901234567890123456789012");

// A fixed IV, 16 bytes for AES
const iv = Buffer.from("1234567890123456");

const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);

let encrypted = cipher.update("Hello campers!", "utf8", "hex");
encrypted += cipher.final("hex");

console.log("Encrypted data:", encrypted);
// Encrypted data: 4ee93aa398ab44e3540e4a67ca96bc8c

// Decrypt the "Hello campers!" message
const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
let decrypted = decipher.update(encrypted, "hex", "utf8");
decrypted += decipher.final("utf8");

console.log("Decrypted data:", decrypted);
// Decrypted data: Hello campers!
```

Otro método criptográfico para la transformación de datos es `sign()` y `verify()`. 

`sign()` crea una firma digital a partir de algunos datos usando una clave privada. Esta firma prueba que los datos provienen del poseedor de la clave privada y que no han sido alterados.

`verify()` luego verifica esa firma, y falla si los datos o la firma no coinciden.

Ahora, veamos los métodos crypto para generar valores aleatorios y crear secretos.

`randomBytes()` recibe un `size` y genera tokens criptográficamente seguros. Eso lo hace bueno para generar UUIDs (identificadores únicos universales). Además, es un buen reemplazo para `Math.random()`, que no es seguro para tokens y claves.

```js
console.log("Random Bytes:", crypto.randomBytes(16));
// Random Bytes: <Buffer 01 88 aa 1e 2c 38 48 39 26 e1 6b a9 d8 c5 ed 49>
```

La salida es un buffer por defecto. Como aprendiste en la lección sobre el módulo Buffer, puedes convertir ese Buffer a una cadena con el método `toString()`:

```js
console.log("Random Bytes:", crypto.randomBytes(16).toString("hex"));
// Random Bytes: a6154ef5a296fa176ad0f332bd94d712
```

El argumento `'hex'` en `toString('hex')` aquí indica a Node que codifique los datos binarios del Buffer como una cadena hexadecimal.

El método `randomInt()` recibe valores `min` y `max` y genera un entero aleatorio seguro entre ellos. Es útil para OTPs y selección aleatoria.

```js
console.log("Random Int:", crypto.randomInt(0, 100)); // 89
```

Nuevamente, la mejora sobre `Math.random()` y `Math.floor()` es que el método usa aleatoriedad criptográficamente segura internamente, por lo que los atacantes no pueden predecir el número aleatorio resultante.

Otro método es `createSecretKey()`. Toma un buffer y genera un byte sin procesar envuelto en un `KeyObject`:

```js
const crypto = require("crypto");

const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret); // SecretKeyObject [KeyObject] { [Symbol(kKeyType)]: 'secret' }
```

Luego puedes usar el método `export` para enviar ese `KeyObject`:

```js
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export());
// <Buffer 53 06 a1 c7 75 69 8b 38 8b a4 b2 f7 1b bc b8
// ae e2 d1 bf 67 af 1a 6a 0a 6e a0 29 62 bb 52 52 32>
```

Y finalmente, usa `toString()` en el buffer para ver la representación en cadena de este:

```js
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export().toString('hex'));
// 32dfe5917668580160986f1623bf8152913329c71163be9c3404a110cd78efd6
```

Además de estos, hay:

- `createPublicKey()` y `createPrivateKey()` que te permiten trabajar con claves generadas en otro lugar
- `createDiffieHellman()` para que dos partes generen un secreto compartido sin enviar el secreto directamente
- `Certificate()` para trabajar con el que se usa en HTTPS, de modo que puedas analizar, exportar y verificar el contenido del certificado

# --questions--

## --text--

¿Cuál de estas es la forma correcta de importar el módulo crypto de Node.js?

## --answers--

`const crypto = require('crypto')`

---

`const crypto = import('crypto')`

### --feedback--

Concéntrate en la sintaxis que Node.js usa para requerir módulos integrados.

---

`import crypto from 'nodes:crypto'`

### --feedback--

Concéntrate en la sintaxis que Node.js usa para requerir módulos integrados.

---

`crypto = requireModule('crypto')`

### --feedback--

Concéntrate en la sintaxis que Node.js usa para requerir módulos integrados.

## --video-solution--

1

## --text--

¿Cuál de estas afirmaciones sobre `sign()` y `verify()` es correcta?

## --answers--

`sign()` usa una clave pública para crear una firma, y `verify()` la verifica con una clave privada.

### --feedback--

Recuerda que las firmas digitales funcionan con pares de claves privadas y públicas.

---

Tanto `sign()` como `verify()` requieren solo una clave privada.

### --feedback--

Recuerda que las firmas digitales funcionan con pares de claves privadas y públicas.

---

`sign()` crea una firma digital con una clave privada, y `verify()` la verifica con la clave pública correspondiente.

---

`verify()` puede comprobar firmas sin necesitar ninguna clave.

### --feedback--

Recuerda que las firmas digitales funcionan con pares de claves privadas y públicas.

## --video-solution--

3

## --text--

¿Qué método en el módulo crypto crea un objeto hash unidireccional usando algoritmos como `sha256`, `sha512` o `md5`?

## --answers--

`createCipheriv()`

### --feedback--

Este método se usa a menudo para hashear contraseñas y crear huellas digitales de archivos.

---

`createDiffieHellman()`

### --feedback--

Este método se usa a menudo para hashear contraseñas y crear huellas digitales de archivos.

---

`createSign()`

### --feedback--

Este método se usa a menudo para hashear contraseñas y obtener la huella digital de archivos.

---

`createHash()`

## --video-solution--

4
