---
id: 657f456223b8c1187b461987
title: Paso 19
challengeType: 20
dashedName: step-19
---

# --description--

En Python, una <dfn>list comprehension</dfn> es una estructura que te permite generar una nueva lista aplicando una expresión a cada elemento de un iterable existente y, opcionalmente, filtrando elementos con una condición. Además de ser más breve, las list comprehensions suelen ejecutarse más rápido.

Una comprensión de listas básica consiste en una expresión seguida de una cláusula `for`:

```py
spam = [i * 2 for i in iterable]
```

Lo anterior usa la variable `i` para iterar sobre `iterable`. Cada elemento de la lista resultante se obtiene evaluando la expresión `i * 2` en la iteración actual.

En este paso, necesitas llenar la lista vacía `snake_cased_char_list` usando la sintaxis de comprensión de listas.

Convierte tu lista vacía en una estructura de comprensión de listas que convierta cada carácter en `pascal_or_camel_cased_string` en un carácter en minúscula y le anteponga un guion bajo (el código que comentaste antes puede ayudarte a escribir la expresión). Usa `char` para iterar sobre `pascal_or_camel_cased_string`. 

# --hints--

Debes convertir `snake_cased_char_list` en una comprensión de listas que itere sobre `pascal_or_camel_cased_string`.

```js
({ 
    test: () => assert(runPython(`
    iters = _Node(_code).find_function("convert_to_snake_case").find_variable("snake_cased_char_list").find_comp_iters()
    len(iters) == 1 and iters[0].is_equivalent("pascal_or_camel_cased_string")
    `)) 
})
```

Tu comprensión de listas debe usar `char` para iterar sobre `pascal_or_camel_cased_string`.

```js
({ 
    test: () => assert(runPython(`
    targets = _Node(_code).find_function("convert_to_snake_case").find_variable("snake_cased_char_list").find_comp_targets()
    len(targets) == 1 and targets[0].is_equivalent("char")
    `)) 
})
```

Tu comprensión de listas debe evaluar `'_' + char.lower()` para cada `char` en `pascal_or_camel_cased_string`.

```js
({ 
    test: () => assert(runPython(`
    target_var = _Node(_code).find_function("convert_to_snake_case").find_variable("snake_cased_char_list")
    target_var.find_comp_expr().is_equivalent("'_' + char.lower()") and len(target_var.find_comp_ifs()) == 0
    `)) 
})
```

# --seed--

## --seed-contents--

```py
def convert_to_snake_case(pascal_or_camel_cased_string):
    # snake_cased_char_list = []
    # for char in pascal_or_camel_cased_string:
    #     if char.isupper():
    #       converted_character = '_' + char.lower()
    #       snake_cased_char_list.append(converted_character)
    #     else:
    #         snake_cased_char_list.append(char)
    # snake_cased_string = ''.join(snake_cased_char_list)
    # clean_snake_cased_string = snake_cased_string.strip('_')

    # return clean_snake_cased_string

--fcc-editable-region--
    snake_cased_char_list = []
--fcc-editable-region--
    return ''.join(snake_cased_char_list).strip('_')

def main():
    print(convert_to_snake_case('aLongAndComplexString'))

main()
```
