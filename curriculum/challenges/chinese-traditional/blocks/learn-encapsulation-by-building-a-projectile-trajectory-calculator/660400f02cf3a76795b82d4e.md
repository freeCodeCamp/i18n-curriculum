---
id: 660400f02cf3a76795b82d4e
title: 步驟 4
challengeType: 20
dashedName: step-4
---

# --description--

首先要設定的是一個計算拋射物位移的方法，也就是從拋出到拋射物接觸地面時所移動的水平距離。

創建一個只有 `self` 參數的 `__calculate_displacement` 方法，並傳回拋射物的位移。

使用以下公式計算拋射物位移：  
\\[ d = \frac{v \cdot \cos\theta \cdot \left(v\cdot\sin\theta + \sqrt{v^2 \cdot \sin^2\theta + 2 \cdot g \cdot h}\right)}{g} \\]

其中 $d$ 是位移，$v$ 是起始速度，$\theta$ 是角度，$h$ 是拋射物的起始高度。  
對於 $g$，你可以使用 `GRAVITATIONAL_ACCELERATION` 變數。

你應該使用三角函數的 `math.cos()` 和 `math.sin()` 方法，以及用 `math.sqrt()` 計算平方根。你也應該知道 $x^y$ 在 python 中寫作 `x ** y`。另外，$\sin^2\theta$ 表示先計算正弦值，然後將該值平方。

請記住，使用名稱改寫時，如果你想測試，則需要以 `_Projectile__calculate_displacement` 呼叫該方法，或從類別外部使用它：

```py
ball = Projectile(10, 3, 45)
displacement_of_ball = ball._Projectile__calculate_displacement() # 12.6173996009878
```

# --hints--

你應該宣告一個名為 `__calculate_displacement` 的方法，使用 `def __calculate_displacement(self):`。

```js
({test: () => assert(runPython(`_Node(_code).find_class("Projectile").has_function("__calculate_displacement")`))})
```

`__calculate_displacement` 方法應該只包含 `self` 引數。

```js
({test: () => assert(runPython(`_Node(_code).find_class("Projectile").find_function("__calculate_displacement").has_args('self')`))})
```

`__calculate_displacement` 方法應該傳回正確的值。

```js
({test: () => assert(runPython(`
p = Projectile(20, 21, 22)
disp = p._Projectile__calculate_displacement()
round(disp, 2) == 55.06 and round(disp, 2) != disp
`))})
```

# --seed--

## --seed-contents--

```py
import math

GRAVITATIONAL_ACCELERATION = 9.81
PROJECTILE = "∙"
x_axis_tick = "T"
y_axis_tick = "⊣"

class Projectile:
    __slots__ = ('__speed', '__height', '__angle')

    def __init__(self, speed, height, angle):
        self.__speed = speed
        self.__height = height
        self.__angle = math.radians(angle)
        
--fcc-editable-region--
    
--fcc-editable-region--
```
