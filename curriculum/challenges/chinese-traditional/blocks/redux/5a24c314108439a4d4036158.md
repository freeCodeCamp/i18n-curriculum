---
id: 5a24c314108439a4d4036158
title: 永遠不要變更狀態
challengeType: 6
forumTopicId: 301445
dashedName: never-mutate-state
---

# --description--

這些最終挑戰描述了在 Redux 中強制執行狀態不變性這一關鍵原則的幾種方法。不變的狀態表示你永遠不會直接修改狀態，而是傳回狀態的新副本。

如果你在一段時間內擷取 Redux 應用程式狀態的螢幕快照，你會看到類似 `state 1`、`state 2`、`state 3`、`state 4`、`...` 等等，每個狀態可能與上一個相似，但每個都是一個獨立的資料。事實上，這種不變性正是提供你可能聽過的時間旅行偵錯等特性的原因。

Redux 不會在其儲存區或 reducers 中作用性地強制執行狀態的不變性，這項責任落在程式設計師身上。幸運的是，JavaScript（特別是 ES6）提供了幾個有用的工具，你可以用來強制執行狀態的不變性，無論它是 `string`、`number`、`array` 或 `object`。請注意，字串和數字是原始值，天生就是不可變的。換句話說，3 永遠是 3。你無法改變數字 3 的值。然而，`array` 或 `object` 是可變的。實務上，你的狀態很可能由 `array` 或 `object` 組成，因為這些是表述多種類型資訊的有用資料結構。

# --instructions--

程式碼編輯器中有一個 `store` 和 `reducer` 用於管理待辦事項。完成在 reducer 中撰寫 `ADD_TO_DO` 的案例，以將新的待辦事項附加到狀態中。使用標準 JavaScript 或 ES6 有幾種方法可以達成此目的。看看你是否能找到一種方法，傳回一個新的陣列，並將來自 `action.todo` 的條款附加到陣列末端。

# --hints--

Redux store 應該存在並以與程式碼編輯器中 `todos` 陣列相等的狀態初始化。

```js
assert(
  (function () {
    const todos = [
      'Go to the store',
      'Clean the house',
      'Cook dinner',
      'Learn to code'
    ];
    const initialState = store.getState();
    return (
      Array.isArray(initialState) && initialState.join(',') === todos.join(',')
    );
  })()
);
```

`addToDo` 和 `immutableReducer` 都應該是函式（程式）。

```js
assert(typeof addToDo === 'function' && typeof immutableReducer === 'function');
```

在 Redux 儲存庫上分派型別為 `ADD_TO_DO` 的動作應該會添加一個 `todo` 項目，且不應該變更狀態。

```js
const initialState = store.getState();
const isFrozen = !!DeepFreeze(initialState);
store.dispatch(addToDo('__TEST__TO__DO__'));
const finalState = store.getState();
const expectedState = [
  'Go to the store',
  'Clean the house',
  'Cook dinner',
  'Learn to code',
  '__TEST__TO__DO__'
];
assert(isFrozen);
assert.deepEqual(finalState, expectedState);
```

# --seed--

## --seed-contents--

```js
const ADD_TO_DO = 'ADD_TO_DO';

// A list of strings representing tasks to do:
const todos = [
  'Go to the store',
  'Clean the house',
  'Cook dinner',
  'Learn to code',
];

const immutableReducer = (state = todos, action) => {
  switch(action.type) {
    case ADD_TO_DO:
      // Don't mutate state here or the tests will fail
      return
    default:
      return state;
  }
};

const addToDo = (todo) => {
  return {
    type: ADD_TO_DO,
    todo
  }
}

const store = Redux.createStore(immutableReducer);
```

# --solutions--

```js
const ADD_TO_DO = 'ADD_TO_DO';

const todos = [
  'Go to the store',
  'Clean the house',
  'Cook dinner',
  'Learn to code',
];

const immutableReducer = (state = todos, action) => {
  switch(action.type) {
    case ADD_TO_DO:
      return state.concat(action.todo);
    default:
      return state;
  }
};

const addToDo = (todo) => {
  return {
    type: ADD_TO_DO,
    todo
  }
}

const store = Redux.createStore(immutableReducer);
```
