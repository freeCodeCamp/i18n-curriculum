---
id: 67f39b40deaec81a3e40e0c5
title: Revisão dos Conceitos Básicos de Python
challengeType: 31
dashedName: review-python-basics
---

# --description--

## O que é Python?

- **Introdução**: Python é uma linguagem de programação de uso geral conhecida por sua simplicidade e facilidade de uso. Python é usado em muitos campos como ciência de dados e aprendizado de máquina, desenvolvimento web, scripting e automação, sistemas embarcados e IoT e muito mais.
- **Casos de Uso Comuns**: Python é usado em ciência de dados, aprendizado de máquina, desenvolvimento web, cibersegurança, automação e microcomputadores como o Raspberry Pi e placas compatíveis com MicroPython.

## Python no Seu Ambiente Local

- **Instalação**: A melhor forma de instalar Python no Windows, Mac e Linux é baixar o instalador do site oficial do Python (`https://www.python.org/`).

## Variáveis

- **Declarando Variáveis**: Para declarar uma variável, você começa com o nome da variável seguido pelo operador de atribuição (`=`) e então o tipo de dado. Isso pode ser um número, string, boolean, etc. Aqui estão alguns exemplos:

```py
name = 'John Doe'
age = 25
```

- **Convenções de Nomenclatura para Variáveis**: Aqui estão as convenções de nomenclatura que você deve usar para variáveis:

  - Nomes de variáveis só podem começar com uma letra ou um underscore (_), não com um número.
  - Nomes de variáveis só podem conter caracteres alfanuméricos (a-z, A-Z, 0-9) e underscores (_).
  - Nomes de variáveis são sensíveis a maiúsculas e minúsculas — `age`, `Age` e `AGE` são todos considerados únicos.
  - Nomes de variáveis não podem ser uma das palavras reservadas do Python, como `if`, `class` e `def`.
  - Nomes de variáveis com múltiplas palavras são separados por underscores. Ex. `snake_case`.


## Comentários

- **Comentários de Linha Única**: Esses tipos de comentários devem ser usados para notas curtas que você deseja deixar no seu código.

```py
# This is a single line comment
```

- **Strings de Múltiplas Linhas**: Esses tipos de strings podem ser usados para deixar notas maiores ou para comentar seções do código.

```py
"""
This is is a multi-line string.
Here is some code commented out.

name = 'John Doe'
age = 25
"""
```

- **Função `print()`**: Para imprimir dados no console, você pode usar a função `print()` assim:

```py
print('Hello world!') # Hello world!
```

## Tipos Comuns de Dados em Python

- **Introdução**: Python é uma linguagem de tipagem dinâmica como JavaScript, o que significa que você não precisa declarar explicitamente os tipos para variáveis. A linguagem sabe qual é o tipo de uma variável com base no que você atribui à variável. 
- **Integer**: Um número inteiro sem decimais:

```py
my_integer_var = 10
print('Integer:', my_integer_var) # Integer: 10
```

- **Float**: Um número com decimais:

```py
my_float_var = 4.50
print('Float:', my_float_var) # Float: 4.50
```

- **Complexo**: Um número com parte real e imaginária:

```py
my_complex_var = 3 + 4j
print('Complex:', my_complex_var) # Complex: (3+4j)
```

- **String**: Uma sequência de caracteres envolvida por aspas:

```py
my_string_var = 'hello'
print('String:', my_string_var) # String: hello
```

- **Booleano**: Um valor que representa `True` ou `False`:

```py
my_boolean_var = True
print('Boolean:', my_boolean_var) # Boolean: True
```

- **Set**: Uma coleção não ordenada de elementos únicos:

```py
my_set_var = {7, 5, 8}
print('Set:', my_set_var) # Set: {7, 5, 8}
```

- **Dicionário**: Uma coleção de pares chave-valor, delimitada por chaves:

```py
my_dictionary_var = {"name": "Alice", "age": 25}
print('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}
```

- **Tuple**: Uma coleção ordenada imutável, delimitada por parênteses:

```py
my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)
```

- **Range**: Uma sequência de números, frequentemente usada em loops:

```py
my_range_var = range(5)
print(my_range_var) # range(0, 5)
```

- **Lista**: Uma coleção ordenada de elementos que suporta diferentes tipos de dados:

```py
my_list = [22, 'Hello world', 3.14, True]
print(my_list) # [22, 'Hello world', 3.14, True]
```

- **None**: Um valor especial que representa a ausência de um valor:

```py
my_none_var = None
print('None:', my_none_var) # None: None
```

## Tipos Imutáveis e Mutáveis

- **Tipos Imutáveis**: Esses tipos não podem mudar depois de declarados, embora você possa apontar suas variáveis para algo novo, o que é chamado de reatribuição. Eles incluem integer, float, complex, boolean, string, tuple, range e `None`.
- **Tipos Mutáveis**: Esses tipos podem mudar depois de declarados. Você pode adicionar, remover e atualizar seus itens. Eles incluem tipos de coleção como list, set e dictionary.
- **Função `type()`**: Para ver o tipo de uma variável, você pode usar a função `type()` assim:

```py
greeting = 'Hello there!'
age = 21

print(type(greeting)) # <class 'str'>
print(type(age)) # <class 'int'>
```

- **Função `isinstance()`**: Isso é usado para verificar se uma variável corresponde a um tipo de dado específico:

```py
print(isinstance('Hello world', str)) # True
print(isinstance('John Doe', int)) # False
```

## Trabalhando com Strings

- **Definição**: Como você se lembra do JavaScript, strings são imutáveis o que significa que você não pode alterá-las depois que elas foram criadas. Em Python, você pode usar aspas simples ou duplas. É recomendado escolher uma regra e segui-la:

```py
developer = 'Jessica'
city = 'Los Angeles'
```

- **Acessando Caracteres de Strings**: Você pode acessar caracteres de strings usando a notação de colchetes assim:

```py
my_str = "Hello world"

print(my_str[0])  # H
print(my_str[6])  # w

print(my_str[-1])  # d
print(my_str[-2]) # l
```

- **Escapando Strings**: Você pode usar uma barra invertida (`\`) se sua string contiver aspas assim:

```py
msg = 'It\'s a sunny day'
quote = "She said, \"Hello!\""
```

- **Concatenação de Strings**: Para concatenar strings, você pode usar o operador `+` assim:

```py
developer = 'Jessica'
print('My name is ' + developer + '.') # My name is Jessica
```

Outra forma de concatenar strings é usando o operador `+=`. Isto é usado para realizar concatenação e atribuição na mesma etapa assim:

```py
greeting = 'My name is '
developer = 'Jessica.'

greeting += developer
print(greeting) # My name is Jessica.
```

- **`f-strings`**: Isso é a abreviação de formatted string literals. Permite que você faça interpolação e também alguma concatenação com uma sintaxe compacta e legível:

```py
developer = 'Jessica'
greeting = f'My name is {developer}.'
print(greeting) # My name is Jessica.
```

- **Fatiamento de String**: Isso é quando você pode extrair partes de uma string. Aqui está a sintaxe básica:

```py
str[start:stop:step]
```

A posição inicial representa o índice onde a extração deve começar. A posição de parada é onde o slice deve terminar. Esta posição não é inclusiva. A posição do passo representa o intervalo para incrementar no fatiamento. Aqui estão alguns exemplos:

```py
message = 'Python is fun!'

print(message[0:6])  # Python
print(message[7:])  # is fun!
print(message[::2])  # Pto sfn
```

- **Obtendo o Comprimento de uma String**: A função `len()` é usada para retornar o número de caracteres na string:

```py
developer = 'Jessica'

print(len(developer)) # 7
```

## Trabalhando com o operador `in`

- **Operador `in`**: Isso retorna um booleano que especifica se o caractere ou os caracteres existem na string ou não:

```py
my_str = 'Hello world'

print('Hello' in my_str)  # True
print('hey' in my_str)    # False
print('hi' in my_str)    # False
print('e' in my_str)  # True
print('f' in my_str)  # False
```

## Métodos Comuns de String

- **`str.upper()`**: Isso retorna uma nova string com todos os caracteres convertidos para maiúsculas:

```py
developer = 'Jessica'

print(developer.upper()) # JESSICA
```

- **`str.lower()`**: Isso retorna uma nova string com todos os caracteres convertidos para minúsculas:

```py
developer = 'Jessica'

print(developer.lower()) # jessica
```

- **`str.strip()`**: Isso retorna uma cópia da string com os caracteres especificados no início e no fim removidos (se nenhum argumento for passado para o método, ele remove os espaços em branco no início e no fim).

```py
greeting = '  hello world  '

trimmed_my_str = greeting.strip()
print(trimmed_my_str)  # 'hello world'
```

- **`replace()`**: Isso retorna uma nova string com todas as ocorrências da string antiga substituídas por uma nova.

```py
greeting = 'hello world'

replaced_my_str = greeting.replace('hello', 'hi')
print(replaced_my_str)  # 'hi world'
```

- **`split()`**: Isso é usado para dividir uma string em uma lista usando um separador especificado. Um separador é uma string que especifica onde a divisão deve acontecer.

```py
dashed_name = 'example-dashed-name'

split_words = dashed_name.split('-')
print(split_words)  # ['example', 'dashed', 'name']
```

- **`join()`**: Isso é usado para juntar elementos de um iterável em uma string com um separador. Um iterável é uma coleção de elementos que podem ser percorridos como uma lista, string ou uma tupla. 

```py
example_list = ['example', 'dashed', 'name']

joined_str = ' '.join(example_list)
print(joined_str)  # example dashed name
```

- **`str.startswith(prefix)`**: Isso retorna um booleano indicando se uma string começa com o prefixo especificado:

```py
developer = 'Naomi'

result = developer.startswith('N')
print(result)  # True
```

- **`str.endswith(suffix)`**: Isso retorna um booleano indicando se uma string termina com o sufixo especificado:

```py
developer = 'Naomi'

result = developer.endswith('N')
print(result)  # False
```

- **`str.find()`**: Isso retorna o índice da primeira ocorrência de uma substring. Se nenhuma for encontrada, então `-1` é retornado:

```py
developer = 'Naomi'

result = developer.find('N')
print(result)  # 0

city = 'Los Angeles'
print(city.find('New')) # -1
```

- **`str.count(substring)`**: Isso conta quantas vezes uma substring aparece em uma string:

```py
city = 'Los Angeles'
print(city.count('e')) # 2
```

- **`str.capitalize()`**: Isso retorna uma nova string com o primeiro caractere em maiúscula e os outros caracteres em minúscula:

```py
dessert = 'chocolate cake'
print(dessert.capitalize()) # Chocolate cake
```

- **`str.isupper()`**: Isso retorna `True` se todas as letras na string estiverem em maiúsculas e `False` caso contrário:

```py
dessert = 'chocolate cake'
print(dessert.isupper()) # False
```

- **`str.islower()`**: Isso retorna `True` se todas as letras na string estiverem em minúsculas e `False` caso contrário:

```py
dessert = 'chocolate cake'
print(dessert.islower()) # True
```

- **`str.title()`**: Isso retorna uma nova string com a primeira letra de cada palavra em maiúscula:

```py
city = 'los angeles'
print(city.title()) # Los Angeles
```

- **`str.maketrans()`**: Este método é usado para criar uma tabela de mapeamentos de caracteres 1 para 1 para tradução. Ele é frequentemente usado com o método `translate()` que aplica essa tabela a uma string e retorna o resultado traduzido.

```py
trans_table = str.maketrans('abc', '123')
print(trans_table) # {97: 49, 98: 50, 99: 51}

result = 'abcabc'.translate(trans_table)
print(result)  # 123123
```

## Operações Comuns usadas com Integers e Floats

- **Operações Matemáticas Básicas**: Em Python, você pode fazer operações matemáticas básicas com inteiros e floats incluindo adição, subtração, multiplicação e divisão:

```py
int_1 = 56
int_2 = 12
float_1 = 5.4
float_2 = 12.0

# Addition

print('Integer Addition:', int_1 + int_2) # Integer Addition: 68
print('Float Addition:', float_1 + float_2) # Float Addition: 17.4

# Subtraction

print('Int Subtraction:', int_1 - int_2) # Int Subtraction: 44
print('Float Subtraction:',  float_2 - float_1) # Float Subtraction: 6.6

# Multiplication

print('Int Multiplication:', int_1 * int_2) # Int Multiplication: 672
print('Float Multiplication:', float_2 * float_1) # Float Multiplication: 64.80000000000001

# Division

print('Int Division:', int_1 / int_2) # Int Division: 4.666666666666667
print('Float Division:', float_2 / float_1) # Float Division: 2.222222222222222
```

Quando você adiciona um float e um inteiro, o resultado será convertido para um float assim:

```py
int_1 = 56
float_1 = 5.4

print(int_1 + float_1) # 61.4
```

- **Operador Módulo (`%`)**: Isso retorna o resto quando um número é dividido por outro número:

```py
int_1 = 56
int_2 = 12

print(int_1 % int_2) # 8
```

- **Divisão Inteira (`//`)**: Este operador é usado para dividir dois números e arredondar para baixo o resultado para o número inteiro mais próximo:

```py
int_1 = 56
int_2 = 12

print(int_1 // int_2) # 4
```

- **Operador de Exponenciação (`**`)**: Este operador é usado para elevar um número à potência de outro:

```py
int_1 = 4
int_2 = 2

print(int_1 ** int_2) # 16
```

- **Função `float()`**: Você pode usar esta função para converter um inteiro em float.

```py
num = 4

print(float(num)) # 4.0
```

- **Função `int()`**: Você pode usar esta função para converter um float em um inteiro.

```py
num = 4.0

print(int(num)) # 4
```

- **Função `round()`**: Esta é usada para arredondar um número para o inteiro mais próximo:

```py
num_1 = 3.4
num_2 = 7.7

print(round(num_1)) # 3
print(round(num_2)) # 8
```

- **Função `abs()`**: Esta é usada para retornar o valor absoluto de um número:

```py
num = -13

print(abs(num)) # 13
```

- **Função `bin()`**: Esta é usada para converter um inteiro em sua representação binária como uma string:

```py
num = 56

print(bin(num))  # 0b111000
```

- **Função `oct()`**: Esta é usada para converter um inteiro em sua representação octal como uma string:

```py
num = 56

print(oct(num))  # 0o70
```

- **Função `hex()`**: Esta é usada para converter um inteiro em sua representação hexadecimal como uma string:

```py
num = 56

print(hex(num))  # 0x38
```

- **Função `pow()`**: Esta é usada para elevar um número à potência de outro:

```py
result = pow(2, 3) 
print(result)  # 8
```

## Atribuições Aumentadas

- **Definição**: A atribuição aumentada combina uma operação binária com uma atribuição em um único passo. Ela pega uma variável, aplica uma operação nela com outro valor e armazena o resultado de volta na mesma variável.

```py
# Addition assignment 
my_var = 10
my_var += 5

print(my_var) # 15

# Subtraction assignment
count = 14
count -= 3

print(count) # 11

# Multiplication assignment 
product = 65
product *= 7

print(product) # 455

# Division assignment 
price = 100
price /= 4

print(price) # 25.0

# Floor Division assignment 
total_pages = 23
total_pages //= 5

print(total_pages) # 4

# Modulus assignment 
bits = 35
bits %= 2

print(bits) # 1

# Exponentiation assignment 
power = 2
power **= 3

print(power) # 8
```

Existem outros operadores de atribuição aumentada também, como aqueles para operadores bit a bit. Eles incluem `&=`, `^=`, `>>=` e `<<=`.

## Trabalhando com Funções

- **Definição**: Funções são pedaços reutilizáveis de código que recebem entradas (argumentos) e retornam uma saída. Para chamar uma função, você precisa referenciar o nome da função seguido por um conjunto de parênteses:

```py
# Defining a function

def get_sum(num_1, num_2):
    return num_1 + num_2

result = get_sum(3, 4) # function call
print(result) # 7
```

Se uma função não retornar explicitamente um valor, então o valor de retorno padrão é `None`:

```py
def greet():
    print('hello') 

result = greet() # hello
print(result) # None
```

Você também pode fornecer valores padrão para parâmetros assim:

```py
def get_sum(num_1, num_2=2):
    return num_1 + num_2

result = get_sum(3) 
print(result) # 5
```

Se você chamar a função sem o número correto de argumentos, você receberá um `TypeError`:

```py
def calculate_sum(a, b):
    print(a + b)

calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'
```

## Funções Internas Comuns

- **Função `input()`**: Esta é usada para solicitar uma entrada do usuário:

```py
name = input('What is your name?') # User types 'Kolade' and presses Enter  
print('Hello', name) # Hello Kolade
```

- **Função `int()`**: Esta é usada para converter um número, booleano ou uma string numérica em um inteiro:

```py
print(int(3.14)) # 3
print(int('42')) # 42
print(int(True)) # 1
print(int(False)) # 0 
```

## Decorators

- **Definição**: Decorators são um tipo especial de função em Python. Eles são como invólucros para outras funções, então recebem outra função como argumento.

```py
def say_hello():
    name = input('What is your name? ')
    return 'Hello ' + name

def uppercase_decorator(func):
    def wrapper():
        original_func = func()
        modified_func = original_func.upper()
        return modified_func
    return wrapper

say_hello_res = uppercase_decorator(say_hello)

print(say_hello_res())
```

## Escopo em Python

- **Escopo Local**: Isso ocorre quando uma variável declarada dentro de uma função ou classe só pode ser acessada dentro dessa função ou classe.

```py
def my_func():
    num = 10
    print(num)
```

- **Escopo Envolvente**: Isso ocorre quando uma função que está aninhada dentro de outra função pode acessar as variáveis da função na qual está aninhada.

```py
def outer_func():
    msg = 'Hello there!'
    
    def inner_func():
        print(msg)
    inner_func()

print(outer_func()) # Hello there!
```

- **Escopo Global**: Isso se refere a variáveis que são declaradas fora de qualquer função ou classe que podem ser acessadas de qualquer lugar no programa.

```py
tax = 0.70 

def get_total(subtotal):
    total = subtotal + (subtotal * tax)
    return total

print(get_total(100))  # 170.0
```

- **Escopo Embutido**: Nomes reservados em Python para funções, módulos, palavras-chave e objetos pré-definidos.

```py
print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False
```

## Operadores de Comparação

- **Igual (`==`)**: Verifica se dois valores são iguais:

```py
print(3 == 4) # False
```

- **Diferente (`!=`)**: Verifica se dois valores não são iguais:

```py
print(3 != 4) # True
```

- **Estritamente maior que (`>`)**: Verifica se um valor é maior que outro:

```py
print(3 > 4) # False
```

- **Estritamente menor que (`<`)**: Verifica se um valor é menor que outro:

```py
print(3 < 4) # True
```

- **Maior ou igual a (`>=`)**: Verifica se um valor é maior ou igual a outro:

```py
print(3 >= 4) # False
```

- **Menor ou igual(`<=`)**: Verifica se um valor é menor ou igual a outro:

```py
print(3 <= 4) # True
```

## Trabalhando com as declarações `if`, `elif` e `else`

- **`if` Statements**: Estas são condições usadas para determinar se algo é verdadeiro ou não. Se a condição for avaliada como `True`, então aquele bloco de código será executado.

```py
age = 18

if age >= 18:
    print('You are an adult') # You are an adult
```

- **Declaração `elif`**: Estas são condições que vêm depois de uma declaração `if`. Se a condição `elif` for avaliada como `True`, então esse bloco de código será executado.

```py
age = 16

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')  # You are a teenager
```

- **Cláusula `else`**: Isso será executado se nenhuma outra condição for avaliada como `True`.

```py
age = 12

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')
else:
    print('You are a child')  # You are a child
```

Você também pode usar declarações `if` aninhadas assim:

```py
is_citizen = True
age = 25

if is_citizen:
    if age >= 18:
        print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

## Valores Truthy e Falsy

- **Definição**: Em Python, todo valor tem um valor booleano inerente, ou um sentido embutido de se ele deve ser tratado como `True` ou `False` em um contexto lógico. Muitos valores são considerados truthy, isto é, eles avaliam para `True` em um contexto lógico. Outros são falsy, significando que eles avaliam para `False`. Aqui estão alguns exemplos de valores falsy:

```md
None
False
Integer 0
Float 0.0
Empty strings ''
```

Outros valores como números diferentes de zero e strings não vazias são truthy.

## Trabalhando com a Função `bool()`

- **Definição**: Se você quiser verificar se um valor é truthy ou falsy, pode usar a função embutida `bool()`. Ela converte explicitamente um valor para seu equivalente booleano e retorna `True` para valores truthy e `False` para valores falsy. Aqui estão alguns exemplos:

```py
print(bool(False)) # False
print(bool(0))  # False
print(bool('')) # False

print(bool(True)) # True
print(bool(1)) # True
print(bool('Hello')) # True
```

## Operadores Booleanos e Short-circuiting

- **Definição**: Estes são operadores especiais que permitem combinar múltiplas expressões para criar uma lógica de tomada de decisão mais complexa no seu código. Existem três operadores Booleanos em Python: `and`, `or` e `not`.
- **Operador `and`**: Este operador recebe dois operandos e retorna o primeiro operando se ele for falso, caso contrário, retorna o segundo operando. Ambos os operandos devem ser verdadeiros para que uma expressão resulte em um valor verdadeiro.

```py
is_citizen = True
age = 25

print(is_citizen and age) # 25
```

Você também pode usar o operador `and` em condicionais assim:

```py
is_citizen = True
age = 25

if is_citizen and age >= 18:
    print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

- **Operador `or`**: Este operador retorna o primeiro operando se ele for truthy, caso contrário, retorna o segundo operando. Uma expressão or resulta em um valor truthy se pelo menos um operando for truthy. Aqui está um exemplo:

```py
age = 19
is_employed = False

print(age or is_employed) # 19
```

Assim como com o operador `and`, você pode usar o operador `or` em condicionais assim:

```py
age = 19
is_student = True

if age < 18 or is_student:
    print('You are eligible for a student discount') # You are eligible for a student discount
else:
    print('You are not eligible for a student discount')
```

- **Curto-circuito**: Os operadores `and` e `or` são conhecidos como operadores de curto-circuito. Curto-circuito significa que o Python verifica os valores da esquerda para a direita e para assim que determina o resultado final.
- **Operador `not`**: Este operador recebe um único operando e inverte seu valor booleano. Ele converte valores truthy em `False` e valores falsy em `True`. Diferente dos operadores anteriores que vimos, `not` sempre retorna `True` ou `False`. Aqui estão alguns exemplos:

```py
print(not '') # True, because empty string is falsy
print(not 'Hello') # False, because non-empty string is truthy
print(not 0) # True, because 0 is falsy
print(not 1) # False, because 1 is truthy
print(not False) # True, because False is falsy
print(not True) # False, because True is truthy
```

Aqui está um exemplo do operador `not` em uma condicional: 

```py
is_admin = False

if not is_admin:
    print('Access denied for non-administrators.') # Access denied for non-administrators.
else:
    print('Welcome, Administrator!')
```

# --assignment--

Revise os tópicos e conceitos básicos de Python.
