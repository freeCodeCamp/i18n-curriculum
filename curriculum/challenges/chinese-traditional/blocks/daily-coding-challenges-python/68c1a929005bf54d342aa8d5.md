---
id: 68c1a929005bf54d342aa8d5
title: "挑戰 58：太空週第 4 天：著陸點"
challengeType: 29
dashedName: challenge-58
---

# --description--

在太空週的第四天，你會得到一個數字矩陣（陣列的陣列），表述你探測車的潛在著陸點。根據以下規則找到最安全的著陸點：

- 矩陣中的每個位置都會包含一個介於 `0-9`（含）之間的數字。
- 任何 `0` 表示一個潛在的著陸點。
- 任何非 `0` 的數字都太危險而無法著陸。數字越高，危險性越大。
- 最安全的位置定義為 `0` 單元格，其周圍的單元格（最多 4 個鄰居，不包括對角線）具有最低的總危險值。
- 忽略超出範圍的鄰居（角落和邊緣只有較少的鄰居）。
- 傳回最安全著陸點的索引。永遠只有一個最安全的點。

例如，給定：

```js
[
  [1, 0],
  [2, 0]
]
```

傳回 `[0, 1]`，第一個陣列中 `0` 的索引。

# --hints--

`find_landing_spot([[1, 0], [2, 0]])` 應該傳回 `[0, 1]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(find_landing_spot([[1, 0], [2, 0]]), [0, 1])`)
}})
```

`find_landing_spot([[9, 0, 3], [7, 0, 4], [8, 0, 5]])` 應該傳回 `[1, 1]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(find_landing_spot([[9, 0, 3], [7, 0, 4], [8, 0, 5]]), [1, 1])`)
}})
```

`find_landing_spot([[1, 2, 1], [0, 0, 2], [3, 0, 0]])` 應該傳回 `[2, 2]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(find_landing_spot([[1, 2, 1], [0, 0, 2], [3, 0, 0]]), [2, 2])`)
}})
```

`find_landing_spot([[9, 6, 0, 8], [7, 1, 1, 0], [3, 0, 3, 9], [8, 6, 0, 9]])` 應該傳回 `[2, 1]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(find_landing_spot([[9, 6, 0, 8], [7, 1, 1, 0], [3, 0, 3, 9], [8, 6, 0, 9]]), [2, 1])`)
}})
```

# --seed--

## --seed-contents--

```py
def find_landing_spot(matrix):

    return matrix
```

# --solutions--

```py
def find_landing_spot(matrix):
    best_spot = None
    lowest_neighbor_sum = float('inf')

    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            if matrix[i][j] == 0:
                current_neighbor_sum = 0

                if i > 0:
                    current_neighbor_sum += matrix[i - 1][j]
                if j < len(matrix[i]) - 1:
                    current_neighbor_sum += matrix[i][j + 1]
                if i < len(matrix) - 1:
                    current_neighbor_sum += matrix[i + 1][j]
                if j > 0:
                    current_neighbor_sum += matrix[i][j - 1]

                if current_neighbor_sum < lowest_neighbor_sum:
                    lowest_neighbor_sum = current_neighbor_sum
                    best_spot = [i, j]

    return best_spot
```
