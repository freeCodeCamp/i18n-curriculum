---
id: 688291b65db00473e1136725
title: 什麼是 CI/CD，CI 如何與 GitHub Actions 一起運作？
challengeType: 19
dashedName: what-is-ci-cd-and-how-does-ci-work-with-github-actions
---

# --description--

CI 代表持續整合，CD 代表持續交付或持續部署。這些處理程序讓你在確保變更可正常運作後，自動將變更部署到你的應用程式。

在 CI 管線中，你可能會對程式碼執行你的 linter 和測試。CI 管線通常會在 pull request 上執行，以確保所做的更動不會破壞應用程式，也會在 `main` 分支上執行，以確保它已準備好部署。

CD 管線也可能會在 pull requests 上執行，如果你設置了預覽環境，這樣你就可以即時查看變更。但你也會在你的 `main` 分支上執行它，以便在變更被接受並合併後持續部署。

但是這些實際上如何與 GitHub Actions 一起運作？首先，我們需要了解 GitHub Actions 究竟是什麼。GitHub Actions 提供臨時的 runner（可以想像成一台臨時的電腦），讓你能夠執行特定的指令。

動作是使用 YAML 檔案組態的。你可以有多個檔案來指定不同的動作以執行。<dfn>例如</dfn>，你可能有一個檔案用於你的 CI，另一個用於你的 CD。

讓我們來看看一個基本的 CI 範例：

```yml
name: Node.js CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  lint:
    name: Lint and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Source Files
        uses: actions/checkout@v4

      - name: Use Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10

      - name: Install Dependencies
        run: pnpm install

      - name: Lint Source Files
        run: pnpm run lint

      - name: Verify Build
        run: pnpm run build

      - name: Run Tests
        run: pnpm run test
```

這很多，所以我們來拆解。先看第一部分：

```yml
name: Node.js CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
```

`name` 定義動作本身的名稱。這會出現在像 PR 的狀態檢查區域等地方。`on` 屬性定義所謂的「工作流程觸發器」－這些是會觸發你的動作執行的事件。

在此範例中，我們在提交推送到 `main` 時執行該動作，並且在拉取請求的標的為 `main` 時執行。這表示當有人建立拉取請求時，CI 會執行一次，合併時會再執行一次。

`jobs` 區段是你定義你的 action 實際執行內容的地方。`lint:` 鍵是一個任意鍵，用來定義該工作的內部名稱。`name` 屬性定義此特定工作的外部名稱。而 `runs-on` 屬性定義你的 action 應該在哪種類型的環境中執行－在這個案例中，我們是在最新支援的 Ubuntu 版本中執行。

`steps` 屬性是魔法發生的地方。這個區塊定義了你的動作應該採取的實際步驟。讓我們來看看那裡的第一個區塊：

```yml
      - name: Checkout Source Files
        uses: actions/checkout@v4
```

這個步驟有兩個屬性，`name` 是步驟應該擁有的名稱，還有一個 `uses` 屬性。這個 `uses` 屬性很特別，因為它告訴動作執行器去從 GitHub 取得一個公開動作並執行它，而不是執行一個指令。`actions/checkout` 動作負責在你的執行器中克隆並設定儲存庫。

```yml
      - name: Use Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10
```

接下來的兩個區段也使用第三方動作。這些步驟設定了 Node 和 pnpm 軟體包管理員。它們兩者都有一個 `with` 鍵，你可以用它來傳遞引數給那些第三方動作。把這當作傳遞引數給函式（程式）一樣。

最後四個區塊才是真正發生魔法的地方。

```yml
      - name: Install Dependencies
        run: pnpm install

      - name: Lint Source Files
        run: pnpm run lint

      - name: Verify Build
        run: pnpm run build

      - name: Run Tests
        run: pnpm run test
```

我們有一個 `Install Dependencies` 區塊，會安裝 npm 軟體包。我們的 `Lint Source Files` 區塊會執行 linter，`Verify Build` 區塊確保 Typescript 程式碼可以編譯，而 `Run Tests` 區塊會執行單元測試。

關於 actions 重要的是，預設情況下，如果這些步驟中的一個失敗，剩下的步驟將會被跳過，整個執行將被標記為失敗。

你將 YAML 檔案放在哪裡才能執行這些動作？它們需要放在你的儲存庫中的 `.github/workflows` 目錄，GitHub 才能找到並使用它們。

動作可以做很多額外的事情，我鼓勵你閱讀文件並探索像 freeCodeCamp 倉庫這類專案中現有的動作。但現在，你應該對 GitHub Actions 和 CI/CD 的基礎有相當的了解！

# --questions--

## --text--

在 GitHub Actions 工作流程檔案中，`on` 屬性定義了什麼？

## --answers--

動作的名稱。

### --feedback--

思考你想要你的動作何時自動執行。

---

觸發工作流程執行的事件。

---

要執行的作業系統。

### --feedback--

思考你想要你的動作何時自動執行。

---

執行的步驟。

### --feedback--

思考你想要你的動作何時自動執行。

## --video-solution--

2

## --text--

GitHub Actions 工作流程 YAML 檔案應該放置在儲存庫的哪裡？

## --answers--

在根目錄。

### --feedback--

GitHub 會在特定的目錄結構中尋找工作流程檔案。

---

在 `.github/actions` 目錄中。

### --feedback--

GitHub 會在特定的目錄結構中尋找工作流程檔案。

---

在 `.github/workflows` 目錄中。

---

在 `workflows` 目錄中。

### --feedback--

GitHub 會在特定的目錄結構中尋找工作流程檔案。

## --video-solution--

3

## --text--

當 GitHub Actions 工作流程中的步驟失敗時，預設會發生什麼？

## --answers--

工作流程繼續，並顯示警告。

### --feedback--

考慮 GitHub Actions 如何處理工作流程執行中的錯誤。

---

只有該特定步驟被標記為失敗。

### --feedback--

考慮 GitHub Actions 如何處理工作流程執行中的錯誤。

---

工作流程從頭開始重新啟動。

### --feedback--

考慮 GitHub Actions 如何處理工作流程執行中的錯誤。

---

剩餘步驟將被跳過，且該執行標記為失敗。

## --video-solution--

4
