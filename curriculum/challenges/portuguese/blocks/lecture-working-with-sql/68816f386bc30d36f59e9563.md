---
id: 68816f386bc30d36f59e9563
title: O que é Normalização em SQL?
challengeType: 19
dashedName: what-is-normalization-in-sql
---

# --description--

Normalização é o processo de organizar um banco de dados relacional usando formas normais estabelecidas para reduzir a redundância de dados e melhorar a integridade dos dados.

Para normalizar um banco de dados, você analisa os atributos e relacionamentos nas suas estruturas de tabelas para identificar oportunidades de simplificação com base nas regras de normalização. Então, você divide os dados em tabelas menores e mais focadas e estabelece relacionamentos entre elas usando chaves primárias e estrangeiras. Essas tabelas menores armazenarão todos os dados que você tinha originalmente, mas serão mais fáceis de gerenciar, organizar e trabalhar, em comparação com tabelas maiores.

Ao minimizar a redundância de dados, a normalização reduz o espaço de armazenamento e previne inconsistências. Por exemplo, se o endereço de um cliente mudar, você só precisa atualizá-lo em uma tabela de clientes em vez de em todos os registros de pedidos. 

Também ajuda a preservar a integridade dos dados garantindo que as dependências sejam aplicadas por meio de restrições de chave primária e estrangeira. Isso reduz a probabilidade de anomalias de inserção, atualização e exclusão.

Um banco de dados normalizado é mais fácil de entender e manter, o que contribui para um sistema de banco de dados bem projetado.

O conjunto de regras que você deve seguir para organizar suas tabelas é chamado de formas normais. Cada forma normal se baseia nas anteriores, com regras se tornando mais rigorosas à medida que você avança para formas normais superiores. A Primeira Forma Normal (1NF) é a forma fundamental, com as regras mais básicas.

Uma tabela está na Primeira Forma Normal (1NF) se:

- Cada célula deve conter apenas um valor. Por exemplo, se você tiver uma tabela `students`, pode haver um estudante com vários números de telefone. Em vez de armazená-los como uma lista separada por vírgulas em uma célula, você deve criar uma tabela `phone_numbers` separada com uma chave estrangeira apontando para a tabela `students` e armazenar apenas um valor em cada célula. Isso mantém cada valor atômico e o design normalizado.
- Cada registro (linha) deve ser único. Enquanto as chaves primárias garantem esse requisito, a 1NF exige explicitamente que não existam linhas duplicadas na tabela.
- A ordem das linhas e colunas não deve ser relevante. Os dados não devem depender da sua localização física.

Essencialmente, a Primeira Forma Normal (1NF) foca em tornar os valores simples e atômicos.

A Segunda Forma Normal (2NF) baseia-se na 1NF, exigindo que todos os requisitos da 1NF sejam atendidos além de restrições adicionais.

Entender 2NF requer familiaridade com dois conceitos-chave: superkeys e candidate keys. Uma superchave é qualquer conjunto de atributos que identifica exclusivamente cada linha em uma tabela, significando que nenhuma duas linhas podem ter valores idênticos em todas as colunas da superchave.

Por exemplo, se tivermos uma tabela `customers` com três colunas:

```sql
customer_id | name | email
```

Vamos supor que `customer_id` e `email` devem ser únicos para cada registro. Alguns exemplos de superkeys para esta tabela seriam:

- `customer_id`
- `{ customer_id, name }`, essa combinação identifica linhas de forma única porque `customer_id` sozinho é único, independentemente da unicidade de `name`.
- `{ customer_id, name, email }`
- `email`, já que estamos adicionando a restrição única a esta coluna também, cada registro pode ser identificado de forma única pelo email.

Qualquer conjunto de atributos que, juntos, identificam cada linha pode ser uma superchave.

Uma chave candidata é semelhante e ainda assim, um pouco diferente. É um conjunto de uma ou mais colunas na tabela que podem identificar exclusivamente cada registro. Uma tabela pode ter várias chaves candidatas mas você precisará escolher uma para atuar como a chave primária.

Eles soam bastante semelhantes, certo? A diferença deles é que a superkey também pode conter atributos adicionais que não são necessários para identificar cada linha de forma única, enquanto a candidate key contém apenas atributos que identificam a linha de forma única.

No nosso exemplo de `customers`, mencionamos que `customer_id`, `{ customer_id, name }`, `{ customer_id, name, email }` e `email` podem ser superchaves. Neste caso, somente `customer_id` e `email` podem ser chaves candidatas porque chaves candidatas não podem incluir atributos que não identificam a linha de forma única, como `name`. Isto ilustra o princípio da minimalidade que distingue chaves candidatas de superchaves.

Agora que você está familiarizado com esses conceitos, vamos voltar para a Second Normal Form (2NF).

A Segunda Forma Normal (2NF) é baseada em resolver dependências parciais. Uma dependência parcial ocorre em uma tabela quando um atributo que não faz parte da chave primária depende apenas de parte de uma chave primária composta (uma chave composta é uma chave primária formada por múltiplas colunas). Isso pode levar à redundância de dados e anomalias de atualização.

Por exemplo, digamos que temos uma tabela `orders` com estas colunas:

```sql
order_id | item_id | order_date | quantity | order_shipping_city
```

Nesta tabela, a chave primária é a combinação de `order_id` e `item_id` porque o mesmo ID de item pode estar em pedidos diferentes, mas a combinação deles será única. Você pode ver que há uma dependência parcial entre `order_id` e `order_shipping_city`. `order_id` é parte da chave primária. `order_shipping_city` depende de `order_id` porque todo pedido com o mesmo ID terá a mesma cidade de envio. No entanto, a cidade de envio não depende do `item_id`, mas esta também faz parte da chave primária. Portanto, `order_shipping_city` não depende de toda a chave primária.

Para corrigir isso, você pode dividir a tabela em duas tabelas menores, como `order_header` e `order_items`. Na tabela `order_header`, você pode armazenar as informações de nível superior sobre os pedidos: 

```sql
order_id | order_date | order_shipping_city
```

Na tabela `order_items`, você pode armazenar informações sobre os itens nos diferentes pedidos que foram enviados:

```sql
order_id | item_id | quantity
```

Com essas mudanças, ambas as tabelas estarão na Segunda Forma Normal (2NF).

E isso nos leva à Terceira Forma Normal (3NF). Esta forma normal baseia-se na segunda forma normal.

Para uma tabela estar na Terceira Forma Normal, ela deve:

- Esteja na Segunda Forma Normal.
- Tenha todos os atributos não-chave dependendo diretamente da chave primária, ou seja, nenhum atributo não-chave deve depender de outro atributo não-chave.

Para entender a Terceira Forma Normal (3NF), você precisa entender dependências transitivas. Uma dependência transitiva ocorre quando um atributo que não faz parte da chave primária depende de outro atributo que não faz parte da chave primária, que por sua vez depende da chave primária.

Por exemplo, vamos modificar nossa tabela `orders` para ter essas colunas:

```sql
order_id | customer_id | customer_city | city_postal_code | order_date | quantity
```

A chave primária nesta nova tabela é `order_id` porque ela identifica exclusivamente cada linha.

Há uma dependência transitiva nesta tabela:

```sql
order_id > customer_id > customer_city > city_postal_code
```

O código postal da cidade é determinado pela cidade do cliente, que é determinada pelo ID do cliente, que é determinado pelo ID do pedido. `city_postal_code`, um atributo que não faz parte da chave primária, é determinado por `customer_city`, que também não faz parte da chave primária, mas `customer_city` é determinado por `order_id` através de `customer_id`. Isso significa que o código postal da cidade será repetido para cada pedido feito por clientes que moram na mesma cidade. Isso levará à redundância de dados. Além disso, qualquer alteração no código postal de uma cidade exigiria atualizações em vários registros.

Para resolver a dependência transitiva, você precisaria dividir a tabela em várias tabelas. Primeiro, uma tabela `orders`:

```sql
order_id | customer_id | order_date | quantity
```

Então, uma tabela `customers`:

```sql
customer_id | city_name
```

E uma tabela `cities`:

```sql
city_name | city_postal_code
```

Isso remove a dependência transitiva da tabela.

E finalmente, temos a Boyce-Codd Normal Form (BCNF). Isto também é conhecido como Forma Normal 3.5 porque resolve algumas anomalias que a Terceira Forma Normal pode não resolver. Para uma tabela estar na Boyce-Codd Normal Form (BCNF), ela precisa:

- Esteja na Terceira Forma Normal.
- Tenha todo lado esquerdo de uma dependência funcional como uma superchave.

O objetivo desta forma normal é garantir que todo atributo ou conjunto de atributos que determina outro atributo seja uma superchave, que é uma chave candidata ou um superconjunto delas.

Entender e aplicar as formas normais é essencial para projetar bancos de dados relacionais robustos e eficientes. Ao eliminar a redundância de dados e garantir dependências lógicas de dados, a normalização leva a uma integridade de dados aprimorada, redução dos requisitos de armazenamento e simplificação da manutenção do banco de dados. Você geralmente deve buscar alcançar a Terceira Forma Normal (3NF).

# --questions--

## --text--

Com qual forma normal se preocupa principalmente em substituir grupos de dados dentro de uma única linha por valores únicos?

## --answers--

Primeira Forma Normal (1NF)

---

Segunda Forma Normal (2NF)

### --feedback--

Pense no nível mais básico de organização dentro de uma tabela e no que constitui uma única peça indivisível de dados.

---

Terceira Forma Normal (3NF)

### --feedback--

Pense no nível mais básico de organização dentro de uma tabela e no que constitui uma única peça indivisível de dados.

---

Forma Normal de Boyce-Codd (BCNF)

### --feedback--

Pense no nível mais básico de organização dentro de uma tabela e no que constitui uma única peça indivisível de dados.

## --video-solution--

1

## --text--

Uma tabela está na Segunda Forma Normal (2NF) se estiver na Primeira Forma Normal (1NF) e se alguma das seguintes condições for verdadeira?

## --answers--

Todos os atributos não-chave são transitivamente dependentes da chave primária.

### --feedback--

Pense no problema que a Segunda Forma Normal (2NF) resolve quando uma tabela tem uma chave primária composta.

---

Todos os atributos não-chave são totalmente dependentes funcionalmente de toda a chave primária.

---

Todo determinante é uma chave candidata.

### --feedback--

Pense no problema que a Segunda Forma Normal (2NF) resolve quando uma tabela tem uma chave primária composta.

---

Não há grupos repetidos de dados.

### --feedback--

Pense no problema que a Segunda Forma Normal (2NF) resolve quando uma tabela tem uma chave primária composta.

## --video-solution--

2

## --text--

Qual forma normal trata dependências transitivas, onde um atributo não-chave depende de outro atributo não-chave?

## --answers--

Primeira Forma Normal (1NF)

### --feedback--

Pense nas relações indiretas entre atributos não-chave e a chave primária que esta forma normal visa eliminar.

---

Segunda Forma Normal (2NF)

### --feedback--

Pense nas relações indiretas entre atributos não-chave e a chave primária que esta forma normal visa eliminar.

---

Terceira Forma Normal (3NF)

---

Forma Normal de Boyce-Codd (BCNF)

### --feedback--

Pense nas relações indiretas entre atributos não-chave e a chave primária que esta forma normal visa eliminar.

## --video-solution--

3
