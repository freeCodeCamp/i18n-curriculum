---
id: 587d8257367417b2b2512c7b
title: 為你的 `Binary Search Tree` 添加新元素
challengeType: 1
forumTopicId: 301618
dashedName: add-a-new-element-to-a-binary-search-tree
---

# --description--

這一系列的挑戰將介紹樹狀資料結構。樹是計算機科學中一種重要且多功能的資料結構。當然，它們的名稱來自於當視覺化時，它們看起來非常像我們在自然界中熟悉的樹。樹狀資料結構從一個節點開始，通常稱為根節點，然後從這裡分支出更多節點，每個節點可能有更多的子節點，如此類推。這種資料結構通常以根節點位於頂端來視覺化；你可以將它想像成一棵顛倒過來的自然樹。

首先，讓我們描述一些在樹狀結構中常見的術語。根節點是樹的頂端。樹中的資料點稱為節點。具有分支通往其他節點的節點稱為該分支所通往節點（子節點）的父節點。其他更複雜的親屬術語如你所預期的也適用。子樹指的是特定節點的所有後代，分支可能被稱為邊，葉節點是樹的末端且沒有子節點的節點。最後，請注意樹本質上是遞迴的資料結構。也就是說，任何節點的子節點都是其自身子樹的父節點，依此類推。理解樹的遞迴特性對於設計常見樹操作的演算法非常重要。

首先，我們將討論一種特定型別的樹，二元樹。事實上，我們將實際討論一種特定的二元樹，二元搜尋樹。讓我們描述這是什麼意思。雖然樹資料結構在單一節點可以有任意數量的分支，但二元樹在每個節點只能有兩個分支。此外，二元搜尋樹相對於子樹是有序的，使得左子樹中每個節點的值都小於或相等於父節點的值，而右子樹中每個節點的值都大於或相等於父節點的值。為了更好地理解，將這種關係視覺化非常有幫助：

<div style='width: 100%; display: flex; justify-content: center; align-items: center;'><img alt="an example of a binary search tree" style='width: 100%; max-width: 350px; background-color: var(--gray-05);' src='https://user-images.githubusercontent.com/18563015/32136009-1e665d98-bbd6-11e7-9133-63184f9f9182.png'></div>

現在這種有序關係非常容易看出。請注意，位於根節點 `8` 左側的每個值都小於 `8`，而位於右側的每個值都大於 `8`。同時也注意到這種關係同樣適用於每個子樹。<dfn>例如</dfn>，第一個左子節點是一個子樹。`3` 是父節點，並且它恰好有兩個子節點——根據二元搜尋樹的規則，我們甚至不用看就知道這個節點的左子節點（以及其任何子節點）會小於 `3`，而右子節點（以及其任何子節點）會大於 `3`（但也小於該結構的根節點值），依此類推。

二元搜尋樹是非常常見且有用的資料結構，因為它們在平均情況下為多種常見的操作行為（例如查找、插入和刪除）提供對數時間。

# --instructions--

我們將從簡單開始。我們在這裡定義了二元搜尋樹結構的骨架，並且創建了一個用於產生樹節點的函式。請注意，每個節點可能有左值和右值。如果存在子樹，這些將被指定為子樹。在我們的二元搜尋樹中，你將創建一個用於為樹添加新值的行為。該行為應該稱為 `add`，並且應該接受一個整數值以添加到樹中。請注意維護二元搜尋樹的不變條件：每個左子節點的值應該小於或相等於父節點的值，而每個右子節點的值應該大於或相等於父節點的值。在這裡，我們設定樹中不能有重複值。如果你嘗試添加已存在的值，該行為應該傳回 `null`。否則，如果添加成功，應該傳回 `undefined`。

**提示：**樹狀結構本質上是遞迴的資料結構！

# --hints--

應該存在 `BinarySearchTree` 資料結構。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    }
    return typeof test == 'object';
  })()
);
```

二元搜尋樹應該有一個名為 `add` 的方法。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    return typeof test.add == 'function';
  })()
);
```

add 方法應該根據二元搜尋樹規則添加元素。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    if (typeof test.add !== 'function') {
      return false;
    }
    test.add(4);
    test.add(1);
    test.add(1);
    test.add(7);
    test.add(87);
    test.add(34);
    test.add(45);
    test.add(73);
    test.add(8);
    const expectedResult = [1, 4, 7, 8, 34, 45, 73, 87];
    const result = test.inOrder();
    return expectedResult.toString() === result.toString();
  })()
);
```

新增已存在的元素應該傳回 `null`。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    if (typeof test.add !== 'function') {
      return false;
    }
    test.add(4);
    return test.add(4) == null;
  })()
);
```

# --seed--

## --after-user-code--

```js
BinarySearchTree.prototype = Object.assign(
  BinarySearchTree.prototype,
  {
    inOrder() {
      if (!this.root) {
        return null;
      }
      var result = new Array();
      function traverseInOrder(node) {
        node.left && traverseInOrder(node.left);
        result.push(node.value);
        node.right && traverseInOrder(node.right);
      }
      traverseInOrder(this.root);
      return result;
    }
  }
);
```

## --seed-contents--

```js
var displayTree = tree => console.log(JSON.stringify(tree, null, 2));
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}
function BinarySearchTree() {
  this.root = null;
  // Only change code below this line
  
  // Only change code above this line
}
```

# --solutions--

```js
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}
function BinarySearchTree() {
  this.root = null;
  this.add = function(element) {
    let current = this.root;
    if (!current) {
      this.root = new Node(element);
      return;
    } else {
      const searchTree = function(current) {
        if (current.value > element) {
          if (current.left) {
            return searchTree(current.left);
          } else {
            current.left = new Node(element);
            return;
          }
        } else if (current.value < element) {
          if (current.right) {
            return searchTree(current.right);
          } else {
            current.right = new Node(element);
            return;
          }
        } else {
          return null;
        }
      };
      return searchTree(current);
    }
  };
}
```
