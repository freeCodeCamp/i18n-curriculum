---
id: 68829116a80ecd73681261b1
title: Quais São as Boas Práticas para Manter a Sincronização com Seus Contrapartes Remotas?
challengeType: 19
dashedName: what-are-good-practices-for-remaining-in-sync-with-your-remote-counterparts
---

# --description--

Falamos um pouco sobre usar branches para trabalhar em mudanças isoladas e evitar sujar seu branch `main`. Mas o que isso significa e por que é importante?

Se você fizer commit de alterações diretamente no seu branch `main` e o repositório upstream aceitar outras alterações que não são suas, você acabará com algo chamado "histórico divergente". Isso significa que os commits no seu branch `main` não estão mais alinhados com os commits no branch `main` do upstream. E isso torna a sincronização das alterações do upstream um pesadelo.

Então, digamos que você tenha seguido boas práticas de branching e isso não seja um problema. Se você acompanhou nossas lições anteriores, deve ter um fork de um repositório que você clonou localmente e deve ter um remote upstream que aponta para o repositório original.

Se você não fez isso, aqui está um lembrete rápido. Você vai querer fazer um fork de um repositório, clonar seu fork localmente e executar este comando:

```sh
git remote add upstream <url>
```

Substitua `<url>` pela URL SSH do repositório original, NÃO pelo seu fork.

Com um upstream configurado corretamente, você pode executar a seguinte série de comandos para puxar as últimas alterações do upstream:

```sh
git checkout main
git fetch upstream
git merge upstream/main
```

O que isso faz? Bem, você aprendeu sobre `git checkout`, então o primeiro comando garante que você esteja na sua branch `main` localmente.

O segundo comando, `git fetch upstream`, instrui o Git a buscar as últimas alterações que estão no seu remoto upstream (que é o repositório original). No entanto, diferente de um pull, o Git não atualizará automaticamente sua branch. Isso é importante, porque sua branch `main` localmente está conectada à branch `main` no seu fork - não à branch `main` no repositório original! Executar um git pull pode resultar em um comportamento inesperado.

O comando final, `git merge upstream/main`, diz ao Git para mesclar as últimas alterações do branch `main` no repositório remoto upstream para o seu branch atual - que é o seu branch local `main`, porque foi isso que fizemos checkout.

Mas e se a mesclagem falhar? E se você acidentalmente tiver feito um commit em `main` e o Git não conseguir mesclar os históricos divergentes? Bem... assumindo que você não tenha feito nenhum pull request a partir do seu branch `main`, você pode fazer um hard reset para forçar o Git a atualizar seu branch.

```sh
git reset --hard upstream/main
```

O comando `git reset` permite que você redefina o estado atual de um branch. Passar a flag `--hard` instrui o Git a forçar os arquivos locais a corresponderem ao estado do branch. Isso garante que você tenha uma base limpa para trabalhar. E passar `upstream/main` informa ao Git que você quer que seu branch atual (que é `main`) corresponda ao branch `main` do remoto upstream. Tenha cuidado com esse comando - sempre que você atualizar forçadamente um histórico do Git, coisas estranhas e indesejadas podem acontecer.

Depois de atualizar corretamente sua branch local `main`, é importante enviar esse estado para seu fork remoto (que deve ser `origin`, se você seguiu nossas lições). Para fazer isso, você pode executar:

```sh
git push
```

Isso enviará o estado atual para o seu fork remoto. Mas se você teve que fazer um reset hard para limpar o histórico, é possível que seu fork remoto também tenha um histórico divergente e o push falhará.

Você pode corrigir isso forçando o push:

```sh
git push --force
```

**Tenha cuidado com este comando**. Fazer um force push efetivamente reescreve seu histórico remoto e se você fez algo incorretamente então um forced push se torna um pesadelo para desfazer.

Enviar as alterações sincronizadas para o seu fork remoto é importante porque ajuda a garantir que você possa clonar com segurança o fork com as alterações mais recentes se você perdeu seu repositório local existente.

E uma vez que você tenha sincronizado sua branch `main`, você está livre para criar uma nova branch a partir desse estado para começar a trabalhar em outra contribuição - com a versão mais recente da codebase original!

# --questions--

## --text--

Qual é a principal razão para evitar fazer commit de alterações diretamente na sua branch `main` ao trabalhar com repositórios forkados?

## --answers--

Ele cria commits duplicados.

### --feedback--

Pense no que acontece quando seu branch e o repositório original evoluem separadamente.

---

Isso causa um "histórico divergente" tornando difícil sincronizar com o upstream.

---

O Git não permite commits na branch main.

### --feedback--

Pense no que acontece quando seu branch e o repositório original evoluem separadamente.

---

Ele apaga automaticamente suas alterações locais.

### --feedback--

Pense no que acontece quando seu branch e o repositório original evoluem separadamente.

## --video-solution--

2

## --text--

Qual série de comandos atualizará corretamente sua branch local `main` com as alterações do repositório original?

## --answers--

`git checkout main`; `git pull upstream`

### --feedback--

Considere o processo passo a passo necessário para obter as mudanças upstream sem interromper seu fork.

---

`git pull upstream main`

### --feedback--

Considere o processo passo a passo necessário para obter as mudanças upstream sem interromper seu fork.

---

`git checkout main`; `git fetch upstream`; `git merge upstream/main`

---

`git fetch upstream/main`; `git merge`

### --feedback--

Considere o processo passo a passo necessário para obter as mudanças upstream sem interromper seu fork.

## --video-solution--

3

## --text--

Se você acidentalmente fez commit na sua branch `main` e não consegue mesclar as alterações upstream, qual comando você pode usar para redefinir forçadamente sua branch `main` para corresponder ao upstream (assumindo que você não fez nenhum pull request)?

## --answers--

`git checkout upstream/main`

### --feedback--

Qual comando redefine completamente seu branch para corresponder ao estado de outro branch?

---

`git reset --hard upstream/main`

---

`git rebase upstream/main`

### --feedback--

Qual comando redefine completamente seu branch para corresponder ao estado de outro branch?

---

`git clean upstream/main`

### --feedback--

Qual comando redefine completamente seu branch para corresponder ao estado de outro branch?

## --video-solution--

2
