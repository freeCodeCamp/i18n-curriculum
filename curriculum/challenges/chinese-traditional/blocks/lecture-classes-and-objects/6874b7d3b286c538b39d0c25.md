---
id: 6874b7d3b286c538b39d0c25
title: 什麼是特殊方法以及它們的用途是什麼？
challengeType: 19
dashedName: what-are-special-methods-and-what-are-they-used-for
---

# --description--

Python 中的特殊方法，也稱為「魔術方法」或「dunder 方法」，是以雙底線（`__`）開頭和結尾的特殊 Python 方法。字「dunder」本身來自於雙底線（**d** 代表 double，**under** 代表 underscores）。

你可能已經在不知不覺中使用過特殊方法。每當你寫下像 `3 + 4` 這樣的東西時，Python 會在背後靜靜地執行 `3.__add__(4)`。這就是特殊方法的運作方式。所以雖然你*可以*直接呼叫特殊方法，但你很少這麼做。像 `3 + 4` 這樣的寫法比你自己呼叫 `3.__add__(4)` 更清楚且更容易閱讀。

除了 `__add__`，`__init__()` 是你最常看到和使用的另一個特殊方法，因為它是類別的初始化方法。還有其他像是 `__len__()` 和 `__str__()`。

將特殊方法視為程式設計者與 Python 直譯器本身之間活動的導演。

請記住，你不需要直接呼叫特殊方法。相反地，當發生某些操作行為時，Python 會自動呼叫它們。這些操作行為包括：

- **像加法、減法、乘法、除法等算術操作**。此外，會呼叫 `__add__()`、`__sub__()` 用於減法、`__mul__()` 用於乘法，以及 `__truediv__()` 用於除法。
    
- **字串操作行為如串接、重複、格式化及轉換為文字**。`__add__()` 用於串接，`__mul__()` 用於重複，`__format__()` 用於格式化，`__str__()` 和 `__repr__()` 用於文字轉換，等等。
    
- **比較操作行為如相等、小於、大於等**。`__eq__()` 用於相等性檢查，`__lt__()` 用於小於，`__gt__()` 用於大於，依此類推。
    
- **像是讓物件可迭代以及在項目中前進的迭代操作行為**。會呼叫 `__iter__()` 來傳回迭代器，並呼叫 `__next__()` 來取得下一個項目。
    

通常，Python 資料型別像是字串和數字已經知道如何進行加法、串接、比較相等性、用於迴圈等操作。

但是當你創建你自己的類別時，Python 不會自動知道如何控制代碼。

這就是特殊方法發揮作用的地方——它們讓你自訂 Python 內建的行為。

假設你想取得由以下類別創建的書本物件中的頁數，或比較它們並取得物件的可讀字串。以下是在沒有特殊方法時會發生的情況：

```python
class Book:
   def __init__(self, title, pages):
       self.title = title
       self.pages = pages

book1 = Book("Built Wealth Like a Boss", 420)
book2 = Book("Be Your Own Start", 420)

print(len(book1)) # TypeError: object of type 'Book' has no len()
print(str(book1)) # <__main__.Book object at 0x102ed2900>
print(book1 == book2) # False even though they have the same number of pages
```

在範例中：

- `len(book1)` 失敗，因為 Python 不知道如何在沒有 `__len__()` 的情況下取得你的 book 物件的長度。
    
- `str(book1)` 列印出類似 `<__main__.Book object at 0x102ed2900>` 的東西，因為當你不使用 `__str__()` 時，那是預設的表現。
    
- `book1 == book2` 結果為 `False`，因為 Python 只是檢查兩個物件是否在記憶體中相同，而不是依內容比較。
    

以下是你如何定義自己的 `__len__()`、`__str__()` 和 `__eq__()` 特殊方法，以便更輕鬆地操作從 `Book` 類別產生的物件：

```python
class Book:
   def __init__(self, title, pages):
       self.title = title
       self.pages = pages

   def __len__(self):
       return self.pages

   def __str__(self):
       return f"'{self.title}' has {self.pages} pages"

   def __eq__(self, other):
       return self.pages == other.pages
  
book1 = Book("Built Wealth Like a Boss", 420)
book2 = Book("Be Your Own Start", 420)

print(len(book1)) # 420
print(len(book2)) # 420
print(str(book1)) # 'Built Wealth Like a Boss' has 420 pages
print(str(book2)) # 'Be Your Own Start' has 420 pages
print(book1 == book2) # True
```

另一個範例是一個購物車，在那裡你執行以下操作：

- 將項目添加到購物車
    
- 從購物車中移除項目
    
- 取得購物車中項目的數量
    
- 檢查購物車中有哪些項目
    
- 檢查特定項目是否在購物車中
    
- 傳回或顯示購物車中指定索引的項目
    

雖然你可能有一個將項目添加到購物車和從購物車中移除特定項目的方法，但你可以為所有其他功能創建特殊方法：

- 使用 `__len__()` 取得購物車中項目的長度
    
- 使用 `__iter__()` 來迴圈瀏覽購物車中的項目，以便你能看到它們
    
- 使用 `__contains__()` 來檢查購物車中是否有特定項目
    
- `__getitem__()` 用來傳回或顯示購物車中特定索引的項目
    

以下是具有這些使用者定義方法和特殊方法的 `Cart` 類別範例：

```python
class Cart:
   def __init__(self):
       self.items = []

   def add(self, item):
       self.items.append(item)

   def remove(self, item):
       if item in self.items:
           self.items.remove(item)
       else:
           print(f'{item} is not in cart')

   def list_items(self):
       return self.items

   def __len__(self):
       return len(self.items)

   def __getitem__(self, index):
       return self.items[index]

   def __contains__(self, item):
       return item in self.items

   def __iter__(self):
       return iter(self.items)
```

以下是你如何使用它們的方法：

```python
cart = Cart()
cart.add('Laptop')
cart.add('Wireless mouse')
cart.add('Ergo keyboard')
cart.add('Monitor')

for item in cart:
   print(item, end=' ') # Laptop Wireless mouse Ergo keyboard Monitor

print(len(cart)) # 4
print(cart[3]) # Monitor

print('Monitor' in cart) # True
print('banana' in cart) # False

cart.remove('Ergo keyboard')

print(cart.list_items()) # ['Laptop', 'Wireless mouse', 'Monitor']

cart.remove('banana') # banana is not in cart
```

這些就是你在實際應用中使用 Python 特殊方法的幾種方式。

# --questions--

## --text--

在加法操作期間被呼叫的特殊方法是哪一個？

## --answers--

`__plus__()`

### --feedback--

注意使用 `+` 運算子時會觸發什麼。

---

`__sum__()`

### --feedback--

注意使用 `+` 運算子時會觸發什麼。

---

`__add__()`

---

`__concat__()`

### --feedback--

注意使用 `+` 運算子時會觸發什麼。

## --video-solution--

3

## --text--

「dunder」這個字是如何衍生出來的？

## --answers--

從動態底層操作

### --feedback--

思考「dunder」這個字如何與 dunder 方法的寫法相關。

---

從縮寫「double underscore」(`__`)

---

來自 Python 暱稱的創作者

### --feedback--

思考「dunder」這個字如何與 dunder 方法的寫法相關。

---

在隱藏方法的引用下的資料

### --feedback--

思考「dunder」這個字如何與 dunder 方法的寫法相關。

## --video-solution--

2

## --text--

當你使用大於 (`>`) 比較運算子時，會呼叫哪個特殊方法？

## --answers--

`__more__()`

### --feedback--

它代表「大於」，並由 `>` 運算子觸發。

---

`__compare__()`

### --feedback--

它代表「大於」，並由 `>` 運算子觸發。

---

`__greater__()`

### --feedback--

它代表「大於」，並由 `>` 運算子觸發。

---

`__gt__()`

## --video-solution--

4
