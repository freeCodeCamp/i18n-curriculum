---
id: 66f55eac933ff64ce654ca74
title: 构建一个 Markdown 到超文本标记语言 转换器
challengeType: 25
dashedName: build-a-markdown-to-html-converter
demoType: onClick
saveSubmissionToDB: true
---

# --description--

Markdown 是一种用于为纯文本文档添加格式元素的标记语言。对于本实验，所有的 HTML 和 CSS 都已提供给你。你将使用 JavaScript 来完成 Markdown 到 HTML 转换器应用，以便它能够处理基本 Markdown 结构转换为 HTML 元素。

**注意：** 最终结果不会是一个全面的 Markdown 到 `HTML` 转换器，但如果你愿意，可以为它添加额外的功能。

**目标：**实现以下用户需求并通过所有测试以完成实验。

**用户故事：**

1. 你应该有一个名为 `convertMarkdown` 的函数，该函数不接受任何参数。
1. `convertMarkdown` 函数应使用正则表达式将来自 `#markdown-input` 的 markdown 输入转换为超文本标记语言，并应返回包含超文本标记语言代码的字串。
1. `convertMarkdown` 函数应将一级、二级和三级标题转换为对应的 `h1`、`h2` 和 `h3` 元素。Markdown 中的标题由与其级别相同数量的 `#` 字符表示，后跟一个空格和标题文本。`#` 字符应放在行首：行首可以有空格，但不能有其他字符。
1. `convertMarkdown` 函数应将加粗文本转换为 `strong` 元素。Markdown 中的加粗文本由一对双星号或一对双下划线包围文本表示。
1. `convertMarkdown` 函数应将斜体文本转换为 `em` 元素。Markdown 中的斜体文本由一对星号或一对下划线包围文本表示。
1. `convertMarkdown` 函数应将图像转换为 `img` 元素。Markdown 中的图像由 `![alt-text](image-source)` 表示，其中 `alt-text` 是 `alt` 属性的值，`image-source` 是 `src` 属性的值。
1. `convertMarkdown` 函数应将链接转换为锚点元素。Markdown 中的链接由 `[link text](URL)` 表示，其中 `link text` 是包含在锚点标签内的文本，`URL` 是 `href` 属性的值。
1. `convertMarkdown` 函数应将引用转换为 `blockquote` 元素。Markdown 中的引用由 `>` 后跟一个空格和引用文本表示。`>` 字符应放在行首：行首可以有空格，但不能有其他字符。
1. 当你在 `#markdown-input` 中输入文本时，`convertMarkdown` 返回的未经处理的超文本标记语言代码应显示在 `#html-output` 中。
1. 当你在 `#markdown-input` 中输入文本时，`convertMarkdown` 返回的超文本标记语言代码应渲染在 `#preview` 中。

注意：你应该为这个 `project` 使用 `input` 事件。

这是一个包含所有 `convertMarkdown` 应该能够处理的 markdown 以及转换后预期的超文本标记语言的表格：

<table>
  <thead>
    <tr>
      <th>Markdown</th>
      <th>HTML</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code># heading 1</code></th>
      <td><code>&lth1&gtheading 1&lt/h1&gt</code></th>
    </tr>
    <tr>
      <td><code>## heading 2</code></th>
      <td><code>&lth2&gtheading 2&lt/h2&gt</code></th>
    </tr>
    <tr>
      <td><code>### heading 3</code></th>
      <td><code>&lth3&gtheading 3&lt/h3&gt</code></th>
    </tr>
    <tr>
      <td><code>**bold text**</code> or <code>__bold text__</code></th>
      <td><code>&ltstrong&gtbold text&lt/strong&gt</code></th>
    </tr>
    <tr>
      <td><code>*italic text*</code> or <code>_italic text_</code></th>
      <td><code>&ltem&gtitalic text&lt/em&gt</code></th>
    </tr>
    <tr>
      <td><code>![alt-text](image-source)</code></th>
      <td><code>&ltimg alt="alt-text" src="image-source"&gt</code></th>
    </tr>
    <tr>
      <td><code>[link text](URL)</code></th>
      <td><code>&lta href="URL"&gtlink text&lt/a&gt</code></th>
    </tr>
    <tr>
      <td><code>> quote</code></th>
      <td><code>&ltblockquote&gtquote&lt/blockquote&gt</code></th>
    </tr>
  </tbody>
</table>

**注意：** 确保在你的超文本标记语言中链接你的 JavaScript 文件。

# --hints--

你应该有一个名为 `convertMarkdown` 的函数。

```js
assert.isFunction(convertMarkdown);
```

当 `#markdown-input` 的值为 `# title 1` 时，`convertMarkdown()` 应该返回 `<h1>title 1</h1>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "# title 1";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const headings = testDiv.querySelectorAll("h1");
assert.lengthOf(headings, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(headings[0].innerText, "title 1");
```

当 `#markdown-input` 的值为 `# title 1` 时，`#html-output` 内应显示 `<h1>title 1</h1>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "# title 1";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const headings = testDiv.querySelectorAll("h1");
assert.lengthOf(headings, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(headings[0].innerText, "title 1");
```

当 `#markdown-input` 的值为 `# title 1` 时，应将带有 `title 1` 文本的 `h1` 元素追加为 `#preview` 的子元素。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "# title 1";
input.dispatchEvent(new Event("input"));
const headings = preview.querySelectorAll("h1");
assert.lengthOf(headings, 1);
assert.lengthOf(preview.children, 1);
assert.equal(headings[0].innerText, "title 1");
```

当 `#markdown-input` 的值为 `some text # title 1` 时，`convertMarkdown()` 不应将 `# title 1` 转换为 `h1` 元素。

```js
const input = document.querySelector("#markdown-input");
input.value = "some text # title 1";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const testH1 = testDiv.querySelector("h1")
assert.notExists(testH1);
assert.equal(testDiv.innerText, input.value)
```

当 `#markdown-input` 的值是 `# title 1`，后面紧跟新行的 `# alternate title` 时，`convertMarkdown()` 应该返回 `<h1>title 1</h1><h1>alternate title</h1>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "# title 1\n# alternate title";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const headings = testDiv.querySelectorAll("h1");
assert.lengthOf(headings, 2);
assert.lengthOf(testDiv.children, 2);
assert.equal(headings[0].innerText, "title 1");
assert.equal(headings[1].innerText, "alternate title");
```

当 `#markdown-input` 的值为 `## title 2` 时，`convertMarkdown()` 应该返回 `<h2>title 2</h2>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "## title 2";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const headings = testDiv.querySelectorAll("h2");
assert.lengthOf(headings, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(headings[0].innerText, "title 2");
```

当 `#markdown-input` 的值为 `## title 2` 时，`#html-output` 内应显示 `<h2>title 2</h2>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "## title 2";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const headings = testDiv.querySelectorAll("h2");
assert.lengthOf(headings, 1);
assert.lengthOf(testDiv.children, 1)
assert.equal(headings[0].innerText, "title 2");
```

当 `#markdown-input` 的值为 `## title 2` 时，应将带有 `title 2` 文本的 `h2` 元素追加为 `#preview` 的子元素。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "## title 2";
input.dispatchEvent(new Event("input"));
const headings = preview.querySelectorAll("h2");
assert.lengthOf(headings, 1);
assert.lengthOf(preview.children, 1)
assert.equal(headings[0].innerText, "title 2");
```

当 `#markdown-input` 的值为 `some text ## title 2` 时，`convertMarkdown()` 不应将 `## title 2` 转换为 `h2` 元素。

```js
const input = document.querySelector("#markdown-input");
input.value = "some text ## title 2";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const testH2 = testDiv.querySelector("h2")
assert.notExists(testH2);
assert.equal(testDiv.innerText, input.value)
```

当 `#markdown-input` 的值是 `## title 2`，后面紧跟新一行的 `## title 2 alt` 时，`convertMarkdown()` 应该返回 `<h2>title 2</h2><h2>title 2 alt</h2>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "## title 2\n## title 2 alt";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const headings = testDiv.querySelectorAll("h2");
assert.lengthOf(headings, 2);
assert.lengthOf(testDiv.children, 2);
assert.equal(headings[0].innerText, "title 2");
assert.equal(headings[1].innerText, "title 2 alt");
```

当 `#markdown-input` 的值为 `### title 3` 时，`convertMarkdown()` 应该返回 `<h3>title 3</h3>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "### title 3";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const headings = testDiv.querySelectorAll("h3");
assert.lengthOf(headings, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(headings[0].innerText, "title 3");
```

当 `#markdown-input` 的值为 `### title 3` 时，`#html-output` 内应显示 `<h3>title 3</h3>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "### title 3";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const headings = testDiv.querySelectorAll("h3");
assert.lengthOf(headings, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(headings[0].innerText, "title 3");
```

当 `#markdown-input` 的值为 `### title 3` 时，应将带有 `title 3` 文本的 `h3` 元素追加为 `#preview` 的子元素。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "### title 3";
input.dispatchEvent(new Event("input"));
const headings = preview.querySelectorAll("h3");
assert.lengthOf(headings, 1);
assert.lengthOf(preview.children, 1);
assert.equal(headings[0].innerText, "title 3");
```

当 `#markdown-input` 的值为 `some text ### title 3` 时，`convertMarkdown()` 不应将 `### title 3` 转换为 `h3` 元素。

```js
const input = document.querySelector("#markdown-input");
input.value = "some text ### title 3";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const testH3 = testDiv.querySelector("h3")
assert.notExists(testH3);
assert.equal(testDiv.innerText, input.value)
```

当 `#markdown-input` 的值是 `### title 3`，后面紧跟新行的 `### third title` 时，`convertMarkdown()` 应该返回 `<h3>title 3</h3><h3>third title</h3>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "### title 3\n### third title";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const headings = testDiv.querySelectorAll("h3");
assert.lengthOf(headings, 2);
assert.lengthOf(testDiv.children, 2);
assert.equal(headings[0].innerText, "title 3");
assert.equal(headings[1].innerText, "third title");
```

当 `#markdown-input` 的值为 `**this is bold**` 时，`convertMarkdown()` 应该返回 `<strong>this is bold</strong>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "**this is bold**";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const strongs = testDiv.querySelectorAll("strong");
assert.lengthOf(strongs, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(strongs[0].innerText, "this is bold");
```

当 `#markdown-input` 的值为 `**this is bold**` 时，`#html-output` 内应显示 `<strong>this is bold</strong>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "**this is bold**";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const strongs = testDiv.querySelectorAll("strong");
assert.lengthOf(strongs, 1);
assert.lengthOf(testDiv.children, 1)
assert.equal(strongs[0].innerText, "this is bold");
```

当 `#markdown-input` 的值为 `**this is bold**` 时，应将带有文本 `this is bold` 的 `strong` 元素追加为 `#preview` 的子元素。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "**this is bold**";
input.dispatchEvent(new Event("input"));
const strongs = preview.querySelectorAll("strong");
assert.lengthOf(strongs, 1);
assert.lengthOf(preview.children, 1)
assert.equal(strongs[0].innerText, "this is bold");
```

当 `#markdown-input` 的值是 `**this is bold**`，后面紧跟新行的 `**this is also bold**` 时，`convertMarkdown()` 应该返回 `<strong>this is bold</strong><strong>this is also bold</strong>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "**this is bold**\n**this is also bold**";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const strongs = testDiv.querySelectorAll("strong");
assert.lengthOf(strongs, 2);
assert.lengthOf(testDiv.children, 2);
assert.equal(strongs[0].innerText, "this is bold");
assert.equal(strongs[1].innerText, "this is also bold");
```

当 `#markdown-input` 的值为 `__this is bold__` 时，`#html-output` 内应显示 `<strong>this is bold</strong>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "__this is bold__";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const strongs = testDiv.querySelectorAll("strong");
assert.lengthOf(strongs, 1);
assert.lengthOf(testDiv.children, 1)
assert.equal(strongs[0].innerText, "this is bold");
```

当 `#markdown-input` 的值为 `__this is bold__` 时，应将带有文本 `this is bold` 的 `strong` 元素追加为 `#preview` 的子元素。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "__this is bold__";
input.dispatchEvent(new Event("input"));
const strongs = preview.querySelectorAll("strong");
assert.lengthOf(strongs, 1);
assert.lengthOf(preview.children, 1)
assert.equal(strongs[0].innerText, "this is bold");
```

当 `#markdown-input` 的值是 `__this is bold__`，后面紧跟新行的 `__this is also bold__` 时，`convertMarkdown()` 应该返回 `<strong>this is bold</strong><strong>this is also bold</strong>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "__this is bold__\n__this is also bold__";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const strongs = testDiv.querySelectorAll("strong");
assert.lengthOf(strongs, 2);
assert.lengthOf(testDiv.children, 2);
assert.equal(strongs[0].innerText, "this is bold");
assert.equal(strongs[1].innerText, "this is also bold");
```

当 `#markdown-input` 的值为 `*this is italic*` 时，`convertMarkdown()` 应该返回 `<em>this is italic</em>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "*this is italic*";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const italics = testDiv.querySelectorAll("em");
assert.lengthOf(italics, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(italics[0].innerText, "this is italic");
```

当 `#markdown-input` 的值为 `*this is italic*` 时，`#html-output` 内应显示 `<em>this is italic</em>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "*this is italic*";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const italics = testDiv.querySelectorAll("em");
assert.lengthOf(italics, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(italics[0].innerText, "this is italic");
```

当 `#markdown-input` 的值为 `*this is italic*` 时，应将带有文本 `this is italic` 的 `em` 元素追加为 `#preview` 的子元素。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "*this is italic*";
input.dispatchEvent(new Event("input"));
const italics = preview.querySelectorAll("em");
assert.lengthOf(italics, 1);
assert.lengthOf(preview.children, 1);
assert.equal(italics[0].innerText, "this is italic");
```

当 `#markdown-input` 的值是 `*this is italic*`，后面紧跟新行的 `*this is also italic*` 时，`convertMarkdown()` 应该返回 `<em>this is italic</em><em>this is also italic</em>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "*this is italic*\n*this is also italic*";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const italics = testDiv.querySelectorAll("em");
assert.lengthOf(italics, 2);
assert.lengthOf(testDiv.children, 2);
assert.equal(italics[0].innerText, "this is italic");
assert.equal(italics[1].innerText, "this is also italic");
```

当 `#markdown-input` 的值为 `_this is italic_` 时，`convertMarkdown()` 应该返回 `<em>this is italic</em>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "_this is italic_";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const italics = testDiv.querySelectorAll("em");
assert.lengthOf(italics, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(italics[0].innerText, "this is italic");
```

当 `#markdown-input` 的值为 `_this is italic_` 时，`#html-output` 内应显示 `<em>this is italic</em>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "_this is italic_";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const italics = testDiv.querySelectorAll("em");
assert.lengthOf(italics, 1);
assert.lengthOf(testDiv.children, 1);
assert.equal(italics[0].innerText, "this is italic");
```

当 `#markdown-input` 的值为 `_this is italic_` 时，应将带有文本 `this is italic` 的 `em` 元素追加为 `#preview` 的子元素。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "_this is italic_";
input.dispatchEvent(new Event("input"));
const italics = preview.querySelectorAll("em");
assert.lengthOf(italics, 1);
assert.lengthOf(preview.children, 1);
assert.equal(italics[0].innerText, "this is italic");
```

当 `#markdown-input` 的值为 `_this is italic_`，后面紧跟新行的 `_this is also italic_` 时，`convertMarkdown()` 应该返回 `<em>this is italic</em><em>this is also italic</em>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "_this is italic_\n_this is also italic_";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const italics = testDiv.querySelectorAll("em");
assert.lengthOf(italics, 2);
assert.lengthOf(testDiv.children, 2);
assert.equal(italics[0].innerText, "this is italic");
assert.equal(italics[1].innerText, "this is also italic");
```

当 `#markdown-input` 的值为 `# **title 1**` 或 `# __title 1__` 时，`convertMarkdown()` 应返回 `<h1><strong>title 1</strong></h1>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "# **title 1**";
const testDiv1 = document.createElement("div");
testDiv1.innerHTML = convertMarkdown();
let headings = testDiv1.querySelectorAll("h1");
let testStrong = testDiv1.querySelector("h1>strong")
assert.lengthOf(testDiv1.children, 1);
assert.lengthOf(headings, 1);
assert.lengthOf(headings[0].children, 1);
assert.exists(testStrong);
assert.equal(testStrong.innerText, "title 1");

input.value = "# __title 1__";
const testDiv2 = document.createElement("div");
testDiv2.innerHTML = convertMarkdown();
headings = testDiv2.querySelectorAll("h1");
testStrong = testDiv2.querySelector("h1>strong")
assert.lengthOf(testDiv2.children, 1);
assert.lengthOf(headings, 1);
assert.lengthOf(headings[0].children, 1);
assert.exists(testStrong);
assert.equal(testStrong.innerText, "title 1");
```

当 `#markdown-input` 的值为 `# **title 1**` 或 `# __title 1__` 时，`#html-output` 内应显示 `<h1><strong>title 1</strong></h1>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "# **title 1**";
input.dispatchEvent(new Event("input"));
const testDiv1 = document.createElement("div");
testDiv1.innerHTML = output.innerText;
let headings = testDiv1.querySelectorAll("h1")
let testStrong = testDiv1.querySelector("h1>strong")
assert.lengthOf(testDiv1.children, 1);
assert.lengthOf(headings, 1);
assert.lengthOf(headings[0].children, 1);
assert.exists(testStrong);
assert.equal(testStrong.innerText, "title 1");

output.innerText = "";
input.value = "# __title 1__";
input.dispatchEvent(new Event("input"));
const testDiv2 = document.createElement("div");
testDiv2.innerHTML = output.innerText;
headings = testDiv2.querySelectorAll("h1")
testStrong = testDiv2.querySelector("h1>strong")
assert.lengthOf(testDiv2.children, 1);
assert.lengthOf(headings, 1);
assert.lengthOf(headings[0].children, 1);
assert.exists(testStrong);
assert.equal(testStrong.innerText, "title 1");
```

当 `#markdown-input` 的值为 `# **title 1**` 或 `# __title 1__` 时，你将 `#preview` 的内部 HTML 设置为 `<h1><strong>title 1</strong></h1>`。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "# **title 1**";
input.dispatchEvent(new Event("input"));
let headings = preview.querySelectorAll("h1")
let testStrong = preview.querySelector("h1>strong")
assert.lengthOf(preview.children, 1);
assert.lengthOf(headings, 1);
assert.lengthOf(headings[0].children, 1);
assert.exists(testStrong);
assert.equal(testStrong.innerText, "title 1");

preview.innerHTML = "";
input.value = "# __title 1__";
input.dispatchEvent(new Event("input"));
headings = preview.querySelectorAll("h1")
testStrong = preview.querySelector("h1>strong")
assert.lengthOf(preview.children, 1);
assert.lengthOf(headings, 1);
assert.lengthOf(headings[0].children, 1);
assert.exists(testStrong);
assert.equal(testStrong.innerText, "title 1");
```

当 `#markdown-input` 的值为 `![alt-text](image-source)` 时，`convertMarkdown()` 应该返回 `<img alt="alt-text" src="image-source">`。

```js
const input = document.querySelector("#markdown-input");
input.value = "![alt-text](image-source)";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const imgs = testDiv.querySelectorAll("img");
assert.lengthOf(testDiv.children, 1);
assert.lengthOf(imgs, 1);
assert.equal(imgs[0].alt, "alt-text");
assert.isTrue(imgs[0].src.endsWith("image-source"));
```

当 `#markdown-input` 的值为 `![alt-text](image-source)` 时，`#html-output` 内应显示 `<img alt="alt-text" src="image-source">`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "![alt-text](image-source)";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const imgs = testDiv.querySelectorAll("img");
assert.lengthOf(testDiv.children, 1)
assert.lengthOf(imgs, 1);
assert.equal(imgs[0].alt, "alt-text");
assert.isTrue(imgs[0].src.endsWith("image-source"));
```

当 `#markdown-input` 的值为 `![alt-text](image-source)` 时，应将 `<img alt="alt-text" src="image-source">` 追加为 `#preview` 的子元素。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "![alt-text](image-source)";
input.dispatchEvent(new Event("input"));
const imgs = preview.querySelectorAll("img");
assert.lengthOf(preview.children, 1)
assert.lengthOf(imgs, 1);
assert.equal(imgs[0].alt, "alt-text");
assert.isTrue(imgs[0].src.endsWith("image-source"));
```

当 `#markdown-input` 的值是 `![alt-text](image-source)`，后面紧跟新行的 `![alt-text-2](image-source-2)` 时，`convertMarkdown()` 应该返回 `<img alt="alt-text" src="image-source"><img alt="alt-text-2" src="image-source-2">`。

```js
const input = document.querySelector("#markdown-input");
input.value = "![alt-text](image-source)\n![alt-text-2](image-source-2)";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const imgs = testDiv.querySelectorAll("img");
assert.lengthOf(testDiv.children, 2);
assert.lengthOf(imgs, 2);
assert.equal(imgs[0].alt, "alt-text");
assert.isTrue(imgs[0].src.endsWith("image-source"));
assert.equal(imgs[1].alt, "alt-text-2");
assert.isTrue(imgs[1].src.endsWith("image-source-2"));
```

当 `#markdown-input` 的值是 `[link text](URL)` 时，`convertMarkdown()` 应该返回 `<a href="URL">link text</a>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "[link text](URL)";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const anchors = testDiv.querySelectorAll("a");
assert.lengthOf(testDiv.children, 1);
assert.lengthOf(anchors, 1);
assert.isTrue(anchors[0].href.endsWith("URL"));
assert.equal(anchors[0].innerText, "link text");
```

当 `#markdown-input` 的值为 `[link text](URL)` 时，`#html-output` 内应显示 `<a href="URL">link text</a>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "[link text](URL)";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const anchors = testDiv.querySelectorAll("a");
assert.lengthOf(testDiv.children, 1);
assert.lengthOf(anchors, 1);
assert.isTrue(anchors[0].href.endsWith("URL"));
assert.equal(anchors[0].innerText, "link text");
```

当 `#markdown-input` 的值为 `[link text](URL)` 时，应将 `<a href="URL">link text</a>` 追加为 `#preview` 的子元素。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "[link text](URL)";
input.dispatchEvent(new Event("input"));
const anchors = preview.querySelectorAll("a");
assert.lengthOf(preview.children, 1);
assert.lengthOf(anchors, 1);
assert.isTrue(anchors[0].href.endsWith("URL"));
assert.equal(anchors[0].innerText, "link text");
```

当 `#markdown-input` 的值是 `[link text](URL)`，后面紧跟新行的 `[link text 2](URL2)` 时，`convertMarkdown()` 应返回 `<a href="URL">link text</a><a href="URL2">link text 2</a>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "[link text](URL)\n[link text 2](URL2)";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const anchors = testDiv.querySelectorAll("a");
assert.lengthOf(testDiv.children, 2);
assert.lengthOf(anchors, 2);
assert.isTrue(anchors[0].href.endsWith("URL"));
assert.equal(anchors[0].innerText, "link text");
assert.isTrue(anchors[1].href.endsWith("URL2"));
assert.equal(anchors[1].innerText, "link text 2");
```

当 `#markdown-input` 的值为 `> this is a quote` 时，`convertMarkdown()` 应该 `return` `<blockquote>this is a quote</blockquote>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "> this is a quote";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const quotes = testDiv.querySelectorAll("blockquote");
assert.lengthOf(testDiv.children, 1);
assert.lengthOf(quotes, 1);
assert.equal(quotes[0].innerText, "this is a quote");
```

当 `#markdown-input` 的值为 `> this is a quote` 时，`<blockquote>this is a quote</blockquote>` 应显示在 `#html-output` 内。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "> this is a quote";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const quotes = testDiv.querySelectorAll("blockquote");
assert.lengthOf(testDiv.children, 1);
assert.lengthOf(quotes, 1);
assert.equal(quotes[0].innerText, "this is a quote");
```

当 `#markdown-input` 的值为 `> this is a quote` 时，`<blockquote>this is a quote</blockquote>` 应作为 `#preview` 的子元素追加。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "> this is a quote";
input.dispatchEvent(new Event("input"));
const quotes = preview.querySelectorAll("blockquote");
assert.lengthOf(preview.children, 1);
assert.lengthOf(quotes, 1);
assert.equal(quotes[0].innerText, "this is a quote");
```

当 `#markdown-input` 的值是 `> this is a quote`，后面紧跟新行的 `> this is another quote` 时，`convertMarkdown()` 应该返回 `<blockquote>this is a quote</blockquote><blockquote>this is another quote</blockquote>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "> this is a quote\n> this is another quote";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const quotes = testDiv.querySelectorAll("blockquote");
assert.lengthOf(testDiv.children, 2);
assert.lengthOf(quotes, 2);
assert.equal(quotes[0].innerText, "this is a quote");
assert.equal(quotes[1].innerText, "this is another quote");
```


当 `#markdown-input` 的值为 `some text > not a quote anymore` 时，`convertMarkdown()` 不应将 `> not a quote anymore` 转换为 `blockquote` 元素。

```js
const input = document.querySelector("#markdown-input");
input.value = "some text > not a quote anymore";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const testQuote = testDiv.querySelector("blockquote")
assert.notExists(testQuote);
assert.equal(testDiv.innerText, input.value)
```

当 `#markdown-input` 的值为 `> **this is a *quote***` 时，`convertMarkdown()` 应该 `return` `<blockquote><strong>this is a <em>quote</em></strong></blockquote>`。

```js
const input = document.querySelector("#markdown-input");
input.value = "> **this is a *quote***";
const testDiv = document.createElement("div");
testDiv.innerHTML = convertMarkdown();
const quotes = testDiv.querySelectorAll("blockquote");
const strongs = testDiv.querySelectorAll("blockquote>strong");
const italics = testDiv.querySelectorAll("blockquote>strong>em");
assert.lengthOf(testDiv.children, 1);
assert.lengthOf(quotes, 1);
assert.lengthOf(quotes[0].children, 1);
assert.lengthOf(strongs, 1);
assert.lengthOf(strongs[0].children, 1);
assert.equal(strongs[0].innerText, "this is a quote");
assert.lengthOf(italics, 1);
assert.equal(italics[0].innerText, "quote");
```

当 `#markdown-input` 的值为 `> **this is a *quote***` 时，`#html-output` 内应显示 `<blockquote><strong>this is a <em>quote</em></strong></blockquote>`。

```js
const input = document.querySelector("#markdown-input");
const output = document.querySelector("#html-output");
output.innerText = "";
input.value = "> **this is a *quote***";
input.dispatchEvent(new Event("input"));
const testDiv = document.createElement("div");
testDiv.innerHTML = output.innerText;
const quotes = testDiv.querySelectorAll("blockquote");
const strongs = testDiv.querySelectorAll("blockquote>strong");
const italics = testDiv.querySelectorAll("blockquote>strong>em");
assert.lengthOf(testDiv.children, 1);
assert.lengthOf(quotes, 1);
assert.lengthOf(quotes[0].children, 1);
assert.lengthOf(strongs, 1);
assert.lengthOf(strongs[0].children, 1);
assert.equal(strongs[0].innerText, "this is a quote");
assert.lengthOf(italics, 1);
assert.equal(italics[0].innerText, "quote");
```

当 `#markdown-input` 的值为 `> **this is a *quote***` 时，你应该将 `#preview` 的内部 HTML 设置为 `<blockquote><strong>this is a <em>quote</em></strong></blockquote>`。

```js
const input = document.querySelector("#markdown-input");
const preview = document.querySelector("#preview");
preview.innerHTML = "";
input.value = "> **this is a *quote***";
input.dispatchEvent(new Event("input"));
const quotes = preview.querySelectorAll("blockquote");
const strongs = preview.querySelectorAll("blockquote>strong");
const italics = preview.querySelectorAll("blockquote>strong>em");
assert.lengthOf(preview.children, 1);
assert.lengthOf(quotes, 1);
assert.lengthOf(quotes[0].children, 1);
assert.lengthOf(strongs, 1);
assert.lengthOf(strongs[0].children, 1);
assert.equal(strongs[0].innerText, "this is a quote");
assert.lengthOf(italics, 1);
assert.equal(italics[0].innerText, "quote");
```

你的超文本标记语言中应该只有一个 `script` 元素。

```js
assert.lengthOf(document.querySelectorAll("script"), 1);
```

# --seed--

## --seed-contents--

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML Converter</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1>Markdown to HTML Converter</h1>
    <div id="container">
        <div class="container">
            <h2>Markdown Input:</h2>
            <textarea id="markdown-input" placeholder="Enter your markdown here..."></textarea>
        </div>
        <div class="container">
            <h2>Raw HTML Output:</h2>
            <div id="html-output"></div>
        </div>
        <div class="container">
            <h2>HTML Preview:</h2>
            <div id="preview"></div>
        </div>
    </div>
</body>

</html>
```

```css
* {
     box-sizing: border-box;
}
 body {
     font-family: Arial, sans-serif;
     padding: 20px;
}
 #markdown-input {
     width: 100%;
     height: 100px;
}
 #html-output, #preview {
     height: 100px;
     display: inline-block;
     width: 100%;
     border: 1px solid #ccc;
     padding: 10px;
     margin: auto;
     white-space: pre-wrap;
     background-color: #f9f9f9;
}
 @media (min-width: 600px) {
     #markdown-input, #html-output, #preview {
         height: 200px;
         margin: 0;
    }
     #container {
         display: flex;
         justify-content: space-evenly;
         gap: 10px;
    }
}
```

```js

```

# --solutions--

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML Converter</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1>Markdown to HTML Converter</h1>
    <div id="container">
        <div class="container">
            <h2>Markdown Input:</h2>
            <textarea id="markdown-input" placeholder="Enter your markdown here..."></textarea>
        </div>
        <div class="container">
            <h2>Raw HTML Output:</h2>
            <div id="html-output"></div>
        </div>
        <div class="container">
            <h2>HTML Preview:</h2>
            <div id="preview"></div>
        </div>
    </div>
    <script src="script.js"></script>
</body>

</html>
```

```css
* {
     box-sizing: border-box;
}
 body {
     font-family: Arial, sans-serif;
     padding: 20px;
}
 #markdown-input {
     width: 100%;
     height: 100px;
}
 #html-output, #preview {
     height: 100px;
     display: inline-block;
     width: 100%;
     border: 1px solid #ccc;
     padding: 10px;
     margin: auto;
     white-space: pre-wrap;
     background-color: #f9f9f9;
}
 @media (min-width: 600px) {
     #markdown-input, #html-output, #preview {
         height: 200px;
         margin: 0;
    }
     #container {
         display: flex;
         justify-content: space-evenly;
         gap: 10px;
    }
}
```

```js
const patternReplacementArray = [
    { h6: [/^[ \t]*######[ \t](.+$)/gm, "<h6>$1</h6>"] },
    { h5: [/^[ \t]*#####[ \t](.+$)/gm, "<h5>$1</h5>"] },
    { h4: [/^[ \t]*####[ \t](.+$)/gm, "<h4>$1</h4>"] },
    { h3: [/^[ \t]*###[ \t](.+$)/gm, "<h3>$1</h3>"] },
    { h2: [/^[ \t]*##[ \t](.+$)/gm, "<h2>$1</h2>"] },
    { h1: [/^[ \t]*#[ \t](.+$)/gm, "<h1>$1</h1>"] },
    { hr: [/(?<=\n|^)---(?=\n|$)/, "<hr>"] },
    { strong: [/((?:\*|_){2})(.*?)\1/g, "<strong>$2</strong>"] },
    { em: [/(\*|_)(.*?)\1/g, "<em>$2</em>"] },
    { img: [/!\[\s*(.*?)\s*\]\(\s*(.*?)\s*\)/g, '<img alt="$1" src="$2">'] },
    { a: [/\[(.*?)\]\(\s*(.*?)\s*\)/g, '<a href="$2">$1</a>'] },
    { blockquote1: [/^[ \t]*> ([^\n]+?)$/gm, "<blockquote>$1</blockquote>\n"] },
    { blockquote2: [/(?<=<blockquote>)(.+?)<\/blockquote>\n\n^([^<\n]+?)$/gm, "$1 $2</blockquote>\n"] },
    { ul: [/(?:^[-*+]\s+.*?$\n)+\s*?/gm, "<ul>\n$&</ul>"] },
    { ol: [/(?:^\d*\.\s+?\w.*?$\n)+\s*?/gm, "<ol>\n$&</ol>"] },
    { uli: [/^[-*+]\s+(.*?$)\n/gm, "<li>$1</li>\n"] },
    { oli: [/^\d*\.\s+?(.*?$)\n/gm, "<li>$1</li>\n"] },
    { p1: [/^([^<>\s].*?)(?=\n\s*$)/gsm, "<p>$1</p>"] },
    { p2: [/^\w*?(?:<strong>|<em>).+(?:<\/strong>|<\/em>)\s*\w*?[ \t]*$/gm, "<p>$&</p>"] }
]

const markdownInput = document.getElementById('markdown-input');
const convertMarkdown = () => {
    let markdown = markdownInput.value;
    let matchUList = false;
    let matchOList = false;
    patternReplacementArray.forEach((item) => {
        const [key] = Object.keys(item);
        const [pattern, replacement] = Object.values(item)[0];
        if (key === "blockquote2") {
            while (markdown.match(pattern)) {
                markdown = markdown.replace(pattern, replacement);
            }
        } else if (key === "ul") {
            if (markdown.match(pattern)) {
                matchUList = true;
                markdown = markdown.replace(pattern, replacement);
            }

        } else if (key === "ol") {
            if (markdown.match(pattern)) {
                matchOList = true;
                markdown = markdown.replace(pattern, replacement);
            }

        } else if (key === "uli" && !matchUList) {
            return;
        } else if (key === "oli" && !matchOList) {
            return;
        } else {
            markdown = markdown.replace(pattern, replacement);
        }
    })
    return markdown;
}

markdownInput.addEventListener('input', () => {
    const html = convertMarkdown();
    const out = document.getElementById('html-output');
    const preview = document.getElementById('preview');
    out.textContent = html;
    preview.innerHTML = html;
});
```
