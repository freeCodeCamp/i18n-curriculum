---
id: 65d8a6fcb15a3a239ba35dfd
title: Paso 46
challengeType: 20
dashedName: step-46
---

# --description--

Después de encontrar el valor mínimo, necesitarás eliminar recursivamente el nodo con el valor mínimo del subárbol derecho.

Este paso asegura que el nodo con el valor mínimo sea eliminado del árbol mientras se mantiene la propiedad del árbol binario de búsqueda (BST).

Llama al método `_delete` recursivamente con `node.right` y `node.key` como argumentos. Asigna el valor de retorno de la llamada a `_delete()` al hijo derecho del nodo actual.

# --hints--

Debes llamar al método `_delete` recursivamente con `node.right` y `node.key` como argumentos.

```js
assert.match(code, /self\._delete\(\s*node\.right\s*,\s*node\.key\s*/);
```

Debes asignar el valor de retorno de la llamada `_delete()` al hijo derecho del nodo actual.

```js
assert.match(code, /node\.right\s*=\s*self\._delete\(\s*node\.right\s*,\s*node\.key/);
```

# --seed--

## --seed-contents--

```py

class TreeNode:

    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

    def __str__(self):
        return str(self.key)

class BinarySearchTree:

    def __init__(self):
        self.root = None

    def _insert(self, node, key):
        if node is None:
            return TreeNode(key)

        if key < node.key:
            node.left = self._insert(node.left, key)
        elif key > node.key:

            node.right = self._insert(node.right, key)
        return node

    def insert(self, key):
        self.root = self._insert(self.root, key)
        
    def _search(self, node, key):
        if node is None or node.key == key:
            return node
        if key < node.key:
            return self._search(node.left, key)
        return self._search(node.right, key)
    
    def search(self, key):
        return self._search(self.root, key)

--fcc-editable-region--
    def _delete(self, node, key):
        if node is None:
            return node
        if key < node.key:
            node.left = self._delete(node.left, key)
        elif key > node.key:
            node.right = self._delete(node.right, key)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left

            node.key = self._min_value(node.right) 
            
--fcc-editable-region--
    def _min_value(self, node):
        while node.left is not None:
            node = node.left

bst = BinarySearchTree()

nodes = [50, 30, 20, 40, 70, 60, 80]

for node in nodes:
    bst.insert(node)

# print('Search for 80:', bst.search(80))


```
