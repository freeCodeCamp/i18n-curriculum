---
id: 68910fc037a90c285107af04
title: ¿Qué es Divide and Conquer, y cómo funciona Merge Sort?
challengeType: 19
dashedName: what-is-divide-and-conquer-and-how-does-merge-sort-work
---

# --description--

El paradigma divide y vencerás en la informática es una técnica para descomponer problemas recursivamente en subproblemas más pequeños. Uno de los aspectos clave de esta técnica es la recursión, que ocurre cuando una función se llama a sí misma repetidamente hasta que se alcanza un caso base. En esta lección, veremos el algoritmo merge sort para entender mejor cómo funciona la técnica divide y vencerás.

Digamos que tenemos esta lista de números:

```md
42 37 53 17
```

El objetivo es ordenar esa lista de menor a mayor usando el algoritmo merge sort. El primer paso es dividir esa lista a la mitad:

```md
42 37 | 53 17
```

Luego necesitamos mirar el lado izquierdo de la lista:

```md
42 37
```

Tomamos esa sublista y la dividimos a la mitad nuevamente hasta que cada sublista tenga solo un elemento:

```md
42 | 37
```

Una lista con solo un elemento está ordenada por defecto. A continuación, necesitamos combinar cada una de esas sublistas de un elemento en una lista ordenada:

```md
37 42
```

Luego seguimos el mismo proceso para el lado derecho de la lista original:

```py
# right side of original list
53 17

# divide the list in half
53 | 17

# merge the lists in sorted order
17 53
```

Ahora que ambas mitades de la lista original están ordenadas, combinamos esas dos mitades y ordenamos los elementos:

```markdown
17 37 42 53
```

Aquí está cómo se ve el algoritmo en código:

```py
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    sorted_list = []
    i = 0
    j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            sorted_list.append(left[i])
            i += 1
        else:
            sorted_list.append(right[j])
            j += 1

    sorted_list.extend(left[i:])
    sorted_list.extend(right[j:])

    return sorted_list
```

La complejidad temporal de merge sort sería `O(n log n)` porque la lista se divide continuamente a la mitad (`log n`) y luego se combina (`O(n)`). A diferencia de otros algoritmos de ordenamiento como bubble sort, merge sort no se ordena en el lugar y tiene una complejidad espacial de `O(n)`.

# --questions--

## --text--

¿Qué es el paradigma divide and conquer en ciencias de la computación?

## --answers--

Una técnica para detectar un ciclo en las iteraciones de valores de función usando solo dos iteradores.

### --feedback--

Revisa el comienzo de la lección.

---

Un algoritmo para comparar dos elementos e intercambiarlos de menor a mayor si es necesario.

### --feedback--

Revisa el comienzo de la lección.

---

Una técnica para descomponer problemas recursivamente en subproblemas más pequeños.

---

Un algoritmo para calcular la red de conexión más corta para puntos en un plano.

### --feedback--

Revisa el comienzo de la lección.

## --video-solution--

3

## --text--

¿Cuál es la complejidad temporal del algoritmo merge sort?

## --answers--

`O(n log n)`

---

`O(log n²)`

### --feedback--

Revisa el final de la lección.

---

`O(n³ log n)`

### --feedback--

Revisa el final de la lección.

---

`O(log n³)`

### --feedback--

Revisa el final de la lección.

## --video-solution--

1

## --text--

¿Cuál es la complejidad espacial para el algoritmo merge sort?

## --answers--

`O(n²)`

### --feedback--

Revisa el final de la lección.

---

`O(1)`

### --feedback--

Revisa el final de la lección.

---

`O(n log n)`

### --feedback--

Revisa el final de la lección.

---

`O(n)`

## --video-solution--

4
