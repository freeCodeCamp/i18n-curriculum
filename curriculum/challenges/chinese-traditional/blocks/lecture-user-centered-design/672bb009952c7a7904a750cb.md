---
id: 672bb009952c7a7904a750cb
title: 設計無限滾動的最佳實踐是什麼？
challengeType: 19
dashedName: what-are-best-practices-for-designing-infinite-scrolls
---

# --interactive--

**注意**：有些互動範例可能會使用你還沒學過的 CSS 和 JavaScript。不要擔心試著理解所有的程式碼。這些範例的目標是為了展示這些設計概念的預覽，讓你更了解事物的運作方式。要看到預覽，你需要啟用互動式編輯器。

無限滾動是一種設計樣式，會在使用者向下捲動頁面時載入更多內容。這通常用於像 Twitter 這樣的社交媒體網站。例如，如果你已登入並想看到更多推文，你可以向下捲動，更多推文就會載入。這是一個無限滾動的範例。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="infinite-scroll">
  <div class="post">Post 1</div>
  <div class="post">Post 2</div>
  <div class="post">Post 3</div>
  <div class="post">Post 4</div>
  <div class="post">Post 5</div>
  <div class="post">Post 6</div>
  <div class="post">Post 7</div>
  <div class="post">Post 8</div>
  <div class="post">Post 9</div>
  <div class="post">Post 10</div>
  <!-- More posts will load here as the user scrolls down -->
</div>

<script src="index.js"></script>
```

```css
.infinite-scroll {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.post {
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
```

```js
// Simulate loading more content as the user scrolls
window.addEventListener('scroll', () => {
  if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
    loadMorePosts();
  }
});

function loadMorePosts() {
  const container = document.querySelector('.infinite-scroll');
  for (let i = 0; i < 3; i++) {
    const post = document.createElement('div');
    post.className = 'post';
    post.textContent = `Post ${container.children.length + 1}`;
    container.appendChild(post);
  }
}
```

:::

無限滾動也用作分頁的替代方案。分頁是一種將內容分成多頁的設計樣式。當有大量內容需要顯示時，通常會使用這種方式。分頁的範例是當你在 Google 上搜尋某些東西時，會看到多頁的搜尋結果。使用分頁時，你必須點擊按鈕才能前往下一頁。使用無限滾動時，你只需不斷向下滾動，更多內容就會載入。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="pagination">
  <div class="post">Post 1</div>
  <div class="post">Post 2</div>
  <div class="post">Post 3</div>
  <!-- More posts will be on the next pages -->
</div>
<div class="pagination-controls">
  <button class="prev" disabled>Previous</button>
  <button class="next">Next</button>
</div>
<script src="index.js"></script>
```

```css
.pagination {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.post {
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.pagination-controls {
  margin-top: 12px;
}

.pagination-controls button {
  padding: 8px 16px;
  margin-right: 8px;
}
```

```js
let currentPage = 1;
const postsPerPage = 3;
const totalPosts = 9; 
const totalPages = Math.ceil(totalPosts / postsPerPage);
const container = document.querySelector('.pagination');
const prevButton = document.querySelector('.prev');
const nextButton = document.querySelector('.next'); 

function renderPosts() {
  container.innerHTML = '';
  const start = (currentPage - 1) * postsPerPage;
  const end = start + postsPerPage;
  for (let i = start; i < end && i < totalPosts; i++) {
    const post = document.createElement('div');
    post.className = 'post';
    post.textContent = `Post ${i + 1}`;
    container.appendChild(post);
  }
  prevButton.disabled = currentPage === 1;
  nextButton.disabled = currentPage === totalPages;
}

prevButton.addEventListener('click', () => {
  if (currentPage > 1) {
    currentPage--;
    renderPosts();
  }
});

nextButton.addEventListener('click', () => {
  if (currentPage < totalPages) {
    currentPage++;
    renderPosts();
  }
});

renderPosts();
```

:::

當你將無限滾動納入你的設計時，有幾個最佳實務需要記住。第一個考量是提供一個「`Load More`」按鈕，當使用者點擊時載入下一組結果。這是讓使用者控制何時想要查看更多內容的好方法。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="infinite-scroll">
  <div class="post">Post 1</div>
  <div class="post">Post 2</div>
  <div class="post">Post 3</div>
  <!-- More posts will load when the user clicks "Load More" -->
</div>
<button class="load-more">Load More</button>
<script src="index.js"></script>
```

```css
.infinite-scroll {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.post {
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.load-more {
  margin-top: 12px;
  padding: 8px 16px;
}
```

```js
const loadMoreButton = document.querySelector('.load-more');
const container = document.querySelector('.infinite-scroll');   
loadMoreButton.addEventListener('click', () => {
  loadMorePosts();
});

function loadMorePosts() {
  for (let i = 0; i < 3; i++) {
    const post = document.createElement('div');
    post.className = 'post';
    post.textContent = `Post ${container.children.length + 1}`;
    container.appendChild(post);
  }
}
```

:::

另一個考量是為你的介面添加一個「返回」按鈕。這讓使用者能夠回到前一頁，而不必一直捲動回到頁面頂端。這會創造更好的使用者體驗，並讓他們對瀏覽過程擁有更多控制。

有時你會看到設計中有一個「回到頂部」按鈕，該按鈕會將使用者帶回結果頁面的頂部。另一個考量是提供載入指示器。使用者應該清楚知道更多內容正在載入；否則，他們可能會認為頁面壞掉了。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="infinite-scroll">
  <div class="post">Post 1</div>
  <div class="post">Post 2</div>
  <div class="post">Post 3</div>
  <div class="post">Post 4</div>
  <div class="post">Post 5</div>
  <div class="post">Post 6</div>
  <div class="post">Post 7</div>
  <div class="post">Post 8</div>
  <div class="post">Post 9</div>
  <div class="post">Post 10</div>
  <!-- More posts will load here as the user scrolls down -->
</div>

<div class="loading-indicator" style="display: none;">Loading...</div>

<button id="back-to-top" class="back-to-top">↑ Back to Top</button>

<script src="index.js"></script>

```

```css
.infinite-scroll {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.post {
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.loading-indicator {
  margin-top: 12px;
  font-weight: bold;
}

.back-to-top {
  position: fixed;
  bottom: 30px;
  right: 30px;
  display: none;
  padding: 10px 15px;
  background-color: #007BFF;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.back-to-top:hover {
  background-color: #0056b3;
}
```

```js
const container = document.querySelector('.infinite-scroll');
const loadingIndicator = document.querySelector('.loading-indicator');
const backToTopBtn = document.getElementById('back-to-top');

window.addEventListener('scroll', () => {
  if (window.scrollY > 400) {
    backToTopBtn.style.display = 'block';
  } else {
    backToTopBtn.style.display = 'none';
  }

  if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
    loadMorePosts();
  }
});

backToTopBtn.addEventListener('click', () => {
  window.scrollTo({ top: 0, behavior: 'smooth' });
});

function loadMorePosts() {
  loadingIndicator.style.display = 'block';
  setTimeout(() => {
    for (let i = 0; i < 3; i++) {
      const post = document.createElement('div');
      post.className = 'post';
      post.textContent = `Post ${container.children.length + 1}`;
      container.appendChild(post);
    }
    loadingIndicator.style.display = 'none';
  }, 1000);
}
``` 

:::

最後的考量之一是保持頁腳對使用者可存取。如果頁腳包含重要資訊，則應該讓使用者隨時都能存取該頁腳。

總結來說，無限滾動是展示你網站內容的絕佳方式。然而，你應該在設計無限滾動時記住最佳實踐，這樣才能提供最佳的使用者體驗。

# --questions--

## --text--

什麼是無限滾動？

## --answers--

一種會更改頁面上捲軸的設計樣式。

### --feedback--

回顧課程開始時介紹此概念的部分。

---

一種改變頁面大小的設計樣式。

### --feedback--

回顧課程開始時介紹此概念的部分。

---

一種用於更改頁面背景顏色的設計樣式。

### --feedback--

回顧課程開始時介紹此概念的部分。

---

一種當使用者向下捲動頁面時載入更多內容的設計樣式

## --video-solution--

4

## --text--

「load more」按鈕在無限滾動中的角色是什麼？

## --answers--

它會重新載入頁面。

### --feedback--

名稱暗示它的角色是什麼。

---

讓使用者控制何時想要查看更多內容。

---

它允許使用者返回先前載入的內容。

### --feedback--

名稱暗示它的角色是什麼。

---

它限制了可以載入的資料量。

### --feedback--

名稱暗示它的角色是什麼。

## --video-solution--

2

## --text--

為什麼在使用無限滾動時保持頁腳可存取很重要？

## --answers--

它有助於讓頁面上的顏色更突出。

### --feedback--

思考使用者應該能存取哪些資訊

---

它有助於使頁面載入更快。

### --feedback--

思考使用者應該能存取哪些資訊

---

保持頁腳可存取並不重要。

### --feedback--

思考使用者應該能存取哪些資訊

---

因此使用者可以隨時從頁腳存取聯結和重要資訊。

## --video-solution--

4
