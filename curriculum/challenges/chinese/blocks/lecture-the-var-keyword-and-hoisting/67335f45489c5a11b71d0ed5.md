---
id: 67335f45489c5a11b71d0ed5
title: 什么是提升？
challengeType: 19
dashedName: what-is-hoisting
---

# --interactive--

提升是 JavaScript 中一种常常让初学者感到困惑的行为，但理解它可以帮助你避免代码中的细微错误。简单来说，提升是 JavaScript 在编译阶段将声明移动到各自作用域顶部的默认行为，发生在代码执行之前。

要理解提升，重要的是要知道 JavaScript 在两个阶段运行：编译阶段和执行阶段。在编译阶段，JavaScript 引擎会遍历你的代码并为变量和函数分配内存空间。这就是提升发挥作用的地方。

让我们从变量提升开始，当你使用 `var` 关键字声明一个变量时，JavaScript 会将声明提升到其作用域的顶部。然而，关键的是要注意，只有声明被提升，初始化不会被提升。这意味着你可以在声明变量之前在代码中使用它，但它的值将是 `undefined`，直到你实际为它赋值。

:::interactive_editor

```js
console.log(x); // undefined
var x = 5;
console.log(x); // 5
```

:::

在这段代码中，即使我们在声明 `x` 之前使用它，也不会出现误差，而是得到 `undefined`。这是因为 JavaScript 会将声明 `var x` 提升到其作用域的顶部，但不会提升初始化 `x = 5`。这就好像代码被重写成这样：

:::interactive_editor

```js
var x;
console.log(x); // undefined
x = 5;
console.log(x); // 5
```

:::

函数提升的工作方式有些不同。当你使用 `function` 声明语法声明一个函数时，函数名和函数体都会被提升。这意味着你可以在代码中声明函数之前调用它。以下是函数提升的示例：

:::interactive_editor

```js
sayHello(); // "Hello, World!"

function sayHello(){
  console.log("Hello, World!");
}
```

:::

在这种分支中，我们可以在 `sayHello()` 的声明之前调用它，因为整个函数会被提升到其作用域的顶部。

需要注意的是，ES6 中引入的 `let` 和 `const` 声明的提升行为不同。

```js
console.log(y); // Throws a ReferenceError
let y = 10;
```

这些声明会被提升，但它们不会被初始化，并且你不能在代码中实际声明之前访问它们。这通常被称为暂时性死区。

理解提升可以帮助你编写更简洁、更可预测的代码。然而，依赖提升会使你的代码更难阅读和维护。作为最佳实践，建议你在作用域顶部声明变量，并在使用函数之前声明函数，无论是否存在提升。这样可以使你的代码行为更显式，也更容易被包括未来的自己在内的其他人理解。

# --questions--

## --text--

使用 `var` 声明的变量被提升时会发生什么？

## --answers--

声明和初始化都被移到顶部。

### --feedback--

考虑一个被提升的变量在被显式赋值之前具有的值。

---

只有声明被移到顶部。

---

变量根本不会被提升。

### --feedback--

考虑一个被提升的变量在被显式赋值之前具有的值。

---

该变量已从代码中删除。

### --feedback--

考虑一个被提升的变量在被显式赋值之前具有的值。

## --video-solution--

2

## --text--

函数提升与变量提升有何不同？

## --answers--

函数不会被提升。

### --feedback--

考虑你是否可以在代码中函数的声明之前调用该函数。

---

只有函数名被提升。

### --feedback--

考虑你是否可以在代码中函数的声明之前调用该函数。

---

函数名和体都会被提升。

---

函数提升仅适用于箭头函数。

### --feedback--

考虑你是否可以在代码中函数的声明之前调用该函数。

## --video-solution--

3

## --text--

尝试在代码中声明 `let` 变量之前访问该变量的结果是什么？

## --answers--

返回 `undefined`。

### --feedback--

思考课程中提到的 `"temporal dead zone"` 概念。

---

它会抛出一个 `ReferenceError`。

---

返回 `null`。

### --feedback--

思考课程中提到的 `"temporal dead zone"` 概念。

---

它运行没有任何问题

### --feedback--

思考课程中提到的 `"temporal dead zone"` 概念。

## --video-solution--

2
