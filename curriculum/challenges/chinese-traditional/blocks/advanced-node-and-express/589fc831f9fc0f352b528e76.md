---
id: 589fc831f9fc0f352b528e76
title: 處理斷線
challengeType: 2
forumTopicId: 301552
dashedName: handle-a-disconnect
---

# --description--

你可能會注意到，到目前為止你只是在增加使用者數量。處理使用者斷線和處理初始連線一樣簡單，只是你必須在每個 `socket` 上監聽，而不是在整個 `server` 上監聽。

為此，請在現有的 `'connect'` 監聽器內添加另一個監聽器，該監聽器監聽 socket 上的 `'disconnect'`，且不傳遞任何資料。你可以透過將使用者已斷線的訊息記錄到主控台來測試此功能。

```js
socket.on('disconnect', () => {
  /*anything you want to do on disconnect*/
});
```

為了確保客戶端持續擁有最新的當前使用者數量，當斷線發生時，你應該將 `currentUsers` 減少 1，然後發出帶有更新後數量的 `'user count'` 事件。

**注意：** 就像 `'disconnect'` 一樣，所有其他 socket 可以發送到伺服器的事件都應該在定義了 `socket` 的連接監聽器中處理。

當你認為已經正確時，提交你的頁面。如果你遇到錯誤，你可以<a href="https://forum.freecodecamp.org/t/advanced-node-and-express/567135#handle-a-disconnect-8" target="_blank" rel="noopener noreferrer nofollow">查看至此為止完成的專案</a>。

# --hints--

伺服端應該控制代碼來處理來自 `socket` 的事件 disconnect。

```js
  const url = new URL("/_api/server.js", code);
  const res = await fetch(url);
  const data = await res.text();
  assert.match(data, /socket.on.*('|")disconnect('|")/s, '');
```

你的客戶端應該在監聽 `'user count'` 事件。

```js
  const url = new URL("/public/client.js", code);
  const res = await fetch(url);
  const data = await res.text();
  assert.match(
    data,
    /socket.on.*('|")user count('|")/s,
    'Your client should be connection to server with the connection defined as socket'
  );
```

