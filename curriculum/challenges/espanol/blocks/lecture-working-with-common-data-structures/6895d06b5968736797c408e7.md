---
id: 6895d06b5968736797c408e7
title: ¿Cómo funcionan los Maps, Hash Maps y Sets?
challengeType: 19
dashedName: how-do-maps-hash-maps-and-sets-work
---

# --description--

En esta lección, repasaremos mapas, hash maps y sets. Pero antes de eso, definamos Tipos Abstractos de Datos.

Un Tipo Abstracto de Datos (ADT) es una representación conceptual de un tipo de datos, incluyendo qué operaciones se pueden realizar sobre los datos y las propiedades de esos datos.

Los Tipos Abstractos de Datos son como planos que describen **qué** operaciones se pueden realizar, no **cómo** se realizan. Separan la interfaz de la implementación real de las operaciones.

Un **map** es un TDA que gestiona colecciones de pares clave-valor y sus operaciones de una manera muy específica y eficiente.

En un mapa, cada valor está asociado a una clave específica.

Una de las características clave de los mapas es que cada clave debe ser única. Esta unicidad permite búsquedas directas, lo que hace que el proceso de recuperar información sea mucho más eficiente.

Solo las claves deben ser únicas, los valores pueden repetirse.

El tipo abstracto de datos map también define operaciones importantes, como insertar pares clave-valor, obtener el valor asociado a una clave, actualizar el valor asociado a una clave, eliminar un par clave-valor y verificar si una clave existe en el map.

En realidad no especifica cómo deben realizarse estas operaciones, solo las lista como parte de las operaciones disponibles del tipo de datos.

Un **hash map**, también conocido como tabla hash, es una estructura concreta del tipo abstracto de datos map.

Los mapas hash usan una técnica llamada "hashing" para realizar operaciones comunes de manera muy eficiente.

El hashing funciona esencialmente generando un valor hash para cada elemento usando una función hash.

El valor hash se genera basado en la clave del par clave-valor y se usa para calcular un índice en un arreglo subyacente, la estructura de datos real donde se almacenan los pares clave-valor.

Pero podrías preguntarte: ¿Qué pasa si dos claves resultan en el mismo índice?

Los mapas hash resuelven estas colisiones con estrategias inteligentes.

Una opción es usar la estrategia de "encadenamiento", donde cada índice del arreglo apunta a una lista enlazada (otra estructura de datos), donde se almacenan todos los elementos con el mismo índice.

Otra estrategia es usar "open addressing", que implica buscar el siguiente índice disponible en el array basado en una secuencia de búsqueda predefinida.

La complejidad temporal en el caso promedio de los hash maps es "Tiempo Constante" `O(1)` para insertar, recuperar y eliminar pares clave-valor.

La complejidad temporal en el peor caso de estas operaciones es Tiempo Lineal `O(n)`, lo que ocurre cuando hay muchas colisiones de hash, por lo que la estrategia de resolución de colisiones debe aplicarse múltiples veces.

La complejidad espacial de insertar en un hash map es constante `O(1)` en el caso promedio, una cantidad constante de memoria para almacenar el nuevo par. Sin embargo, en el peor caso, puede tener una complejidad espacial lineal `O(n)` debido a una operación de redimensionamiento del arreglo subyacente. En general, eliminar un elemento tiene una complejidad espacial constante `O(1)`.

Esto convierte la tabla hash en algo similar a una estructura de datos lineal donde se deben escanear `n` elementos para encontrar la clave objetivo. Sin embargo, esto es relativamente raro si el mapa hash está implementado correctamente.

Los **diccionarios** de Python están implementados como mapas hash detrás de escena.

Para crear un diccionario en Python, solo necesitas escribir los pares clave-valor dentro de llaves y separarlos con una coma. Cada clave debe estar separada de su valor correspondiente con dos puntos.

```python
my_dictionary = {
  "A": 1,
  "B": 2, 
  "C": 3
}
```

En este código, `"A"` es la clave y `1` es el valor:

```python
"A": 1
```

Alternativamente, puedes usar `dict()`:

```python
my_dictionary = dict(A="1", B="2", C="3")
```

Puedes obtener el valor a través de su clave correspondiente:

```python
my_dictionary["A"]  # 1
```

También puedes actualizar el valor asociado con una clave:

```python
my_dictionary["A"] = 4
```

Y puedes eliminar un par clave-valor:

```python
del my_dictionary["A"]  
```

También puedes verificar si una clave está (o no) en el diccionario:

```python
"C" in my_dictionary
```

Y puedes llamar a estos métodos para obtener las keys, values y items del diccionario, respectivamente.

```python
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

Genial. Ahora que sabes más sobre mapas y hash maps, hablemos de conjuntos.

**Conjuntos** son colecciones desordenadas de elementos únicos.

Desglosemos este concepto en sus componentes clave:

* Los conjuntos no tienen orden. Los elementos de un conjunto no se almacenan en un orden específico, por lo que no puedes acceder a ellos mediante índices.
    
* Los conjuntos solo contienen elementos únicos. Si intentas agregar el mismo valor dos veces, solo se conservará una copia del valor.
    

Son análogos a los conjuntos en matemáticas y implementan las mismas operaciones de conjuntos, como intersección, unión y diferencia.

Una de las principales ventajas de los conjuntos es que garantizan que los elementos serán únicos (sin duplicados). Por eso, a menudo se usan para eliminar duplicados de listas y otras estructuras de datos.

También son dinámicos. Pueden ajustarse al número de elementos que están almacenados actualmente. Esto los hace bastante poderosos.

La complejidad temporal promedio de agregar, eliminar, obtener la longitud del conjunto y verificar si un elemento está en el conjunto es "Tiempo Constante" `O(1)`, lo cual es muy eficiente.

Dado que los conjuntos están implementados como tablas hash, la complejidad temporal en el peor caso para agregar, eliminar y verificar la pertenencia es "Tiempo Lineal" `O(n)`. Esto puede ocurrir cuando hay múltiples colisiones de hash, transformando la tabla hash en algo similar a una estructura de datos lineal, donde se requieren `n` escaneos para encontrar la clave.

En términos de complejidad espacial, en el caso promedio, insertar un elemento tendría una complejidad constante `O(1)`, con un nuevo elemento único que requiere una cantidad constante de memoria. Sin embargo, en el peor caso, podría haber una operación de redimensionamiento del arreglo subyacente, que podría tomar una complejidad espacial lineal `O(n)`. En general, eliminar un elemento tomaría una complejidad espacial constante `O(1)`.

Python tiene una estructura de datos `set` incorporada que usas para trabajar con conjuntos en tus programas.

Detrás de escena, los conjuntos en Python se implementan usando una tabla hash donde solo se almacenan las claves, sin valores asociados.

Los conjuntos solo pueden almacenar objetos de tipos de datos inmutables porque sus valores hash siempre permanecen iguales. En contraste, los valores hash de los objetos mutables pueden cambiar cuando son mutados. Por eso no pueden formar parte de los conjuntos. Si el valor hash de un objeto almacenado en el conjunto cambia, el programa ya no podría encontrarlo.

Para definir un conjunto en Python, solo necesitas rodear los elementos con llaves y separarlos con comas:

```python
numbers = {1, 2, 3, 4}
```

Para crear un conjunto vacío, puedes llamar a `set()`:

```python
numbers = set()
```

Ten en cuenta que si usas llaves vacías, esto creará automáticamente un diccionario de Python, no un conjunto, por lo que debes llamar a la función `set()` para crear un conjunto vacío.

Puedes agregar un elemento a un conjunto con el método `.add()`:

```python
numbers.add(5)
```

También puedes eliminar elementos del conjunto con el método `.remove()`:

```python
numbers.remove(5)
```

Esto lanzará un `KeyError` si el elemento no se encuentra. Pero si no quieres lanzar un error en ese caso, puedes usar el método `.discard()` en su lugar.

El método `.pop()` devuelve un elemento arbitrario del conjunto, mientras que el método `.clear()` elimina todos los elementos del conjunto.

Puedes probar si un elemento está en un conjunto con el operador `in`:

```python
5 in numbers
```

Python también soporta operaciones con conjuntos, incluyendo unión, diferencia, diferencia simétrica e intersección, que puedes realizar con estos métodos:

```python
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

set_a.union(set_b)
set_a.intersection(set_b)
set_a.symmetric_difference(set_b)
set_a.difference(set_b)
```

O con sus operadores equivalentes:

```python
set_a | set_b
set_a & set_b
set_a ^ set_b
set_a - set_b 
```

La complejidad temporal en el caso promedio para agregar, eliminar y verificar membresía es "Tiempo Constante" `O(1)`.

La complejidad temporal en el peor caso para estas operaciones es "Tiempo Lineal" `O(n)` debido al peor escenario de colisiones en el hash map.

También puedes verificar si un conjunto es un subconjunto o un superconjunto de otro:

```python
set_a.issubset(set_b)
set_a.issuperset(set_b)
```

En general, debes usar conjuntos cuando necesites almacenar una colección de elementos únicos y verificar frecuentemente la presencia de un elemento.

Los mapas, hash maps y sets son estructuras de datos poderosas diseñadas para la organización y recuperación eficiente de datos. Cada una de ellas tiene características y casos de uso únicos. Como desarrollador, necesitarás elegir la mejor para tu proyecto.

# --questions--

## --text--

¿Cuál es la diferencia fundamental en el tipo de datos almacenados por un hash map (o map) comparado con un set?

## --answers--

Los mapas hash almacenan colecciones ordenadas, mientras que los Sets almacenan colecciones no ordenadas.

### --feedback--

Piensa en qué está diseñada principalmente para almacenar cada estructura de datos.

---

Los mapas hash almacenan pares clave-valor únicos, mientras que los Sets almacenan elementos individuales únicos.

---

Los mapas hash no pueden almacenar valores duplicados, mientras que los Sets sí pueden.

### --feedback--

Piensa en qué está diseñada principalmente para almacenar cada estructura de datos.

---

Los conjuntos se usan para datos numéricos, mientras que los mapas hash son para datos textuales.

### --feedback--

Piensa en qué está diseñada principalmente para almacenar cada estructura de datos.

## --video-solution--

2

## --text--

¿Cuál es el mecanismo principal que permite a los hash maps y Sets lograr un rendimiento promedio de `O(1)` (tiempo constante) para operaciones como inserción y búsqueda?

## --answers--

Mantienen todos los elementos ordenados, permitiendo una búsqueda binaria rápida.

### --feedback--

Piensa en la función especial que convierte un elemento en un índice.

---

Almacenan elementos en una lista enlazada, permitiendo un recorrido rápido.

### --feedback--

Piensa en la función especial que convierte un elemento en un índice.

---

Usan una función hash para calcular una ubicación directa en la memoria para los elementos.

---

Siempre almacenan un número muy pequeño de elementos, haciendo que todas las operaciones sean rápidas.

### --feedback--

Piensa en la función especial que convierte un elemento en un índice.

## --video-solution--

3

## --text--

En el contexto de los mapas hash y conjuntos, ¿qué es una "colisión de hash"?

## --answers--

Cuando un elemento se encuentra con éxito después de una búsqueda.

### --feedback--

Piensa en el resultado cuando la función hash asigna diferentes entradas a la misma salida.

---

Cuando se inserta un elemento al principio de la colección.

### --feedback--

Piensa en el resultado cuando la función hash asigna diferentes entradas a la misma salida.

---

Cuando el hash map se queda sin memoria y necesita redimensionarse.

### --feedback--

Piensa en el resultado cuando la función hash asigna diferentes entradas a la misma salida.

---

Cuando dos claves o elementos diferentes producen el mismo valor hash.

## --video-solution--

4
