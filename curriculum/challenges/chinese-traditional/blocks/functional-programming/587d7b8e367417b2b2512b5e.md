---
id: 587d7b8e367417b2b2512b5e
title: 使用函式式程式設計避免變異和副作用
challengeType: 1
forumTopicId: 301228
dashedName: avoid-mutations-and-side-effects-using-functional-programming
---

# --description--

如果你還沒弄清楚，前一個挑戰的問題出在 `tabClose()` 函式中的 `splice` 呼叫。不幸的是，`splice` 會改變它所呼叫的原始陣列，所以第二次呼叫時使用了已被修改的陣列，導致了意料之外的結果。

這是一個更大樣式中的小範例－你對變數、陣列或物件呼叫函式，該函式會改變變數或物件中的某些東西。

函式（程式）設計的核心原則之一是不改變事物。改變會導致錯誤。知道你的函式不會改變任何東西，包括函式引數或任何全域變數，能更容易預防錯誤。

前一個範例沒有任何複雜的操作行為，但 `splice` 方法改變了原始陣列，並導致了錯誤。

請記住，在函式（程式）設計中，改變或修改事物稱為 <dfn>mutation</dfn>，而結果稱為 <dfn>side effect</dfn>。理想情況下，函式應該是 <dfn>pure function</dfn>，意即它不會造成任何副作用。

讓我們嘗試精通這門學科，並且不要更改程式碼中的任何變數或物件。

# --instructions--

填寫函式（程式）`incrementer` 的程式碼，使其傳回全域變數 `fixedValue` 加 1 後的值。

# --hints--

你的函式（程式）`incrementer` 不應該改變 `fixedValue`（其值為 `4`）。

```js
incrementer();
assert(fixedValue === 4);
```

你的 `incrementer` 函式應該傳回比 `fixedValue` 值大 1 的值。

```js
const __newValue = incrementer();
assert(__newValue === 5);
```

你的 `incrementer` 函式應該根據全域的 `fixedValue` 變數值傳回一個值。

```js
(function () {
  fixedValue = 10;
  const newValue = incrementer();
  assert(fixedValue === 10 && newValue === 11);
  fixedValue = 4;
})();
```

# --seed--

## --seed-contents--

```js
// The global variable
let fixedValue = 4;

function incrementer() {
  // Only change code below this line


  // Only change code above this line
}
```

# --solutions--

```js
let fixedValue = 4

function incrementer() {
  return fixedValue + 1
}
```
