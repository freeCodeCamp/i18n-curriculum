---
id: 67335f45489c5a11b71d0ed5
title: O que é Hoisting?
challengeType: 19
dashedName: what-is-hoisting
---

# --description--

Hoisting é um comportamento em JavaScript que frequentemente confunde iniciantes, mas entendê-lo pode ajudar você a evitar bugs sutis no seu código. Em termos simples, hoisting é o comportamento padrão do JavaScript de mover declarações para o topo de seus respectivos escopos durante a fase de compilação antes que o código seja executado.

Para entender hoisting, é importante saber que o JavaScript é executado em duas fases: a fase de compilação e a fase de execução. Durante a fase de compilação, o motor JavaScript percorre seu código e configura espaço de memória para variáveis e funções. É aqui que o hoisting entra em cena.

Vamos começar com o hoisting de variáveis, quando você declara uma variável usando a palavra-chave `var`, o JavaScript eleva a declaração para o topo do seu escopo. No entanto, é crucial notar que apenas a declaração é hoisted, não a inicialização. Isso significa que você pode usar uma variável no seu código antes de declará-la, mas seu valor será `undefined` até que você realmente atribua um valor a ela.

```js
console.log(x); // undefined
var x = 5;
console.log(5); // 5
```

Neste código, mesmo que usemos `x` antes de declará-lo, não recebemos um erro, em vez disso recebemos `undefined`. Isso acontece porque o JavaScript eleva a declaração `var x` para o topo do seu escopo mas não a inicialização `x = 5`. É como se o código fosse reescrito assim:

```js
var x;
console.log(x); // undefined
x = 5;
console.log(x); // 5
```

A elevação de função funciona de forma um pouco diferente. Quando você declara uma função usando a sintaxe de declaração `function` tanto o nome da função quanto o corpo da função são içados. Isso significa que você pode chamar uma função antes de declará-la no seu código. Aqui está um exemplo de hoisting de função:

```js
sayHello(); // "Hello, World!"

function sayHello(){
  console.log("Hello, World!");
}
```

Neste caso, podemos chamar `sayHello()` antes da sua declaração porque toda a função é içada para o topo do seu escopo.

É importante notar que o hoisting funciona de forma diferente com as declarações `let` e `const` introduzidas no ES6. 

```js
console.log(y); // Throws a ReferenceError
let y = 10;
```

Essas declarações são elevadas, mas não são inicializadas e você não pode acessá-las antes da declaração real no seu código. Isso é frequentemente referido como a zona morta temporal.

Entender hoisting pode ajudar você a escrever código mais limpo e previsível. No entanto, depender de hoisting pode tornar seu código mais difícil de ler e manter. Como uma boa prática, recomenda-se declarar suas variáveis no topo do seu escopo e suas funções antes de usá-las independentemente de hoisting.  This make your code's behavior more explicit and easier for others including your future self to understand.

# --questions--

## --text--

O que acontece quando uma variável declarada com `var` é içada?

## --answers--

Tanto a declaração quanto a inicialização são movidas para o topo.

### --feedback--

Pense no valor que uma variável içada tem antes de ser explicitamente atribuída um valor.

---

Apenas a declaração é movida para o topo.

---

A variável não é hoisted de forma alguma.

### --feedback--

Pense no valor que uma variável içada tem antes de ser explicitamente atribuída um valor.

---

A variável é deletada do código.

### --feedback--

Pense no valor que uma variável içada tem antes de ser explicitamente atribuída um valor.

## --video-solution--

2

## --text--

Como o hoisting de função difere do hoisting de variável?

## --answers--

Funções não são içadas.

### --feedback--

Considere se você pode chamar uma função antes da sua declaração no código.

---

Apenas o nome da função é içado.

### --feedback--

Considere se você pode chamar uma função antes da sua declaração no código.

---

Tanto o nome da função quanto o corpo são içados.

---

A elevação de função funciona apenas com arrow functions.

### --feedback--

Considere se você pode chamar uma função antes da sua declaração no código.

## --video-solution--

3

## --text--

Qual é o resultado de tentar acessar uma variável declarada com `let` antes da sua declaração no código?

## --answers--

Retorna `undefined`.

### --feedback--

Pense no conceito da "zona morta temporal" mencionada na lição.

---

Ele lança um `ReferenceError`.

---

Ele retorna `null`.

### --feedback--

Pense no conceito da "zona morta temporal" mencionada na lição.

---

Funciona sem nenhum problema

### --feedback--

Pense no conceito da "temporal dead zone" mencionado na lição.

## --video-solution--

2
