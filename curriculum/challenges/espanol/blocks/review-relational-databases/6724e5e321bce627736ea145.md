---
id: 6724e5e321bce627736ea145
title: Revisión de Bases de Datos Relacionales
challengeType: 31
dashedName: review-relational-databases
---

# --description--

## Conceptos Básicos de Terminal, Shell y Línea de Comandos

- **Línea de comandos**: Una interfaz de texto donde los usuarios escriben comandos.
- **Terminal**: La aplicación que proporciona acceso a la línea de comandos.
- **Emulador de terminal**: Añade características adicionales a un terminal.
- **Shell**: Interpreta los comandos introducidos en el terminal (por ejemplo, Bash).
- **PowerShell / Command Prompt / Microsoft Terminal**: Opciones para acceder a la línea de comandos en Windows.
- **Terminal (macOS)**: Opción incorporada en macOS, con alternativas de terceros como iTerm o Ghostty.
- **Terminal (Linux)**: Las opciones varían según la distribución, con muchos emuladores de terceros como kitty.
- **Terminología**: Aunque "terminal", "shell" y "línea de comandos" se usan a menudo de manera intercambiable, tienen significados específicos.

## Atajos de Línea de Comandos

- **Flechas arriba/abajo**: Recorre los comandos anteriores/siguientes en el historial.
- **Tab**: Autocompletar comandos.
- **`Control+L`** (Linux/macOS) o escribiendo `cls` (Windows): Limpie la pantalla del terminal.
- **`Control+C`**: Interrumpe un comando en ejecución (también se usa para copiar en PowerShell si el texto está seleccionado).
- **`Control+Z`** (solo Linux/macOS): Suspende una tarea en segundo plano; use `fg` para reanudarla.
- **`!!`**: Vuelva a ejecutar instantáneamente el último comando ejecutado.

## Conceptos Básicos de Bash

- **Bash** (Bourne Again Shell): Shell ampliamente utilizado en sistemas tipo Unix.Comandos clave:

  - **`pwd`**: Mostrar el directorio actual.
  - **`cd`**: Cambiar de directorios.
    - **`..`** se refiere al directorio principal (un nivel arriba).
    - **`.`** se refiere al directorio actual.
  - **`ls`**: Listar archivos y carpetas.
    - **`-a`**: Mostrar todos los archivos, incluidos los ocultos.
    - **`-l`**: Mostrar información detallada sobre archivos.
  - **`less`**: Ver el contenido del archivo una página a la vez con opciones de navegación, incluyendo desplazamiento hacia atrás y búsqueda.
  - **`more`**: Mostrar el contenido del archivo una pantalla a la vez, con desplazamiento hacia atrás limitado y navegación básica.
  - **`cat`**: Mostrar el contenido completo del archivo a la vez sin desplazamiento ni navegación, útil para archivos más pequeños.
  - **`mkdir`**: Crear un nuevo directorio.
  - **`rmdir`**: Eliminar un directorio vacío.
  - **`touch`**: Crear un nuevo archivo.
  - **`mv`**: Mover o renombrar archivos.
    - Renombrar: `mv oldname.txt newname.txt`
    - Mover: `mv filename.txt /path/to/target/`
  - **`cp`**: Copiar archivos.
    - **`-r`**: Copiar directorios y sus contenidos de forma recursiva.
  - **`rm`**: Eliminar archivos.
    - **`-r`**: Eliminar directorios y sus contenidos de forma recursiva.
  - **`echo`**: Mostrar una línea de texto o el valor de una variable.
    - Usa `>` para sobrescribir el contenido existente en un archivo. (por ejemplo, `echo "text" > file.txt`)
    - Usa `>>` para agregar salida a un archivo **sin sobrescribir el contenido existente** (por ejemplo, `echo "text" >> file.txt`).
  - **`exit`**: Salir de la sesión del terminal.
  - **`clear`**: Limpiar la pantalla del terminal.
  - **`find`**: Buscar archivos y directorios.
    - **`-name`**: Busca archivos por patrón de nombre (por ejemplo, `find . -name "*.txt"`).
  - Use **`man`** seguido de un comando (por ejemplo, `man ls`) para acceder a páginas de manual/ayuda detallada.

## Opciones y Banderas de Comando

- **Opciones** o **banderas**: modifican el comportamiento de un comando y generalmente se preceden por guiones:
  - **Forma larga (dos guiones)**:
    - Ejemplo: `--help`, `--version`
    - Los valores se adjuntan utilizando un signo igual, por ejemplo, `--width=50`.
  - **Forma corta (un guión)**:
    - Ejemplo: `-a`, `-l`
    - Los valores se pasan con un espacio, por ejemplo, `-w 50`.
    - Se pueden encadenar varias opciones cortas, por ejemplo, `ls -alh`.
- **`--help`**: Siempre puede usar un comando con esta bandera para comprender las opciones disponibles para cualquier comando.

## Introducción a las Bases de Datos Relacionales

- **Bases de datos relacionales**: Organizan datos en tablas relacionadas compuestas por filas y columnas. Cada fila representa un registro, y cada columna representa un atributo de los datos.
- **Ventajas de las Bases de Datos Relacionales**: Escalables, ampliamente aplicables en diversos dominios (por ejemplo, salud, negocios, juegos) y estructuradas para mantener datos confiables.
- **Casos de uso comunes**: desarrollo web, sistemas de inventario, comercio electrónico, salud y aplicaciones empresariales.

## Conceptos clave

- **Esquema**: Una base de datos relacional requiere un esquema que defina su estructura—tablas, columnas, tipos de datos, restricciones y relaciones.
- **Claves Primarias**: Identificadores únicos para cada fila en una tabla. Son esenciales para la integridad de los datos y se usan para relacionar registros entre tablas mediante claves foráneas.
- **Claves foráneas**: Referencias a claves primarias en otra tabla, usadas para enlazar datos relacionados entre tablas.
- **Relaciones**: Al conectar tablas mediante claves primarias y foráneas, puedes estructurar datos normalizados y realizar consultas significativas.
- **Diagramas de Relaciones de Entidades (ERDs)**: Visualiza cómo las entidades (tablas) se relacionan entre sí en un esquema de base de datos.
- **Integridad de Datos**: Se aplica usando claves y tipos de datos. Garantiza la consistencia y precisión de los datos almacenados.

## Conceptos básicos de SQL

- **Consultas**: Solicitudes para recuperar datos específicos de la base de datos.

```sql
SELECT * FROM dogs WHERE age < 3;
```

- **Cláusula WHERE**: Filtra resultados basados en condiciones. Usa operadores de comparación como `<`, `=`, `>`, etc.
- **Select con ORDER BY**: Recupera y ordena resultados basados en una columna.

```sql
SELECT columns FROM table_name ORDER BY column_name;
```

## Operaciones de Tabla

- **Sentencia `CREATE TABLE`**: Esta sentencia se usa para crear una nueva tabla en una base de datos.

```sql
CREATE TABLE first_table();
```

- **Sentencia `ALTER TABLE ADD COLUMN`**: Esta sentencia se usa para agregar una columna a una tabla existente.

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE;
```

- **Sentencia `ALTER TABLE DROP COLUMN`**: Esta sentencia se usa para eliminar una columna de una tabla existente.

```sql
ALTER TABLE table_name DROP COLUMN column_name;
```

- **Sentencia `ALTER TABLE RENAME COLUMN`**: Esta sentencia se usa para renombrar una columna en una tabla.

```sql
ALTER TABLE table_name RENAME COLUMN column_name TO new_name;
```

- **Sentencia `DROP TABLE`**: Esta sentencia se usa para eliminar una tabla completa de la base de datos.

```sql
DROP TABLE table_name;
```

- **Sentencia `ALTER DATABASE RENAME`**: Esta sentencia se usa para renombrar una base de datos.

```sql
ALTER DATABASE database_name RENAME TO new_database_name;
```

- **Sentencia `DROP DATABASE`**: Esta sentencia se usa para eliminar una base de datos completa.

```sql
DROP DATABASE database_name;
```

## Restricciones e Integridad de Datos

- **`ALTER TABLE ADD COLUMN` con Restricción**: Esta sentencia se usa para agregar una columna con una restricción a una tabla existente.

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE CONSTRAINT;
```

- **Restricción `NOT NULL`**: Esta restricción asegura que una columna no pueda tener valores NULL.

```sql
column_name VARCHAR(50) NOT NULL
```

- **Sentencia `ALTER TABLE ADD PRIMARY KEY`**: Esta sentencia se usa para agregar una restricción de clave primaria a una tabla.

```sql
ALTER TABLE table_name ADD PRIMARY KEY(column_name);
```

- **Sentencia `ALTER TABLE DROP CONSTRAINT`**: Esta sentencia se usa para eliminar una restricción de una tabla.

```sql
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
```

- **`ALTER TABLE ADD COLUMN` con clave foránea**: Esta instrucción se usa para agregar una columna de clave foránea que referencia a otra tabla.

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE REFERENCES referenced_table_name(referenced_column_name);
```

- **Sentencia `ALTER TABLE ADD UNIQUE`**: Esta sentencia se usa para agregar una restricción UNIQUE a una columna.

```sql
ALTER TABLE table_name ADD UNIQUE(column_name);
```

- **Sentencia `ALTER TABLE ALTER COLUMN SET NOT NULL`**: Esta sentencia se usa para establecer una restricción NOT NULL en una columna existente.

```sql
ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL;
```

- **Sentencia `INSERT` con valores NULL**: Esta sentencia muestra cómo insertar valores NULL en una tabla.

```sql
INSERT INTO table_name(column_a) VALUES(NULL);
-- or
INSERT INTO table_name(column_b) VALUES('value'); -- if column_a allows nulls
```

- **Clave primaria compuesta**: Esta restricción define una clave primaria que consiste en múltiples columnas.

```sql
CREATE TABLE course_enrollments (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id)
);
```

## Manipulación de Datos (CRUD)

- **Sentencia `INSERT`**: Esta sentencia se usa para insertar una sola fila en una tabla.

```sql
INSERT INTO table_name(column_1, column_2) VALUES(value1, value2);
```

- **Sentencia `INSERT` con Columnas Omitidas**: Esta sentencia muestra cómo insertar valores sin listar explícitamente los nombres de las columnas, confiando en el orden predeterminado de las columnas en la tabla.

```sql
INSERT INTO dogs VALUES ('Gino', 3);
```

- **Sentencia `INSERT` con Múltiples Filas**: Esta sentencia se usa para insertar múltiples filas en una tabla en una sola operación.

```sql
INSERT INTO dogs (name, age) VALUES 
('Gino', 3),
('Nora', 2);
```

- **Sentencia `UPDATE`**: Esta sentencia se usa para actualizar datos existentes en una tabla basándose en una condición.

```sql
UPDATE table_name SET column_name=new_value WHERE condition;
```

- **Sentencia `DELETE`**: Esta sentencia se usa para eliminar filas de una tabla basándose en una condición.

```sql
DELETE FROM table_name WHERE condition;
```

## Tipos de datos

- **Tipo de dato `NUMERIC`**: Este tipo de dato se usa para almacenar números decimales precisos con una precisión y escala especificadas.

```sql
price NUMERIC(10, 2)
```

- **Tipo de dato `TEXT`**: Este tipo de dato se usa para almacenar cadenas de caracteres de longitud variable sin un límite específico de longitud.

```sql
column_name TEXT
```

- **Tipo de dato `INTEGER`**: Este tipo de dato se usa para almacenar números enteros sin decimales.

```sql
units_sold INTEGER
```

- **Tipos de Datos `SMALLINT` y `BIGINT`**: Estas son variantes de INTEGER con rangos más pequeños y más grandes respectivamente.

- **Tipo de dato `SERIAL`**: Este tipo de dato se usa para crear columnas enteras con auto-incremento en PostgreSQL.

```sql
id SERIAL
```

- **Atributo `AUTO_INCREMENT`**: Este atributo se usa en MySQL para crear columnas enteras con incremento automático.

```sql
id INT AUTO_INCREMENT
```

- **Tipo de dato `VARCHAR`**: Este tipo de dato se usa para almacenar cadenas de caracteres de longitud variable con una longitud máxima especificada.

```sql
name VARCHAR(50)
```

- **Tipo de dato `DATE`**: Este tipo de dato se usa para almacenar valores de fecha (año, mes, día).

```sql
event_date DATE
```

- **Tipo de dato `TIME`**: Este tipo de dato se usa para almacenar valores de tiempo (hora, minuto, segundo).

```sql
start_time TIME
```

- **Tipo de dato `TIMESTAMP`**: Este tipo de dato se usa para almacenar valores de fecha y hora, opcionalmente con información de zona horaria.

```sql
event_timestamp TIMESTAMP
event_timestamp TIMESTAMP WITH TIME ZONE
```

- **Tipo de dato `BOOLEAN`**: Este tipo de dato se usa para almacenar valores verdadero/falso.

```sql
is_active BOOLEAN
```

## Relaciones de Base de Datos

- **Tipos de Relaciones**: Estas son las diferentes formas en que las tablas pueden estar relacionadas entre sí en una base de datos relacional.
  - Uno a uno
  - Uno a muchos
  - Muchos a uno
  - Muchos a muchos
  - Auto-referencia (recursiva)

- **Relación Uno a Uno**: Este tipo de relación significa que cada registro en una tabla corresponde exactamente a un registro en otra tabla.

```md
One employee is assigned exactly one vehicle.
Tables: employees, vehicles
```

- **Relación Uno a Muchos**: Este tipo de relación significa que un registro en una tabla puede estar asociado con múltiples registros en otra tabla.

```md
One customer can have many orders.
Tables: customers → orders
```

- **Relación Muchos a Muchos mediante Tabla de Unión**: Este tipo de relación se implementa usando una tabla de unión que contiene claves foráneas de ambas tablas relacionadas.

```sql
CREATE TABLE books_authors (
    author_id INT REFERENCES authors(id),
    book_id INT REFERENCES books(id)
);
```

- **Relaciones de Autorreferencia**: Este tipo de relación ocurre cuando una tabla se referencia a sí misma, creando una estructura jerárquica.

```md
An employee table where each employee may report to another employee.
```

## SQL avanzado (Joins)

- **Sentencia `INNER JOIN`**: Esta unión devuelve solo las filas que tienen valores coincidentes en ambas tablas.

```sql
SELECT *
FROM products
INNER JOIN sales ON products.product_id = sales.product_id;
```

- **Sentencia `FULL OUTER JOIN`**: Esta unión devuelve todas las filas de ambas tablas, incluyendo las filas no coincidentes de cualquiera de las tablas.

```sql
SELECT *
FROM products
FULL OUTER JOIN sales ON products.product_id = sales.product_id;
```

- **Sentencia `LEFT OUTER JOIN`**: Esta unión devuelve todas las filas de la tabla izquierda y las filas coincidentes de la tabla derecha.

```sql
SELECT *
FROM products
LEFT JOIN sales ON products.product_id = sales.product_id;
```

- **Sentencia `RIGHT OUTER JOIN`**: Esta unión devuelve todas las filas de la tabla derecha y las filas coincidentes de la tabla izquierda.

```sql
SELECT *
FROM products
RIGHT JOIN sales ON products.product_id = sales.product_id;
```

- **Sentencia `SELF JOIN`**: Esta unión se usa para unir una tabla consigo misma y comparar filas dentro de la misma tabla.

```sql
SELECT A.column_name, B.column_name
FROM table_name A
JOIN table_name B ON A.related_column = B.related_column;
```

- **Sentencia `CROSS JOIN`**: Esta unión devuelve el producto cartesiano de dos tablas, combinando cada fila de la primera tabla con cada fila de la segunda tabla.

```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

## Comandos específicos de PostgreSQL

- **Comando de inicio de sesión `psql`**: Este comando se usa para iniciar sesión en PostgreSQL con un nombre de usuario y base de datos específicos.

```bash
psql --username=freecodecamp --dbname=postgres
```

- **Comando `\l`**: Este comando lista todas las bases de datos en la instancia de PostgreSQL.

```sql
\l
```

- **Comandos `CREATE DATABASE` y `\c`**: Estos comandos se usan para crear una nueva base de datos y conectarse a ella.

```sql
CREATE DATABASE database_name;
\c database_name
```

- **Comando `\d`**: Este comando lista todas las tablas en la base de datos actual.

```sql
\d
```

- **Comando `\d table_name`**: Este comando muestra el esquema/estructura de una tabla específica.

```sql
\d table_name
```

- **Comando `\q`**: Este comando cierra el cliente de PostgreSQL.

```bash
\q
```

## Relacional vs No Relacional

- **Bases de datos no relacionales (NoSQL)**: Almacenan datos no estructurados o semi-estructurados. No requieren un esquema rígido y son más flexibles para modelos de datos en evolución.
- **Elegir entre relacional y no relacional**: Depende de la naturaleza de tus datos y los requisitos de la aplicación.
- **Relacional vs No relacional**: Elige relacional para datos estructurados y consistencia; NoSQL para flexibilidad y datos que cambian rápidamente.

## Sistemas RDBMS populares

- **MySQL**: De código abierto, confiable, ampliamente usado en el desarrollo web, respaldado por una gran comunidad.
- **PostgreSQL**: De código abierto, avanzado, extensible. Soporta tipos de datos personalizados y programación del lado del servidor.
- **SQLite**: Ligero, basado en archivos, sin servidor. Ideal para aplicaciones pequeñas.
- **Microsoft SQL Server**: Base de datos propietaria de nivel empresarial.
- **Oracle Database**: RDBMS comercial conocido por su rendimiento y escalabilidad a gran escala.

## Mejores Prácticas

- **Convención de Nombres**: Usa `snake_case` (por ejemplo, `delivery_orders`) para nombres de tablas y columnas.

## Conceptos Básicos de Scripting en Bash

- **Scripting en Bash**: Escribir una secuencia de comandos Bash en un archivo, que luego puedes ejecutar con Bash para correr el contenido del archivo.
- **Shebang**: La línea comentada al inicio de un script (por ejemplo, `#!/bin/bash`) que indica qué intérprete debe usarse para el script.

  ```bash
  #!/bin/bash
  ```

- **Asignación de variables**: Instancia variables usando la sintaxis `variable_name=value`.

  ```bash
  servers=("prod" "dev")
  ```

- **Reglas para la creación de variables**: Crea variables con la sintaxis `VARIABLE_NAME=VALUE`. No se permiten espacios alrededor del signo igual (`=`). Usa comillas dobles si el valor contiene espacios.

  ```bash
  NAME=John
  MESSAGE="Hello World"
  COUNT=5
  TEXT="The next number is, "
  ```

- **Uso de variables**: Accede a los valores de las variables colocando `$` delante del nombre de la variable.

  ```bash
  echo $NAME
  echo "The message is: $MESSAGE"
  ```

- **Interpolación de variables**: Usa `$variable_name` para acceder al valor de una variable dentro de cadenas y comandos.

  ```bash
  TEXT="The next number is, "
  NUMBER=42
  echo $TEXT B:$NUMBER
  echo $TEXT I:$NUMBER
  
  echo "Pulling $server"
  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf
  ```

- **Ámbito de variable**: Los scripts de Shell se ejecutan de arriba hacia abajo, por lo que las variables solo pueden usarse debajo del lugar donde se crean.

  ```bash
  NAME="Alice"
  echo $NAME
  ```

- **Entrada del usuario**: Usa `read` para aceptar entrada de los usuarios y almacenarla en una variable.

  ```bash
  read USERNAME
  echo "Hello $USERNAME"
  ```

- **Comentarios**: Añade comentarios a tus scripts usando `#` seguido del texto de tu comentario.
  - Los comentarios de una sola línea comienzan con `#` y continúan hasta el final de la línea
  - Los comentarios son ignorados por el shell y no afectan la ejecución del script

  ```bash
  # This is a single-line comment
  NAME="John"  # Comment at end of line
  ```

- **Comentarios multilínea**: Comenta bloques de código usando dos puntos y comillas.

  ```bash
  : '
  This is a multi-line comment
  Everything between the quotes is ignored
  Useful for debugging or documentation
  '
  ```

- **Comandos integrados y ayuda**:
  - Usa `help` para ver una lista de comandos bash integrados
  - Usa `help <command>` para obtener información sobre comandos integrados específicos
  - Algunos comandos (como `if`) son incorporados y no tienen páginas man
  - Los comandos integrados se ejecutan directamente por el shell en lugar de como programas externos
  - Usa `help function` para ver información sobre cómo crear funciones

  ```bash
  help
  help if
  help function
  ```

- **Encontrar ubicaciones de comandos**: Usa `which` para localizar dónde están instalados los ejecutables.
  - Muestra la ruta completa a los archivos ejecutables
  - Útil para encontrar ubicaciones del intérprete (como bash)
  - Ayuda a verificar qué versión de un comando se ejecutará

  ```bash
  which bash
  which python
  which ls
  ```

- **Páginas de manual**: Usa `man` para acceder a la documentación detallada de los comandos.
  - Proporciona información completa sobre el uso de comandos
  - Muestra todas las opciones y ejemplos disponibles
  - Usa las teclas de flecha para navegar, 'q' para salir
  - No todos los comandos tienen páginas de manual (los integrados usan `help` en su lugar)

  ```bash
  man echo
  man ls
  man bash
  ```

- **Banderas de ayuda**: Muchos comandos soportan `--help` para información rápida de ayuda.
  - Alternativa a las páginas de manual para referencia rápida
  - Muestra la sintaxis del comando y las opciones comunes
  - No todos los comandos soportan esta bandera (algunos pueden mostrar error)

  ```bash
  ls --help
  chmod --help
  mv --help
  ```

- **Opciones del comando Echo**: El comando `echo` soporta varias opciones:
  - La opción `-e` habilita la interpretación de secuencias de escape con barra invertida
  - `\n` crea una nueva línea
  - Las líneas vacías solo se imprimen cuando los valores están entre comillas
  - Útil para crear salida formateada y títulos de programas

  ```bash
  echo -e "Line 1\nLine 2"
  echo ""
  echo -e "\n~~ Program Title ~~\n"
  echo "Line 1\nLine 2"
  ```

- **Argumentos de script**: Los programas pueden aceptar argumentos que son accesibles usando variables `$`.
  - `$*` imprime todos los argumentos pasados al script
  - `$@` imprime todos los argumentos pasados al script como cadenas separadas entre comillas
  - `$<number>` accede a argumentos específicos por posición (por ejemplo, `$1`, `$2`, `$3`)

  ```bash
  echo $*
  echo $@
  echo $1
  echo $2
  ```

## Expresiones de Doble Corchete `[[ ]]`

- **Sintaxis de doble corchete**: Usa `[[ ]]` para pruebas condicionales y coincidencia de patrones.
  - Debe haber espacios dentro de los corchetes y alrededor de los operadores
  - Devuelve el estado de salida 0 (true) o 1 (false) según el resultado de la prueba

  ```bash
  [[ $variable == "value" ]]
  [[ $number -gt 10 ]]
  [[ -f filename.txt ]]
  ```

- **Operadores de comparación de cadenas**: Compara cadenas usando varios operadores dentro de `[[ ]]`.
  - `==` (equal): Prueba si dos cadenas son idénticas
  - `!=` (no es igual): Prueba si dos cadenas son diferentes
  - `<` (menos lexicográficamente): comparación de cadenas en orden alfabético
  - `>` (lexicográficamente mayor): comparación de cadenas en orden alfabético

  ```bash
  [[ "apple" == "apple" ]]
  [[ "apple" != "orange" ]]
  [[ "apple" < "banana" ]]
  [[ "zebra" > "apple" ]]
  ```

- **Operadores de comparación numérica**: Compara números usando operadores numéricos específicos.
  - `-eq` (equal): comparación de igualdad numérica
  - `-ne` (not equal): comparación de desigualdad numérica
  - `-lt` (less than): comparación numérica de menor que
  - `-le` (less than or equal): comparación numérica de menor o igual
  - `-gt` (greater than): comparación numérica de mayor que
  - `-ge` (greater than or equal): comparación numérica de mayor o igual que

  ```bash
  [[ $number -eq 5 ]]
  [[ $count -ne 0 ]]
  [[ $age -ge 18 ]]
  [[ $score -lt 100 ]]
  ```

- **Operadores lógicos**: Combina múltiples condiciones usando operadores lógicos.
  - `&&` (y): Ambas condiciones deben ser verdaderas
  - `||` (o): Al menos una condición debe ser verdadera
  - `!` (not): Niega la condición (convierte true en false, false en true)

  ```bash
  [[ $age -ge 18 && $age -le 65 ]]
  [[ $name == "John" || $name == "Jane" ]]
  [[ ! -f missing_file.txt ]]
  ```

- **Operadores de prueba de archivo**: Prueba propiedades y existencia de archivos.
  - `-e file`: Verdadero si el archivo existe
  - `-f file`: Verdadero si el archivo existe y es un archivo regular
  - `-d file`: Verdadero si el archivo existe y es un directorio
  - `-r file`: Verdadero si el archivo existe y es legible
  - `-w file`: Verdadero si el archivo existe y es escribible
  - `-x file`: Verdadero si el archivo existe y es ejecutable
  - `-s file`: Verdadero si el archivo existe y tiene un tamaño mayor que cero

  ```bash
  [[ -e /path/to/file ]]
  [[ -f script.sh ]]
  [[ -d /home/user ]]
  [[ -x program ]]
  ```

- **Coincidencia de patrones con `=~`**: Usa expresiones regulares para una coincidencia avanzada de patrones.
  - El operador `=~` permite la coincidencia de patrones regex
  - El patrón no debe ir entre comillas cuando uses metacaracteres de regex
  - Soporta la sintaxis completa de expresiones regulares
  - Sensible a mayúsculas y minúsculas por defecto

  ```bash
  [[ "hello123" =~ [0-9]+ ]]
  [[ "email@domain.com" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
  [[ "filename.txt" =~ \.txt$ ]]
  ```

- **Prueba de existencia de variable**: Verifica si las variables están definidas o vacías.
  - Prueba si la variable está vacía: `[[ ! $variable ]]`

  ```bash
  [[ ! $undefined_var ]]
  ```

## Expresiones de Doble Paréntesis `(( ))`

- **Evaluación aritmética**: Usa `(( ))` para cálculos matemáticos y comparaciones numéricas.
  - Evalúa expresiones aritméticas usando sintaxis estilo C
  - Las variables no necesitan el prefijo `$` dentro de los paréntesis dobles
  - Devuelve el estado de salida 0 si el resultado es distinto de cero, 1 si el resultado es cero
  - Soporta todos los operadores aritméticos estándar

  ```bash
  (( result = 10 + 5 ))
  (( count++ ))
  (( total += value ))
  ```

- **Operadores aritméticos**: Operadores matemáticos disponibles en `(( ))`.
  - `+` (adición): Suma dos números
  - `-` (subtraction): Resta el segundo número del primero
  - `*` (multiplicación): Multiplica dos números
  - `/` (división): Divide el primer número por el segundo (división entera)
  - `%` (módulo): Residuo después de la división
  - `**` (exponenciación): Eleva el primer número a la potencia del segundo

  ```bash
  (( sum = a + b ))
  (( diff = x - y ))
  (( product = width * height ))
  (( remainder = num % 10 ))
  (( power = base ** exponent ))
  ```

- **Operadores de asignación**: Modifica variables usando operadores de asignación aritmética.
  - `=` (asignación): Asigna un valor a la variable
  - `+=` (sumar y asignar): Añade un valor a la variable
  - `-=` (restar y asignar): Resta un valor a la variable
  - `*=` (multiplicar y asignar): Multiplica la variable por el valor
  - `/=` (divide y asigna): Divide la variable por el valor
  - `%=` (módulo y asignar): Establece la variable al resto

  ```bash
  (( counter = 0 ))
  (( counter += 5 ))
  (( total -= cost ))
  (( area *= 2 ))
  (( value /= 3 ))
  ```

- **Operadores de incremento y decremento**: Modifica variables en uno.
  - `++variable` (pre-incremento): Incrementa antes de usar
  - `variable++` (post-incremento): Incrementa después de usarlo
  - `--variable` (pre-decremento): Decrementa antes de usar
  - `variable--` (post-decremento): Decrementa después de usar

  ```bash
  (( ++counter ))
  (( index++ ))
  (( --remaining ))
  (( attempts-- ))
  ```

- **Operadores de comparación**: Compara números usando comparación aritmética.
  - `==` (equal): Los números son iguales
  - `!=` (no es igual): Los números no son iguales
  - `<` (menos que): El primer número es menor que el segundo
  - `<=` (menor o igual): El primer número es menor o igual que el segundo
  - `>` (mayor que): El primer número es mayor que el segundo
  - `>=` (mayor o igual que): El primer número es mayor o igual que el segundo

  ```bash
  (( age >= 18 ))
  (( score < 100 ))
  (( count == 0 ))
  (( temperature > freezing ))
  ```

- **Operadores lógicos**: Combina condiciones aritméticas.
  - `&&` (y): Ambas condiciones deben ser verdaderas
  - `||` (o): Al menos una condición debe ser verdadera
  - `!` (not): Niega la condición

  ```bash
  (( age >= 18 && age <= 65 ))
  (( score >= 90 || extra_credit > 0 ))
  (( !(count == 0) ))
  ```

- **Operadores a nivel de bits**: Realizan operaciones a nivel de bits en enteros.
  - `&` (AND a nivel de bits): operación AND en cada bit
  - `|` (bitwise OR): operación OR en cada bit
  - `^` (bitwise XOR): operación XOR en cada bit
  - `~` (bitwise NOT): Invierte todos los bits
  - `<<` (left shift): Desplaza bits hacia la izquierda
  - `>>` (right shift): Desplaza bits hacia la derecha

  ```bash
  (( result = a & b ))
  (( flags |= new_flag ))
  (( shifted = value << 2 ))
  ```

- **Operador condicional (ternario)**: Usa la sintaxis `condition ? true_value : false_value`.
  - Proporciona una forma concisa de asignar valores basados en condiciones
  - Similar al operador ternario en lenguajes estilo C
  - Evalúa la condición y devuelve uno de dos valores

  ```bash
  (( result = (score >= 60) ? 1 : 0 ))
  (( max = (a > b) ? a : b ))
  (( sign = (num >= 0) ? 1 : -1 ))
  ```

- **Sustitución de comandos con aritmética**: Usa `$(( ))` para capturar resultados aritméticos.
  - Devuelve el resultado de la expresión aritmética como una cadena
  - Puede usarse en asignaciones o argumentos de comando
  - Útil para cálculos que necesitan ser usados en otro lugar

  ```bash
  result=$(( 10 + 5 ))
  echo "The answer is $(( a * b ))"
  array_index=$(( RANDOM % array_length ))
  ```

## Flujo de Control y Condicionales

- **Sentencias condicionales**: Usa sentencias `if` para ejecutar código basado en condiciones.
  - Sintaxis básica: `if [[ CONDITION ]] then STATEMENTS fi`
  - Sintaxis completa: `if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`
  - Puedes usar tanto las expresiones `[[ ]]` como `(( ))` para diferentes tipos de condiciones
  - **elif (else if)**: Opcional, puede repetirse varias veces para probar condiciones adicionales en secuencia
  - **else**: Opcional, se ejecuta cuando todas las condiciones anteriores son falsas
  - Puedes mezclar dobles paréntesis `(( ... ))` y dobles corchetes `[[ ... ]]` en la misma cadena condicional

  ```bash
  if (( NUMBER <= 15 ))
  then
      echo "B:$NUMBER"
  elif [[ $NUMBER -le 30 ]]
  then
      echo "I:$NUMBER"
  elif (( NUMBER < 46 ))
  then
      echo "N:$NUMBER"
  elif [[ $NUMBER -lt 61 ]]
  then
      echo "G:$NUMBER"
  else
      echo "O:$NUMBER"
  fi
  ```

## Ejecución de Comandos y Control de Procesos

- **Separación de comandos**: Usa punto y coma (`;`) para ejecutar múltiples comandos en una sola línea.
  - Los comandos se ejecutan secuencialmente de izquierda a derecha
  - El estado de salida de cada comando puede verificarse individualmente

  ```bash
  [[ 4 -ge 5 ]]; echo $?
  ls -l; echo "Done"
  ```

- **Estado de salida**: Cada comando tiene un estado de salida que indica éxito o fallo.
  - Accede al estado de salida del último comando con `$?`
  - El estado de salida `0` significa éxito (verdadero/sin errores)
  - Cualquier estado de salida distinto de cero significa fallo (ocurrieron errores/falso)
  - Códigos de error comunes: `127` (comando no encontrado), `1` (error general)

  ```bash
  echo $?
  [[ 4 -le 5 ]]; echo $?
  ls; echo $?
  bad_command; echo $?
  ```

- **Subshells y sustitución de comandos**: Diferentes usos de paréntesis para contextos de ejecución.
  - Los paréntesis simples `( ... )` crean una subshell
  - `$( ... )` realiza la sustitución de comandos
  - Las subshells se ejecutan en entornos separados y no afectan las variables del shell padre

  ```bash
  ( cd /tmp; echo "Current dir: $(pwd)" )
  current_date=$(date)
  file_count=$(ls | wc -l)
  echo "Today is $current_date"
  echo "Found $file_count files"
  ```

- **Comando Sleep**: Pausa la ejecución del script por un número especificado de segundos.
  - Útil para crear retrasos en scripts
  - Puede usarse con valores decimales para retrasos de subsegundos

  ```bash
  sleep 3
  sleep 0.5
  sleep 1
  ```

## Loops

- **Bucles while**: Ejecuta código repetidamente mientras una condición sea verdadera.
  - Sintaxis: `while [[ CONDITION ]] do STATEMENTS done`

  ```bash
  I=5
  while [[ $I -ge 0 ]]
  do
      echo $I
      (( I-- ))
      sleep 1
  done
  ```

- **Bucles Until**: Ejecuta código repetidamente hasta que una condición se vuelva verdadera.
  - Sintaxis: `until [[ CONDITION ]] do STATEMENTS done`

  ```bash
  until [[ $QUESTION =~ \?$ ]]
  do
      echo "Please enter a question ending with ?"
      read QUESTION
  done
  until [[ $QUESTION =~ \?$ ]]
  do
      GET_FORTUNE again
  done
  ```

- **Bucles for**: Itera a través de arreglos o listas usando bucles `for` con `do` y `done` para definir el bloque lógico del bucle.

  ```bash
  for server in "${servers[@]}"
  do
      echo "Processing $server"
  done
  for (( i = 1; i <= 5; i++ ))
  do
      echo "Number: $i"
  done
  for (( i = 5; i >= 1; i-- ))
  do
      echo "Countdown: $i"
  done
  for i in {1..5}
  do
      echo "Count: $i"
  done
  ```

## Arreglos

- **Arrays**: Almacena múltiples valores en una sola variable.
  - Crea arreglos con paréntesis: `ARRAY=("value1" "value2" "value3")`
  - Accede a elementos por índice: `${ARRAY[0]}`, `${ARRAY[1]}`
  - Accede a todos los elementos: `${ARRAY[@]}` o `${ARRAY[*]}`
  - El índice de un array comienza en 0

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Ask again later")

  echo ${RESPONSES[0]}     # Yes          
  echo ${RESPONSES[1]}     # No         
  echo ${RESPONSES[5]}     # Index 5 doesn't exist; empty string              
  echo ${RESPONSES[@]}     # Yes No Maybe Ask again later   
  echo ${RESPONSES[*]}     # Yes No Maybe Ask again later 
  ```

- **Inspección de arrays con declare**: Usa `declare -p` para ver los detalles del array.
  - Muestra el tipo de arreglo con la bandera `-a`
  - Muestra todos los elementos del array y su estructura

  ```bash
  ARR=("a" "b" "c")
  declare -p ARR # ARR=([0]="a" [1]="b" [2]="c")
  ```

- **Expansión de arrays**: Usa la sintaxis `"${array_name[@]}"` para expandir un array en elementos individuales.

```bash
for server in "${servers[@]}"
```

## Funciones

- **Funciones**: Crea bloques reutilizables de código.
  - Define con `FUNCTION_NAME() { STATEMENTS }`
  - Llama usando el nombre de la función
  - Puede aceptar argumentos accesibles como `$1`, `$2`, etc.

  ```bash
  GET_FORTUNE() {
      echo "Ask a question:"
      read QUESTION
  }
  GET_FORTUNE
  ```

- **Argumentos de función**: Las funciones pueden aceptar argumentos al igual que los scripts.
  - Los argumentos se pasan al llamar a la función
  - Accede a los argumentos dentro de la función usando `$1`, `$2`, etc.
  - Usa lógica condicional para manejar diferentes argumentos

  ```bash
  GET_FORTUNE() {
      if [[ ! $1 ]]
      then
          echo "Ask a yes or no question:"
      else
          echo "Try again. Make sure it ends with a question mark:"
      fi
      read QUESTION
  }
  GET_FORTUNE
  GET_FORTUNE again
  ```

## Números aleatorios y operaciones matemáticas

- **Números aleatorios**: Genera valores aleatorios usando la variable `$RANDOM`.
  - `$RANDOM` genera números entre 0 y 32767
  - Usa el operador módulo para limitar el rango: `$RANDOM % 75`
  - Suma 1 para evitar cero: `$(( RANDOM % 75 + 1 ))`
  - Debes usar la sintaxis `$(( ... ))` para cálculos con `$RANDOM`

  ```bash
  NUMBER=$(( RANDOM % 6 ))
  DICE=$(( RANDOM % 6 + 1 ))
  BINGO=$(( RANDOM % 75 + 1 ))
  echo $(( RANDOM % 10 ))
  ```

- **Acceso aleatorio a arrays**: Usa números aleatorios para acceder a elementos del array de forma aleatoria.
  - Genera un índice aleatorio dentro de los límites del array
  - Usa un índice aleatorio para acceder a los elementos del arreglo
  - Útil para selecciones aleatorias de opciones predefinidas

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Outlook good" "Don't count on it" "Ask again later")
  N=$(( RANDOM % 6 ))
  echo ${RESPONSES[$N]}
  ```

- **Operador módulo**: Usa `%` para obtener el resto de las operaciones de división.
  - Esencial para limitar rangos de números aleatorios
  - Funciona con `$RANDOM` para crear valores aleatorios limitados
  - `RANDOM % n` da números desde 0 hasta n-1

  ```bash
  echo $(( 15 % 4 ))
  echo $(( RANDOM % 100 ))
  echo $(( RANDOM % 10 + 1 ))
  ```

## Información del entorno y del sistema

- **Variables de entorno**: Variables predefinidas disponibles en el entorno de la shell.
  - `$RANDOM`: Genera números aleatorios entre 0 y 32767
  - `$LANG`: configuración del idioma del sistema
  - `$HOME`: ruta del directorio personal del usuario
  - `$PATH`: Directorios donde se buscan los comandos ejecutables
  - Ve todo con `printenv` o `declare -p`

  ```bash
  echo $RANDOM
  echo $HOME
  echo $LANG
  printenv
  ```

- **Inspección de variables**: Usa `declare` para ver y trabajar con variables.
  - `declare -p`: Imprime todas las variables y sus valores
  - `declare -p VARIABLE`: Imprime detalles específicos de la variable
  - Muestra el tipo de variable (string, array, etc.) y los atributos

  ```bash
  declare -p
  declare -p RANDOM
  declare -p MY_ARRAY
  ```

- **Tipos de comandos**: Diferentes categorías de comandos disponibles en bash.
  - **Comandos integrados**: Ejecutados directamente por el shell (por ejemplo, `echo`, `read`, `if`)
  - **Comandos externos**: Archivos binarios en directorios del sistema (por ejemplo, `ls`, `sleep`, `bash`)
  - **Palabras clave de Shell**: Estructuras del lenguaje (por ejemplo, `then`, `do`, `done`)
  - Usa `type <command>` para ver qué tipo es un comando

  ```bash
  type echo
  type ls
  type if
  type ./script.sh
  ```

## Creación y gestión de archivos

- **Creación de archivos**: Usa `touch` para crear archivos vacíos nuevos.
  - Crea un archivo nuevo si no existe
  - Actualiza la marca de tiempo si el archivo ya existe
  - Comúnmente usado para crear archivos de script antes de editar

  ```bash
  touch script.sh
  touch bingo.sh
  touch filename.txt
  ```

## Creando y Ejecutando Scripts Bash

- **Métodos de ejecución de scripts**: Varias formas de ejecutar scripts bash:
  - **`sh scriptname.sh`**: Ejecuta con el intérprete de shell sh.
  - **`bash scriptname.sh`**: Ejecuta con el intérprete de la shell bash.
  - **`./scriptname.sh`**: Ejecuta directamente (requiere permisos de ejecución).

```bash
sh questionnaire.sh
bash questionnaire.sh
./questionnaire.sh
```

## Permisos de Archivos y Ejecución de Scripts

- **Error de permiso denegado**: Al usar `./scriptname.sh`, puedes recibir "permission denied" si el archivo no tiene permisos de ejecución.
- **Comprobando permisos**: Usa `ls -l` para ver los permisos de archivos.

  ```bash
  ls -l questionnaire.sh
  ```

- **Formato de permisos**: La salida muestra los permisos como `-rw-r--r--` donde:
  - Primer carácter (`-`): Tipo de archivo (- para archivo regular, d para directorio)
  - Los siguientes 9 caracteres: Permisos para propietario, grupo y otros
  - `r` = leer, `w` = escribir, `x` = ejecutar
  
- **Agregar permisos de ejecución**: Usa `chmod +x` para dar permisos de ejecución a todos.

  ```bash
  chmod +x questionnaire.sh
  ```

- **Organización de scripts**: Mejores prácticas para estructurar scripts bash.
  - Comienza con shebang (`#!/bin/bash`)
  - Agrega comentarios descriptivos sobre el propósito del script
  - Define variables en la parte superior
  - Agrupa funciones relacionadas juntas
  - Lógica principal del script al final

  ```bash
  #!/bin/bash
  NAME="value"
  ARRAY=("item1" "item2")
  my_function() {
      echo "Function code here"
  }
  my_function
  echo "Script complete"
  ```

- **Ejecución secuencial de scripts**: Crea scripts maestros que ejecuten múltiples programas en secuencia.
  - Útil para automatizar flujos de trabajo que involucran múltiples scripts
  - Cada script se ejecuta hasta completarse antes de que comience el siguiente
  - Puedes combinar diferentes programas en un solo flujo de ejecución
  - Los argumentos pueden pasarse a scripts individuales según sea necesario
  - Puede incluir diferentes tipos de programas (interactivos, automatizados, etc.)

  ```bash
  #!/bin/bash
  ./setup.sh
  ./interactive.sh
  ./processing.sh
  ./cleanup.sh
  ```

## Normalización de Bases de Datos

Este es el proceso de organizar una base de datos relacional para reducir la redundancia de datos y mejorar la integridad.

Sus beneficios incluyen:

- Minimizar datos duplicados, lo que ahorra espacio de almacenamiento y reduce inconsistencias.
- Aplicando la integridad de datos mediante el uso de claves primarias y foráneas.
- Hacer que las bases de datos sean más fáciles de mantener y entender.

### Formas Normales

- **1NF (Primera Forma Normal)**
  - Cada celda contiene un solo valor (atómico).
  - Cada registro es único (garantizado por una clave primaria).
  - El orden de las filas/columnas es irrelevante.
  - Ejemplo: Mueve múltiples números de teléfono de una tabla `students` a una tabla separada `student_phones`.

- **2NF (Segunda Forma Normal)**
  - Cumple con los requisitos de 1NF.
  - No hay **dependencias parciales**: cada atributo que no es clave debe depender de toda la clave primaria compuesta.
  - Ejemplo: Divide la tabla `orders` en `order_header` y `order_items` para evitar que los atributos dependan solo de una parte de la clave.

- **3NF (Tercera Forma Normal)**
  - Cumple con los requisitos de 2NF.
  - No hay **dependencias transitivas**: los atributos que no son clave no pueden depender de otros atributos que tampoco son clave.
  - Ejemplo: Mueve `city_postal_code` a una tabla `cities` en lugar de almacenarlo con cada orden.

- **BCNF (Forma Normal de Boyce-Codd)**
  - Cumple con los requisitos de 3NF.
  - Cada determinante (lado izquierdo de una dependencia funcional) debe ser una superclave.

**Consejo**: Apunta a 3NF en la mayoría de los diseños para un buen equilibrio entre integridad y rendimiento.

## Conceptos clave de SQL

- SQL es un Lenguaje de Consulta Estructurado para comunicarse con bases de datos relacionales.
- **Comandos básicos** → `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`, `ALTER TABLE`, etc.
- `Joins` → Combina datos de múltiples tablas (`INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`).

## Ejecutando comandos SQL en Bash

Puedes ejecutar comandos SQL directamente desde la línea de comandos usando el cliente de línea de comandos `psql` para PostgreSQL o herramientas similares para otras bases de datos.

Por ejemplo, para ejecutar un archivo SQL en PostgreSQL:

```bash
psql -U username -d database_name -c "SELECT * FROM students;"
```

También puedes ejecutar comandos MySQL directamente:

```bash
mysql -u username -p database_name -e "SELECT * FROM students;"
```

### Ejecuta SQL desde un Archivo

```bash
# PostgreSQL
psql -U username -d database_name -f script.sql

# MySQL
mysql -u username -p database_name < script.sql
```

### Incrusta SQL en un script de Bash

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Insert student data
psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'CS');"
```

### Uso de Variables en SQL

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"
STUDENT_NAME="Bob"
AGE=21

psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age) VALUES ('$STUDENT_NAME', $AGE);"
```

**Consejo**: Sanitiza las variables para evitar la inyección SQL.

## Recuperar y usar resultados de consultas SQL en Bash

Cuando ejecutas consultas SQL a través de `psql`, puedes **capturar** y **procesar** los valores devueltos en tus scripts de Bash.

### Capturando un Valor Único

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get total student count
STUDENT_COUNT=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -c \
"SELECT COUNT(*) FROM students;")

echo "Total students: $STUDENT_COUNT"
```

Salida → 42

### Recuperar Múltiples Columnas

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get top 3 students' names and ages
RESULTS=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, age FROM students LIMIT 3;")

echo "Top 3 students:"
echo "$RESULTS"
```

Resultado

```bash
Alice,20
Bob,21
Charlie,22
```

### Iterando a través de los resultados de la consulta

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get student names and majors
psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, major FROM students;" | while IFS="," read -r name major
do
    echo "Student: $name | Major: $major"
done
```

Forma de la salida

```bash
Student: Alice | Major: CS
Student: Bob   | Major: Math
Student: Carol | Major: Physics
```

## Inyección SQL

Es una vulnerabilidad de seguridad web donde los atacantes insertan código SQL malicioso en los campos de entrada para manipular la base de datos.

Esto puede llevar a acciones arriesgadas como:

- Omitiendo la autenticación.
- Robar datos sensibles.
- Modificando o eliminando registros.

Un ejemplo de un ataque de inyección SQL:

```sql
SELECT * FROM users WHERE username = ' " " OR "1"="1" -- ' AND password = 'anything';
```

Esta consulta devolvería todos los usuarios porque la condición `OR "1"="1"` siempre es verdadera, permitiendo que los atacantes evadan las verificaciones de inicio de sesión.

### Previniendo la inyección SQL

1. **Usa Prepared Statements**: Estos separan el código SQL de los datos, previniendo inyecciones. Aquí tienes un ejemplo (Node.js con pg):

    ```sql
    client.query('SELECT * FROM users WHERE username = $1 AND password = $2', [username, password]);
    ```

2. **Validación de Entrada**: Sanitiza y valida todas las entradas del usuario para asegurar que cumplan con los formatos esperados.

3. **Menor Privilegio**: Usa cuentas de base de datos con los permisos mínimos necesarios para la aplicación.

**Nota**: Nunca otorgues derechos de administrador a las cuentas de aplicación.

## Problema N+1

El problema N+1 ocurre cuando una aplicación hace una consulta para obtener una lista de elementos (N) y luego hace una consulta adicional por cada elemento para obtener datos relacionados, resultando en N+1 consultas.

**Por qué es malo**

- Cada consulta añade sobrecarga de red y procesamiento.
- Varias consultas pequeñas son más lentas que una consulta optimizada.

### Ejemplo del patrón N+1

```sql
-- 1: Get list of orders
SELECT * FROM orders LIMIT 50;

-- N: For each order, get customer
SELECT * FROM customers WHERE customer_id = ...;
```

**Solución**: Usa `JOINs` u otras operaciones basadas en conjuntos.

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name,
  customers.email,
  customers.address
FROM orders
JOIN customers 
  ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50);
```

Siempre busca oportunidades para combinar datos relacionados en una sola consulta.

## Introducción al Control de Versiones

- **Definición**: Un sistema de control de versiones te permite rastrear y gestionar cambios en tu proyecto. Ejemplos de sistemas de control de versiones usados en software son Git, SVN o Mercurial.

## Proveedores de Control de Versiones Basados en la Nube

- **Lista de proveedores de control de versiones basados en la nube**: GitHub y GitLab son ejemplos populares de proveedores de control de versiones basados en la nube que permiten a los equipos de software colaborar y gestionar repositorios.

## Instalando y configurando Git

- **Instalando Git**: Para verificar si Git ya está instalado en tu máquina, puedes ejecutar el siguiente comando en la terminal:

```sh
git --version
```

Si ves un número de versión, eso significa que Git está instalado. Si no, entonces necesitarás instalarlo.

Para sistemas Linux, Git a menudo viene preinstalado con la mayoría de las distribuciones. Si no tienes Git preinstalado, deberías poder instalarlo con los comandos de tu gestor de paquetes, como `sudo apt-get install git` o `sudo pacman -S git`.

Para usuarios de Mac, puedes instalar Git vía Homebrew con `brew install git`, o puedes descargar el instalador ejecutable desde el sitio web de Git.

Para Windows, puedes descargar el instalador ejecutable desde el sitio web de Git. O, si has configurado Chocolatey, puedes ejecutar `choco install git.install` en PowerShell. Ten en cuenta que en Windows, también puede que quieras descargar Git Bash para tener un entorno de shell similar a Unix disponible.

Para asegurarte de que la instalación funcionó, ejecuta el comando `git --version` nuevamente en la terminal.

- **Configuraciones de Git**: `git config` se usa para establecer variables de configuración que determinan cómo Git funciona en tu máquina. Para ver las variables de configuración actuales y dónde están almacenadas en tu sistema, puedes ejecutar el siguiente comando:

```sh
git config --list --show-origin
```

En este momento deberías estar viendo solo la configuración a nivel de sistema si acabas de instalar Git por primera vez. 

Para establecer tu nombre de usuario, puedes ejecutar el siguiente comando:

```sh
git config --global user.name "Jane Doe"
```

La bandera `--global` se usa aquí para establecer el nombre de usuario para todos los proyectos en tu sistema que usan Git. Si necesitas sobrescribir el nombre de usuario para un proyecto en particular, entonces puedes ejecutar el comando en ese directorio de proyecto sin la bandera `--global`.

Para establecer la dirección de correo electrónico del usuario, puedes ejecutar el siguiente comando:

```sh
git config --global user.email janedoe@example.com
```

Otra configuración que puedes establecer es el editor preferido que quieres que Git use. Aquí tienes un ejemplo de cómo establecer tu editor preferido a Emacs:

```sh
git config --global core.editor emacs
```

Si eliges no configurar un editor preferido, entonces Git usará el editor predeterminado de tu sistema.

## Software de Código Abierto vs. Cerrado

- **Definición**: "Open-source" significa que las personas pueden ver el código que publicas, proponer cambios, reportar problemas e incluso ejecutar una versión modificada. "Closed-source" significa que las únicas personas que pueden ver e interactuar con el proyecto son las que autorizas explícitamente.

## GitHub

- **Definición**: GitHub es una solución basada en la nube que ofrece almacenamiento de proyectos con control de versiones en algo llamado "repositories", y permite funciones de colaboración para usar con esos proyectos.
- **GitHub CLI**: Esta herramienta se usa para realizar tareas específicas de GitHub sin salir de la línea de comandos. Si no la tienes instalada, puedes obtener instrucciones para hacerlo en la documentación de GitHub, pero deberías tenerla disponible en el gestor de paquetes de tu sistema.
- **GitHub Pages**: GitHub Pages es una opción para desplegar sitios estáticos, o aplicaciones que no requieren un servidor back-end para manejar la lógica. Es decir, aplicaciones que se ejecutan completamente del lado del cliente, o en el navegador del usuario, pueden ser desplegadas completamente en esta plataforma.
- **GitHub Actions**: GitHub Actions es una función que te permite automatizar flujos de trabajo directamente en tu repositorio de GitHub, incluyendo la construcción, prueba y despliegue de tu código.

## Comandos comunes de Git

- **`git init`**: Esto inicializará un repositorio Git vacío para que Git pueda comenzar a rastrear cambios en este proyecto. Cuando inicializas un repositorio Git vacío en un proyecto, se añadirá un nuevo directorio oculto `.git`. Este directorio `.git` contiene información importante para que Git gestione tu proyecto.
- **`git status`**: Este comando se usa para mostrar el estado actual de tu directorio de trabajo; usarás este comando mucho en tu flujo de trabajo.
- **`git add`**: Este comando se usa para preparar tus cambios. Todo lo que esté en el área de preparación se añadirá para el próximo commit. Si quieres preparar todos los cambios no preparados, puedes usar `git add .` El punto (`.`) es un alias para el directorio actual en el que estás.
- **`git commit`**: Este comando se usa para confirmar tus cambios. Un commit es una instantánea del estado de tu proyecto en ese momento. Si ejecutas `git commit`, se abrirá el editor que hayas configurado en Git. Una vez abierto el editor, puedes proporcionar un mensaje detallado de tus cambios. También puedes optar por proporcionar un mensaje más corto usando el comando `git commit -m` así:

```sh
git commit -m "short message goes here"
```

- **`git log`**: Esto listará todos los commits anteriores con información útil como el autor, la fecha del commit, el mensaje del commit y el hash del commit. El hash del commit es una cadena larga que sirve como identificador único para un commit.
- **`git remote add`**: Este comando se usa para configurar la conexión remota a tu repositorio remoto.
- **`git push`**: Este comando se usa para subir tus cambios a un repositorio remoto.
- **`git pull`**: Este comando se usa para descargar los últimos cambios de tu repositorio remoto a tu repositorio local.
- **`git clone`**: Este comando clonará un repositorio. Esto significa que tendrás una copia del repositorio. Esta copia incluye el historial del repositorio, todos los archivos/carpetas y commits en tu dispositivo local.
- **`git remote -v`**: Este comando mostrará la lista de repositorios remotos asociados con tu repositorio local de Git.
- **`git branch`**: Este comando mostrará todas tus ramas locales.
- **`git fetch upstream`**: Este comando le indica a Git que obtenga los últimos cambios que están en tu remoto upstream (que es el repositorio original).
- **`git merge upstream/main`**: Este comando indica a Git que fusione los últimos cambios de la rama `main` en el remoto upstream dentro de tu rama actual.
- **`git reset`**: Este comando te permite restablecer el estado actual de una rama. Usar la bandera `--hard` le indica a Git que fuerce los archivos locales para que coincidan con el estado de la rama. Esto asegura que tengas una base limpia desde la cual trabajar.
- **`git rebase`**: Un rebase en Git es una forma de mover o combinar una secuencia de commits de una rama a otra.
  
## Trabajando con Branches

- **Definición**: Una rama en Git es un espacio de trabajo separado donde puedes hacer cambios. La rama `main` a menudo representará la rama principal o de producción en una aplicación del mundo real. Los equipos de desarrollo crearán múltiples ramas para nuevas funciones y correcciones de errores y luego fusionarán esos cambios de nuevo en la rama `main`.
- **Crear una Nueva Rama**: Para crear una nueva rama puedes ejecutar el siguiente comando:

```sh
git branch feature
```

Para cambiar a esa rama, puedes ejecutar el siguiente comando:

```sh
git checkout feature
```

La mayoría de los desarrolladores usarán el comando abreviado para crear y cambiar a una rama, que es el siguiente:

```sh
git checkout -b new-branch-name
```

Un comando más nuevo y alternativo sería el comando `git switch`. Aquí tienes un ejemplo para crear y cambiar a una nueva rama:

```sh
git switch -c new-branch-name
```

- **Estrategias de branching**: Tu rama `main` es tu rama predeterminada y generalmente es bastante estable. Por eso, es mejor crear nuevas ramas a partir de ella para elementos como correcciones de errores, nuevas funcionalidades u otros trabajos diversos.
- **Conflictos de fusión**: Esto ocurre cuando Git intenta fusionar automáticamente cambios de diferentes ramas pero no puede decidir qué cambios conservar. Esto suele pasar cuando hay cambios conflictivos en la misma parte del archivo.

## Cinco estados para un archivo rastreado por Git

- **"Untracked"**: Esto significa que el archivo es nuevo en el repositorio y Git no lo ha "visto" antes.
- **"Modificado"**: Este archivo existía en el commit anterior y tiene cambios que no han sido confirmados.
- **"Ignored"**: Probablemente no verás archivos ignorados en Git, pero tu IDE podría tener un indicador para ellos. Los archivos ignorados están excluidos de las operaciones de Git, normalmente porque están incluidos en el archivo `.gitignore`.
- **"Deleted"**: Un archivo eliminado es lo opuesto a un archivo no rastreado: es un archivo que existía previamente y ha sido removido.
- **"Renombrado"**: Un archivo renombrado es un archivo cuyo contenido no ha cambiado, pero el nombre o la ubicación del archivo fue modificada. En algunos casos, un archivo puede considerarse renombrado incluso si tiene una pequeña cantidad de cambios.

## Archivos `.gitignore`

- **Definición**: El archivo `.gitignore` es un tipo especial de archivo relacionado con las operaciones de Git. El nombre sugiere que este archivo se usa para decirle a Git que ignore cosas, y ese es el caso de uso común. Pero lo que realmente hace es indicarle a Git que deje de rastrear un archivo.

## Trabajando con Repositorios

- **Definición**: Un repositorio es como un contenedor para un proyecto: si estás trabajando en una app, guardarías los archivos de esa app juntos en un repositorio. Los repositorios pueden estar locales en tu computadora o remotos en un servicio como GitHub.
- **Repositorios Públicos vs. Privados**: Un repositorio público puede ser visto y descargado por cualquiera. Un repositorio privado solo puede ser accedido por ti y por quienes les otorgues acceso explícito.
- **Creando Repositorios en GitHub**: Para crear un nuevo repositorio en GitHub, puedes hacer clic en el botón `"New Repository"` y seguir la interfaz de GitHub para configurar un nuevo repositorio.
- **Subir repositorios locales a GitHub**: Si tienes un proyecto local en tu computadora, puedes subir ese repositorio a GitHub. Aquí tienes un resumen paso a paso del proceso:

1. Inicializa un repositorio git vacío en el directorio del proyecto (`git init`).
2. Haz cambios en tu proyecto.
3. Ejecuta el comando `git status` para ver todos los cambios realizados que están siendo rastreados por git.
4. Prepara tus cambios (`git add`).
5. Confirma tus cambios (`git commit`).
6. Configura la conexión remota (`git remote add`).
7. Envía tus cambios a GitHub (`git push`).

## Solicitudes de extracción

- **Pull Requests**: Un pull request es una solicitud para incorporar cambios desde tu rama hacia la rama objetivo. Los pull requests son el flujo que usas cuando quieres contribuir con cambios de código a un proyecto. Este enfoque permite que los mantenedores del proyecto revisen tus cambios. Pueden dejar comentarios, hacer preguntas y sugerir ajustes. Luego, una vez que el proceso de revisión esté completo, puede ser aprobado y fusionado en la rama principal.

## Contribuyendo a Otros Repositorios

- **Proceso**: Hay miles de proyectos a los que puedes contribuir. Aquí está el proceso básico sobre cómo contribuir a otro repositorio:

1. Lee la documentación de contribución
2. Encuentra un issue disponible para trabajar
3. Haz un fork del repositorio
4. Clona tu copia bifurcada del repositorio
5. Crea una nueva rama
6. Haz los cambios según el problema
7. Crea un PR (Pull Request)
8. Espera una revisión para ese PR

## Trabajando con llaves SSH y GPG

- **Claves GPG**: Las claves GPG, o Gnu Privacy Guard, se usan típicamente para firmar archivos o commits. Alguien puede usar entonces tu clave pública GPG para verificar que la firma del archivo proviene de tu clave y que el contenido del archivo no ha sido modificado ni alterado.

Para generar una clave GPG, necesitarás ejecutar:

```sh
gpg --full-generate-key
```

- **Claves SSH**: Las claves SSH, o Secure SHell, se usan típicamente para autenticar una conexión remota a un servidor mediante la utilidad `ssh`. También puedes usar una clave SSH para firmar commits.

Para una clave SSH, ejecutarás:

```sh
ssh-keygen -t ed25519 -C "your_email@example.com"
```

`ed25519` es un algoritmo moderno de firma de clave pública.

- **Firmar Commits con Claves GPG**: Para firmar tus commits con tu clave GPG, necesitarás subir tu clave pública, no la clave privada, a tu cuenta de GitHub. Para listar tus claves públicas, deberás ejecutar lo siguiente:

```sh
gpg --list-secret-keys --keyid-format=long
```

Luego, para obtener la clave pública, usa:

```sh
gpg --armor --export "<key id>"
```
  
Luego, toma el ID corto que obtuviste al listar las claves y ejecuta este comando para configurarlo como tu clave de firma de git:

```sh
git config --global user.signingkey <your_gpg_key_id>
```

Luego, puedes pasar la bandera `-S` a tu comando `git commit` para firmar un commit específico; necesitarás proporcionar tu frase de contraseña. Alternativamente, si quieres firmar cada commit automáticamente, puedes configurar autosign en `true`:

```sh
git config --global commit.gpgsign true
```

- **Firmar Commits con Claves SSH**: Para firmar con una clave SSH, que es una función relativamente nueva en GitHub, primero necesitarás subir la clave a tu cuenta de GitHub. Luego deberás configurar el modo de firma para que git use SSH:

```sh
git config --global gpg.format ssh
```

Luego, para establecer la clave de firma, pasarás la ruta del archivo en lugar de un ID:

```sh
git config --global user.signingkey <path_to_your_ssh_keys>
```

# --assignment--

Revisa temas y conceptos de Bash, SQL y otras bases de datos relacionales.
