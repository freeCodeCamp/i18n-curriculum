---
id: 6724e2dbf723fe1c8883cc69
title: Revisión de bibliotecas de interfaz de usuario
challengeType: 31
dashedName: review-front-end-libraries
---

# --description--

## Bibliotecas y frameworks de JavaScript

- Las bibliotecas y frameworks de JavaScript ofrecen soluciones rápidas a problemas comunes y aceleran el desarrollo al proporcionar código preconstruido.
- Las bibliotecas generalmente se enfocan en proporcionar soluciones a tareas específicas, como manipular el DOM, manejar eventos, o gestionar solicitudes AJAX.
- Un par de ejemplos de bibliotecas de JavaScript son jQuery y React.
- Los frameworks, por otro lado, ofrecen una estructura más definida para construir aplicaciones. A menudo vienen con un conjunto de reglas y convenciones que los desarrolladores deben seguir.
- Ejemplos de frameworks incluyen Angular y Next.js, un meta framework para React.
- <strong x-id= "1">Aplicaciones de una sola página</strong> (SPAs) son aplicaciones web que cargan una sola página HTML y actualizan dinámicamente esa página a medida que el usuario interactúa con la aplicación sin recargar la página completa.
- Las SPAs usan JavaScript para gestionar el estado de la aplicación y renderizar contenido. Esto a menudo se hace utilizando frameworks que proporcionan grandes herramientas para construir interfaces de usuario complejas.
- Some issues surrounding SPAs include:

  - Los lectores de pantalla tienen dificultades con contenido actualizado dinámicamente.
  - La URL no cambia cuando el usuario navega dentro de la aplicación, lo que puede dificultar el marcado, el retroceso o el compartir páginas específicas.
  - El tiempo de carga inicial puede ser lento si la aplicación es grande, ya que todos los recursos necesitan cargarse de antemano.

## React

- React es una librería muy popular de JavaScript para construir interfaces de usuario y aplicaciones web.
- Un concepto fundamental de React es la creación de componentes de UI reutilizables que pueden actualizarse y renderizarse independientemente a medida que cambian los datos.
- React permite a los desarrolladores describir cómo debería parecer la UI basándose en el estado de la aplicación. React luego actualiza y renderiza los componentes correctos cuando los datos o el estado cambian.

## Componentes de React

- Los componentes son las piezas fundamentales de las aplicaciones React que permiten a los desarrolladores descomponer interfaces de usuario complejas en partes más pequeñas y manejables.
- La UI se describe utilizando JSX, una extensión de la sintaxis de JavaScript, que permite a los desarrolladores escribir código similar a HTML dentro de JavaScript.
- Los componentes son básicamente funciones o clases JS que retornan un fragmento de UI.

Aquí tienes un ejemplo de un componente React simple que renderiza un mensaje de saludo:

```jsx
function Greeting() {
  const name = 'Anna';
  return <h1>Welcome, {name}!</h1>;
}
```

Para usar el componente, simplemente puedes llamar:
    
```jsx
  <Greeting />
```

## Importando y Exportando componentes React

- Los componentes React pueden ser exportados de un archivo y importados en otro archivo.
- Digamos que tienes un componente llamado `City` en un archivo llamado `City.js`. Puedes exportar el componente usando la palabra clave `export`:

```jsx
// City.js
function City() {
  return <p>New York</p>;
}

export default City;
```

- Para importar el componente `City` en otro archivo, puedes usar la palabra clave `import`:

```jsx
// App.js
import City from './City';

function App() {
  return (
    <div>
      <h1>My favorite city is:</h1>
      <City />
    </div>
  );
}
```

- La palabra clave `default` se usa ya que es la exportación por defecto del archivo `City.js`.

- También puedes elegir exportar el componente en la misma línea que la definición del componente de esta manera:

```jsx
export default function City() {
  return <p>New York</p>;
}
```

## Configuración de un proyecto React usando Vite

- Las herramientas de configuración de proyectos y las CLIs ofrecen una forma rápida y sencilla de iniciar nuevos proyectos, permitiendo a los desarrolladores enfocarse en escribir código en lugar de lidiar con la configuración.
- Vite es una herramienta popular para la configuración de proyectos y puede usarse con React.
- Para crear un nuevo proyecto con Vite, puedes usar el siguiente comando en tu terminal:

```bash
npm create vite@latest my-react-app -- --template react
```

Este comando crea un nuevo proyecto React llamado `my-react-app` usando la plantilla React de Vite. En el directorio del proyecto, verás un archivo `package.json` con las dependencias del proyecto y los comandos listados en él.

- Para ejecutar el proyecto, navega al directorio del proyecto y ejecuta los siguientes comandos:

```bash
cd my-react-app # path to the project directory
npm install # installs the dependencies listed in the package.json file
```

- Una vez instaladas las dependencias, deberías notar una nueva carpeta en tu proyecto llamada `node_modules`.

- La carpeta `node_modules` es donde se almacenan todos los paquetes y bibliotecas requeridos por tu proyecto.

- Para ejecutar tu proyecto, usa el siguiente comando:

```bash
npm run dev
```

- Después de eso, abre tu navegador y navega a `http://localhost:5173` para ver tu aplicación React funcionando.

- Para ver realmente el código de la plantilla inicial, puedes ir a tu proyecto dentro de la carpeta `src` y deberías ver el archivo `App.jsx`.

## Pasando props en componentes React

- En React, props (abreviatura de propiedades) son una manera de pasar datos de un componente padre a un componente hijo. Este mecanismo es necesario para crear elementos de UI reutilizables y dinámicos.
- Los props pueden ser cualquier valor de JavaScript. Para pasar props de un padre a un componente hijo, debes añadir los props como atributos cuando usas el componente hijo en el JSX del padre. Aquí hay un ejemplo simple:

```jsx
// Parent component
function Parent() {
  const name = 'Anna';
  return <Child name={name} />;
}

// Child component
function Child(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

Puedes pasar múltiples props usando el operador de propagación `(...)`, después de convertirlos en un objeto. Aquí tienes un ejemplo:
    
```jsx
// Parent component
function Parent() {
  const person = {
    name: 'Anna',
    age: 25,
    city: 'New York'
  };
  return <Child {...person} />;
}
```

En este código, el operador de propagación `{...person}` convierte el objeto person en props individuales que son pasados al componente hijo.

## Renderizado condicional en React

- El renderizado condicional en React te permite crear interfaces de usuario dinámicas. Se utiliza para mostrar diferente contenido basado en ciertas condiciones o estados dentro de la aplicación.
- Hay varias maneras de renderizar contenido condicionalmente en React. Una aproximación común es usar el operador ternario. Aquí tienes un ejemplo:

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please log in</h1>}
    </div>
  );
}
```

- Another way to conditionally render content is to use the logical AND (`&&`) operator. Esto es útil cuando quieres renderizar contenido sólo si se cumple cierta condición. Aquí tienes un ejemplo:

```jsx
function Greeting({ user }) {
  return (
    <div>
      {user && <h1>Welcome, {user.name}!</h1>}
    </div>
  );
}
```

En el código anterior, el elemento `h1` sólo se renderiza si el objeto usuario es verdadero.

También puedes usar directamente una sentencia `if` de esta manera:

```js
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  }
  return <h1>Please sign in</h1>;
}
```

## Renderizando listas en React

- Renderizar listas en React es una tarea común al construir interfaces de usuario.
- Las listas pueden ser renderizadas usando el método `map()` del arreglo JS para iterar sobre un arreglo de elementos y retornar un nuevo arreglo de elementos JSX.
- Por ejemplo, si tienes un arreglo de nombres que deseas renderizar como una lista, puedes hacer lo siguiente:

```jsx
function NameList({ names }) {
  return (
    <ul>
      {names.map((name, index) => (
        <li key={`${name}-${index}`}>{name}</li>
      ))}
    </ul>
  );
}
```

- Siempre recuerda proporcionar una clave única para cada elemento de la lista para ayudar a React a gestionar el papel de actualización y renderizado. Con estas técnicas, puedes crear listas flexibles, eficientes y dinámicas en tus aplicaciones React.

## Estilos en línea en React

- Los estilos en línea en React te permiten aplicar estilos CSS directamente a elementos JSX usando objetos JavaScript.
- Para aplicar estilos en línea en React, puedes usar el atributo style en los elementos JSX. El atributo style toma un objeto donde las claves son propiedades CSS en camelCase y los valores son los valores correspondientes. Aquí tienes un ejemplo:

```js
function Greeting() {
  return (
    <h1
      style={{ color: 'blue', fontSize: '24px', backgroundColor: 'lightgray' }}
    >
      Hello, world!
    </h1>
  );
}

export default Greeting;
```

También puedes extraer los estilos en un objeto separado y referenciarlo en el atributo `style` de esta manera:

```jsx
function Greeting() {

  const styles = {
    color: 'blue',
    fontSize: '24px',
    backgroundColor: 'lightgray'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- Los estilos en línea soportan estilos dinámicos al permitirte aplicar estilos condicionalmente basados en props o estado. Aquí tienes un ejemplo de cómo puedes aplicar estilos condicionalmente basados en un prop:

```jsx
function Greeting({ isImportant }) {

  const styles = {
    color: isImportant ? 'red' : 'black',
    fontSize: isImportant ? '24px' : '16px'
  };

  return <h1 style={styles}>Hello, world!</h1>;
}

export default Greeting;
```

- En el código anterior, los estilos `color` y `fontSize` se establecen condicionalmente basándose en el prop `isImportant`.

## Trabajando con Eventos en React

- **Sistema de Eventos Sintéticos**: Esta es la forma en que React maneja los eventos. Sirve como un envoltorio alrededor de los eventos nativos como los eventos de `click`, `keydown` y `submit`.  Event handlers in React use the camel casing naming convention. (Ex. `onClick`, `onSubmit`, etc)

Aquí hay un ejemplo de uso del atributo `onClick` para un elemento `button` en React:

```jsx
function handleClick() {
  console.log("Button clicked!");
}

<button onClick={handleClick}>Click Me</button>;
```

En React, las funciones manejadoras de eventos usualmente comienzan con el prefijo `handle` para indicar que son responsables de manejar eventos, como `handleClick` o `handleSubmit`.

Cuando una acción del usuario dispara un evento, React pasa un objeto de Evento Sintético a tu manejador. Este objeto se comporta mucho como el objeto Evento nativo en JavaScript puro, proporcionando propiedades como `type`, `target` y `currentTarget`.

Para prevenir comportamientos predeterminados como la actualización del navegador durante un evento `onSubmit`, por ejemplo, puedes llamar al método `preventDefault()`:

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("Form submitted!");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>Submit</button>
</form>;
```

También puedes envolver una función manejadora en una función de flecha de esta forma:

```jsx
function handleDelete(id) {
  console.log("Deleting item:", id);
}

<button onClick={() => handleDelete(1)}>Delete Item</button>;
```

## Trabajando con Estado y el Hook `useState`

- <strong x-id= "1">Definición de estado</strong>: En React, el estado es un objeto que contiene datos para un componente. Cuando el estado se actualiza, el componente se volverá a renderizar. React trata el estado como inmutable, lo que significa que no debe modificarlo directamente.
- **Hook `useState()`**: El hook `useState` es una función que te permite declarar variables de estado en componentes funcionales. Aquí tienes una sintaxis básica:

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

En la variable de estado tienes lo siguiente:

- `stateVariable` contiene el valor actual del estado
- `setStateFunction` (la función que establece) actualiza la variable de estado
- `initialValue` establece el estado inicial

Aquí está un ejemplo completo para un componente `Counter`:

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

## Renderizando y Componentes de React

- **Definición**: En React, el renderizado es el proceso por el cual los componentes aparecen en la interfaz de usuario (UI), generalmente en el navegador. El proceso de renderizado consta de tres etapas: activación, renderizado y compromiso.

La etapa de activación ocurre cuando React detecta que algo ha cambiado y la interfaz de usuario (UI) podría necesitar ser actualizada. Este cambio a menudo se debe a una actualización en el estado o en las propiedades.

Una vez que se activa algo, React entra en la etapa de renderización. Aquí, React vuelve a evaluar tus componentes y determina qué mostrar. Para hacer esto, React utiliza una copia ligera del "DOM real" llamada DOM virtual. Con el DOM virtual, React puede verificar rápidamente qué necesita cambiar en el componente.

La etapa de compromiso es donde React toma los cambios preparados del DOM virtual y los aplica al DOM real. En otras palabras, esta es la etapa donde ves el resultado final en la pantalla.

## Actualizando Objetos y Arrays en el Estado

- **Actualizando Objetos en el Estado**: Si necesitas actualizar un objeto en el estado, debes crear un nuevo objeto o copiar un objeto existente primero, y luego establecer el estado para ese nuevo objeto. Cualquier objeto puesto en el estado debe considerarse como de solo lectura. Aquí está un ejemplo de cómo establecer el nombre, la edad y la ciudad de un usuario. La función `handleChange` se usa para manejar actualizaciones de la información del usuario:

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **Actualizando Arrays en el Estado**: Al actualizar arrays en el estado, es importante no modificar directamente el array usando métodos como `push()` o `pop()`. En cambio, deberías crear un nuevo array al actualizar el estado:

```jsx
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

Si quieres eliminar elementos de un array, deberías usar el método `filter()`, que devuelve un nuevo array después de filtrar lo que quieres eliminar:

```jsx
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## Referenciando Valores Usando Refs

- **Atributo `ref`**: Puedes acceder a un nodo del DOM en React usando el atributo `ref`. Aquí está un ejemplo para mostrar un `ref` para enfocar un elemento `input`. Se utiliza la propiedad `current` para acceder al valor actual de ese `ref`:

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Focus;
```

## Trabajando con el Hook `useEffect`

- **Hook `useEffect()`**: En React, un efecto es cualquier cosa que sucede fuera del proceso de renderizado de un componente. Es decir, cualquier cosa que React no maneja directamente como parte de la renderización de la interfaz de usuario. Los ejemplos comunes incluyen obtener datos, actualizar el título de la pestaña del navegador, leer o escribir en el almacenamiento local del navegador, obtener la ubicación del usuario y mucho más. Estas operaciones interactúan con el mundo exterior y se conocen como efectos secundarios. React proporciona el hook `useEffect` para que puedas manejar esos efectos secundarios. `useEffect` te permite ejecutar una función después de que el componente se renderice o actualice.

```js
import { useEffect } from "react";

useEffect(() => {
 // Your side effect logic (usually a function) goes here
}, [dependencies]);
```

La función de efecto se ejecuta después de que el componente se renderiza, mientras que el argumento opcional `dependencias` controla cuándo se ejecuta el efecto.

Ten en cuenta que `dependencias` puede ser un arreglo de "valores reactivos" (estado, props, funciones, variables, etc.), un arreglo vacío, o se puede omitir por completo. Así es como todas esas opciones controlan cómo funciona `useEffect`:

- Si `dependencias` es un arreglo que incluye uno o más valores reactivos, el efecto se ejecutará cada vez que cambien.

- Si `dependencias` es un arreglo vacío, `useEffect` se ejecuta solo una vez cuando el componente se renderiza por primera vez.

- Si omites `dependencias`, el efecto se ejecuta cada vez que el componente se renderiza o se actualiza.

## Cómo Crear Hooks Personalizados

- **Hooks Personalizados**: Un hook personalizado te permite extraer lógica reutilizable de los componentes, como la obtención de datos, la gestión de estado, alternar y efectos secundarios como rastrear el estado en línea. En React, todos los hooks incorporados comienzan con la palabra `use`, por lo que tu hook personalizado debe seguir la misma convención.

Aquí está un ejemplo de creación de un hook `useDebounce`:

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

## Trabajando con Formularios en React

- **Entradas Controladas**: Esto ocurre cuando almacenas el valor del campo de entrada en un estado y lo actualizas a través de eventos `onChange`. Esto te da control total sobre los datos del formulario y permite validación inmediata y renderizado condicional.

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form>
    </>
  );
}

export default App;
```

- **Entradas No Controladas**: En lugar de manejar las entradas mediante el gancho `useState`, las entradas no controladas en HTML mantienen su propio estado interno con la ayuda del DOM. Dado que el DOM controla los valores de entrada, necesitas obtener los valores de los campos de entrada con un `ref`.

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">Your</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">Submit</button>
   </form>
 );
}

export default App;
```

## Trabajando con el Gancho `useActionState`

- **Acciones del Servidor**: Estas son funciones que se ejecutan en el servidor para permitir el manejo de formularios directamente en el servidor sin necesidad de puntos finales de API. Aquí hay un ejemplo de una aplicación Next.js:

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `Hello, ${name}!` };
}
```

La directiva `"use server"` marca la función como una acción del servidor.

- **Gancho `useActionState`**: Este gancho actualiza el estado basado en el resultado de una presentación de formulario. Aquí está la sintaxis básica del hook `useActionState`:

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` es el estado actual que la acción devuelve.
- `action` es la función que desencadena la acción del servidor.
- `isPending` es un booleano que indica si la acción se está ejecutando actualmente o no.
- `actionFunction` parámetro es la propia acción del servidor.
- `initialState` es el parámetro que representa el punto de partida para el estado antes de que la acción se ejecute.
- `permalink` es una cadena opcional que contiene la URL única de la página que el formulario modifica.

## Obtención de Datos en React

- **Opciones Para Obtener Datos**: Existen muchas formas diferentes de obtener datos en React. Puedes usar la API nativa Fetch, o herramientas de terceros como Axios o SWR.
- **Variables de Estado Comunes al Obtener Datos**: Independientemente de cómo elijas obtener tus datos en React, hay algunos fragmentos de estado que necesitarás rastrear. El primero es el propio dato. El segundo rastrea si los datos aún se están obteniendo. El tercero es una variable de estado que capturará cualquier error que pueda ocurrir durante el proceso de obtención de datos.

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

Dado que la obtención de datos es un efecto secundario, es mejor usar el `Fetch API` dentro de un gancho `useEffect`.

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      
      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Entonces puedes mostrar un mensaje de carga si la obtención de datos no está completa, un mensaje de error si hubo un error al obtener los datos o los resultados.

```jsx
if (loading) {
  return <p>Loading...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

Si deseas usar Axios, necesitas instalarlo e importarlo:

```bash
npm i axios
```

```js
import axios from "axios";
```

Entonces puedes obtener los datos usando `axios.get`:

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Para obtener datos usando el gancho `useSWR`, primero debes instalarlo e importarlo.

```bash
npm i swr
```

```js
import useSWR from "swr";
```

Aquí está cómo puedes usar el gancho para obtener datos:

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>Loading...</h2>;
 }
 if (error) {
   return <h2>Error: {error.message}</h2>;
 }

 return (
   <>
     <h2>Todos</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## Trabajando con el Gancho `useOptimistic`

- **Gancho `useOptimistic`**: Este gancho se utiliza para mantener interfaces de usuario receptivas mientras se espera que una acción asincrónica se complete en segundo plano. Ayuda a gestionar "actualizaciones optimistas" en el UI, una estrategia en la que proporcionas actualizaciones inmediatas al UI basadas en el resultado esperado de una acción, como esperar una respuesta del servidor.

Esta es la sintáxis básica:

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` es el estado temporal que se actualiza de inmediato para una mejor experiencia del usuario.
- `addOptimistic` es la función que aplica la actualización optimista antes de que el estado real cambie.
- `actualState` es el valor del estado real que proviene del resultado de una acción, como obtener datos de un servidor.
- `updateFunction` es la función que determina cómo debe actualizarse el estado optimista cuando es llamada.

Aquí hay un ejemplo de usar el gancho `useOptimistic` en un componente `TaskList`:

```js
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**: Esto se utiliza para renderizar parte del UI y marcar una actualización de estado como una transición no urgente. Esto permite que la interfaz de usuario sea receptiva durante actualizaciones costosas. Esta es la sintáxis básica:

```js
startTransition(action)
```

La `action` realiza una actualización de estado o desencadena alguna lógica relacionada con la transición. Esto asegura que las actualizaciones urgentes de UI (como escribir o hacer clic) no se bloqueen.

## Trabajando con el Gancho `useMemo`

- **Memorización**: Esta es una técnica de optimización en la cual el resultado de llamadas a funciones costosas se almacenan en caché (recordados) basados en argumentos específicos. Cuando se proporcionan los mismos argumentos nuevamente, se devuelve el resultado en caché en lugar de volver a calcular la función.
- **Gancho `useMemo`**: Este gancho se usa para memorizar valores calculados. Aquí hay un ejemplo de memorizar el resultado de ordenar un arreglo grande. La función `expensiveSortFunction` solo se ejecutará cuando `largeArray` cambie:

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## Trabajando con el Gancho `useCallback`

- **Gancho `useCallback`**: Este se utiliza para memorizar referencias de funciones.

```js
const handleClick = useCallback(() => {
 // code goes here
}, [dependency]);
``` 

- **`React.memo`**: Esto se usa para memorizar un componente para evitar que se vuelva a rendereizar innecesariamente cuando su prop no ha cambiado.

```js
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* Presentation */}
   </>
 )
});
``` 

## Herramientas de Gestión de Dependencias

- **Definición de Dependencia**: En software, una dependencia es cuando un componente o módulo en una aplicación depende de otro para funcionar correctamente. Las dependencias son comunes en las aplicaciones de software porque permiten a los desarrolladores usar funciones o herramientas preconstruidas creadas por otros. Las dos dependencias centrales necesarias para un proyecto de React serán los paquetes `react` y `react-dom`:

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **Definición del Administrador de Paquetes**: Para gestionar las dependencias de software en un proyecto, necesitarás usar un administrador de paquetes. Un administrador de paquetes es una herramienta utilizada para la instalación, actualizaciones y eliminación de dependencias. Muchos lenguajes de programación populares como JavaScript, Python, Ruby y Java, todos usan gestores de paquetes. Los administradores de paquetes populares para JavaScript incluyen npm, Yarn y pnpm.
- **Archivo `package.json`**: Este es un archivo clave de configuración en proyectos que contiene metadatos sobre tu proyecto, incluyendo su nombre, versión y dependencias. También define scripts, información de licencias y otras configuraciones que ayudan a gestionar el proyecto y sus dependencias.
- **Archivo `package-lock.json`**: Este archivo bloqueará las versiones exactas de todos los paquetes que tu proyecto está utilizando. Cuando actualices un paquete, las nuevas versiones también se actualizarán en el archivo de bloqueo.
- **Carpeta `node_modules`**: Esta carpeta contiene el código real para las dependencias listadas en tu archivo `package.json`, incluyendo tanto las dependencias directas de tu proyecto como las de esas dependencias.
- **Dependencias de Desarrollo**: Estos son paquetes que solo se usan para desarrollo y no en producción. Un ejemplo de esto sería una biblioteca de pruebas como Jest. Instalarías Jest como una dependencia de desarrollo porque se necesita para probar tu aplicación localmente, pero no para que la aplicación funcione en producción.

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **Introducción**: React Router es una biblioteca de terceros que te permite agregar enrutamiento a tus aplicaciones React. Para comenzar, necesitarás instalar React Router en un proyecto React existente de esta manera:

```bash
npm i react-router
```

Luego, dentro del archivo `main.jsx` o `index.jsx`, deberás configurar la estructura de rutas de esta manera:

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

El `path` y el `element` se utilizan para unir la URL y los componentes de la interfaz de usuario. En este caso, estamos configurando una ruta para la página de inicio que apunta al componente `App`. 

- **Configuración de Vistas Múltiples y Rutas**: Es común en aplicaciones más grandes tener configuradas múltiples vistas y rutas de esta manera:

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

El `index` prop en estos ejemplos está destinado a representar la ruta predeterminada para un segmento de ruta dado. Por lo tanto, el componente `Home` se mostrará en la ruta raíz `/`, mientras que el componente `ProductsHome` se mostrará en la ruta `/products`.

- **Anidando Rutas**: Puedes anidar rutas dentro de otras rutas, lo que da como resultado que la ruta del hijo se agregue a la ruta del padre.

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

En el ejemplo anterior, la ruta para los productos en tendencia será productos/tendencia.

- **Segmentos Dinámicos**: Un segmento dinámico es donde cualquier parte de la ruta del URL es dinámica.

```jsx
<Route path=":category" element={<Category />} />
```

En este ejemplo tenemos un segmento dinámico llamado `category`. Cuando un usuario navega a una URL como productos/instrumentos-de-latón, el visor cambiará al componente `Category` y podrás obtener dinámicamente los datos apropiados basados en el segmento.

- **Gancho `useParams`**: Este gancho se utiliza para acceder a los parámetros dinámicos de una ruta de URL.

```js
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
   {/* Accessing the category param: params.category */}
   {/* rest of code goes here */}
}
```

## Frameworks de React

- **Introducción**: Los frameworks de React proporcionan características como enrutamiento, optimización de imágenes, obtención de datos, autenticación y más. Esto significa que podría no ser necesario configurar aplicaciones frontend y backend separadas para ciertos casos de uso. Ejemplos de Frameworks de React incluyen Next.js y Remix.
- **Enrutamiento en Next.js**: Este sistema de enrutamiento incluye soporte para rutas dinámicas, rutas paralelas, manejadores de rutas, redirecciones, internalización y más.

Aquí tienes un ejemplo de creación de un manejador de solicitudes personalizado:

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Optimización de Imágenes en Next.js**: El componente `Image` extiende el elemento HTML nativo `img` y permite cargas de página más rápidas y optimizaciones de tamaño. Esto significa que las imágenes solo se cargarán cuando entren en el viewport y el componente `Image` automáticamente servirá imágenes del tamaño correcto para cada dispositivo.

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
``` 

## Perforación de Props

- **Definición**: La perforación de props es el proceso de pasar props de un componente padre a componentes hijos profundamente anidados, incluso cuando algunos de los componentes hijos no necesitan los props.

## Gestión de Estado

- **Context API**: Contexto se refiere a cuando un componente padre pone información a disposición de componentes hijos sin necesidad de pasarla explícitamente a través de props. Se usa `createContext` para crear un objeto de contexto que representa el contexto que otros componentes leerán. El `Provider` se usa para suministrar valores de contexto a los componentes hijos.

```js
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**: Redux maneja la gestión de estado al proporcionar una almacén central y un control estricto sobre las actualizaciones de estado. Utiliza un patrón predecible con acciones, reductores y middleware. Las acciones son cargas de información que envían datos desde tu aplicación a la tienda de Redux, a menudo desencadenadas por interacciones de usuario. Los reductores son funciones que especifican cómo debería cambiar el estado en respuesta a esas acciones, asegurando que el estado se actualice de manera inmutable. El middleware, por otro lado, actúa como un puente entre el despacho de acciones y el reductor, permitiéndote extender la funcionalidad de Redux (por ejemplo, registro, manejo de operaciones asíncronas) sin modificar el flujo central.

- **Zustand**: Esta solución de gestión de estado es ideal para aplicaciones de pequeña a mediana escala. Funciona usando un gancho `useStore` para acceder directamente al estado en componentes y páginas. Esto te permite modificar y acceder a la información sin necesitar acciones, reductores o un proveedor.

## Depurando Componentes de React Usando las Herramientas de Desarrollo de React

- **Herramientas para Desarrolladores de React**: Esta es una extensión de navegador que puedes usar en Chrome, Firefox y Edge para inspeccionar componentes de React e identificar problemas de rendimiento. Para Safari, necesitarás instalar el paquete npm `react-devtools`. Después de instalar las Herramientas de Desarrollo de React y abrir una aplicación React en el navegador, abre las herramientas para desarrolladores del navegador para acceder a las dos pestañas adicionales proporcionadas para depurar React: Componentes y Perfilador.
- **Components Tab**: This tab displays each component for you in a tree view format. Here are some things you can do in this tab:
  - ver la jerarquía de componentes de la aplicación
  - ver y modificar props, estados y valores de contexto en tiempo real
  - verificar el código fuente de cada componente seleccionado
  - registrar los datos del componente en la consola
  - inspeccionar los elementos del DOM para el componente
- **Pestaña de Perfilador**: Esta pestaña te ayuda a analizar el rendimiento de los componentes. Puedes grabar el rendimiento de los componentes para identificar renderizados innecesarios, ver duraciones de commits y posteriormente optimizar componentes lentos.

## Componentes del Servidor React

- **Definición**: Los Componentes del Servidor React son componentes React que se renderizan exclusivamente en el servidor, enviando solo el HTML final al cliente. Esto significa que esos componentes pueden acceder directamente a los recursos del lado del servidor y reducir drásticamente la cantidad de JavaScript enviado al navegador.

## Diferencias entre el Rendimiento Real y Percibido

- **Rendimiento Percibido**: Así es como los usuarios perciben el rendimiento de un sitio web. Es cómo lo evalúan en cuanto a respuesta y fiabilidad. Esta es una medida subjetiva, por lo que es difícil de cuantificarla, pero es muy importante, ya que la experiencia del usuario determina el éxito o fracaso de un sitio web.
- **Rendimiento Real**: Este es el rendimiento objetivo y medible del sitio web. Se mide utilizando métricas como el tiempo de carga de la página, el tiempo de respuesta del servidor y el tiempo de renderizado. Estas mediciones están influenciadas por múltiples factores relacionados con la red y el mismo código.

## Técnicas para Mejorar el Rendimiento Percibido

- **Carga Perezosa**: Esta técnica reduce el tiempo de carga inicial lo máximo posible cargando recursos no esenciales en segundo plano.
- **Minimizar Retrasos de Fuente**: Si tu sitio web tiene fuentes personalizadas, también deberías intentar minimizar los retrasos de carga de fuentes, ya que esto puede causar parpadeos o mostrar la fuente de respaldo mientras se carga la fuente personalizada. Una sugerencia para esto es usar una fuente de respaldo similar a la fuente personalizada, así que en caso de que esto suceda, el cambio será más sutil.
- **Uso de Indicadores de Carga**: Mostrar un indicador de carga para un proceso prolongado tan pronto como el usuario haga clic en un elemento puede ayudar al usuario a sentirse conectado e involucrado con el proceso, haciendo que el tiempo de espera parezca más corto.

## Conceptos Clave de Rendimiento

- **Orden de Fuente**: Esto se refiere a la forma en que los elementos HTML están estructurados en el documento. Esto determina qué carga primero y puede impactar significativamente en el rendimiento y la accesibilidad.

Algunas buenas prácticas para el orden de fuente incluyen:

- Colocar contenido crítico como encabezados, navegación o texto principal más arriba en la estructura HTML.
- Diferir scripts no esenciales, como los de analíticas o widgets de terceros, para que no bloqueen la renderización.
- Usar la mejora progresiva, para asegurar que la experiencia principal funcione incluso antes de que los estilos y scripts se carguen. La mejora progresiva es una manera de construir sitios web y aplicaciones basada en la idea de que debes hacer tu página funcional con HTML primero.

Aquí hay un ejemplo de buen orden de fuente, utilizando las mejores prácticas que acabamos de describir:

```html
<h1>Welcome to FastSite!</h1>
<p>Critical information loads first.</p>
<script src="slow-script.js" defer></script>
```

- **Camino de Representación Crítico**: Esta es la secuencia de pasos que el navegador sigue para convertir el código en píxeles en la pantalla.
- **Latencia**: Este es el tiempo que tarda una solicitud en viajar entre el navegador y el servidor. En otras palabras, alta latencia equivale a páginas lentas.

Algunas formas de reducir la latencia incluyen:

- Usar CDNs, o Redes de Entrega de Contenido, para servir archivos desde ubicaciones más cercanas.
- Habilitar la compresión usando cosas como Gzip para reducir el tamaño de los archivos.
- Optimizar imágenes y utilizar carga perezosa.

```html
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
```

## Mejorando INP

- **Definición**: INP (Interacción al Próximo Pintado) evalúa la capacidad de respuesta general de una página midiendo el tiempo desde que un usuario interactúa, como un clic o una pulsación de tecla, hasta la próxima vez que el navegador actualiza la pantalla. Un INP más bajo indica una página más responsiva.

Aquí hay algunas maneras de mejorar el INP:

- Reducir el trabajo en el hilo principal al dividir tareas largas de JavaScript.
- Usar `requestIdleCallback()` para scripts no críticos. Esto pondrá en la cola una función para ser llamada durante los períodos de inactividad del navegador.
- Diferir o cargar de manera perezosa recursos pesados que se cubrieron anteriormente.
- Optimizar manejadores de eventos. Si estos manejadores se ejecutan con demasiada frecuencia o realizan operaciones pesadas, pueden ralentizar la página e incrementar el INP. La solución para esto es el debounce. El debounce asegura que la función solo se ejecute después de que el usuario deje de escribir por un breve lapso - por ejemplo, 300ms. Esto evita cálculos innecesarios y mejora el rendimiento.

## Cómo Funciona el Renderizado en el Navegador

- **Cómo funciona el renderizado**: Primero el navegador analiza el HTML y construye el DOM. Luego, el navegador procesa el CSS, construyendo el Modelo de Objeto CSS, o CSSOM. Esta es otra estructura en forma de árbol que dicta cómo deben ser estilizados los elementos. Finalmente, el navegador pinta los píxeles en la pantalla, renderizando cada elemento basado en los estilos y diseño calculados. En páginas complejas, esto puede involucrar múltiples capas que se combinan para formar la salida visual final.

## Cómo el Rendimiento Impacta la Sostenibilidad

- **Información de Fondo**: Internet representa alrededor del 2% de las emisiones de carbono globales, ¡lo mismo que la industria aérea! Cada byte transferido requiere electricidad, desde centros de datos hasta dispositivos de usuario. Archivos más grandes y scripts ineficientes significan mayor consumo de energía. Un sitio web de alto rendimiento no solo es más rápido, también reduce el procesamiento y el uso de energía innecesarios.

## Formas de Reducir los Tiempos de Carga de Páginas

- **Optimizar Activos Multimédia**: Las imágenes grandes y los videos son causantes comunes de tiempos de carga lentos. Optimizando estos activos, puedes acelerar significativamente tu sitio. Esto incluye cosas como comprimir imágenes, usar formatos modernos como WebP y usar carga perezosa para activos.
- **Aprovechar el Caché del Navegador**: El caché permite a los navegadores almacenar partes de tu sitio localmente, reduciendo el tiempo de carga para los visitantes que regresan.
- **Minificar y Comprimir Archivos**: Reducir el tamaño de tus archivos puede llevar a descargas más rápidas. Esto incluye reducir el tamaño de los archivos transmitidos y minificar archivos CSS y JavaScript.

## Mejorando "tiempo hasta usable"

- **Definición**: "tiempo hasta usable" es el intervalo desde cuando un usuario solicita una página hasta cuando pueden interactuar de manera significativa con ella. Para mejorar el "tiempo hasta usable", puedes cargar perezosamente tus recursos o minimizar los recursos de renderizado que bloquean.

## Métricas Clave para Medir el Rendimiento

- **Primer Pintado de Contenido o FCP**: Mide qué tan rápido aparece la primera pieza de contenido—texto o imagen—en la pantalla. Un buen FCP se considera un tiempo por debajo de 1.8 segundos, y un mal FCP está por encima de 3 segundos. Puedes verificar tu FCP usando las Herramientas de Desarrollo de Chrome y revisando la pestaña de rendimiento.
- **Tiempo Total de Bloqueo**: Esto muestra cuánto tiempo está bloqueado el hilo principal por tareas pesadas de JavaScript. Si el Tiempo Total de Bloqueo (TBT) es alto, los usuarios experimentan interacciones lentas. Para mejorar el TBT, divide tareas largas y pospone scripts no esenciales.
- **Tasa de Rebote**: Este es el porcentaje de visitantes que se van sin interactuar. Si tu sitio tiene altas tasas de rebote puede ser porque tu página es demasiado lenta.
- **Usuarios Únicos**: Esta métrica rastrea cuántos visitantes individuales vienen a tu sitio. Para ver la Tasa de Rebote y Usuarios Únicos, puedes usar Google Analytics. Te permitirá monitorear estas métricas y mejorar el compromiso.

## Herramientas Comunes de Medición de Desempeño

- **Herramientas de Desarrollo de Chrome**: Las Herramientas de Desarrollo de Chrome son una herramienta incorporada dentro de Google Chrome que te permite analizar y depurar el rendimiento en tiempo real. DevTools mostrará tiempos de carga, uso de CPU y retrasos en la renderización. Es especialmente útil para medir el Primer Pintado de Contenido, o FCP, qué tan rápido ve el usuario el primer contenido visible. Si tu página web parece lenta, DevTools te ayudará a identificar los cuellos de botella.
- **Faro**: Esta es una herramienta automatizada que verifica rendimiento, SEO y accesibilidad.
- **WebPageTest**: Esta herramienta te permite probar cómo se carga tu sitio desde diferentes ubicaciones y dispositivos. Esta herramienta te da un desglose detallado del índice de velocidad de tu sitio, del Tiempo Total de Bloqueo y otras métricas clave de rendimiento. Si deseas saber cómo los usuarios reales experimentan tu sitio globalmente, WebPageTest es la herramienta adecuada para eso.
- **PageSpeed Insights**: Esta herramienta analiza tu sitio web y sugiere mejoras rápidas tanto para móvil como para escritorio. Te dirá qué está ralentizando tu sitio y dará recomendaciones específicas como optimizar imágenes, eliminar scripts que bloquean la representación y reducir los tiempos de respuesta del servidor. PageSpeed Insights es una manera rápida y sencilla de verificar cómo Google ve el rendimiento de tu sitio.
- **Monitoreo de Usuarios Reales**: Las herramientas RUM rastrean el comportamiento real de los usuarios, mostrando cómo los visitantes reales experimentan tu sitio. Herramientas populares de RUM incluyen Google Analytics, que rastrea tiempos de carga de página y tasas de rebote, y New Relic o Datadog, que monitorean problemas de rendimiento en tiempo real. Si deseas datos de usuarios reales, las herramientas RUM son esenciales.

## Trabajando con APIs de Rendimiento Web

- **Definición**: Las APIs de Rendimiento Web permiten a los desarrolladores rastrear cómo carga y responde de manera eficiente una página web directamente en el código. Estas APIs te permiten medir los tiempos de carga de la página, rastrear retrasos de renderizado e interacción y analizar el tiempo de ejecución de JavaScript.
- **`performance.now()`**: Esta API te da marcas de tiempo de alta precisión (en milisegundos) para medir cuánto tardan en cargar diferentes partes de tu sitio.

```js
const start = performance.now();  
// Run some code here  
const end = performance.now();  

console.log(`Execution time: ${end - start}ms`);
```

- **API de Timing de Rendimiento**: Esta API te da un desglose de cada etapa de carga de la página, desde la búsqueda de DNS hasta `DOMContentLoaded`.

```js
const timing = performance.timing;  

const pageLoadTime = timing.loadEventEnd - timing.navigationStart;  
console.log(`Page load time: ${pageLoadTime}ms`);
```

- **`PerformanceObserver`**: Esta API escucha eventos de rendimiento como cambios de disposición, tareas largas e interacciones de usuario.

```js
const observer = new PerformanceObserver((list) => {  
  list.getEntries().forEach((entry) => {  
    console.log(`Long task detected: ${entry.duration}ms`);  
  });  
});  

observer.observe({ type: "longtask", buffered: true });
```

## Técnicas para Mejorar el Rendimiento del CSS

- **Animaciones CSS**: Animar ciertas propiedades CSS, como dimensiones, posición y disposición, activa un proceso llamado "reflujo", durante el cual el navegador recalcula la posición y geometría de ciertos elementos en la página. Esto requiere una repintura, que es computacionalmente costosa. Por lo tanto, se recomienda reducir la cantidad de animaciones CSS tanto como sea posible o al menos dar al usuario una opción para activarlas o desactivarlas.

## Técnicas para Mejorar el Rendimiento de JavaScript

- **División de Código**: Dividir tu código de JavaScript en módulos que realicen tareas críticas y no críticas también es útil. De esta manera, podrás precargar los críticos tan pronto como sea posible y diferir los no críticos para renderizar la página lo más rápido posible.
- **Manipulación del DOM**: Recuerda que la Manipulación del DOM se refiere al proceso de cambiar dinámicamente el contenido de una página con JavaScript interactuando con el Modelo de Objeto de Documento (DOM). Manipular el DOM es computacionalmente costoso. Reduciendo la cantidad de manipulación del DOM en tu código JavaScript mejorará el rendimiento.

## Frameworks CSS

- **Frameworks CSS**: Los frameworks CSS pueden acelerar tu flujo de trabajo, crear un estilo visual uniforme en todo un sitio web, hacer que tu diseño se vea consistente en varios navegadores y mantener tu código CSS más organizado.
- **Frameworks CSS populares**: Algunos de los frameworks CSS populares son Tailwind CSS, Bootstrap, Materialize y Foundation.
- **Potential disadvantages**:
  - El CSS proporcionado por el framework puede conflicto con tu CSS personalizado.
  - Tu sitio web puede parecer similar a otros sitios web que utilizan el mismo framework.
  - Los frameworks grandes pueden causar problemas de rendimiento.

## Dos Tipos de Frameworks CSS

- **Frameworks CSS de utilidad**: Estos frameworks tienen clases pequeñas con propósitos específicos, como establecer el margen, el padding o el color de fondo. Puedes asignar estas clases pequeñas directamente a los elementos HTML según sea necesario. Tailwind CSS se clasifica como un framework CSS de utilidad.

Aquí tienes un ejemplo de cómo usar Tailwind CSS para dar estilo a un botón.

```html
<button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700">
  Button
</button>
```

- **Frameworks CSS basados en componentes**: Estos frameworks tienen componentes pre-construidos con estilos predefinidos que puedes añadir a tu sitio web. Los componentes están disponibles en la documentación oficial del framework CSS y puedes copiarlos y pegarlos en tu proyecto. Bootstrap se clasifica como un framework CSS basado en componentes.

Aquí tienes un ejemplo de cómo usar Bootstrap para crear un grupo de listas. En lugar de aplicar clases pequeñas a tus elementos HTML, añadirás todo el componente, incluyendo la estructura HTML.

```html
<div class="card" style="width: 25rem;">
  <ul class="list-group list-group-flush">
    <li class="list-group-item">HTML</li>
    <li class="list-group-item">CSS</li>
    <li class="list-group-item">JavaScript</li>
  </ul>
</div>
```

## Tailwind CSS

Tailwind es un framework CSS basado en utilidades. En lugar de escribir reglas CSS personalizadas, construyes tus diseños combinando pequeñas clases de utilidad directamente en tu HTML.

### Utilidades de Diseño Responsivo

Tailwind usa prefijos como `sm:`, `md:` y `lg:` para aplicar estilos en diferentes tamaños de pantalla.

```html
<div class="w-full md:w-1/2 lg:flex-row">
  Responsive layout
</div>
```

### Utilidades de Flexbox

Clases como `flex`, `flex-col`, `justify-around` y `items-center` facilitan la creación de diseños flexibles.

```html
<div class="flex flex-col md:flex-row justify-around items-center">
  <p>Column on small screens</p>
  <p>Row on medium and larger screens</p>
</div>
```

### Utilidades de Grid

Tailwind incluye utilidades para CSS Grid, como `grid`, `grid-cols-1` y `md:grid-cols-3`.

```html
<div class="grid grid-cols-1 md:grid-cols-3 gap-8">
  <div class="bg-gray-100 p-4">Column 1</div>
  <div class="bg-gray-100 p-4">Column 2</div>
  <div class="bg-gray-100 p-4">Column 3</div>
</div>
```

### Utilidades de Espaciado

Utilidades como `mt-8`, `mx-auto`, `p-4` y `gap-4` ayudan a crear un espaciado consistente sin escribir CSS.

```html
<div class="mt-8 p-4 bg-indigo-600 text-white">
  Spaced content
</div>
```

### Utilidades de Tipografía

Utilidades como `uppercase`, `font-bold`, `font-semibold` y `text-4xl` controlan la apariencia del texto.

Puedes establecer tamaños de fuente que se ajusten en puntos de quiebre, como `text-3xl` y `md:text-5xl`.

```html
<h1 class="text-3xl md:text-5xl font-semibold text-center">
  Responsive Heading
</h1>
```

### Colores y estados Hover

Tailwind ofrece una amplia paleta de colores, como `text-red-700`, `bg-indigo-600` y `bg-gray-100`.

Clases como `hover:bg-pink-600` hacen que los efectos interactivos sean sencillos.

```html
<a href="#" class="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-md">
  Hover Me
</a>
```

### Bordes, Anillos y Efectos

- **Bordes**: `border-2 border-red-300` añade bordes con el grosor y los colores especificados.
- **Anillos**: `ring-1 ring-gray-300` crea efectos similares a contornos que se usan frecuentemente para enfoque o tarjetas.
- **Esquinas redondeadas y escalado**: Clases como `rounded-md`, `rounded-xl` y `scale-105` añaden acabado.

```html
<div class="p-6 rounded-xl ring-2 ring-fuchsia-500 scale-105">
  Highlighted card
</div>
```

### Gradientes

Tailwind soporta utilidades de degradado como `bg-gradient-to-r from-fuchsia-500 to-indigo-600`.

```html
<div class="p-4 text-white bg-gradient-to-r from-fuchsia-500 to-indigo-600">
  Gradient background
</div>
```

## Preprocesadores CSS

- **Preprocesador CSS**: Un preprocesador CSS es una herramienta que amplía el CSS estándar. Compila el código con sintaxis ampliada en un archivo CSS nativo. Puede ser útil para escribir CSS más limpio, reutilizable, menos repetitivo y escalable para proyectos complejos.
- **Características**: Algunas de las características que pueden proporcionar los preprocesadores CSS son variables, mixins, anidamiento y herencia de selectores.
- **Preprocesadores CSS populares**: Algunos de los preprocesadores CSS populares son Sass, Less y Stylus.
- **Potential disadvantages**:
  - Compilar las reglas CSS en CSS estándar puede causar una sobrecarga.
  - El código compilado puede ser difícil de depurar.

## Sass

- **Sass**: Es uno de los preprocesadores CSS más populares. Sass significa "Hojas de Estilo Sintácticamente Geniales".
- **Características soportadas por Sass**: Sass soporta características como variables, reglas CSS anidadas, módulos, mixins, herencia y operadores para operaciones matemáticas básicas.

## Dos Sintaxis Soportadas por Sass

- **Sintaxis SCSS**: La SCSS (Sassy CSS) amplía la sintaxis básica de CSS. Es la sintaxis más utilizada para Sass. Los archivos SCSS tienen una extensión `.scss`.

Aquí tienes un ejemplo de cómo definir y usar una variable en SCSS.

```scss
$primary-color: #3498eb;

header {
  background-color: $primary-color;
}
```

- **Sintaxis con sangría**: La sintaxis con sangría fue la sintaxis original de Sass y también se conoce como la "sintaxis Sass."

Aquí tienes un ejemplo de cómo definir y usar una variable en la sintaxis con sangría.

```sass
$primary-color: #3498eb

header
  background-color: $primary-color
```

### Mixins

- **Mixins**: Los mixins te permiten agrupar múltiples propiedades CSS y sus valores bajo un nombre y reutilizar ese bloque de código CSS en tu hoja de estilo.

Aquí tienes un ejemplo de cómo definir un mixin en sintaxis SCSS. En este caso, el mixin se llama `center-flex`. Tiene tres propiedades CSS para centrar elementos usando flexbox.

```scss
@mixin center-flex {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

Aquí tienes un ejemplo de cómo usar el mixin que definiste.

```scss
section {
  @include center-flex;
  height: 500px;
  background-color: #3289a8;
}
```

## Pruebas Manuales y Automatizadas

- **Pruebas Manuales**: En las pruebas manuales, un evaluador realizará de manera manual cada parte de la aplicación y probará diferentes funciones para asegurarse de que funcione correctamente. Si se descubren errores en el proceso de prueba, el evaluador informará esos errores al equipo de software para que puedan ser corregidos.
- **Pruebas Automatizadas**: En las pruebas automatizadas, puedes automatizar tus pruebas escribiendo un programa separado que verifique si tu aplicación se comporta como se espera.

## Pruebas de Unidad

- **Pruebas de Unidad**: En las pruebas de unidad, se prueba cada función para asegurarse de que todo funciona como se espera. Las pruebas de unidad también pueden servir como una forma de documentación para tu aplicación, ya que están destinadas a representar el comportamiento esperado de tu código.
- **Principio de Responsabilidad Única**: El principio de responsabilidad única recomienda mantener cada función pequeña y responsable de una sola cosa.
- **Frameworks Comunes de Pruebas en JavaScript**: Algunos frameworks comunes de pruebas incluyen Jest, Mocha y Vitest. Jest es un framework de pruebas popular para pruebas de unidad.

Aquí hay un ejemplo de pruebas de unidad utilizando Jest.

Primero, puedes crear una función que sea responsable de devolver una cadena recién formateada:

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

En un archivo separado `getFormattedWord.test.js` , puedes escribir algunas pruebas para verificar que la función esté funcionando como se espera. El archivo `getFormattedWord.test.js` se verá así:

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **`expect` Función**: La función `expect` se utiliza para probar un valor.
- **Matcher**: Matcher es una función que verifica si el valor se comporta como se esperaba. En el ejemplo anterior, el matcher es `toBe()`. Jest tiene una variedad de matchers.

Para usar Jest, primero necesitas instalar el paquete `jest` usando `npm i jest`. También necesitarás agregar un script a tu archivo `package.json` así:

```js
"scripts": {
  "test": "jest"
},
```

Luego, puedes ejecutar el comando `npm run test` para ejecutar tus pruebas.

## Ciclo de Vida del Desarrollo de Software

- **Different Stages of Software Development Lifecycle**:
  - **Etapa de Planificación**: El equipo de desarrollo recopila requisitos para el trabajo propuesto de los interesados.
  - **Etapa de Diseño**: El equipo de software desglosa los requisitos y decide las mejores propuestas para las soluciones.
  - **Etapa de Implementación**: El equipo de software descompone los requisitos en tareas manejables y las implementa.
  - **Etapa de Pruebas**: Esto implica pruebas manuales y automatizadas para el nuevo trabajo. A veces, el equipo prueba la aplicación a lo largo de toda la etapa de desarrollo para detectar y solucionar cualquier problema que surja.
  - **Etapa de Despliegue**: El equipo despliega los nuevos cambios a un entorno de compilación o prueba.
  - **Etapa de Mantenimiento**: Esto implica corregir cualquier problema que surja de los clientes en la aplicación en producción.

- **Different Models of the Software Development Lifecycle**:
  - **Modelo de Cascada**: El modelo de cascada es donde cada fase del ciclo de vida debe completarse antes de que pueda comenzar la siguiente fase.
  - **Modelo Ágil**: El modelo ágil se centra en el desarrollo iterativo dividiendo el trabajo en sprints.

## BDD y TDD

- **TDD**: El desarrollo impulsado por pruebas es una metodología que enfatiza escribir pruebas primero. Escribir pruebas antes de desarrollar funciones proporciona retroalimentación en tiempo real a los desarrolladores durante el proceso de desarrollo.
- **BDD**: El desarrollo impulsado por el comportamiento es el enfoque de alinear una serie de pruebas con los objetivos comerciales. Los escenarios de prueba en BDD deben escribirse en un lenguaje que pueda ser entendido tanto por personas técnicas como no técnicas. Un ejemplo de tal sintaxis es Gherkin.
- **Frameworks de Prueba BDD**: Ejemplos de frameworks de pruebas BDD incluyen Cucumber, JBehave y SpecFlow.

## Aserciones en Pruebas de Unidad

- **Aserción**: Las aserciones se utilizan para comprobar que el código se comporta como se espera.
- **Bibliotecas de Aserciones**: Chai es una biblioteca de aserciones comúnmente utilizada. Otras bibliotecas comunes de aserciones en JavaScript son `should.js` y `expect.js`.

Aquí hay un ejemplo de una aserción utilizando Chai que comprueba que el valor de retorno de la función `addThreeAndFour` es igual al número 7:

```js
assert.equal(addThreeAndFour(), 7);
```

- **Mejores Prácticas**: Independientemente de qué biblioteca de aserción uses, debes escribir mensajes claros de aserción y falla que te ayuden a entender qué pruebas están fallando y por qué.

## Simulación, Falsificación y Relleno

- **Simulación**: Simular es el proceso de reemplazar datos reales con datos falsos que simulan el comportamiento de componentes reales. Por ejemplo, podrías simular la response de la API en pruebas en lugar de realizar llamadas de API continuas para obtener los datos.
- **Relleno**: Los rellenos son objetos que devuelven respuestas predefinidas o datos simulados para un comportamiento esperado en una aplicación. Por ejemplo, puedes definir el comportamiento para una conexión a la base de datos en tus pruebas sin tener que depender de una conexión a la base de datos real.
- **Falsificación**: Las falsificaciones son versiones simplificadas de componentes reales sin la complejidad o efectos secundarios. Por ejemplo, puedes falsificar una base de datos almacenando los datos en memoria en lugar de interactuar con la base de datos real. Esto te permitirá imitar operaciones de base de datos en memoria, lo cual será mucho más rápido que tratar con la base de datos real.

## Pruebas Funcionales

- **Pruebas Funcionales**: Las pruebas funcionales verifican si las funciones y características de la aplicación funcionan como se espera. El objetivo de las pruebas funcionales es probar el sistema como un todo en múltiples escenarios.
- **Pruebas No Funcionales**: Las pruebas no funcionales se centran en aspectos como el rendimiento y la fiabilidad.
- **Pruebas de Humo**: Las pruebas de humo son una verificación preliminar del sistema para identificar problemas básicos o críticos antes de comenzar pruebas más exhaustivas.

## Pruebas de Extremo a Extremo

- **Pruebas de Extremo a Extremo**: Las pruebas de extremo a extremo, o E2E, prueban escenarios del mundo real desde la perspectiva del usuario. Las pruebas de extremo a extremo ayudan a garantizar que tu aplicación se comporte correctamente y sea predecible para los usuarios. Sin embargo, lleva mucho tiempo configurarlas, diseñarlas y mantenerlas.
- **Frameworks de Pruebas de Extremo a Extremo**: Playwright es un framework popular para pruebas de extremo a extremo desarrollado por Microsoft. Otros ejemplos de herramientas de pruebas de extremo a extremo incluyen Cypress, Selenium y Puppeteer.

Aquí tienes un ejemplo de pruebas E2E del código abierto de freeCodeCamp usando Playwright. El hook `beforeEach` se ejecutará antes de cada una de las pruebas. Las pruebas verifican que el donante tenga un enlace de apoyo en la barra de menú, así como un borde especial estilizado alrededor de su avatar:

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## Pruebas de Usabilidad

- **Pruebas de Usabilidad**: Las pruebas de usabilidad se realizan cuando usuarios reales interactúan con la aplicación para descubrir si hay problemas de diseño, experiencia de usuario o funcionalidad en la aplicación. Las pruebas de usabilidad se centran en la intuición de la aplicación por parte de los usuarios.
- **Four Common Types of Usability Testing**:
  - **Explorativa**: La prueba de usabilidad explorativa implica que los usuarios interactúen con las diferentes funciones de la aplicación para comprender mejor cómo funcionan.
  - **Comparativa**: La prueba comparativa consiste en comparar la experiencia del usuario de tu aplicación con aplicaciones similares en el mercado.
  - **Evaluación**: En la prueba de evaluación, se estudia cuán intuitiva es la aplicación al usarla.
  - **Validación**: La prueba de validación es donde se identifican los problemas importantes que impedirán al usuario utilizar la aplicación de manera efectiva.
- **Herramientas de Pruebas de Usabilidad**: Ejemplos de herramientas para pruebas de usabilidad incluyen Loop11, Maze, Userbrain, UserTesting y UXTweak.

## Pruebas de Compatibilidad

- **Pruebas de Compatibilidad**: El objetivo de las pruebas de compatibilidad es asegurar que tu aplicación funcione en diferentes entornos de computación.
- **Different Types of Compatibility Testing**:
  - **Compatibilidad hacia Atrás**: La compatibilidad hacia atrás se refiere a cuando el software es compatible con versiones anteriores.
  - **Compatibilidad hacia Adelante**: La compatibilidad hacia adelante se refiere a cuando los software y sistemas funcionarán con versiones futuras.
  - **Compatibilidad de Hardware**: La compatibilidad de hardware es la capacidad del software para funcionar correctamente en diferentes configuraciones de hardware.
  - **Compatibilidad de Sistemas Operativos**: La compatibilidad de sistemas operativos es la capacidad del software para funcionar en diferentes sistemas operativos, como macOS, Windows y distribuciones de Linux como Ubuntu y Fedora.
  - **Compatibilidad de Redes**: La compatibilidad de redes significa que el software puede funcionar en diferentes condiciones de red, como diferentes velocidades, protocolos, configuraciones de seguridad, etc.
  - **Compatibilidad de Navegadores**: La compatibilidad de navegadores significa que la aplicación web puede funcionar de manera consistente en diferentes navegadores, como Google Chrome, Safari, Firefox, etc.
  - **Compatibilidad Móvil**: Es importante asegurarse de que tus aplicaciones de software funcionen en una variedad de dispositivos Android y iOS, incluidos teléfonos y tabletas.

## Pruebas de Rendimiento

- **Pruebas de Rendimiento**: En las pruebas de rendimiento, se prueba la velocidad, capacidad de respuesta, escalabilidad y estabilidad de una aplicación bajo diferentes cargas de trabajo. El objetivo es resolver cualquier tipo de cuello de botella de rendimiento.
- **Different Types of Performance Testing**:
  - **Pruebas de Carga**: Las pruebas de carga determinan cómo un sistema se comporta durante tiempos de carga normales y máximos.
  - **Pruebas de Estrés**: Las pruebas de estrés son donde se prueba tu aplicación bajo cargas extremas y se observa qué tan bien responde tu sistema a la carga más alta.
  - **Pruebas de Soak (Pruebas de Resistencia)**: Las pruebas de soak o pruebas de resistencia son un tipo de pruebas de carga donde se prueba el sistema con una carga más alta durante un período de tiempo prolongado.
  - **Pruebas de Picos**: Las pruebas de picos son donde se aumenta y disminuye drásticamente las cargas y se analiza las reacciones del sistema a los cambios.
  - **Pruebas de Punto de Ruptura (Pruebas de Capacidad)**: Las pruebas de punto de ruptura o pruebas de capacidad son donde se incrementa lentamente la carga a lo largo del tiempo hasta el punto en el que el sistema comienza a fallar o degradarse.

## Pruebas de Seguridad

- **Pruebas de Seguridad**: Las pruebas de seguridad ayudan a identificar vulnerabilidades y debilidades.
- **Security Principles**:
  - **Confidencialidad**: Esto protege contra la divulgación de información sensible a destinatarios que no son los previstos.
  - **Integridad**: Esto implica prevenir que usuarios malintencionados modifiquen información de usuarios.
  - **Autenticación**: Esto implica verificar la identidad del usuario para asegurar que esté autorizado para usar el sistema.
  - **Autorización**: Este es el proceso de determinar qué acciones pueden realizar los usuarios autenticados o a qué partes del sistema tienen permitido acceder.
  - **Disponibilidad**: Esto asegura que la información y los servicios estén disponibles para usuarios autorizados cuando los necesiten.
  - **No Repudio**: Esto asegura que tanto el remitente como el destinatario tengan pruebas de entrega y verificación de la identidad del remitente. Protege contra el remitente negando haber enviado la información.
- **Common Security Threats**:
  - **XSS (Cross-Site Scripting)**: Los ataques XSS ocurren cuando un atacante inyecta scripts maliciosos en una página web y luego los ejecuta en el contexto del navegador de la víctima.
  - **Inyección SQL**: La inyección SQL permite a usuarios malintencionados inyectar código malicioso en una base de datos.
  - **Denegación de Servicio (DoS)**: Un ataque DoS ocurre cuando usuarios malintencionados inundan un sitio web con un alto número de solicitudes o tráfico, haciendo que el servidor se ralentice o colapse y el sitio no esté disponible para los usuarios.
- **Categories of Security Testing Tools**:
  - **Pruebas de Seguridad de Aplicaciones Estáticas**: Estas herramientas evalúan el código fuente de una aplicación para identificar vulnerabilidades de seguridad.
  - **Pruebas de Seguridad de Aplicaciones Dinámicas**: Estas herramientas interactúan con el frontend de la aplicación para descubrir potenciales debilidades de seguridad. Las herramientas DAST no tienen acceso al código fuente.
- **Pruebas de Penetración (pentest)**: Las pruebas de penetración son un tipo de pruebas de seguridad que implican crear ataques cibernéticos simulados en la aplicación para identificar vulnerabilidades en el sistema.

## Pruebas A/B

- **Pruebas A/B**: Las pruebas A/B implican comparar dos versiones de una página o aplicación y estudiar cuál versión desempeña mejor. También se le conoce como pruebas de cubeta o división. Las pruebas A/B te permiten tomar decisiones más basadas en datos y mejorar continuamente la experiencia del usuario.
- **Herramientas para Pruebas A/B**: Ejemplos de herramientas para usar en pruebas A/B incluyen GrowthBook y LaunchDarkly.

## Pruebas Alfa y Beta

Una vez que se completa el desarrollo inicial y las pruebas de software, es importante que la aplicación sea probada por evaluadores y usuarios reales. Es aquí donde entran las pruebas alfa y beta.

- **Pruebas Alfa**: Las pruebas alfa son realizadas por un grupo selecto de evaluadores que revisan la aplicación para garantizar que no haya errores antes de ser lanzada al mercado. Las pruebas alfa son parte de las pruebas de aceptación e implementan técnicas de caja blanca y caja negra.
- **Pruebas Beta**: Las pruebas beta son donde la aplicación se pone a disposición de usuarios reales. Los usuarios pueden interactuar con la aplicación y proporcionar retroalimentación. Las pruebas beta también son una forma de pruebas de aceptación por parte del usuario.
- **Pruebas de Aceptación**: Las pruebas de aceptación aseguran que la aplicación de software cumpla con los requisitos comerciales y las necesidades de los usuarios antes de su lanzamiento.
- **Pruebas de Caja Negra**: Las pruebas de caja negra solo se centran en el comportamiento esperado de la aplicación.
- **Pruebas de Caja Blanca**: Las pruebas de caja blanca implican que el evaluador conoce los componentes internos y realiza pruebas sobre ellos.

## Pruebas de Regresión

- **Regresión**: La regresión se refiere a situaciones donde cambios nuevos rompen involuntariamente la funcionalidad existente.
- **Pruebas de Regresión**: Las pruebas de regresión ayudan a identificar problemas de regresión. En las pruebas de regresión, vuelves a ejecutar pruebas funcionales en partes de tu aplicación para garantizar que todo sigue funcionando como se esperaba.
- **Herramientas para Pruebas de Regresión**: Las herramientas que puedes usar para realizar pruebas de regresión incluyen Puppeteer, Playwright, Selenium y Cypress.
- **Techniques for Regression Testing**: 
  - **Pruebas de regresión unitaria**: Esta es una lista de elementos que deben ser probados cada vez que se implementan cambios o correcciones importantes en la aplicación.
  - **Pruebas de regresión parcial**: Esto implica enfoques dirigidos para garantizar que los nuevos cambios no hayan roto aspectos específicos de la aplicación.
  - **Pruebas de regresión completa**: Esto ejecuta pruebas en todas las funcionalidades del código base. Esta es la opción más detallada y consume más tiempo.
- **Repruebas**: Se emplea para verificar problemas conocidos y asegurar que se hayan resuelto. Por el contrario, las pruebas de regresión buscan problemas desconocidos que podrían haber ocurrido debido a cambios recientes en el código base.

## ¿Qué es TypeScript?

- **JavaScript**: JavaScript es un lenguaje de tipado dinámico. Esto significa que las variables pueden recibir cualquier valor en tiempo de ejecución. El reto de un lenguaje de tipado dinámico es que la falta de seguridad de tipos puede introducir errores.

Por ejemplo, incluso si tu función de JavaScript espera un arreglo, se puede llamar con un número:

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

La salida de `console` para el ejemplo anterior será `undefined`.

- **TypeScript**: TypeScript amplía el lenguaje JavaScript para incluir tipado estático, lo que ayuda a detectar errores causados por desajustes de tipos antes de ejecutar el código.

Por ejemplo, puedes definir un tipo para el parámetro `array` de la siguiente manera:

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Esta definición de tipo indica a TypeScript que el parámetro `array` debe ser un arreglo de cadenas. Luego, cuando llamas a `getRandomValue` y pasas un número, obtienes un error llamado error de compilador.

- **Compilador**: Primero necesitas compilar el código TypeScript a JavaScript normal. Cuando ejecutas el compilador, TypeScript evaluará tu código y lanzará un error para cualquier problema donde los tipos no coincidan.

## Tipos de Datos en TypeScript

- **Tipos de Datos Primitivos en TypeScript**: Para los tipos de datos primitivos `cadena`, `null`, `undefined`, `número`, `booleano`, y `bigint`, TypeScript ofrece palabras clave de tipo correspondientes.

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **Arreglo**: Puedes definir un arreglo de un tipo específico con dos sintaxis diferentes.

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **Objetos**: Puedes definir la estructura exacta de un objeto.

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

Si quieres un objeto con cualquier clave, pero donde todos los valores deben ser cadenas, hay dos maneras de definirlo:

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **Other Helpful Types in TypeScript**:
  - **`cualquier`**: `cualquier` indica que un valor puede tener cualquier tipo. Le dice al compilador que deje de preocuparse por el tipo de esa variable.
  - **`unknown`**: `unknown` tells TypeScript that you _do_ care about the type of the value, but you don’t actually know what it is. `unknown` is generally preferred over `any`.
  - **`void`**: Este es un tipo especial que típicamente solo usarás al definir funciones. Las funciones que no tienen un valor de retorno utilizan un tipo de retorno `void`.
  - **`nunca`**: Representa un tipo que nunca existirá.

- **`tipo` Palabra Clave **: Esta palabra clave es como `const`, pero en lugar de declarar una variable, puedes declarar un tipo.

Es útil para declarar tipos personalizados como tipos de unión o tipos que incluyen solo valores específicos:

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interfaz`**: Las interfaces son como clases para tipos. Pueden implementar o extender otras interfaces, son tipos específicamente de objeto, y generalmente se prefieren a menos que necesites una característica específica ofrecida por una declaración `tipo`.

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **Defining Return Type**: You can also define the _return type_ of the function. 

El ejemplo a continuación define el valor de retorno como una cadena. Si intentas devolver algo más, TypeScript te dará un error de compilador.

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## Genéricos

- **Definiendo Tipo Genérico**: Puedes definir un tipo genérico y referirlo en tu función. Se puede considerar como un parámetro especial que proporcionas a una función para controlar el comportamiento de la definición del tipo de la función.

Aquí tienes un ejemplo de cómo definir un tipo genérico para una función:

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

La sintaxis `<T>` le indica a TypeScript que estás definiendo un tipo genérico `T` para la función. `T` es un nombre común para tipos genéricos, pero puedes usar cualquier nombre.

Luego, le dices a TypeScript que el parámetro `array` es un arreglo de valores que coinciden con el tipo genérico, y que el valor devuelto es un solo elemento de ese mismo tipo.

- **Especificar el Argumento de Tipo en la Llamada a la Función**: Puedes pasar un argumento de tipo a una llamada a la función utilizando corchetes angulares entre el nombre de la función y sus parámetros.

Aquí tienes un ejemplo de cómo pasar un argumento de tipo a una llamada a la función:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Esto le dice a TypeScript que el elemento que esperas encontrar será un elemento de entrada.

## Reducción de Tipo

- **Narrowing by Truthiness**: In the example below, you get a compiler error trying to access the `value` property of `email` because `email` _might_ be `null`.

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

You can use a conditional statement to confirm `email` is _truthy_ before accessing the property:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

Los chequéos de veracidad también pueden funcionar en la dirección opuesta:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

Throwing an error ends the logical execution of this code, which means when you reach the `console.log()` call, TypeScript knows `email` _cannot_ be `null`.

- **Encadenamiento Opcional**: El encadenamiento opcional `?.` también es una forma de reducción de tipo, bajo la premisa de que el acceso a la propiedad no puede ocurrir si el valor `email` es `null`.

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **Operador `typeof`**: Puedes usar un condicional para verificar el tipo de la variable utilizando el operador `typeof`.

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **Palabra clave `instanceof`**: Si el objeto proviene de una clase, puedes usar la palabra clave `instanceof` para reducir el tipo.

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **Casting**: Cuando TypeScript no puede determinar automáticamente el tipo de un valor, como el resultado del método `request.json()` en el ejemplo a continuación, obtendrás un error de compilador. Una forma de resolver esto es haciendo casting del tipo, pero al hacerlo se debilita la capacidad de TypeScript para detectar errores potenciales.

```typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **Guardia de Tipo**: En lugar de hacer casting del tipo, puedes escribir un guardia de tipo:

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

La sintaxis `user is User` indica que tu función retorna un valor booleano, que cuando es verdadero, significa que el valor `user` satisface la interface `User`.

## Archivo `tsconfig`

- **`tsconfig.json`**: Las configuraciones del compilador de TypeScript residen en un archivo `tsconfig.json` en el directorio raíz de tu proyecto.

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

Aquí tienes las descripciones de las opciones del compilador usadas en el ejemplo anterior:

- **`opcionesDelCompilador`**: La propiedad `opcionesDelCompilador` es donde controlas cómo se comporta el compilador de TypeScript.
- **`directorioRaíz` y `directorioDeSalida`**: Los `directorioRaíz` y `directorioDeSalida` le dicen a TypeScript qué directorio contiene tus archivos fuente y qué directorio debería contener el código JavaScript transpilation.
- **`biblioteca`**: La propiedad `biblioteca` determina qué definiciones de tipo utiliza el compilador y te permite incluir soporte para lanzamientos específicos de ES, el DOM y más.
- **`módulo` y `resoluciónDelMódulo`**: El `módulo` y `resoluciónDelMódulo` trabajan en conjunto para gestionar cómo tu paquete utiliza módulos - ya sea CommonJS o ECMAScript.
- **`interoperabilidadConESMódulos`**: La `interoperabilidadConESMódulos` permite una interoperabilidad más fluida entre CommonJS y ES módulos al crear automáticamente objetos de espacio de nombres para las importaciones.
- **`omitirVerificaciónDeBiblioteca`**: La opción `omitirVerificaciónDeBiblioteca` omite la validación de archivos `.d.ts` que no están referenciados por importaciones en tu código.
- **`estricto`**: La bandera `estricto` habilita varios chequeos, como asegurar el manejo adecuado de tipos anulables y advertir cuando TypeScript recurre a `cualquier`.
- **`excluir`**: La propiedad `excluir` de nivel superior indica al compilador que ignore estos archivos TypeScript durante la compilación.


# --assignment--

Revisa los temas y conceptos de Front End Libraries.
