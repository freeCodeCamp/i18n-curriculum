---
id: 697a49e9860d24853adef680
title: "挑戰 195：2026 冬季遊戲第 16 天：冰壺"
challengeType: 29
dashedName: challenge-195
---

# --description--

給定一個 5x5 矩陣，表述冰壺回合結束時的「house」，判斷哪一隊得分以及他們得了多少分。

版面配置：

- 中間儲存格（索引 `[2, 2]`）是「按鈕」。
- 按鈕周圍直接的 8 個儲存格表述環 1。
- 而房屋外緣的 16 個格子表述環 2。

在給定的矩陣中：

- 「.」表述一個空白。
- "`R`" 表示一個帶有紅色石頭的空格。
- `Y` 表示一個帶有黃色石頭的空格。

計分規則：

- 每回合只能有一支隊伍得分。
- 距離 `button` 最近的石頭所屬隊伍得分。
- 得分隊伍每有一顆比對手最近的石頭更接近按鈕，即可獲得 1 分。
- 環號數字越低，寶石越接近中心。
- 如果雙方隊伍距離中心最近的石頭距離相同，則無隊伍得分。

傳回：

- 格式為 `"team: number_of_points"` 的字串。例如：`"R: 2"`。
- 或在雙方隊伍皆未得分時顯示 `"No points awarded"`。

例如，給定：

```js
[
  [".", ".", "R", ".", "."],
  [".", "R", ".", ".", "."],
  ["Y", ".", ".", ".", "."],
  [".", "R", ".", ".", "."],
  [".", ".", ".", ".", "."]
]
```

傳回 `"R: 2"`。第一圈中兩顆紅色棋子並列為最近，且是唯一兩顆比黃色最近的棋子更接近的棋子。 

# --hints--

`score_curling([[".", ".", "R", ".", "."], [".", "R", ".", ".", "."], ["Y", ".", ".", ".", "."], [".", "R", ".", ".", "."], [".", ".", ".", ".", "."]])` 應該傳回 `"R:2"`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(score_curling([[".", ".", "R", ".", "."], [".", "R", ".", ".", "."], ["Y", ".", ".", ".", "."], [".", "R", ".", ".", "."], [".", ".", ".", ".", "."]]), "R: 2")`)
}})
```

`score_curling([[".", ".", "R", ".", "."], [".", ".", ".", ".", "."], [".", ".", "Y", ".", "R"], [".", ".", "Y", "Y", "."], [".", "Y", "R", "R", "."]])` 應該傳回 `"Y: 3"`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(score_curling([[".", ".", "R", ".", "."], [".", ".", ".", ".", "."], [".", ".", "Y", ".", "R"], [".", ".", "Y", "Y", "."], [".", "Y", "R", "R", "."]]), "Y: 3")`)
}})
```

`score_curling([[".", "R", "Y", ".", "."], ["Y", ".", ".", ".", "."], [".", ".", ".", ".", "."], [".", "Y", "R", "Y", "."], [".", ".", "R", "R", "."]])` 應該傳回 `"No points awarded"`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(score_curling([[".", "R", "Y", ".", "."], ["Y", ".", ".", ".", "."], [".", ".", ".", ".", "."], [".", "Y", "R", "Y", "."], [".", ".", "R", "R", "."]]), "No points awarded")`)
}})
```

`score_curling([[".", "Y", "Y", ".", "."], ["Y", ".", ".", "R", "."], [".", ".", "R", ".", "."], [".", ".", "R", "R", "."], [".", "Y", "R", "Y", "."]])` 應該傳回 `"R: 4"`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(score_curling([[".", "Y", "Y", ".", "."], ["Y", ".", ".", "R", "."], [".", ".", "R", ".", "."], [".", ".", "R", "R", "."], [".", "Y", "R", "Y", "."]]), "R: 4")`)
}})
```

`score_curling([["Y", "Y", "Y", "Y", "Y"], ["Y", "R", "R", "R", "Y"], ["Y", "R", "Y", "R", "Y"], ["Y", "R", "R", "R", "Y"], ["Y", "Y", "Y", "Y", "Y"]])` 應該傳回 `"Y: 1"`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(score_curling([["Y", "Y", "Y", "Y", "Y"], ["Y", "R", "R", "R", "Y"], ["Y", "R", "Y", "R", "Y"], ["Y", "R", "R", "R", "Y"], ["Y", "Y", "Y", "Y", "Y"]]), "Y: 1")`)
}})
```

`score_curling([["Y", "R", "Y", "R", "Y"], ["R", ".", ".", ".", "R"], ["Y", ".", ".", ".", "Y"], ["R", ".", ".", ".", "R"], ["Y", ".", ".", "R", "Y"]])` 應該傳回 `"No points awarded"`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(score_curling([["Y", "R", "Y", "R", "Y"], ["R", ".", ".", ".", "R"], ["Y", ".", ".", ".", "Y"], ["R", ".", ".", ".", "R"], ["Y", ".", ".", "R", "Y"]]), "No points awarded")`)
}})
```

# --seed--

## --seed-contents--

```py
def score_curling(house):

    return house
```

# --solutions--

```py
def score_curling(house):
  stones = {'R': [], 'Y': []}
  
  for i in range(5):
    for j in range(5):
      cell = house[i][j]
      if cell == 'R' or cell == 'Y':
        distance = max(abs(i - 2), abs(j - 2))
        stones[cell].append(distance)
  
  red_closest = min(stones['R']) if stones['R'] else float('inf')
  yellow_closest = min(stones['Y']) if stones['Y'] else float('inf')
  
  if red_closest == float('inf') and yellow_closest == float('inf'):
    return "No points awarded"
  
  if red_closest == yellow_closest:
    return "No points awarded"
  
  if red_closest < yellow_closest:
    winner = 'R'
    opponent_closest = yellow_closest
    winning_stones = stones['R']
  else:
    winner = 'Y'
    opponent_closest = red_closest
    winning_stones = stones['Y']
  
  points = sum(1 for d in winning_stones if d < opponent_closest)
  
  return "No points awarded" if points == 0 else f"{winner}: {points}"
```
