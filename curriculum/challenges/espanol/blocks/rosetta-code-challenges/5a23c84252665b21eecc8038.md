---
id: 5a23c84252665b21eecc8038
title: Subleq
challengeType: 1
forumTopicId: 302328
dashedName: subleq
---

# --description--

Subleq es un ejemplo de una Computadora de Conjunto de Instrucción Única (OISC).

Se llama así por su única instrucción, que es **SU**btract y **B**ranch if **L**ess than or **EQ**ual to zero.

Tu tarea es crear un intérprete que emule dicha máquina.

La memoria de la máquina consiste en un arreglo de enteros con signo. Cualquier tamaño de palabra razonable está bien, pero la memoria debe poder contener números negativos así como positivos.

La ejecución comienza con el puntero de instrucciones apuntando a la primera palabra, que es la dirección 0. Procede de la siguiente manera:

<ol>
  <li>Let A, B, and C be the value stored in the three consecutive words in memory starting at the instruction pointer.</li>
  <li>Advance the instruction pointer 3 words to point at the address after the one containing C.</li>
  <li>If A is -1, then a character is read from standard input and its code point stored in the address given by B. C is unused.</li>
  <li>If B is -1, then the number contained in the address given by A is interpreted as a code point and the corresponding character output. C is again unused.</li>
  <li>Otherwise, both A and B are treated as the addresses of memory locations. The number contained in the address given by A is subtracted from the number at the address given by B (and the result stored back in address B). If the result is zero or negative, the value C becomes the new instruction pointer.</li>
  <li>If the instruction pointer becomes negative, execution halts.</li>
</ol>

Otras direcciones negativas además de -1 pueden tratarse como equivalentes a -1, o generar un error, según consideres apropiado.

Tu solución debe aceptar un programa para ejecutar en la máquina, separado de la entrada que se proporciona al programa mismo.

Este programa debe estar en código de máquina subleq en bruto: números decimales separados por espacios en blanco, sin nombres simbólicos ni otras extensiones a nivel de ensamblador, para cargarse en la memoria comenzando en la dirección 0. Muestra la salida de tu solución cuando se le alimente con este programa "Hello, world!". (Ten en cuenta que el ejemplo asume ASCII o un superconjunto de este, como cualquiera de los conjuntos de caracteres Latin-N o Unicode. Puedes traducirlo a otro conjunto de caracteres si tu implementación está en un entorno no compatible con ASCII.)

<pre>15 17 -1 17 -1 -1 16 1 -1 16 3 -1 15 15 0 0 -1 72 101 108 108 111 44 32 119 111 114 108 100 33 10 0</pre>

Lo que corresponde a algo así en un lenguaje ensamblador hipotético:

<pre>start:
    zero, message, -1
    message, -1, -1
    neg1, start+1, -1
    neg1, start+3, -1
    zero, zero, start
zero: 0
neg1: -1
message: "Hello, world!\n\0"
</pre>

# --instructions--

Escribe una función que tome un arreglo de enteros como parámetro. Esto representa los elementos de memoria. La función debe interpretar la secuencia y devolver la cadena de salida. Para esta tarea, asume que no hay entrada estándar.

# --hints--

`Subleq` debería ser una función.

```js
assert(typeof Subleq == 'function');
```

`Subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 0])` debería devolver una cadena.

```js
assert(
  typeof Subleq([
    15,
    17,
    -1,
    17,
    -1,
    -1,
    16,
    1,
    -1,
    16,
    3,
    -1,
    15,
    15,
    0,
    0,
    -1,
    72,
    101,
    108,
    108,
    111,
    44,
    32,
    119,
    111,
    114,
    108,
    100,
    33,
    0
  ]) == 'string'
);
```

`Subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 0])` debería devolver `"Hello, world!"`.

```js
assert.equal(
  Subleq([
    15,
    17,
    -1,
    17,
    -1,
    -1,
    16,
    1,
    -1,
    16,
    3,
    -1,
    15,
    15,
    0,
    0,
    -1,
    72,
    101,
    108,
    108,
    111,
    44,
    32,
    119,
    111,
    114,
    108,
    100,
    33,
    0
  ]),
  'Hello, world!'
);
```

# --seed--

## --seed-contents--

```js
function Subleq(mem) {

}
```

# --solutions--

```js
function Subleq(mem) {
  var out = '';
  var instructionPointer = 0;
  do {
    var a = mem[instructionPointer];
    var b = mem[instructionPointer + 1];
    if (a === -1) {
    } else if (b === -1) {
      out += String.fromCharCode(mem[a]);
    } else {
      mem[b] -= mem[a];
      if (mem[b] < 1) {
        instructionPointer = mem[instructionPointer + 2];
        continue;
      }
    }
    instructionPointer += 3;
  } while (instructionPointer >= 0);

  return out;
}
```
