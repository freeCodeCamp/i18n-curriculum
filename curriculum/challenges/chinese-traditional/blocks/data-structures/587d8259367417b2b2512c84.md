---
id: 587d8259367417b2b2512c84
title: 創建 Trie 搜尋樹
challengeType: 1
forumTopicId: 301634
dashedName: create-a-trie-search-tree
---

# --description--

這裡我們將從二元搜尋樹轉移，來看看另一種稱為 trie 的樹狀結構。trie 是一種有序搜尋樹，通常用來儲存字串，或更一般化地說，是用來儲存鍵為字串的關聯陣列或動態資料集。當許多鍵會有重疊的前置式時，它們非常適合用來儲存資料集合，例如字典中的所有字詞。與二元樹不同，節點並不與實際值相關聯。相反地，通往節點的路徑代表特定的鍵。例如，如果我們想在 trie 中儲存字串 `code`，我們會有四個節點，每個字母一個：c — o — d — e。沿著這些節點的路徑將會產生字串 `code` — 那條路徑就是我們儲存的鍵。接著，如果我們想添加字串 `coding`，它會與 `code` 共享前三個節點，然後在 d 之後分支。透過這種方式，大型資料集可以非常緊湊地儲存。此外，搜尋可以非常快速，因為它實際上限制在你儲存的字串長度內。此外，與二元樹不同，節點可以儲存任意數量的子節點。正如你可能從上述範例猜到的，通常會在儲存鍵結尾的節點存放一些詮釋資料，以便在後續遍歷時仍能取回該鍵。例如，如果我們在上述範例中添加 `codes`，我們需要某種方式知道 `code` 中的 e 代表先前輸入鍵的結尾。否則，當我們添加 `codes` 時，這些資訊將會有效地遺失。

# --instructions--

讓我們創建一個 trie 來儲存字。它將透過 `add` 方法接受字並將這些字儲存在 trie 資料結構中。它也允許我們使用 `isWord` 方法查詢給定的字串是否為一個字，並使用 `print` 方法取得所有輸入到 trie 中的字。`isWord` 應該傳回一個布林值，而 `print` 應該傳回一個包含所有這些字的字串陣列。為了讓我們能驗證這個資料結構是否正確實作，我們提供了一個 `Node` 結構用於樹中的每個節點。每個節點將是一個物件，具有一個 `keys` 屬性，該屬性是一個 JavaScript Map 物件。這將保存每個節點有效鍵的單個字母。我們也在節點上創建了一個 `end` 屬性，當節點代表一個字的結尾時，可以將其設為 `true`。

# --hints--

`Trie` 應該有一個 `add` 方法。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    return typeof test.add == 'function';
  })()
);
```

`Trie` 應該有一個 `print` 方法。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    return typeof test.print == 'function';
  })()
);
```

`Trie` 應該有一個 `isWord` 方法。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    return typeof test.isWord == 'function';
  })()
);
```

`print` 方法應該傳回所有以字串形式添加到 trie 的項目陣列。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    test.add('jump');
    test.add('jumps');
    test.add('jumped');
    test.add('house');
    test.add('mouse');
    var added = test.print();
    return (
      added.indexOf('jump') != -1 &&
      added.indexOf('jumps') != -1 &&
      added.indexOf('jumped') != -1 &&
      added.indexOf('house') != -1 &&
      added.indexOf('mouse') != -1 &&
      added.length == 5
    );
  })()
);
```

`isWord` 方法只應該對添加到 trie 的字傳回 `true`，對所有其他字傳回 `false`。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    test.add('hop');
    test.add('hops');
    test.add('hopped');
    test.add('hoppy');
    test.add('hope');
    return (
      test.isWord('hop') &&
      !test.isWord('ho') &&
      test.isWord('hopped') &&
      !test.isWord('hopp') &&
      test.isWord('hoppy') &&
      !test.isWord('hoping')
    );
  })()
);
```

# --seed--

## --seed-contents--

```js
var displayTree = tree => console.log(JSON.stringify(tree, null, 2));
var Node = function() {
  this.keys = new Map();
  this.end = false;
  this.setEnd = function() {
    this.end = true;
  };
  this.isEnd = function() {
    return this.end;
  };
};
var Trie = function() {
  // Only change code below this line
  
  // Only change code above this line
};
```

# --solutions--

```js
// solution required
```
