---
id: 6874b7d3b286c538b39d0c25
title: ¿Qué son los métodos especiales y para qué se usan?
challengeType: 19
dashedName: what-are-special-methods-and-what-are-they-used-for
---

# --description--

Los métodos especiales en Python, también conocidos como "métodos mágicos" o "métodos dunder", son métodos especiales de Python que comienzan y terminan con dobles guiones bajos (`__`). La palabra "dunder" proviene de dobles guiones bajos (**d** de double, **under** de underscores).

Probablemente ya hayas usado métodos especiales sin darte cuenta. Cada vez que escribes algo como `3 + 4`, Python ejecuta silenciosamente `3.__add__(4)` detrás de escena. Eso es un método especial en acción. Así que, aunque *puedes* llamar a métodos especiales directamente, rara vez lo haces. Algo como `3 + 4` es mucho más claro y fácil de leer que llamar a `3.__add__(4)` tú mismo.

Aparte de `__add__`, `__init__()` es otro método especial que verás y usarás más, ya que es un inicializador de clase. También hay otros como `__len__()` y `__str__()`.

Piensa en los métodos especiales como los directores de las actividades entre una persona que programa y el intérprete del lenguaje Python.

Recuerda, no necesitas llamar a métodos especiales directamente. En cambio, Python los llama automáticamente cuando ocurren ciertas acciones. Estas operaciones incluyen:

- **Operaciones aritméticas como suma, resta, multiplicación, división y otras**. Además, se llama a `__add__()`, `__sub__()` para la resta, `__mul__()` para la multiplicación y `__truediv__()` para la división.
    
- **Operaciones con cadenas como concatenación, repetición, formato y conversión a texto**. Se llama a `__add__()` para concatenación, a `__mul__()` para repetición, a `__format__()` para formato, a `__str__()` y `__repr__()` para conversión a texto, y así sucesivamente.
    
- **Operaciones de comparación como igualdad, menor que, mayor que y otras**. Se llama a `__eq__()` para verificaciones de igualdad, a `__lt__()` para menor que, a `__gt__()` para mayor que, y así sucesivamente.
    
- **Operaciones de iteración como hacer que un objeto sea iterable y avanzar a través de los elementos**. Se llama a `__iter__()` para devolver un iterador y a `__next__()` para obtener el siguiente elemento.
    

Normalmente, los tipos de datos de Python como strings y numbers ya saben cómo sumar cosas, hacer concatenación, comparar igualdad, usarse en bucles y otros.

Pero cuando creas tu propia clase, Python no sabrá cómo manejar las cosas automáticamente.

Aquí es donde entran los métodos especiales: te permiten personalizar el comportamiento incorporado de Python.

Digamos que quieres obtener el número de páginas en objetos libro creados con la clase a continuación, o compararlos y obtener una cadena legible de los objetos. Esto es lo que sucede sin métodos especiales:

```python
class Book:
   def __init__(self, title, pages):
       self.title = title
       self.pages = pages

book1 = Book("Built Wealth Like a Boss", 420)
book2 = Book("Be Your Own Start", 420)

print(len(book1)) # TypeError: object of type 'Book' has no len()
print(str(book1)) # <__main__.Book object at 0x102ed2900>
print(book1 == book2) # False even though they have the same number of pages
```

En el ejemplo:

- `len(book1)` falló porque Python no sabe cómo obtener la longitud de tu objeto book sin `__len__()`
    
- `str(book1)` imprimió algo como `<__main__.Book object at 0x102ed2900>` porque esa es la representación predeterminada cuando no usas `__str__()`
    
- `book1 == book2` resultó en `False` porque Python solo verifica si ambos objetos son los mismos en memoria, no por contenido.
    

Aquí tienes cómo puedes definir tus propios métodos especiales `__len__()`, `__str__()` y `__eq__()` para facilitar el trabajo con objetos creados a partir de la clase `Book`:

```python
class Book:
   def __init__(self, title, pages):
       self.title = title
       self.pages = pages

   def __len__(self):
       return self.pages

   def __str__(self):
       return f"'{self.title}' has {self.pages} pages"

   def __eq__(self, other):
       return self.pages == other.pages
  
book1 = Book("Built Wealth Like a Boss", 420)
book2 = Book("Be Your Own Start", 420)

print(len(book1)) # 420
print(len(book2)) # 420
print(str(book1)) # 'Built Wealth Like a Boss' has 420 pages
print(str(book2)) # 'Be Your Own Start' has 420 pages
print(book1 == book2) # True
```

Otro ejemplo es un carrito de compras donde haces lo siguiente:

- Agrega items al carrito
    
- Elimina items del carrito
    
- Obtén el número de items en el carrito
    
- Revisa qué items están en el carrito
    
- Verifica si un ítem específico está en el carrito
    
- Devuelve o muestra un ítem en un índice específico del carrito
    

Aunque puedas tener un método que añade items al carrito y elimina ciertos items del carrito, puedes crear métodos especiales para toda la otra funcionalidad:

- Usa `__len__()` para obtener la longitud de los elementos en el carrito
    
- Usa `__iter__()` para recorrer los elementos en el carrito y poder verlos
    
- `__contains__()` para verificar si un ítem específico está en el carrito
    
- `__getitem__()` para devolver o mostrar un elemento en un índice específico del carrito
    

Aquí tienes un ejemplo de una clase `Cart` con estos métodos definidos por el usuario y métodos especiales:

```python
class Cart:
   def __init__(self):
       self.items = []

   def add(self, item):
       self.items.append(item)

   def remove(self, item):
       if item in self.items:
           self.items.remove(item)
       else:
           print(f'{item} is not in cart')

   def list_items(self):
       return self.items

   def __len__(self):
       return len(self.items)

   def __getitem__(self, index):
       return self.items[index]

   def __contains__(self, item):
       return item in self.items

   def __iter__(self):
       return iter(self.items)
```

Y aquí está cómo puedes usarlos:

```python
cart = Cart()
cart.add('Laptop')
cart.add('Wireless mouse')
cart.add('Ergo keyboard')
cart.add('Monitor')

for item in cart:
   print(item, end=' ') # Laptop Wireless mouse Ergo keyboard Monitor

print(len(cart)) # 4
print(cart[3]) # Monitor

print('Monitor' in cart) # True
print('banana' in cart) # False

cart.remove('Ergo keyboard')

print(cart.list_items()) # ['Laptop', 'Wireless mouse', 'Monitor']

cart.remove('banana') # banana is not in cart
```

Y esas son algunas formas en las que usarás métodos especiales en Python en el mundo real.

# --questions--

## --text--

¿Cuál de estos es el método especial llamado durante una operación de suma?

## --answers--

`__plus__()`

### --feedback--

Presta atención a lo que se activa cuando usas el operador `+`.

---

`__sum__()`

### --feedback--

Presta atención a lo que se activa cuando usas el operador `+`.

---

`__add__()`

---

`__concat__()`

### --feedback--

Presta atención a lo que se activa cuando usas el operador `+`.

## --video-solution--

3

## --text--

¿Cómo se derivó la palabra "dunder"?

## --answers--

Desde operaciones dinámicas bajo el capó

### --feedback--

Piensa en cómo la palabra "dunder" está relacionada con la forma en que se escriben los métodos dunder.

---

Al abreviar "double underscore" (`__`)

---

Del creador del apodo de Python

### --feedback--

Piensa en cómo la palabra "dunder" está relacionada con la forma en que se escriben los métodos dunder.

---

Desde "data under" en referencia a métodos ocultos

### --feedback--

Piensa en cómo la palabra "dunder" está relacionada con la forma en que se escriben los métodos dunder.

## --video-solution--

2

## --text--

¿Qué método especial se llama cuando usas el operador de comparación mayor que (`>`)?

## --answers--

`__more__()`

### --feedback--

Significa "mayor que" y se activa con el operador `>`.

---

`__compare__()`

### --feedback--

Significa "mayor que" y se activa con el operador `>`.

---

`__greater__()`

### --feedback--

Significa "mayor que" y se activa con el operador `>`.

---

`__gt__()`

## --video-solution--

4
