---
id: 662fbcef5f05e1b84f541a0c
title: Paso 13
challengeType: 20
dashedName: step-13
---

# --description--

Cada objeto ecuación se instanciará pasando tantos argumentos como coeficientes tenga la ecuación, comenzando desde el grado n-ésimo de \( x \) hasta el grado cero, incluyendo el posible coeficiente con el valor de `0`.

Por ejemplo, `LinearEquation(4, 5)` representaría la ecuación \( 4x + 5 = 0 \), donde `4` es el coeficiente del primer grado (el más alto aquí) y `5` el coeficiente del grado cero.

Necesitas verificar que se pase el número correcto de argumentos para instanciar el objeto equation.

Dentro del método `__init__`, crea una estructura `if` para verificar si la longitud de `args` es diferente del número de coeficientes que la ecuación debería tener (`degree + 1`). Si es así, lanza un `TypeError` y usa la siguiente cadena para proporcionar un mensaje personalizado: `f"'{self.__class__.__name__}' object takes {self.degree + 1} positional arguments but {len(args)} were given"`.

Luego, corrige el error pasando el `2` y el `3` para instanciar `lin_eq`.

# --hints--

Debes crear una estructura `if` que verifique si el número de coeficientes usados para instanciar la ecuación es diferente de `degree + 1`.

```js
({ test: () => assert(runPython(`
cond = _Node(_code).find_class("Equation").find_function("__init__").find_ifs()[0].find_conditions()[0]
cond.is_equivalent("(self.degree + 1) != len(args)") or cond.is_equivalent("len(args) != (self.degree + 1)")
`)) })
```

Debes lanzar un `TypeError` dentro de la nueva estructura `if` y usar la cadena proporcionada para devolver un mensaje de error personalizado.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("__init__").find_ifs()[0].find_bodies()[0].has_stmt('raise TypeError(f"\\'{self.__class__.__name__}\\' object takes {self.degree + 1} positional arguments but {len(args)} were given")')
`)) })
```

Debes pasar `2` y `3` para instanciar `lin_eq`.

```js
({ test: () => assert(runPython(`_Node(_code).has_stmt("lin_eq = LinearEquation(2, 3)")`)) })
```


# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod

class Equation(ABC):
    degree: int
--fcc-editable-region--
    def __init__(self, *args):
        pass        
    
    def __init_subclass__(cls):
        if not hasattr(cls, "degree"):
            raise AttributeError(
                f"Cannot create '{cls.__name__}' class: missing required attribute 'degree'"
            )
    
    @abstractmethod
    def solve(self):
        pass
        
    @abstractmethod
    def analyze(self):
        pass
        
class LinearEquation(Equation):
    degree = 1
    
    def solve(self):
        pass
    
    def analyze(self):
        pass
    
lin_eq = LinearEquation()
--fcc-editable-region--
```
