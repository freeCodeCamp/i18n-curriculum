---
id: 68829162a7f96d73c8505d3d
title: ¿Qué son los conflictos de fusión y cómo puedes resolverlos?
challengeType: 19
dashedName: what-are-merge-conflicts-and-how-can-you-resolve-them
---

# --description--

Si has estado con desarrolladores experimentados, ya sea en una comunidad en línea o en persona, probablemente hayas oído hablar de los "temidos conflictos de merge". Pero, ¿qué son exactamente?

Bueno, cuando estás usando una estrategia de branching adecuada como hemos discutido en lecciones anteriores, puedes estar trabajando en dos características diferentes en dos ramas diferentes al mismo tiempo. O tal vez estás trabajando en algo, y un colega está trabajando en otra rama. De cualquier manera, tienes dos cambios independientes ocurriendo. Pero a veces, ambas ramas editarán el mismo archivo. Y si la otra rama se fusiona en `main` primero, los cambios de tu rama ahora están desactualizados.

La mayoría de las veces, esto se puede solucionar fusionando `main` de nuevo en tu rama de características. Pero cuando los cambios de la otra rama entran en conflicto con tu rama, Git no puede determinar qué cambios quieres conservar durante una fusión. Esto se llama un "merge conflict".

¿Pero cómo puedes arreglarlo? Bueno, para conflictos más pequeños y simples, GitHub te dará una interfaz web para solucionarlo. Aparecerá un botón "Resolve conflicts" en la parte inferior de un PR si hay conflictos. Si haces clic en él, verás el archivo con conflictos que incluye tu código y el código en conflicto. Git añadirá "merge conflict markers" alrededor de tu código y el código en conflicto para ayudar a identificar el problema. Se ve algo así:

```sh
1 <<<<<<< feat/conflict
2 Here's some code from my first PR :)
3 =======
4 Here's some code that was merged to main that conflicts with the code on my PR
5 >>>>>>> main
```

El marcador de apertura es `<<<<<<< feat/conflict`, e indica el inicio de los cambios que nuestra rama actual está haciendo. Luego vemos el `Here's some code from my first PR :)`. Después de eso está el marcador `=======`, que indica el final de nuestros cambios y el inicio de los cambios de la rama `main`. Podemos ver que los cambios hechos en `main` son la línea `Here's some code that was merged to main that conflicts with the code on my PR`. Y después de eso está el marcador de cierre `>>>>>> main` para mostrar el final de los conflictos.

¿Pero cómo lo arreglamos? Bueno, necesitas decidir qué cambios quieres conservar como parte de los conflictos de fusión. Si quieres conservar ambos cambios, podrías eliminar solo los marcadores de conflicto y dejar los cambios sin modificar. Alternativamente, si quieres conservar los cambios de solo una rama, deberías eliminar los marcadores de conflicto y los cambios de la otra rama (aquellos que no deseas conservar). Y finalmente, si no te gusta ninguno de los cambios, puedes eliminar todo desde el marcador de apertura hasta el marcador de cierre (inclusive).

Vamos a eliminar los cambios de la rama `main`, pero conservar los nuestros. Esto es lo que tenemos ahora:

```sh
1 Here's some code from my first PR :)
```

Haz clic en el botón "Mark as resolved", que indica a GitHub que estás satisfecho con tu resolución. Si hubiera archivos adicionales, GitHub cambiaría al siguiente. Pero como este es nuestro único archivo en conflicto, verás que aparece un botón "Commit merge". Haz clic en ese botón y GitHub creará un commit de fusión para ti. Serás llevado de vuelta al pull request, donde verás tu nuevo commit de fusión y los conflictos resueltos. ¡Y ya está todo listo!

¿Pero qué pasa si no puedes editar los conflictos directamente en GitHub, porque son demasiado complejos?

Bueno, si tu rama tiene pocos commits, o solo un par de commits modifican ese archivo, puede que puedas fusionar `main` en tu rama:

```sh
git checkout feat/conflict
git fetch origin
git merge origin/main
```

Mientras Git procesa esta fusión, tendrás conflictos que resolver manualmente. Git te notificará qué archivos necesitan ser corregidos. Cuando abrimos los archivos con conflictos en nuestro editor, obtenemos los mismos marcadores de conflicto, con algunas adiciones útiles en la interfaz gracias a VSCode. Adelante, corrige los conflictos en el archivo de la misma manera. Pero esta vez, necesitaremos crear el commit manualmente. Es lo mismo que crear cualquier otro commit:

```sh
git add .
git commit -m "chore: resolve conflicts"
```

Después de ejecutar estos comandos, podemos ver que Git ha aceptado nuestra resolución.

A veces, cuando tienes muchos commits o conflictos, un rebase puede ser útil. En lugar de fusionar cambios, un rebase toma todos los commits en tu rama y los reaplica para que vengan después de los cambios más recientes en `main`. En términos de Git, esto efectivamente "restablece" la base de tu rama al commit más reciente en `main`.

Para experimentar con esto, necesitamos una nueva rama:

```sh
git checkout main
git pull
git checkout -b feat/rebase
```

Vamos a generar varios commits para nuestra rama, para que podamos practicar el rebase:

```sh
echo "change one" > README.md
git add .
git commit -m "change one"
echo "change two" > README.md
git add .
git commit -m "change two"
echo "change three" > README.md
git add .
git commit -m "change three"
```

Ahora, vamos a hacer otro cambio en `main` para crear un conflicto:

```sh
git checkout main
echo "change four" > README.md
git add .
git commit -m "change four"
```

Y revisa nuestra rama rebase:

```sh
git checkout feat/rebase
```

A continuación, ejecuta `git rebase -i main`. Esto reestructurará nuestra rama sobre el estado actual de la rama `main`. La bandera `-i` le indica a Git que realice un rebase en modo interactivo. Verás tus commits con la palabra `pick` junto a ellos. `pick` le dice a Git que use el commit tal cual para el rebase. Guarda y cierra el archivo, y obtendremos un mensaje de error que nos indica que hay conflictos.

Nuestro commit `change one` tiene un conflicto con el commit `change four`, y necesitamos resolverlo. Abre el archivo en tu editor, y verás la misma interfaz de usuario que obtuvimos con los conflictos anteriores. Vamos a mantener los cambios de `change one`. Luego, necesitarás ejecutar `git add .` para agregar los cambios, y `git rebase --continue` para indicarle a Git que estamos listos para continuar con el rebase. Como hemos resuelto el conflicto en el primer commit, Git puede manejar automáticamente el rebase del resto de los commits.

Ahora, como último paso de limpieza, vamos a combinar nuestros tres commits de cambio en un solo commit para tener un historial más limpio. Ejecuta `git rebase -i main` de nuevo para abrir el editor. Luego, deja el primer comando como `pick` pero cambia los siguientes dos a `squash`. Puede que te encuentres con el mismo conflicto otra vez. Si es así, resuélvelo de la misma manera que antes. Una vez que hayas resuelto y continuado el rebase (o inmediatamente, si no tuviste conflicto), verás que aparece un nuevo editor de mensaje de commit. Este mensaje será tu nuevo commit, que contiene los cambios de los tres commits que hemos combinado. Nombra este como `change three complete`. Guarda y cierra el editor, y Git finalizará el rebase.

Si revisamos tu historial de commits ahora, podemos ver que ahora tenemos nuestro único commit `change three complete`, y está correctamente basado en el commit `change four`. ¡Eso significa que has completado con éxito un rebase con commits combinados! Y ahora tienes las herramientas que necesitas para convertirte en un campeón de conflictos de merge.

# --questions--

## --text--

¿Cuáles son los marcadores de conflicto de fusión que Git agrega para ayudar a identificar los cambios en conflicto?

## --answers--

`<<< current branch`, `=== separator`, `>>> other branch`

### --feedback--

Piensa en la sintaxis específica que Git usa para marcar el inicio, medio y fin de los conflictos.

---

`[[ current branch`, `|| separator`, `]] other branch`

### --feedback--

Piensa en la sintaxis específica que Git usa para marcar el inicio, medio y fin de los conflictos.

---

`<<<<<<< current branch`, `======= separator`, `>>>>>>> other branch`

---

`--- current branch`, `+++ separator`, `--- other branch`

### --feedback--

Piensa en la sintaxis específica que Git usa para marcar el inicio, medio y fin de los conflictos.

## --video-solution--

3

## --text--

Después de resolver manualmente un conflicto de fusión en tu repositorio local, ¿qué comandos necesitas ejecutar para completar la fusión?

## --answers--

`git push origin main` y `git rebase -i origin/main`

### --feedback--

Después de resolver los conflictos, necesitas preparar y confirmar los cambios resueltos como cualquier otro commit.

---

`git add` y `git commit`

---

`git merge --abort` y `git commit`

### --feedback--

Después de resolver los conflictos, necesitas preparar y confirmar los cambios resueltos como cualquier otro commit.

---

`git reset --hard` y `git push -f`

### --feedback--

Después de resolver los conflictos, necesitas preparar y confirmar los cambios resueltos igual que cualquier otro commit.

## --video-solution--

2

## --text--

¿Cuál es la diferencia principal entre merging y rebasing al manejar conflictos de branch?

## --answers--

La fusión crea un nuevo commit, mientras que el rebase reescribe el historial para colocar tus commits después de los commits de la otra rama.

---

Rebasing es más rápido que merging.

### --feedback--

Considera cómo cada operación afecta el historial de commits.

---

La fusión solo se puede hacer en GitHub, el rebase debe hacerse localmente.

### --feedback--

Considera cómo cada operación afecta el historial de commits.

---

No hay diferencia, es la misma operación.

### --feedback--

Considera cómo cada operación afecta el historial de commits.

## --video-solution--

1
