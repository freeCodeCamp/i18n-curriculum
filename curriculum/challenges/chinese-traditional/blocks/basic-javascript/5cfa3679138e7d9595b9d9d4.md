---
id: 5cfa3679138e7d9595b9d9d4
title: 使用遞迴取代迴圈
challengeType: 1
videoUrl: >-
  https://www.freecodecamp.org/news/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9/
forumTopicId: 301175
dashedName: replace-loops-using-recursion
---

# --description--

遞迴是指一個函式可以用自身來表示的概念。為了幫助理解這個概念，先從思考以下任務開始：將一個陣列的前 `n` 個元素相乘，以產生這些元素的乘積。使用 `for` 迴圈，你可以這樣做：

```js
  function multiply(arr, n) {
    let product = 1;
    for (let i = 0; i < n; i++) {
      product *= arr[i];
    }
    return product;
  }
```

但是，請注意 `multiply(arr, n) == multiply(arr, n - 1) * arr[n - 1]`。這表示你可以用 `multiply` 自己來重寫，而永遠不需要使用迴圈。

```js
  function multiply(arr, n) {
    if (n <= 0) {
      return 1;
    } else {
      return multiply(arr, n - 1) * arr[n - 1];
    }
  }
```

`multiply` 的遞迴版本分解如下。在 <dfn>基底案例</dfn> 中，當 `n <= 0` 時，它傳回 1。對於較大的 `n` 值，它會呼叫自己，但參數為 `n - 1`。該函式呼叫以相同方式被評估，持續呼叫 `multiply`，直到 `n <= 0`。此時，所有函式都能傳回，原始的 `multiply` 傳回答案。

**注意：**遞迴函式必須有一個基底情況，當它傳回而不再呼叫該函式時（在此範例中，當 `n <= 0`），否則它們永遠無法完成執行。

# --instructions--

撰寫一個遞迴函式（程式）`sum(arr, n)`，該函式（程式）傳回陣列 `arr` 中前 `n` 個元素的總和。

# --hints--

`sum([1], 0)` 應該相等 0。

```js
assert.equal(sum([1], 0), 0);
```

`sum([2, 3, 4], 1)` 應該相等 2。

```js
assert.equal(sum([2, 3, 4], 1), 2);
```

`sum([2, 3, 4, 5], 3)` 應該相等 9。

```js
assert.equal(sum([2, 3, 4, 5], 3), 9);
```

你的程式碼不應該依賴任何類型的迴圈（`for` 或 `while` 或更高階的函式（程式）例如 `forEach`、`map`、`filter` 或 `reduce`）。

```js
assert(
  !__helpers.removeJSComments(code).match(/for|while|forEach|map|filter|reduce/g)
);
```

你應該使用遞迴來解決這個問題。

```js
assert(
  sum.toString().match(/sum\(.*\)/g).length > 1
);
```

# --seed--

## --seed-contents--

```js
function sum(arr, n) {
  // Only change code below this line

  // Only change code above this line
}
```

# --solutions--

```js
function sum(arr, n) {
  // Only change code below this line
  if(n <= 0) {
    return 0;
  } else {
    return sum(arr, n - 1) + arr[n - 1];
  }
  // Only change code above this line
}
```
