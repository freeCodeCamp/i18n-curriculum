---
id: 69691ff777d428294168d47e
title: 什麼是分而治之，以及合併排序如何運作？
challengeType: 19
dashedName: what-is-divide-and-conquer-and-how-does-merge-sort-work
---

# --description--

計算機科學中的分治法範式是一種遞迴地將問題拆解成較小子問題的技術。這項技術的關鍵之一是遞迴，當函式反覆呼叫自己直到達到基準情況時即發生遞迴。在本課程中，我們將透過合併排序演算法來更好地理解分治法技術的運作方式。

假設我們有這個數字列表：

```md
42 37 53 17
```

目標是使用合併排序演算法將該列表從最小到最大排序。第一步是將該列表對半分割：

```md
42 37 | 53 17
```

然後我們需要查看列表的左側：

```md
42 37
```

我們將該子列表再次對半分割，直到每個子列表中只剩下一個項目：

```md
42 | 37
```

只有一個條款的列表預設會被排序。接下來我們需要將每個只有一個元素的子列表合併成一個排序好的列表：

```md
37 42
```

然後我們對原始列表的右側執行相同的處理程序。

```javascript
// right side of original list
53 17

// divide the list in half
53 | 17

// merge the lists in sorted order
17 53
```

現在原始列表的兩個半部都已排序，我們將這兩個半部合併並排序元素：

```markdown
17 37 42 53
```

以下是演算法在程式碼中的樣子：

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }

    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));

    const sorted = [];
    let i = 0;
    let j = 0;

    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            sorted.push(left[i]);
            i += 1;
        } else {
            sorted.push(right[j]);
            j += 1;
        }
    }

    return sorted.concat(left.slice(i)).concat(right.slice(j));
}
```

合併排序的時間複雜度為 `O(n log n)`，因為列表會持續被對半切割（`log n`），然後再合併在一起（`O(n)`）。與其他排序演算法如泡沫排序不同，合併排序不是就地排序，且具有 `O(n)` 的空間複雜度。

# --questions--

## --text--

在計算機科學中，什麼是分治法範式？

## --answers--

一種只使用兩個迭代器來偵測函式（程式）值迭代中循環的技術。

### --feedback--

檢視課程的開始部分。

---

一個用於比較兩個元素並在需要時從最小到最大交換它們的演算法。

### --feedback--

檢視課程的開始部分。

---

一種將問題遞迴拆解成較小子問題的技術。

---

一個用於計算平面上點的最短連接網路的演算法。

### --feedback--

檢視課程的開始部分。

## --video-solution--

3

## --text--

合併排序演算法的時間複雜度是多少？

## --answers--

`O(n log n)`

---

`O(log n²)`

### --feedback--

檢視課程結尾。

---

`O(n³ log n)`

### --feedback--

檢視課程結尾。

---

`O(log n³)`

### --feedback--

檢視課程結尾。

## --video-solution--

1

## --text--

合併排序演算法的空間複雜度是多少？

## --answers--

`O(n²)`

### --feedback--

檢視課程結尾。

---

`O(1)`

### --feedback--

檢視課程結尾。

---

`O(n log n)`

### --feedback--

檢視課程結尾。

---

`O(n)`

## --video-solution--

4
