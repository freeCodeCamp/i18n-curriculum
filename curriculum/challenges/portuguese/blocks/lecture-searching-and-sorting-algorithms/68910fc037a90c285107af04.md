---
id: 68910fc037a90c285107af04
title: O que é Divide and Conquer e como o Merge Sort funciona?
challengeType: 19
dashedName: what-is-divide-and-conquer-and-how-does-merge-sort-work
---

# --description--

O paradigma divide e conquista em ciência da computação é uma técnica para dividir recursivamente problemas em subproblemas menores. Um dos aspectos principais dessa técnica é a recursão, que acontece quando uma função chama a si mesma repetidamente até que um caso base seja alcançado. Nesta lição, vamos analisar o algoritmo merge sort para entender melhor como a técnica divide e conquista funciona.

Vamos supor que temos esta lista de números:

```md
42 37 53 17
```

O objetivo é ordenar essa lista do menor para o maior usando o algoritmo `merge sort`. O primeiro passo é dividir essa lista ao meio:

```md
42 37 | 53 17
```

Então precisamos olhar para o lado esquerdo da lista:

```md
42 37
```

Pegamos essa sublista e dividimos ao meio novamente até que cada sublista tenha apenas um item:

```md
42 | 37
```

Uma lista com apenas um item é ordenada por padrão. Em seguida, precisamos mesclar cada uma dessas sublistas de um elemento em uma lista ordenada:

```md
37 42
```

Então seguimos o mesmo processo para o lado direito da lista original:

```py
# right side of original list
53 17

# divide the list in half
53 | 17

# merge the lists in sorted order
17 53
```

Agora que ambas as metades da lista original estão ordenadas, nós unimos essas duas metades e ordenamos os elementos:

```markdown
17 37 42 53
```

Aqui está como o algoritmo se parece em código:

```py
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    sorted_list = []
    i = 0
    j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            sorted_list.append(left[i])
            i += 1
        else:
            sorted_list.append(right[j])
            j += 1

    sorted_list.extend(left[i:])
    sorted_list.extend(right[j:])

    return sorted_list
```

A complexidade de tempo para merge sort seria `O(n log n)` porque a lista é continuamente dividida ao meio (`log n`) e depois mesclada (`O(n)`). Ao contrário de outros algoritmos de ordenação como bubble sort, merge sort não é ordenado in place e tem uma complexidade de espaço de `O(n)`.

# --questions--

## --text--

O que é o paradigma divide and conquer em ciência da computação?

## --answers--

Uma técnica para detectar um ciclo em iterações de valor de função usando apenas dois iteradores.

### --feedback--

Revise o início da lição.

---

Um algoritmo para comparar dois elementos e trocá-los do menor para o maior se necessário.

### --feedback--

Revise o início da lição.

---

Uma técnica para dividir recursivamente problemas em subproblemas menores.

---

Um algoritmo para calcular a rede de conexão mais curta para pontos em um plano.

### --feedback--

Revise o início da lição.

## --video-solution--

3

## --text--

Qual é a complexidade de tempo para o algoritmo `merge sort`?

## --answers--

`O(n log n)`

---

`O(log n²)`

### --feedback--

Revise o final da lição.

---

`O(n³ log n)`

### --feedback--

Revise o final da lição.

---

`O(log n³)`

### --feedback--

Revise o final da lição.

## --video-solution--

1

## --text--

Qual é a complexidade de espaço para o algoritmo `merge sort`?

## --answers--

`O(n²)`

### --feedback--

Revise o final da lição.

---

`O(1)`

### --feedback--

Revise o final da lição.

---

`O(n log n)`

### --feedback--

Revise o final da lição.

---

`O(n)`

## --video-solution--

4
