---
id: 67f39e2119042d2f2ca926ff
title: 动态编程回顾
challengeType: 31
dashedName: review-dynamic-programming
---

# --description--

## 动态规划简介

- **定义**：动态规划是一种算法技术，通过将复杂问题分解为更简单的子问题并存储结果以避免重复计算来解决问题。
- **重叠子问题**：在解决较大问题时，相同的较小问题会多次出现。我们不是反复重新计算这些子问题，而是将它们的 `solution` 保存起来。
- **最优子结构**：问题的最优 `solution` 包含其子问题的最优 `solution`。这意味着我们可以通过组合较小部分的最优 `solution` 来构建最佳 `solution`。

## 动态编程方案

- **记忆化（自顶向下方法）**：记忆化保存昂贵函数调用的结果，当相同的 `input` 再次出现时返回缓存的结果。

```py
def climb_stairs_memo(n, memo={}):
    """Dynamic programming with memoization"""
    # Check if we've already calculated this value
    if n in memo:
        return memo[n]  # Return cached result - O(1) lookup!
    
    # Base cases
    if n <= 2:
        return n
    
    # Calculate once and store in memo for future use
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    return memo[n]
```

- **自底向上法（Tabulation）**：Tabulation 从底层构建方案，通过填充一个表格来解决子问题。

```py
def climb_stairs_tabulation(n):
    """Dynamic programming with tabulation"""
    if n <= 2:
        return n
    
    # Create array to store results for all steps from 0 to n
    dp = [0] * (n + 1)
    dp[1] = 1  # 1 way to reach step 1
    dp[2] = 2  # 2 ways to reach step 2
    
    # Build up the solution iteratively
    for i in range(3, n + 1):
        # Ways to reach step i = ways to reach (i-1) + ways to reach (i-2)
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

## 使用动态编程的现实世界应用

- **路径优化**：GPS 系统使用动态编程算法来查找位置之间的最短路径。
- **文本处理**：拼写检查器和自动完成功能通常依赖动态编程来计算单词之间的编辑距离。
- **金融模型**：投资策略和投资组合优化经常采用动态编程技术。
- **资源分配**：背包问题及其变体出现在调度、预算和资源管理中。

## 何时使用动态规划

你应该考虑在以下场景中使用动态编程：

- 该问题可以分解为重叠子问题。
- 该问题表现出最优子结构。
- 一个简单的递归的方案将涉及重复计算。
- 你需要以空间复杂度为代价优化时间复杂度。

# --assignment--

复习动态编程主题和概念。
