---
id: 66f1ad049d7a6ac0886cc2ba
title: React 表單、資料擷取與路由測驗
challengeType: 8
dashedName: quiz-react-forms-data-fetching-and-routing
---

# --description--

要通過測驗，你必須在以下 20 題中正確回答至少 18 題。

# --quizzes--

## --quiz--

### --question--

#### --text--

以下哪一項是受控輸入的範例？

#### --distractors--

```jsx
<input id="name" type="text" />
```

---

```jsx
<input id="name" onChange={handleChange} type="text" />
```

---

```jsx
<input value="" id="name" type="text" />
```

#### --answer--

```jsx
<input value={name} id="name" onChange={handleChange} type="text" />
```

### --question--

#### --text--

以下哪一項是不受控制的輸入範例？

#### --distractors--

```jsx
<input type="text" references={nameRef} id="name" />
```

---

```jsx
<input type="text" refs={nameRef} id="name" />
```

---

```jsx
<input type="text" reference={nameRef} id="name" />
```

#### --answer--

```jsx
<input type="text" ref={nameRef} id="name" />
```

### --question--

#### --text--

以下哪一項不是在 React 中常用的取得資料方式？

#### --distractors--

SWR

---

Axios

---

Fetch API

#### --answer--

Redux

### --question--

#### --text--

以下哪一個掛鉤通常與在 React 中擷取資料相關？

#### --distractors--

`useParams`

---

`useContext`

---

`useReducer`

#### --answer--

`useEffect`

### --question--

#### --text--

什麼是記憶化？

#### --distractors--

一種常用於尋找圖中兩個頂點之間最短路徑的演算法。

---

一種用於最佳化所有受控和非受控輸入效率的特殊技術。

---

一種分治演算法，用於遞迴排序子陣列並將它們合併在一起。

#### --answer--

一種優化技術，根據特定引數將昂貴函式（程式）呼叫的結果快取（記憶）起來。

### --question--

#### --text--

以下哪一個掛鉤用於記憶計算出的值？

#### --distractors--

`useParams`

---

`useEffect`

---

`useState`

#### --answer--

`useMemo`

### --question--

#### --text--

以下哪一項使用正確的掛鉤來記憶函式的引用？

#### --distractors--

```js
useContext(() => {
 // code goes here
}, [dependency]);
``` 

---

```js
useParams(() => {
 // code goes here
}, [dependency]);
``` 

---

```js
useState(() => {
 // code goes here
}, [dependency]);
``` 

#### --answer--

```js
useCallback(() => {
 // code goes here
}, [dependency]);
``` 

### --question--

#### --text--

什麼是相依性？

#### --distractors--

相依性是在 React 應用程式中常用的測試函式庫。

---

相依性是一種只在伺服端執行的 React 組件型別。

---

相依性是在 React 應用程式中用來將 React 程式碼編譯成 JavaScript 的特殊編譯器。 

#### --answer--

相依性是指應用程式中的一個組件或模組依賴另一個組件或模組才能正常運作。

### --question--

#### --text--

什麼是軟體包管理工具？

#### --distractors--

一個用於更新應用程式中安裝的第三方軟體包的工具。

---

一個用於管理僅在專案內創建的軟體包的工具。

---

一個用於將相依性從 `node_modules` 資料夾移出並放入特殊設定資料夾的工具。

#### --answer--

一個用於安裝、更新和移除相依性的工具。

### --question--

#### --text--

以下哪一項不是 JavaScript 生態系中常用的軟體包管理工具？

#### --distractors--

pnpm

---

Yarn

---

npm

#### --answer--

Jest

### --question--

#### --text--

以下哪一個是包含你專案詮釋資料的主要設定檔案？

#### --distractors--

`config.json`

---

`lint.json`

---

`node_modules.json`

#### --answer--

`package.json`

### --question--

#### --text--

以下哪一個是常用的 React 框架？

#### --distractors--

Django

---

Webpack

---

Gulp

#### --answer--

混音

### --question--

#### --text--

以下哪一種方式是使用 React Router 為你的 React 應用程式添加路由的正確方法？

#### --distractors--

```jsx
<StrictMode>
  <AddRouter>
    <Routes>
      <Route path="/" element={<App />} />
    </Routes>
  </AddRouter>
</StrictMode>
```

---

```jsx
<StrictMode>
  <ContextRouter>
    <Routes>
      <Route path="/" element={<App />} />
    </Routes>
  </ContextRouter>
</StrictMode>
```

---

```jsx
<StrictMode>
  <SetRoute>
    <Routes>
      <Route path="/" element={<App />} />
    </Routes>
  </SetRoute>
</StrictMode>
```

#### --answer--

```jsx
<StrictMode>
  <BrowserRouter>
    <Routes>
      <Route path="/" element={<App />} />
    </Routes>
  </BrowserRouter>
</StrictMode>
```

### --question--

#### --text--

以下哪一種方式是在 React Router 中創建動態路由的正確方法？

#### --distractors--

```jsx
<Route path="?category" element={<Category />} />
```

---

```jsx
<Route path="<category" element={<Category />} />
```

---

```jsx
<Route path="/category" element={<Category />} />
```

#### --answer--

```jsx
<Route path=":category" element={<Category />} />
```

### --question--

#### --text--

以下哪一個掛鉤用於存取 URL 路徑中的動態參數？

#### --distractors--

`useParameterized`

---

`usePar`

---

`useParameters`

#### --answer--

`useParams`

### --question--

#### --text--

以下哪一項是在 Next.js 中創建訂製請求處理常式的正確方法？

#### --distractors--

```js
export async function SERVE() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

---

```js
export async function FETCH() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

---

```js
export async function SET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

#### --answer--

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

### --question--

#### --text--

什麼是 prop drilling？

#### --distractors--

建立一個 reducer 的處理程序，指定狀態應如何根據特定的 props 變更。

---

將 props 從子組件傳遞到父組件的處理程序。 

---

為 React 應用程式建立背景關係提供者的處理程序，並使用該提供者將 props 從父組件傳送到子組件。

#### --answer--

從父組件傳遞 props 到深層巢狀子組件的處理程序，即使某些子組件不需要這些 props。

### --question--

#### --text--

以下哪一項不是 React 應用程式中常用的狀態管理解決方案？

#### --distractors--

Context API

---

Zustand

---

Redux

#### --answer--

春季

### --question--

#### --text--

React 開發者工具是用來做什麼的？

#### --distractors--

這些工具僅用於檢查 React 應用程式中的存取性問題。

---

這些工具用於為 React 組件添加額外的測試。

---

這些工具用於對應用程式內所有 React 組件進行記憶化。

#### --answer--

這些工具用於檢查 React 組件並識別效率、性能問題。

### --question--

#### --text--

什麼是 React 伺服器組件？

#### --distractors--

這些是專門在伺服端管理背景關係的組件。

---

這些是只在伺服端呈現的記憶化組件。

---

這些是專門在伺服端管理狀態的組件。

#### --answer--

這些是僅在伺服端呈現的組件。

