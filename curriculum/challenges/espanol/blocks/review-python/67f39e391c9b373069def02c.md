---
id: 67f39e391c9b373069def02c
title: Revisión de Python
challengeType: 31
dashedName: review-python
---

# --description--

## ¿Qué es Python?

- **Introducción**: Python es un lenguaje de programación de propósito general conocido por su simplicidad y facilidad de uso. Python se usa en muchos campos como la ciencia de datos y el aprendizaje automático, desarrollo web, secuencias de comandos y automatización, sistemas embebidos e IoT, y mucho más.
- **Casos de Uso Comunes**: Python se usa en la ciencia de datos, el aprendizaje automático, el desarrollo web, la ciberseguridad, la automatización y microcomputadores como las placas Raspberry Pi y compatibles con MicroPython.

## Python en tu Entorno Local

- **Instalación**: La mejor manera de instalar Python en Windows, Mac y Linux es descargar el instalador desde el sitio web oficial de Python (`https://www.python.org/`).

## Variables

- **Declaring Variables**: To declare a variable, you start with the variable name followed by the assignment operator (`=`) and then the value. Esto puede ser un número, cadena, booleano, etc. Aquí hay algunos ejemplos:

```py
name = 'John Doe'
age = 25
```

- **Convenciones para Nombrar Variables**: Aquí están las convenciones de nombres que debes usar para variables:

  - Los nombres de las variables sólo pueden comenzar con una letra o un guion bajo (_) y no un número.
  - Los nombres de las variables sólo pueden contener caracteres alfanuméricos (a-z, A-Z, 0-9) y guiones bajos (_).
  - Los nombres de las variables son sensibles a mayúsculas — `edad`, `Edad`, y `EDAD` se consideran únicos.
  - Los nombres de las variables no pueden ser una de las palabras clave reservadas de Python como `if`, `class` o `def`.
  - Los nombres de variables con múltiples palabras están separados por guiones bajos. Ej. `snake_case`.


## Comentarios

- **Comentarios de Línea Única**: Este tipo de comentarios debe utilizarse para notas cortas que desees dejar en tu código.

```py
# This is a single line comment
```

- **Cadenas multilínea**: Este tipo de cadenas se pueden usar para dejar notas más extensas o para comentar secciones de código.

```py
"""
This is a multi-line string.
Here is some code commented out.

name = 'John Doe'
age = 25
"""
```

- **Función `print()`**: Para imprimir datos en la consola, puedes usar la función `print()` de esta manera:

```py
print('Hello world!') # Hello world!
```

## Tipos Comunes de Datos en Python

- **Introducción**: Python es un lenguaje de tipado dinámico como JavaScript, lo que significa que no necesitas declarar explícitamente los tipos para las variables. El lenguaje sabe cuál es el tipo de una variable según lo que asignes a la variable.
- **Entero**: Un número entero sin decimales:

```py
my_integer_var = 10
print('Integer:', my_integer_var) # Integer: 10
```

- **Flotante**: Un número con decimales:

```py
my_float_var = 4.50
print('Float:', my_float_var) # Float: 4.5
```

- **Cadena**: Una secuencia de caracteres envuelta entre comillas:

```py
my_string_var = 'hello'
print('String:', my_string_var) # String: hello
```

- **Booleano**: Un valor que representa `True` o `False`:

```py
my_boolean_var = True
print('Boolean:', my_boolean_var) # Boolean: True
```

- **Conjunto**: Una colección desordenada de elementos únicos:

```py
my_set_var = {7, 5, 8}
print('Set:', my_set_var) # Set: {7, 5, 8}
```

- **Diccionario**: Una colección de pares clave-valor encerrados entre llaves:

```py
my_dictionary_var = {"name": "Alice", "age": 25}
print('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}
```

- **Tupla**: Una colección ordenada e inmutable, rodeada por paréntesis:

```py
my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)
```

- **Rango**: Una secuencia de números, que se usa a menudo en bucles:

```py
my_range_var = range(5)
print(my_range_var) # range(0, 5)
```

- **Lista**: Una colección ordenada de elementos que admite diferentes tipos de datos:

```py
my_list = [22, 'Hello world', 3.14, True]
print(my_list) # [22, 'Hello world', 3.14, True]
```

- **Ninguno**: Un valor especial que representa la ausencia de valor:

```py
my_none_var = None
print('None:', my_none_var) # None: None
```

## Tipos Inmutables y Mutables

- **Tipos Inmutables**: Estos tipos no pueden cambiar una vez declarados, aunque se puede redirigir sus variables a algo nuevo, lo que se llama reasignación. Incluyen entero, flotante, complejo, booleano, cadena, tupla, rango y `Ninguno`.
- **Tipos Mutables**: Estos tipos pueden cambiar una vez declarados. Puedes agregar, eliminar o actualizar sus elementos. Incluyen tipos de colección como listas, conjuntos y diccionarios.
- **Función `type()`**: Para ver el tipo de una variable, puedes usar la función `type()` de esta manera:

```py
greeting = 'Hello there!'
age = 21

print(type(greeting)) # <class 'str'>
print(type(age)) # <class 'int'>
```

- **Función `isinstance()`**: Se usa para verificar si una variable coincide con un tipo de dato específico:

```py
print(isinstance('Hello world', str)) # True
print(isinstance('John Doe', int)) # False
```

## Trabajando con Cadenas de Caracteres

- **Definición**: Como recuerdas de JavaScript, las cadenas son inmutables, lo que significa que no puedes cambiarlas después de que han sido creadas. En Python, puedes usar comillas simples o dobles. Se recomienda elegir una regla y mantenerla:

```py
developer = 'Jessica'
city = 'Los Angeles'
```

- **Accediendo a Caracteres de Cadenas**: Puedes acceder a caracteres de cadenas utilizando la notación de corchetes de esta manera:

```py
my_str = "Hello world"

print(my_str[0])  # H
print(my_str[6])  # w

print(my_str[-1])  # d
print(my_str[-2]) # l
```

- **Escape de Cadenas**: Puedes usar una barra invertida (`\`) si tu cadena contiene comillas de esta manera:

```py
msg = 'It\'s a sunny day'
quote = "She said, \"Hello!\""
```

- **Concatenación de Cadenas**: Para concatenar cadenas, puedes usar el operador `+` de esta manera:

```py
developer = 'Jessica'
print('My name is ' + developer + '.') # My name is Jessica.
```

Otra forma de concatenar cadenas es usando el operador `+=`. Esto se usa para realizar la concatenación y la asignación en el mismo paso de esta manera:

```py
greeting = 'My name is '
developer = 'Jessica.'

greeting += developer
print(greeting) # My name is Jessica.
```

- **`f-strings`**: Esta es una abreviatura para cadenas de formato literal. Te permite manejar la interpolación y también realizar cierta concatenación con una sintaxis compacta y legible:

```py
developer = 'Jessica'
greeting = f'My name is {developer}.'
print(greeting) # My name is Jessica.
```

- **Segmentación de Cadenas**: Esto ocurre cuando puedes extraer partes de una cadena. Esta es la sintáxis básica:

```py
str[start:stop:step]
```

La posición de inicio representa el índice donde debe comenzar la extracción. La posición de parada es donde debe terminar el segmento. Esta posición no es inclusiva. La posición de paso representa el intervalo para el incremento en la segmentación. Aquí hay algunos ejemplos:

```py
message = 'Python is fun!'

print(message[0:6])  # Python
print(message[7:])  # is fun!
print(message[::2])  # Pto sfn
```

- **Obtener la Longitud de una Cadena**: La función `len()` se usa para devolver el número de caracteres en la cadena:

```py
developer = 'Jessica'

print(len(developer)) # 7
```

## Trabajando con el Operador `in`

- **Operador `in`**: Esto devuelve un booleano que especifica si el carácter o los caracteres existen en la cadena o no:

```py
my_str = 'Hello world'

print('Hello' in my_str)  # True
print('hey' in my_str)    # False
print('hi' in my_str)    # False
print('e' in my_str)  # True
print('f' in my_str)  # False
```

## Métodos Comunes de Cadenas

- **`str.upper()`**: Esto devuelve una nueva cadena con todos los caracteres convertidos a mayúsculas:

```py
developer = 'Jessica'

print(developer.upper()) # JESSICA
```

- **`str.lower()`**: Esto devuelve una nueva cadena con todos los caracteres convertidos a minúsculas:

```py
developer = 'Jessica'

print(developer.lower()) # jessica
```

- **`str.strip()`**: Esto devuelve una copia de la cadena con los caracteres especificados al inicio y al final eliminados (si no se pasa un argumento al método, elimina los espacios en blanco al inicio y al final).

```py
greeting = '  hello world  '

trimmed_my_str = greeting.strip()
print(trimmed_my_str)  # 'hello world'
```

- **`replace()`**: Esto devuelve una nueva cadena con todas las ocurrencias de la cadena antigua reemplazadas por una nueva.

```py
greeting = 'hello world'

replaced_my_str = greeting.replace('hello', 'hi')
print(replaced_my_str)  # 'hi world'
```

- **`split()`**: Esto se usa para dividir una cadena en una lista usando un separador especificado. Un separador es una cadena que indica dónde debe ocurrir la división.

```py
dashed_name = 'example-dashed-name'

split_words = dashed_name.split('-')
print(split_words)  # ['example', 'dashed', 'name']
```

- **`join()`**: Esto se usa para unir elementos de un iterable en una cadena con un separador. Un iterable es una colección de elementos que se pueden recorrer como una lista, cadena o una tupla.

```py
example_list = ['example', 'dashed', 'name']

joined_str = ' '.join(example_list)
print(joined_str)  # example dashed name
```

- **`str.startswith(prefix)`**: Esto devuelve un booleano que indica si una cadena comienza con el prefijo especificado:

```py
developer = 'Naomi'

result = developer.startswith('N')
print(result)  # True
```

- **`str.endswith(suffix)`**: Esto devuelve un booleano que indica si una cadena termina con el sufijo especificado:

```py
developer = 'Naomi'

result = developer.endswith('N')
print(result)  # False
```

- **`str.find()`**: Esto devuelve el índice de la primera aparición de una subcadena. Si no se encuentra, se devolverá `-1`:

```py
developer = 'Naomi'

result = developer.find('N')
print(result)  # 0

city = 'Los Angeles'
print(city.find('New')) # -1
```

- **`str.count(substring)`**: Esto cuenta cuántas veces aparece una subcadena en una cadena:

```py
city = 'Los Angeles'
print(city.count('e')) # 2
```

- **`str.capitalize()`**: Esto devuelve una nueva cadena con el primer carácter en mayúscula y los demás en minúsculas:

```py
dessert = 'chocolate cake'
print(dessert.capitalize()) # Chocolate cake
```

- **`str.isupper()`**: Esto devuelve `True` si todas las letras en la cadena están en mayúsculas y `False` si no:

```py
dessert = 'chocolate cake'
print(dessert.isupper()) # False
```

- **`str.islower()`**: Esto devuelve `True` si todas las letras en la cadena están en minúsculas y `False` de lo contrario:

```py
dessert = 'chocolate cake'
print(dessert.islower()) # True
```

- **`str.title()`**: Esto devuelve una nueva cadena con la primera letra de cada palabra en mayúscula:

```py
city = 'los angeles'
print(city.title()) # Los Angeles
```

- **`str.maketrans()`**: Este método se usa para crear una tabla de mapeo de caracteres de uno a uno para la traducción. A menudo se usa con el método `translate()` que aplica esa tabla a una cadena y devuelve el resultado traducido.

```py
trans_table = str.maketrans('abc', '123')
print(trans_table) # {97: 49, 98: 50, 99: 51}

result = 'abcabc'.translate(trans_table)
print(result)  # 123123
```

## Operaciones Comunes usadas con Enteros y Flotantes

- **Operaciones Matemáticas Básicas**: En Python, puedes realizar operaciones matemáticas básicas con enteros y flotantes, incluyendo suma, resta, multiplicación y división:

```py
int_1 = 56
int_2 = 12
float_1 = 5.4
float_2 = 12.0

# Addition

print('Integer Addition:', int_1 + int_2) # Integer Addition: 68
print('Float Addition:', float_1 + float_2) # Float Addition: 17.4

# Subtraction

print('Int Subtraction:', int_1 - int_2) # Int Subtraction: 44
print('Float Subtraction:',  float_2 - float_1) # Float Subtraction: 6.6

# Multiplication

print('Int Multiplication:', int_1 * int_2) # Int Multiplication: 672
print('Float Multiplication:', float_2 * float_1) # Float Multiplication: 64.80000000000001

# Division

print('Int Division:', int_1 / int_2) # Int Division: 4.666666666666667
print('Float Division:', float_2 / float_1) # Float Division: 2.222222222222222
```

Cuando sumas un flotante y un entero, el resultado se convierte en un flotante de esta manera:

```py
int_1 = 56
float_1 = 5.4

print(int_1 + float_1) # 61.4
```

- **Operador de Módulo (`%`)**: Esto devuelve el residuo cuando un número es dividido por otro número:

```py
int_1 = 56
int_2 = 12

print(int_1 % int_2) # 8
```

- **División de Piso (`//`)**: Este operador se usa para dividir dos números y redondear el resultado hacia abajo al número entero más cercano:

```py
int_1 = 56
int_2 = 12

print(int_1 // int_2) # 4
```

- **Operador de Exponenciación (`**`)**: Este operador se usa para elevar un número a la potencia de otro:

```py
int_1 = 4
int_2 = 2

print(int_1 ** int_2) # 16
```

- **Función `float()`**: Puedes usar esta función para convertir un entero a flotante.

```py
num = 4

print(float(num)) # 4.0
```

- **Función `int()`**: Puedes usar esta función para convertir un flotante a un entero.

```py
num = 4.0

print(int(num)) # 4
```

- **Función `round()`**: Esto se utiliza para redondear un número al entero más cercano:

```py
num_1 = 3.4
num_2 = 7.7

print(round(num_1)) # 3
print(round(num_2)) # 8
```

- **Función `abs()`**: Esto se usa para devolver el valor absoluto de un número:

```py
num = -13

print(abs(num)) # 13
```

- **Función `bin()`**: Esto se usa para convertir un entero a su representación binaria como una cadena:

```py
num = 56

print(bin(num))  # 0b111000
```

- **Función `oct()`**: Esto se usa para convertir un entero a su representación octal como una cadena:

```py
num = 56

print(oct(num))  # 0o70
```

- **Función `hex()`**: Esto se usa para convertir un entero a su representación hexadecimal como una cadena:

```py
num = 56

print(hex(num))  # 0x38
```

- **Función `pow()`**: Esto se utiliza para elevar un número a la potencia de otro:

```py
result = pow(2, 3) 
print(result)  # 8
```

## Asignaciones Aumentadas

- **Definición**: La asignación aumentada combina una operación binaria con una asignación en un solo paso. Toma una variable, le aplica una operación con otro valor y almacena el resultado nuevamente en la misma variable.

```py
# Addition assignment 
my_var = 10
my_var += 5

print(my_var) # 15

# Subtraction assignment
count = 14
count -= 3

print(count) # 11

# Multiplication assignment 
product = 65
product *= 7

print(product) # 455

# Division assignment 
price = 100
price /= 4

print(price) # 25.0

# Floor Division assignment 
total_pages = 23
total_pages //= 5

print(total_pages) # 4

# Modulus assignment 
bits = 35
bits %= 2

print(bits) # 1

# Exponentiation assignment 
power = 2
power **= 3

print(power) # 8
```

También hay otros operadores de asignación aumentada, como los de operadores bit a bit. Incluyen `&=`, `^=`, `>>=`, y `<<=`.

## Trabajando con Funciones

- **Definición**: Las funciones son piezas reutilizables de código que toman entradas (argumentos) y devuelven una salida. Para llamar a una función, necesitas hacer referencia al nombre de la función seguido de un conjunto de paréntesis:

```py
# Defining a function

def get_sum(num_1, num_2):
    return num_1 + num_2

result = get_sum(3, 4) # function call
print(result) # 7
```

Si una función no devuelve un valor explícitamente, entonces el valor de retorno predeterminado es `Ninguno`:

```py
def greet():
    print('hello') 

result = greet() # hello
print(result) # None
```

También puedes suministrar valores predeterminados a los parámetros de esta manera:

```py
def get_sum(num_1, num_2=2):
    return num_1 + num_2

result = get_sum(3) 
print(result) # 5
```

Si llamas a la función sin el número correcto de argumentos, recibirás un `TypeError`:

```py
def calculate_sum(a, b):
    print(a + b)

calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'
```

## Funciones Integradas Comunes

- **Función `input()`**: Esto se utiliza para pedir al usuario una entrada:

```py
name = input('What is your name?') # User types 'Kolade' and presses Enter  
print('Hello', name) # Hello Kolade
```

- **Función `int()`**: Esto se utiliza para convertir un número, un booleano o una cadena numérica en un entero:

```py
print(int(3.14)) # 3
print(int('42')) # 42
print(int(True)) # 1
print(int(False)) # 0 
```

## Alcance en Python

- **Ámbito Local**: Esto sucede cuando una variable declarada dentro de una función o clase solo puede accederse dentro de esa función o clase.

```py
def my_func():
    num = 10
    print(num)
```

- **Ámbito Envolvente**: Esto sucede cuando una función que está anidada dentro de otra función puede acceder a las variables de la función en la que está anidada.

```py
def outer_func():
    msg = 'Hello there!'
    
    def inner_func():
        print(msg)
    inner_func()

print(outer_func()) # Hello there!
```

- **Ámbito Global**: Esto se refiere a variables que están declaradas fuera de cualquier función o clase, que pueden accederse desde cualquier lugar en el programa.

```py
tax = 0.70 

def get_total(subtotal):
    total = subtotal + (subtotal * tax)
    return total

print(get_total(100))  # 170.0
```

- **Ámbito Incorporado**: Nombres reservados en Python para funciones, módulos, palabras clave y objetos predefinidos.

```py
print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False
```

## Operadores de Comparación

- **Igual (`==`)**: Comprueba si dos valores son iguales:

```py
print(3 == 4) # False
```

- **No igual (`!=`)**: Comprueba si dos valores no son iguales:

```py
print(3 != 4) # True
```

- **Estricto mayor que (`>`)**: Verifica si un valor es mayor que otro:

```py
print(3 > 4) # False
```

- **Estrictamente menor que (`<`)**: Verifica si un valor es menor que otro:

```py
print(3 < 4) # True
```

- **Mayor o igual que (`>=`)**: Verifica si un valor es mayor o igual que otro:

```py
print(3 >= 4) # False
```

- **Menor o igual(`<=`)**: Verifica si un valor es menor o igual que otro:

```py
print(3 <= 4) # True
```

## Trabajando con instrucciones `if`, `elif` y `else`

- **Instrucciones `if`**: Estas son condiciones utilizadas para determinar si algo es verdadero o no. Si la condición evalúa a `True`, entonces ese bloque de código se ejecutará.

```py
age = 18

if age >= 18:
    print('You are an adult') # You are an adult
```

- **Sentencia `elif`**: Estas son condiciones que vienen después de una instrucción `if`. Si la condición `elif` se evalúa como `True`, entonces se ejecutará ese bloque de código.

```py
age = 16

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')  # You are a teenager
```

- **Cláusula `else`**: Esto se ejecutará si ninguna otra condición se evalúa como `True`.

```py
age = 12

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')
else:
    print('You are a child')  # You are a child
```

También puedes usar sentencias `if` anidadas de esta manera:

```py
is_citizen = True
age = 25

if is_citizen:
    if age >= 18:
        print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

## Valores 'Verdaderos' y 'Falsos'

- **Definición**: En Python, cada valor tiene un valor booleano inherente o un sentido incorporado de si debe tratarse como `True` o `False` en un contexto lógico. Muchos valores se consideran verdaderos, es decir, se evalúan como `True` en un contexto lógico. Otros son falsos, lo que significa que se evalúan como `False`. Aquí hay algunos ejemplos de valores falsos:

```md
None
False
Integer 0
Float 0.0
Empty strings ''
```

Otros valores como números distintos de cero y cadenas no vacías son verdaderos.

## Trabajando con la función `bool()`

- **Definición**: Si deseas comprobar si un valor es verdadero o falso, puedes usar la función `bool()` incorporada. Esta convierte explícitamente un valor a su equivalente booleano y devuelve `True` para valores truthy y `False` para valores falsy. Aquí hay algunos ejemplos:

```py
print(bool(False)) # False
print(bool(0))  # False
print(bool('')) # False

print(bool(True)) # True
print(bool(1)) # True
print(bool('Hello')) # True
```

## Operadores Booleanos y Cortocircuito

- **Definición**: Estos son operadores especiales que te permiten combinar múltiples expresiones para crear una lógica de toma de decisiones más compleja en tu código. Hay tres operadores booleanos en Python: `and`, `or` y `not`.
- **`and` Operador**: Este operador toma dos operandos y devuelve el primer operando si es falso, de lo contrario, devuelve el segundo operando. Ambos operandos deben ser truthy para que una expresión resulte en un valor truthy.

```py
is_citizen = True
age = 25

print(is_citizen and age) # 25
```

También puedes usar el operador `and` en condicionales así:

```py
is_citizen = True
age = 25

if is_citizen and age >= 18:
    print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

- **`or` Operador**: Este operador devuelve el primer operando si es verdadero, de lo contrario, devuelve el segundo operando. Una expresión or resulta en un valor verdadero si al menos un operando es verdadero. Aquí hay un ejemplo:

```py
age = 19
is_employed = False

print(age or is_employed) # 19
```

Al igual que con el operador `and`, puedes usar el operador `or` en condicionales así:

```py
age = 19
is_student = True

if age < 18 or is_student:
    print('You are eligible for a student discount') # You are eligible for a student discount
else:
    print('You are not eligible for a student discount')
```

- **Cortocircuito**: Los operadores `and` y `or` se conocen como operadores de cortocircuito. El cortocircuito significa que Python verifica los valores de izquierda a derecha y se detiene tan pronto como determina el resultado final.
- **`not` Operador**: Este operador toma un solo operando e invierte su valor booleano. Convierte valores truthy en `False` y valores falsy en `True`. A diferencia de los operadores anteriores que vimos, `not` siempre devuelve `True` o `False`. Aquí hay algunos ejemplos:

```py
print(not '') # True, because empty string is falsy
print(not 'Hello') # False, because non-empty string is truthy
print(not 0) # True, because 0 is falsy
print(not 1) # False, because 1 is truthy
print(not False) # True, because False is falsy
print(not True) # False, because True is truthy
```

Aquí hay un ejemplo del operador `not` en un condicional: 

```py
is_admin = False

if not is_admin:
    print('Access denied for non-administrators.') # Access denied for non-administrators.
else:
    print('Welcome, Administrator!')
```


## Listas en Python

- **Introducción**: En Python, el tipo de dato lista es una secuencia ordenada de elementos que pueden ser compuestos de cadenas, números o incluso otras listas. Las listas son mutables y tienen índice basado en cero.

```python
cities = ['Los Angeles', 'London', 'Tokyo']
```

- **Acceder a Elementos de una Lista**: Para acceder a un elemento de la lista `cities`, puede referenciar su número de índice en la secuencia:

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[0] # Los Angeles
```

- **Acceder a Elementos Usando Indexación Negativa**: Para acceder al último elemento de cualquier lista, puede usar `-1` como el número de índice:

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[-1] # Tokyo
```

- La indexación negativa se usa para acceder a elementos comenzando desde el final de la lista en lugar del inicio en el índice `0`.

- **Crear Listas Usando el Constructor `list()`**: Las listas también pueden ser creadas usando el constructor `list()`. El constructor `list()` se usa para convertir un iterable en una lista:

```python
developer = 'Jessica'

print(list(developer)) 
# Result: ['J', 'e', 's', 's', 'i', 'c', 'a']
```

- **Encontrar la Longitud de una Lista**: Puede usar la función `len()` para obtener la longitud de una lista:

```python
numbers = [1, 2, 3, 4, 5]
len(numbers) # 5
```

- **Mutabilidad de Listas**: Las listas son mutables, lo que significa que puede actualizar cualquier elemento en la lista siempre que proporcione un número de índice válido. Para actualizar listas en un índice particular, puede asignar un nuevo valor a ese índice:

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[0] = 'JavaScript'
print(programming_languages) # ['JavaScript', 'Java', 'C++', 'Rust']
```

- **Error de Rango de Índice**: Si proporciona un índice (ya sea positivo o negativo) que está fuera de los límites de la lista, entonces recibirá un `IndexError`:

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[10] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
"""
```

- **Eliminar Elementos de una Lista**: Se pueden eliminar elementos de una lista usando la palabra clave `del`:

```python
developer = ['Jane Doe', 23, 'Python Developer']
del developer[1]
print(developer) # ['Jane Doe', 'Python Developer']
```

- **Verificar si un Elemento Existe en una Lista**: La palabra clave `in` puede usarse para verificar si un elemento existe en una lista:

```py
programming_languages = ['Python', 'Java', 'C++', 'Rust']

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **Listas Anidadas**: Las listas pueden anidarse dentro de otras listas:

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
```

- Para acceder a la lista anidada, necesitará acceder usando el índice `2` ya que las listas están indexadas desde cero.

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2] # ['Python', 'Rust', 'C++']
```

- Para acceder a un lenguaje secundario de esa lista anidada, necesitará acceder usando el índice `1`:

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2][1] # Rust
```

- **Desempaquetar Valores de una Lista:** Desempaquetar valores de una lista es una técnica usada para asignar valores de una lista a nuevas variables. Aquí hay un ejemplo para desempaquetar la lista `developer` en nuevas variables llamadas `name`, `age` y `job` así:

```py
developer = ['Alice', 34, 'Rust Developer']
name, age, job = developer
```

- **Recoger el Resto de Elementos de una Lista**: Para recoger cualquier elemento restante de una lista, puede usar el operador asterisco (`*`) de esta manera:

```py
developer = ['Alice', 34, 'Rust Developer']
name, *rest = developer
```

- Si el número de variables en el lado izquierdo del operador de asignación no coincide con el número total de elementos en la lista, entonces recibirá un `ValueError`.

- **Segmentar Listas**: La segmentación es el concepto de acceder a una porción de una lista usando el operador de segmento `:`. Para segmentar una lista que empieza en el índice `1` y termina en el índice `3`, puede usar la siguiente sintaxis:

```python
desserts = ['Cake', 'Cookies', 'Ice Cream', 'Pie']
desserts[1:3] # ['Cookies', 'Ice Cream']
```

- **Intervalos de Paso**: También es posible especificar un intervalo de paso que determine cuánto incrementar entre los índices. Aquí hay un ejemplo si desea extraer una lista de solo números pares usando la segmentación:

```python
numbers = [1, 2, 3, 4, 5, 6]
numbers[1::2] # [2, 4, 6]
```

## Métodos de Lista

- **append()**: Se usa para agregar un elemento al final de la lista. Aquí tienes un ejemplo de cómo usar el método `append()` para agregar el número `6` a esta lista `numbers`:

```py
numbers = [1, 2, 3, 4, 5]
numbers.append(6)
print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **Añadiendo Listas**: El método `append()` también se puede usar para añadir una lista al final de otra:

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.append(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, [6, 8, 10]]
```

- **extend()**: Usado para añadir múltiples ítems al final de una lista. Aquí hay un ejemplo de añadir los números `6`, `8` y `10` al final de la lista `numbers`:

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.extend(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, 6, 8, 10]
```

- **insert()**: Usado para insertar un ítem en un índice específico en la lista. Aquí hay un ejemplo de cómo usar el método `insert()`:

```py
numbers = [1, 2, 3, 4, 5]
numbers.insert(2, 2.5)

print(numbers) # [1, 2, 2.5, 3, 4, 5]
```

- **remove():** Se usa para eliminar un elemento de la lista. El método `remove()` solo eliminará la primera ocurrencia de un elemento en la lista:

```py
numbers = [1, 2, 3, 4, 5, 5, 5]
numbers.remove(5)

print(numbers) # [1, 2, 3, 4, 5, 5]

```

- **pop()**: Usado para eliminar un ítem específico de la lista y devolverlo:

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop(1) # The number 2 is returned
```

- Si no especifica un elemento para el método `pop`, entonces se elimina el último elemento.

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop() # The number 5 is returned
```

- **clear()**: Usado para eliminar todos los ítems de la lista:

```py
numbers = [1, 2, 3, 4, 5]
numbers.clear()

print(numbers) # []
```

- **sort()**: El método `sort()` se usa para ordenar los elementos en su lugar. Aquí hay un ejemplo de cómo ordenar una lista aleatoria de `numbers` en su lugar:

```py
numbers = [19, 2, 35, 1, 67, 41]
numbers.sort()

print(numbers) # [1, 2, 19, 35, 41, 67]
```

- **sorted()**: Usado para ordenar los elementos en una lista y devolver una nueva lista ordenada en lugar de modificar la lista original.

- **reverse()**: Usado para invertir el orden de los elementos en una lista:

```py
numbers = [6, 5, 4, 3, 2, 1]
numbers.reverse()

print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **index()**: Usado para encontrar el primer índice donde se puede encontrar un elemento en una lista:

```python
programming_languages = ['Rust', 'Java', 'Python', 'C++']
programming_languages.index('Java') # 1
```

- Si el elemento no puede ser encontrado usando el método `index()`, entonces el resultado será un `ValueError`.

## Tuplas en Python

- **Definición**: Una tupla es un tipo de dato de Python usado para crear una secuencia ordenada de valores. Las tuplas pueden contener un conjunto mixto de tipos de datos:

```py
developer = ('Alice', 34, 'Rust Developer')
```

- Las tuplas son inmutables, lo que significa que los elementos en la tupla no pueden ser cambiados una vez creados. Si intenta actualizar uno de los elementos en la tupla, obtendrá un `TypeError`:

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')
programming_languages[0] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object does not support item assignment
"""
```

- **Acceder a Elementos de una Tupla**: Para acceder a un elemento de una tupla, use la notación de corchetes y el número de índice:

```py
developer = ('Alice', 34, 'Rust Developer')
developer[1] # 34
```

- La indexación negativa puede ser usada para acceder a elementos comenzando desde el final de la tupla:

```py
numbers = (1, 2, 3, 4, 5)
numbers[-2] # 4
```

- Si intenta pasar un número de índice que excede o iguala la longitud de la tupla, obtendrá un `IndexError`:

```py
numbers = (1, 2, 3, 4, 5)
numbers[7]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: tuple index out of range
"""
```

- Una tupla también puede ser creada usando el constructor `tuple()`. Dentro del constructor, puede pasar diferentes iterables como cadenas, listas e incluso otras tuplas.

```python
developer = 'Jessica'

print(tuple(developer)) 
# Result: ('J', 'e', 's', 's', 'i', 'c', 'a')
```

- **Verificar Ítems en una Tupla**: Para verificar si hay un ítem en una tupla, puede usar la palabra clave `in` de esta manera:

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **Desempaquetar Tuplas**: Los ítems pueden ser desempacados de una tupla así:

```py
developer = ('Alice', 34, 'Rust Developer')
name, age, job = developer
```

- Si necesita recoger cualquier elemento restante de una tupla, puede usar el operador asterisco (`*`) de esta manera:

```py
developer = ('Alice', 34, 'Rust Developer')
name, *rest = developer
```

- **Segmentar Tuplas**: La segmentación puede usarse para extraer una porción de una tupla. Por ejemplo, los ítems `pie` y `cookies` pueden ser segmentados en una tupla separada:

```py
desserts = ('cake', 'pie', 'cookies', 'ice cream')
desserts[1:3] # ('pie', 'cookies')
```

- **Eliminar Ítems de Tuplas**: Eliminar un ítem de una tupla generará un `TypeError` ya que las tuplas son inmutables:

```py
developer = ('Jane Doe', 23, 'Python Developer')
del developer[1]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object doesn't support item deletion
"""
```

- **¿Cuándo usar una Tupla versus una Lista?**: Si necesita una colección dinámica de elementos donde pueda añadir, eliminar y actualizar elementos, entonces debe usar una lista. Si sabe que está trabajando con una colección fija e inmutable de datos, entonces debe usar una tupla.

## Métodos Comunes de Tuplas

- **`count()`**: Usado para determinar cuántas veces aparece un ítem en una tupla. Por ejemplo, puede verificar cuántas veces aparece el idioma `'Rust'` en la tupla:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('Rust') # 2
```

- Si el ítem especificado en la función `count()` no está presente en absoluto en la tupla, entonces el valor de retorno será `0`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('JavaScript') # 0
```

- Si no pasa argumentos a la función `count()`, entonces Python devolverá un `TypeError`.

- **index()**: Usado para encontrar el índice donde un ítem particular está presente en la tupla. Aquí hay un ejemplo de cómo usar el método `index()` para encontrar el índice del lenguaje `'Java'`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.index('Java') # 1
```

- Si el ítem especificado no puede ser encontrado, entonces Python devolverá un `ValueError`.

- Puede pasar un índice de inicio opcional al método `index()` para especificar dónde empezar a buscar el ítem en la tupla:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
programming_languages.index('Python', 3) # 5
```

- También puede pasar un índice de fin opcional al método `index()` para especificar dónde detener la búsqueda del ítem en la tupla:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python', 'JavaScript', 'Python')
programming_languages.index('Python', 2, 5) # 2
```

- **`sorted()`**: Usado para ordenar los elementos en cualquier iterable y devolver una nueva lista ordenada. Aquí hay un ejemplo de cómo crear una nueva lista de números usando la función `sorted()`:

```py
numbers = (13, 2, 78, 3, 45, 67, 18, 7)
sorted(numbers) # [2, 3, 7, 13, 18, 45, 67, 78]
```

- **Modificando el Comportamiento de Ordenación**: Puede personalizar el comportamiento de ordenación para un iterable usando los argumentos opcionales `reverse` y `key`. Aquí hay un ejemplo de cómo usar el argumento `key` para ordenar elementos en una tupla por longitud:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
sorted(programming_languages, key=len)

# Result
# ['C++', 'Rust', 'Java', 'Rust', 'Python', 'Python']
```

- Puede crear una nueva lista de valores en orden inverso, usando el argumento `reverse` así:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')

print(sorted(programming_languages, reverse=True))

# Result
# ['Rust', 'Rust', 'Python', 'Python', 'Java', 'C++']
```

## Bucles en Python

- **Definición**: Los bucles se usan para repetir un bloque de código un número determinado de veces.

- **Bucle `for`**: Se usa para iterar sobre una secuencia (como una lista, tupla o cadena) y ejecutar un bloque de código para cada elemento en esa secuencia. Aquí tienes un ejemplo de cómo usar un bucle `for` para recorrer una lista e imprimir cada idioma en la consola:

```py
programming_languages = ['Rust', 'Java', 'Python', 'C++']

for language in programming_languages:
    print(language)

"""
Result 

Rust
Java
Python
C++
"""
```

- Aquí hay un ejemplo de cómo usar un bucle `for` para recorrer la cadena `code` y escribir cada carácter:

```py
for char in 'code':
    print(char)

"""
Result 

c
o
d
e
"""
```

- Los bucles `for` pueden estar anidados. Aquí hay un ejemplo de cómo usar un bucle `for` anidado:

```py
categories = ['Fruit', 'Vegetable']
foods = ['Apple', 'Carrot', 'Banana']

for category in categories:
    for food in foods:
        print(category, food)

"""
Result

Fruit Apple
Fruit Carrot
Fruit Banana
Vegetable Apple
Vegetable Carrot
Vegetable Banana
"""

```

- **`while` loop**: Repite un bloque de código hasta que la condición sea `False`. Aquí hay un ejemplo de cómo usar un bucle `while` para un juego de adivinanzas:

```py
secret_number = 3
guess = 0

while guess != secret_number:
    guess = int(input('Guess the number (1-5): '))
    if guess != secret_number:
        print('Wrong! Try again.')

print('You got it!')

"""
Result

Guess the number (1-5): 2
Wrong! Try again.
Guess the number (1-5): 1
Wrong! Try again.
Guess the number (1-5): 3
You got it!
"""

```

- **`break` y `continue` statements**: Usados en bucles para modificar la ejecución de un bucle.

- La declaración `break` se usa para salir del bucle inmediatamente cuando una cierta condición se cumple. Aquí hay un ejemplo de cómo usar la declaración `break` para una lista de `developer_names`:

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        break
    print(developer)
```

- La declaración `continue` se usa para saltar la iteración actual y pasar a la siguiente iteración del bucle. Aquí hay un ejemplo para usar la declaración `continue` en lugar de una declaración `break`:

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        continue
    print(developer)
```

- Tanto los bucles `for` como `while` pueden combinarse con una cláusula `else`, que se ejecuta solo cuando el bucle no fue terminado por un `break`:

```python
words = ['sky', 'apple', 'rhythm', 'fly', 'orange']

for word in words:
    for letter in word:
        if letter.lower() in 'aeiou':
            print(f"'{word}' contains the vowel '{letter}'")
            break
    else:
        print(f"'{word}' has no vowels")
```

## Rangos y su Uso en Bucles

- **La función `range()`**: Usada para generar una secuencia de enteros.

```py
range(start, stop, step)
```

- El argumento obligatorio `stop` es un entero (no inclusivo) que representa el punto final para la secuencia de números que se está generando. Aquí hay un ejemplo de cómo usar la función `range()`:

```py
for num in range(3):
    print(num)
```

- Si no se especifica un argumento `start`, entonces el valor predeterminado será `0`. Por defecto, la secuencia de enteros incrementará en `1`. Puedes usar el argumento opcional `step` para cambiar el valor de incremento predeterminado. Aquí tienes un ejemplo de cómo generar una secuencia de enteros pares desde 2 hasta, pero sin incluir, 11 (es decir, incluye 10)

```py
for num in range(2, 11, 2):
    print(num)
```

- Si no proporciona argumentos a la función `range()`, entonces obtendrá un `TypeError`.

- La función `range()` solo acepta enteros como argumentos y no flotantes. Usar flotantes también resultará en un `TypeError`:

```py
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
```

- Puede usar un entero negativo para el argumento `step` para generar una secuencia de enteros en orden decreciente:

```py
for num in range(40, 0, -10):
    print(num)
```

- La función `range()` también puede usarse para crear una lista de enteros usándola con el constructor `list`. El constructor `list` se usa para convertir un iterable en una lista. Aquí hay un ejemplo de cómo generar una lista de enteros pares entre 2 y 10 inclusive:

```py
numbers = list(range(2, 11, 2))
print(numbers) # [2, 4, 6, 8, 10]
```

## Funciones `enumerate()` y `zip()` en Python

- **`enumerate()`**: usada para iterar sobre una secuencia y llevar un seguimiento del índice para cada ítem en esa secuencia. La función `enumerate()` toma un iterable como argumento y devuelve un objeto `enumerate` que consiste en el índice y valor de cada ítem en el iterable.

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

for index, language in enumerate(languages):
    print(f'Index {index} and language {language}')

# Result
# Index 0 and language Spanish
# Index 1 and language English
# Index 2 and language Russian
# Index 3 and language Chinese

```

- La función `enumerate()` también se puede usar fuera de un bucle `for`:

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

print(list(enumerate(languages)))
# [(0, 'Spanish'), (1, 'English'), (2, 'Russian'), (3, 'Chinese')]
```

- La función `enumerate()` también acepta un argumento opcional `start` que especifica el valor inicial para el conteo. Si este argumento es omitido, entonces el conteo comenzará en `0`.

-  **`zip()`** : Se usa para iterar sobre múltiples iterables en paralelo. Aquí tienes un ejemplo usando la función `zip()` para iterar sobre `developers` y `ids`:

```python
developers = ['Naomi', 'Dario', 'Jessica', 'Tom']
ids = [1, 2, 3, 4]

for name, id in zip(developers, ids):
    print(f'Name: {name}')
    print(f'ID: {id}')


"""
Result

Name: Naomi
ID: 1
Name: Dario
ID: 2
Name: Jessica
ID: 3
Name: Tom
ID: 4
"""

```

## Comprehensiones de Lista en Python

- **Definición**: La comprensión de listas le permite crear una nueva lista en una sola línea combinando el bucle y la condición directamente dentro de corchetes cuadrados. Esto hace que el código sea más corto y, a menudo, más fácil de leer.

```py
even_numbers = [num for num in range(21) if num % 2 == 0]
print(even_numbers)
```

## Métodos Iterables

- **`filter()`**: Usado para filtrar elementos de un iterable basado en una condición. Devuelve un iterador que contiene solo los elementos que satisfacen la condición. Aquí hay un ejemplo de cómo crear una nueva lista de sólo palabras con más de cuatro caracteres:

```py
words = ['tree', 'sky', 'mountain', 'river', 'cloud', 'sun']

def is_long_word(word):
    return len(word) > 4

long_words = list(filter(is_long_word, words))
print(long_words) # ['mountain', 'river', 'cloud']
```

- **`map()`**: Usado para aplicar una función a cada ítem en un iterable y devolver un nuevo iterable con los resultados. Aquí hay un ejemplo de cómo usar la función `map()` para convertir una lista de temperaturas en celsius a fahrenheit:

```py
celsius = [0, 10, 20, 30, 40]

def to_fahrenheit(temp):
    return (temp * 9/5) + 32

fahrenheit = list(map(to_fahrenheit, celsius))
print(fahrenheit) # [32.0, 50.0, 68.0, 86.0, 104.0]
```

- **`sum()`**: Usado para obtener la suma de un iterable como una lista o tupla. Aquí hay un ejemplo de cómo usar la función `sum()`:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers)
print(total) # Result: 50
```

- También puede pasar un argumento opcional `start` que establece el valor inicial para la suma. Aquí hay un ejemplo actualizado usando el argumento `start` como un argumento posicional:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, 10) # positional argument
print(total) # 60
```

- También puede optar por usar el argumento `start` como un argumento de palabra clave en lugar de esto:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, start=10) # keyword argument
print(total) # 60
```

## Funciones Lambda

- **Definición**: Una función lambda en Python es una forma concisa de crear una función sin un nombre (una función anónima).
- Las funciones lambda a menudo se usan como argumento para otra función. Aquí hay un ejemplo de una función lambda:

```py
numbers = [1, 2, 3, 4, 5]

even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]
```

- Las mejores prácticas para usar funciones lambda incluyen no asignarlas a una variable, mantenerlas simples y legibles, y usarlas para funciones cortas y puntuales.

## Diccionarios

- **Diccionarios**: Los diccionarios son estructuras de datos integradas que almacenan colecciones de pares clave-valor. Las claves deben ser tipos de datos inmutables. Esta es la sintaxis general de un diccionario en Python:

```python
dictionary = {
    key1: value1,
    key2: value2
}
```

- **Constructor `dict()`**: El constructor `dict()` es una forma alternativa de construir el diccionario. Pasas una lista de tuplas como argumento al constructor `dict()`. Estas tuplas contienen la clave como el primer elemento y el valor como el segundo elemento.

```python
pizza = dict([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250), ('toppings', ['mozzarella', 'basil'])])
```

- **Notación de corchetes**: Para acceder al valor de un par clave-valor, puedes usar la sintaxis conocida como notación de corchetes.

```python
dictionary[key]
```

## Métodos Comunes del Diccionario

- **Método `get()`**: El método `get()` recupera el valor asociado con una clave. Es similar a la notación de corchetes, pero te permite establecer un valor predeterminado, evitando errores si la clave no existe.

```python
dictionary.get(key, default)
```

- **Métodos `keys()` y `values()`**: Los métodos `keys()` y `values()` devuelven un objeto vista con todas las claves y valores del diccionario, respectivamente. Un objeto vista es una forma de ver el contenido de un diccionario sin crear una copia separada de los datos.

```python
pizza = {
    'name': 'Margherita Pizza',
    'price': 8.9,
    'calories_per_slice': 250
}

pizza.keys()
# dict_keys(['name', 'price', 'calories_per_slice'])

pizza.values()
# dict_values(['Margherita Pizza', 8.9, 250])
```

- **Método `items()`**: El método `items()` devuelve un objeto vista con todos los pares clave-valor en el diccionario, incluyendo tanto las claves como los valores.

```python
pizza.items()
# dict_items([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250)])
```

- **Método `clear()`**: El método `clear()` elimina todos los pares clave-valor del diccionario.

```python
pizza.clear()
```

- **Método `pop()`**: El método `pop()` elimina el par clave-valor con la clave especificada como el primer argumento y devuelve su valor. Si la clave no existe, devuelve el valor predeterminado especificado como el segundo argumento. Si la clave no existe y no se especifica un valor predeterminado, se genera un `KeyError`.

```python
pizza.pop('price', 10)
pizza.pop('total_price') # KeyError
```

- **Método `popitem()`**: En Python 3.7 y versiones superiores, el método `popitem()` elimina el último elemento insertado.

```python
pizza.popitem()
```

- **Método `update()`**: El método `update()` actualiza los pares clave-valor con los pares clave-valor de otro diccionario. Si tienen claves en común, sus valores se sobrescriben. Las claves nuevas se agregarán al diccionario como nuevos pares clave-valor.

```python
pizza.update({ 'price': 15, 'total_time': 25 })
```

## Iterando sobre un diccionario

- **Iterando Sobre Valores**: Si necesitas iterar sobre los valores en un diccionario, puedes escribir un ciclo `for` con `values()` para obtener todos los valores de un diccionario.

```python
products = {
    'Laptop': 990,
    'Smartphone': 600,
    'Tablet': 250,
    'Headphones': 70,
}

for price in products.values():
    print(price)
```

Resultado:

```md
990
600
250
70
```

- **Iterando sobre las claves**: Si necesitas iterar sobre las claves en el diccionario `products` de arriba, puedes escribir `products.keys()` o `products` directamente.

```python
for product in products.keys():
    print(product)
    
# Or

for product in products:
    print(product)
```

Resultado:

```md
Laptop
Smartphone
Tablet
Headphones
```

- **Iterando sobre pares clave-valor**: Si necesitas iterar sobre las claves y sus valores correspondientes simultáneamente, puedes iterar sobre `products.items()`. Obtienes tuplas individuales con las claves y sus valores correspondientes.

```python
for product in products.items():
    print(product)
```

Resultado:

```md
('Laptop', 990)
('Smartphone', 600)
('Tablet', 250)
('Headphones', 70)
```

Para almacenar la clave y el valor en variables de bucle separadas, necesitas separarlas con una coma. La primera variable almacena la clave, y la segunda almacena el valor.

```python
for product, price in products.items():
    print(product, price)
```

Resultado:

```md
Laptop 990
Smartphone 600
Tablet 250
Headphones 70
```

- **Función `enumerate()`**: Si necesitas iterar sobre un diccionario mientras llevas un contador, puedes llamar a la función `enumerate()`. La función devuelve un objeto `enumerate`, que asigna un entero a cada elemento, como un contador. Puedes iniciar el contador desde cualquier número, pero por defecto, comienza en 0.

Asignar el índice y el elemento a variables separadas en el ciclo es la forma común de usar `enumerate()`. Por ejemplo, con `products.items()`, puedes obtener el par clave-valor completo además del índice:

```python
for index, product in enumerate(products.items()):
    print(index, product)
```

Resultado:

```md
0 ('Laptop', 990)
1 ('Smartphone', 600)
2 ('Tablet', 250)
3 ('Headphones', 70)
```

Para personalizar el valor inicial del conteo, puedes pasar un segundo argumento a `enumerate()`. Por ejemplo, aquí estamos comenzando el conteo desde 1.

```python
for index, product in enumerate(products.items(), 1):
    print(index, product)
```

Resultado:

```md
1 ('Laptop', 990)
2 ('Smartphone', 600)
3 ('Tablet', 250)
4 ('Headphones', 70)
```

## Conjuntos

- **Conjuntos**: Los conjuntos son estructuras de datos integradas en Python que no permiten valores duplicados. Los conjuntos son mutables y no ordenados, lo que significa que sus elementos no se almacenan en un orden específico, por lo que no puedes usar índices o claves para acceder a ellos. Además, los conjuntos solo pueden contener valores de tipos de datos inmutables, como números, cadenas y tuplas.

- **Definiendo un Conjunto**: Para definir un conjunto, necesitas escribir sus elementos dentro de llaves y separarlos con comas.

```python
my_set = {1, 2, 3, 4, 5}
```

- **Definiendo un Conjunto Vacío**: Si necesitas definir un conjunto vacío, debes usar la función `set()`. Solo escribir llaves vacías creará automáticamente un diccionario.

```python
set() # Set
{}    # Dictionary
```

## Métodos Comunes de Conjunto

- **Método `add()`**: Puedes agregar un elemento a un conjunto con el método `add()`, pasando el nuevo elemento como argumento.

```python
my_set.add(6)
```

- **Métodos `remove()` y `discard()`**: Para eliminar un elemento de un conjunto, puedes usar el método `remove()` o el método `discard()`, pasando el elemento que quieres eliminar como argumento. El método `remove()` generará un `KeyError` si el elemento no se encuentra, mientras que el método `discard()` no lo hará.

```python
my_set.remove(4)
my_set.discard(4)
```

- **Método `clear()`**: El método `clear()` elimina todos los elementos del conjunto.

```python
my_set.clear()
```

## Operaciones Matemáticas de Conjuntos

- **Métodos `issubset()` y `issuperset()`**: Los métodos `issubset()` y `issuperset()` verifican si un conjunto es un subconjunto o un superconjunto de otro conjunto, respectivamente.

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 5}

print(your_set.issubset(my_set)) # True
print(my_set.issuperset(your_set)) # True
```

- **Método `isdisjoint()`**: El método `isdisjoint()` verifica si dos conjuntos son disjuntos, es decir, si no tienen elementos en común.

```python
my_set = {1, 2, 3}
your_set = {4, 5, 6}

print(my_set.isdisjoint(your_set)) # True
```

- **Operador de Unión (`|`)**: El operador de unión `|` devuelve un nuevo conjunto con todos los elementos de ambos conjuntos.

```python
my_set = {1, 2, 3}
your_set = {4, 5, 6}

my_set | your_set # {1, 2, 3, 4, 5, 6}
```

- **Operador de intersección (`&`)**: El operador de intersección `&` devuelve un nuevo conjunto con solo los elementos que los conjuntos tienen en común.

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

my_set & your_set # {2, 3, 4}
```

- **Operador de diferencia (`-`)**: El operador de diferencia `-` devuelve un nuevo conjunto con los elementos del primer conjunto que no están en los otros conjuntos.

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

my_set - your_set # {1, 5}
```

- **Operador de Diferencia Simétrica (`^`)**: El operador de diferencia simétrica `^` devuelve un nuevo conjunto con los elementos que están en el primer o en el segundo conjunto, pero no en ambos.

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

my_set ^ your_set # {1, 5, 6}
```

- **Operador `in`**: Puedes verificar si un elemento está en un conjunto o no con el operador `in`.

```python
print(5 in my_set)
```

## Biblioteca Estándar de Python

- **Biblioteca Estándar de Python**: Una biblioteca te ofrece código preescrito y reutilizable, como funciones, clases y estructuras de datos, que puedes reutilizar en tus proyectos. Python tiene una extensa biblioteca estándar con módulos integrados que implementan soluciones estandarizadas para muchos problemas y tareas. Algunos ejemplos de módulos integrados populares son `math`, `random`, `re` (abreviatura de "expresiones regulares") y `datetime`.

## Declaración de importación

- **Declaración Import**: Para acceder a los elementos definidos en módulos integrados, usas una declaración import. Las declaraciones import generalmente se escriben al principio del archivo. Las declaraciones import funcionan igual para funciones, clases, constantes, variables y cualquier otro elemento definido en el módulo.

- **Declaración básica de importación**: Puedes usar la palabra clave `import` seguida del nombre del módulo:

```python
import module_name
```

Luego, si necesitas llamar a un método de ese módulo, usarías la notación de punto, con el nombre del módulo seguido del nombre del método.

```python
module_name.method_name()
```

Por ejemplo, escribirías lo siguiente en tu código para importar el módulo `math` y obtener la raíz cuadrada de 36:

```python
import math

math.sqrt(36)
```

- **Importar un Módulo con un Nombre Diferente**: Si necesitas importar el módulo con un nombre diferente (también conocido como un "alias"), puedes usar `as` seguido del alias al final de la declaración de importación. Esto se usa a menudo para nombres de módulos largos o para evitar conflictos de nombres.

```python
import module_name as module_alias
```

Por ejemplo, para referirte al módulo `math` como `m` en tu código, puedes asignar un alias así:

```python
import math as m
```

Luego, puedes acceder a los elementos del módulo usando el alias:

```python
m.sqrt(36)
```

- **Importar Elementos Específicos**: Si no necesitas todo de un módulo, puedes importar elementos específicos usando `from`. En este caso, la declaración de importación comienza con `from`, seguida del nombre del módulo, luego la palabra clave `import` y finalmente los nombres de los elementos que quieres importar.

```python
from module_name import name1, name2
```

Luego, puedes usar estos nombres sin el prefijo del módulo en tu script de Python. Por ejemplo:

```python
from math import radians, sin, cos

angle_degrees = 40
angle_radians = radians(angle_degrees)

sine_value = sin(angle_radians)
cos_value = cos(angle_radians)

print(sine_value) # 0.6427876096865393
print(cos_value)  # 0.766044443118978
```
 
Esto es útil, pero puede resultar en conflictos de nombres si ya tienes funciones o variables con el mismo nombre. Tenlo en cuenta al elegir qué tipo de declaración de importación quieres usar.

Si necesitas asignar alias a estos nombres, también puedes hacerlo usando la palabra clave `as` seguida del alias.

```python
from module_name import name1 as alias1, name2 as alias2
```

- **Declaración de importación con asterisco (`*`)**: El asterisco indica a Python que quieres importar todo en ese módulo, pero quieres importarlo para que no necesites usar el nombre del módulo como prefijo.

```python
from module_name import *
```

Por ejemplo, si usas esto para importar el módulo `math`, podrás llamar a cualquier función definida en ese módulo sin especificar el nombre del módulo como prefijo.

```python
from math import *
print(sqrt(36))  # 6.0
```

Sin embargo, esto generalmente se desaconseja porque puede provocar colisiones de espacio de nombres y dificultar saber de dónde provienen los nombres.

## `if __name__ == '__main__'`

- **Variable `__name__`**: `__name__` es una variable especial incorporada en Python. Cuando un archivo Python se ejecuta directamente, Python asigna el valor de esta variable a la cadena `__main__`. Pero si el archivo Python se importa como un módulo en otro script Python, el valor de la variable `__name__` se establece con el nombre de ese módulo.

Por eso a menudo encontrarás esta condicional en scripts de Python. Contiene el código que solo quieres ejecutar **solo** si el script de Python se está ejecutando como el programa principal.

```python
if __name__ == '__main__': 
    # Code
```

## Errores comunes en Python

- **SyntaxError**: El error que Python genera cuando tu código no sigue sus reglas de sintaxis. Por ejemplo, el código `print("Hello there"` causará un error de sintaxis con el mensaje, `SyntaxError: '(' was never closed`, porque al código le falta un paréntesis de cierre.
- **NameError**: Python lanza un `NameError` cuando intentas acceder a una variable o función que no has definido. Por ejemplo, si tienes la línea `print(username)` en tu código sin haber definido primero una variable `username`, obtendrás un error de nombre con el mensaje `NameError: name 'username' is not defined`.
- **TypeError**: Este es el error que Python lanza cuando realizas una operación con dos o más tipos de datos incompatibles. Por ejemplo, si intentas sumar una cadena a un número, obtendrás el error `TypeError: can only concatenate str (not "int") to str`.
- **IndexError**: Obtendrás un `IndexError` si accedes a un índice que no existe en una lista u otras secuencias como tupla y cadena. Por ejemplo, en una cadena `Hello world`, el índice del último carácter es `11`. Si intentas acceder a un carácter de esta manera, `greet = "hello world"; print(greet[12])`, obtendrás un error con el mensaje `IndexError: string index out of range`.
- **AttributeError**: Python lanza este error cuando intentas usar un método o propiedad que no existe en un objeto de ese tipo. Por ejemplo, llamar a `.append()` en una cadena como `"hello".append("!")` causará un error con el mensaje `AttributeError: 'str' object has no attribute 'append'`.

## Buenas técnicas de depuración en Python

- **Usando la función `print`**: Insertar sentencias `print()` en varios puntos de tu código mientras depuras te ayuda a ver los valores de las variables y cómo fluye tu código.
- **Uso del depurador incorporado de Python (`pdb`)**: Python proporciona un módulo `pdb` para depuración. Es parte de la biblioteca estándar de Python, por lo que siempre está disponible para usar. Con `pdb`, puedes establecer una traza con el método `set_trace()` para que puedas comenzar a avanzar paso a paso por el código e inspeccionar variables de manera interactiva.
- **Aprovechando las herramientas de depuración del IDE**: Muchos entornos de desarrollo integrados (IDEs) y editores de código como Pycharm y VS Code ofrecen herramientas de depuración con puntos de interrupción, ejecución paso a paso, inspección de variables y otras funciones de depuración.

## Manejo de excepciones

- **`try...except`**: This is used to execute a block of code that might raise an exception. The `try` block is  where you anticipate an error might occur, while the `except` block takes a specified exception and runs if that specified error is raised. Here's an example:

  ```py
  try:
    print(22 / 0)
  except ZeroDivisionError:
    print('You can\'t divide by zero!')
    # You can't divide by zero!
  ```

  You can also chain multiple `except` blocks so you can handle more types of exceptions:

  ```py
  try:
    number = int(input('Enter a number: '))
    print(22 / number)
  except ZeroDivisionError:
    print('You cannot divide by zero!')
    # You cannot divide by zero! prints when you enter 0
  except ValueError:
    print('Please enter a valid number!')
    # Please enter a valid number! prints when you enter a string  
  ```

- **`else` y `finally`**: Estos bloques extienden `try...except`. Si no ocurre ninguna excepción, se ejecuta el bloque `else`. El bloque `finally` siempre se ejecuta sin importar los errores.

  ```py
  try:
    result = 100 / 4
  except ZeroDivisionError:
    print('You cannot divide by zero!') # This will not run
  else:
    print(f'Result is {result}') # Result is 25.0
  finally:
    print('Execution complete!') # Execution complete!
  ```

- **Objeto Exception**: Esto te permite acceder a la excepción misma para una mejor depuración e imprimir el mensaje de error directo. Para acceder al objeto exception, necesitas usar la palabra clave `as`. Aquí tienes un ejemplo:

  ```py
  try:
      value = int('This will raise an error')
  except ValueError as e:
      print(f'Caught an error: {e}')
      # Caught an error: invalid literal for int() with base 10: 'This will raise an error'
  ```

- **La sentencia `raise`**: Esto te permite lanzar manualmente una excepción. Puedes usarla para lanzar una excepción cuando se cumple una cierta condición. Aquí tienes un ejemplo:

  ```py
  def divide(a, b):
      if b == 0:
          raise ZeroDivisionError('You cannot divide by zero')
      return a / b
  ```
  
## Señalización de excepciones
  
  La sentencia `raise` también es útil cuando creas tus propias excepciones personalizadas, ya que puedes usarla para lanzar una excepción con un mensaje personalizado. Aquí tienes un ejemplo de eso:

  ```py
  class InvalidCredentialsError(Exception):
      def __init__(self, message="Invalid username or password"):
          self.message = message
          super().__init__(self.message)

  def login(username, password):
      stored_username = "admin"
      stored_password = "password123"
      
      if username != stored_username or password != stored_password:
          raise InvalidCredentialsError()
      
      return f"Welcome, {username}!"
  ```  

  Aquí tienes cómo puedes usar la función `login` desde la excepción `InvalidCredentialsError`:

  ```py
  # failed login attempt
  try:
      message = login("user", "wrongpassword")
      print(message)
  except InvalidCredentialsError as e:
      print(f"Login failed: {e}")

  # successful login attempt
  try:
      message = login("admin", "password123")
      print(message)
  except InvalidCredentialsError as e:
      # This block is not executed because the login was successful
      print(f"Login failed: {e}")
  else:
      # The else block runs if the 'try' block completes without an exception
      print(message)
  ```

  La sentencia `raise` también puede usarse con la palabra clave `from` para encadenar excepciones, mostrando la relación entre diferentes errores:

  ```py
  def parse_config(filename):
    try:
        with open(filename, 'r') as file:
            data = file.read()
            return int(data)
    except FileNotFoundError:
        raise ValueError('Configuration file is missing') from None
    except ValueError as e:
        raise ValueError('Invalid configuration format') from e

  config = parse_config('config.txt')
```

## Clases y Objetos en Python

- **Definición de Clase**: Una clase es una estructura para crear objetos. Define el comportamiento que un objeto tendrá a través de sus atributos y métodos. Aquí tienes un ejemplo básico de una definición de clase en Python:

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f'{self.name.upper()} says woof woof!')
```

- **Creación de Objetos**: Los objetos son instancias de una clase. Se crean llamando a la clase con los argumentos necesarios.

```python
dog1 = Dog('Jack', 3)
dog2 = Dog('Thatcher', 5)

dog1.bark()  # JACK says woof woof!
dog2.bark()  # THATCHER says woof woof!
```

- **Llamar métodos con objetos**: Puedes llamar métodos en objetos para realizar acciones o recuperar información.

```python
objectName1.methodName()
objectName2.methodName()
```

- **Diferencia entre Clase y Objeto**: Una clase es una plantilla reutilizable, mientras que un objeto es una instancia específica de esa clase con datos reales.

## Atributos

- **Atributos de Instancia**: Definidos en `__init__()` usando `self`, y únicos para cada objeto.
- **Atributos de Clase**: Definidos directamente dentro de la clase y compartidos por todas las instancias.

```python
class Dog:
    species = 'French Bulldog'  # Class attribute

    def __init__(self, name):
        self.name = name  # Instance attribute

print(Dog.species) # French Bulldog

jack = Dog('Jack')
print(jack.name)     # Jack
print(jack.species)  # French Bulldog
```

## Métodos

- **Métodos**: Funciones definidas dentro de una clase que operan sobre los atributos del objeto.

```python
class Car:
    def __init__(self, color, model):
        self.color = color
        self.model = model

    def describe(self):
        return f'This car is a {self.color} {self.model}'

my_car_1 = Car('red', 'Tesla Model S')
print(my_car_1.describe())  # This car is a red Tesla Model S
```

- **Accediendo a Métodos**: Llama a métodos en objetos usando la notación de punto. Aquí tienes un ejemplo de cómo llamar al método `describe` en dos objetos de coche diferentes:

```python
class Car:
 def __init__(self, color, model):
   self.color = color  
   self.model = model  

 def describe(self):
   return f'This car is a {self.color} {self.model}'

my_car_1 = Car('red', 'Tesla Model S')
my_car_2 = Car('green', 'Lamborghini Revuelto')

print(my_car_1.describe()) # Calling methods using the dot notation

print(my_car_2.describe()) # Calling methods using the dot notation
```

## Métodos Dunder (Mágicos)

- **Definición**: Métodos especiales que comienzan y terminan con un doble guion bajo (por ejemplo, `__init__`, `__len__`, `__str__`, `__eq__`). Python los usa internamente para operaciones integradas.

```python
class Book:
    def __init__(self, title, pages):
        self.title = title
        self.pages = pages

    def __len__(self):
        return self.pages

    def __str__(self):
        return f"'{self.title}' has {self.pages} pages"

    def __eq__(self, other):
        return self.pages == other.pages

book1 = Book('Built Wealth Like a Boss', 420)
print(len(book1))        # 420
print(str(book1))        # 'Built Wealth Like a Boss' has 420 pages
```

- **Llamar a métodos dunder indirectamente**: No necesitas llamar a los métodos dunder directamente. En cambio, Python los llama automáticamente cuando ocurren ciertas acciones. Estas operaciones incluyen:

  - **operaciones aritméticas como suma, resta, multiplicación, división y otras**. Además, se llama a `__add__()`, a `__sub__()` para resta, a `__mul__()` para multiplicación y a `__truediv__()` para división.
        
  - **operaciones con cadenas como concatenación, repetición, formato y conversión a texto**. `__add__()` se llama para concatenación, `__mul__()` para repetición, `__format__()` para formato, `__str__()` y `__repr__()` para conversión a texto, y así sucesivamente.
        
  - **operaciones de comparación como igualdad, menor que, mayor que y otras**. `__eq__()` se llama para verificaciones de igualdad, `__lt__()` para menor que, `__gt__()` para mayor que, y así sucesivamente.
        
  - **operaciones de iteración como hacer que un objeto sea iterable y avanzar a través de los elementos**. Se llama a `__iter__()` para devolver un iterador y a `__next__()` para obtener el siguiente elemento.

## Ejemplo del mundo real: Carrito de compras

- **Clase Cart con métodos dunder**: Permite agregar, eliminar, iterar y verificar contenidos con comportamiento incorporado.

```python
class Cart:
    def __init__(self):
        self.items = []

    def add(self, item):
        self.items.append(item)

    def remove(self, item):
        if item in self.items:
            self.items.remove(item)
        else:
            print(f'{item} is not in cart')

    def list_items(self):
        return self.items

    def __len__(self):
        return len(self.items)

    def __getitem__(self, index):
        return self.items[index]

    def __contains__(self, item):
        return item in self.items

    def __iter__(self):
        return iter(self.items)

cart = Cart()
cart.add('Laptop')
print(len(cart))        # 1
print('Laptop' in cart) # True
```

## ¿Qué es la Programación Orientada a Objetos?

- **Programación orientada a objetos**: Un estilo de programación en el que los desarrolladores tratan todo en su código como un objeto del mundo real. Popularmente se llama OOP. Los cuatro principios clave que te ayudan a organizar y gestionar el código de manera efectiva son **encapsulación**, **herencia**, **polimorfismo** y **abstracción**
- **Clases**: La estructura para crear objetos. Cada objeto creado a partir de una clase tiene atributos que definen datos y métodos que determinan los comportamientos de los objetos.

## ¿Qué es la Encapsulación?

- **Encapsulación**: La agrupación de los atributos y métodos de un objeto en una sola unidad. Te permite ocultar el estado interno del objeto detrás de un conjunto simple de métodos y atributos públicos que actúan como puertas. Detrás de esas puertas están los atributos y métodos privados que controlan cómo cambian los datos y quién puede verlos.
- **Ejemplo de Encapsulación**: Si quieres rastrear el saldo de una billetera, permitirás depósitos y retiros, pero no querrás que nadie manipule el saldo de la billetera en sí:

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

- **Diferencia entre prefijar atributos con un guion bajo simple y doble**: Prefijar atributos y métodos con un guion bajo simple significa que están destinados para uso interno. Esto es una convención y no impide el acceso a los atributos desde el exterior. Prefijar atributos y métodos con un guion bajo doble evita efectivamente que sean accedidos desde fuera de su clase.

## ¿Qué son los Getters y Setters?

- **Getters y Setters**: Métodos que te permiten controlar cómo se accede y modifica los atributos de una clase. Recuperas valores con getters y estableces valores con setters.
- **Propiedades**: Conectan getters y setters, y permiten el acceso a datos. Ejecutan lógica adicional en segundo plano cuando obtienes, estableces o eliminas valores.
- **Por qué Propiedades en lugar de Métodos**: Las propiedades se usan en lugar de métodos para una mejor legibilidad y un código más limpio. Permiten acceder a valores con notación de punto, como atributos regulares, sin paréntesis.
- **Crear un Getter**: Para crear un getter, usa el decorador `@property`. Aquí tienes un getter que obtiene el radio de un círculo:

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

- **Creando un Setter**: Para crear el setter que establecerá el radio, tienes que definir otro método con el mismo nombre y usar `@<property_name>.setter` encima de él:

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

- **Cómo Python maneja los getters y setters**: Una vez que defines getters y setters, Python los llama automáticamente en segundo plano cada vez que usas la sintaxis normal de atributos de esta manera:

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

 Al establecer un valor, no debes asignar al nombre de la propiedad en sí porque eso causará un `RecursionError`. Usa un nombre interno separado, a menudo con un guion bajo, para almacenar el valor.

- **Deleter**: Después de establecer y obtener un valor con setter y getter, puedes controlar cómo se elimina con un `deleter`. Un deleter ejecuta lógica personalizada cuando usas la instrucción `del` en una propiedad. Para crear un deleter, usas el decorador `@<property_name>.deleter`.

```py
  # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

## ¿Qué es la herencia y cómo promueve la reutilización de código?

- **Herencia**: El proceso por el cual una clase hija usa los atributos y métodos de una clase padre. La herencia promueve la reutilización de código, proporciona jerarquías claras y personaliza el comportamiento sin reescribir todo. Para implementar la herencia, una clase hija recibe el nombre de una clase padre:

```py
class Parent:
    # Parent attributes and methods

class Child(Parent):
    # Child inherits, extends, and/or overrides where necessary
```

- **Herencia Simple y Múltiple**: Cuando una clase hija hereda propiedades y métodos de un solo padre, como puedes ver arriba, el proceso se llama **herencia simple**. Cuando una clase hija hereda propiedades y métodos de más de un padre, eso es **herencia múltiple**. Aquí está la sintaxis para eso:

```py
class Parent:
    # Attributes and methods for Parent

class Child:
    # Attributes and methods for Child

class GrandChild(Parent, Child):
    # GrandChild inherits from both Parent and Child
    # GrandChild can combine or override behavior from each
```

- **Función `super()`**: Una función que te permite sobrescribir un método de un padre dentro de una clase hija.

## ¿Qué es el Polimorfismo y Cómo Promueve la Reutilización de Código?

- **Polimorfismo**: El principio de POO que permite que diferentes clases usen el mismo nombre de método, pero cada clase lo implementa de manera diferente cuando se llama. Aquí está la sintaxis para ello:

```py
class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # Works for A, B, or C
```

- **Polimorfismo basado en herencia**: Un padre establece un método, y cada clase hija lo adapta a su uso.

## ¿Qué es Name Mangling y cómo funciona?

- **Name Mangling**: Un proceso en el que Python renombra internamente un atributo que comienza con doble guion bajo agregando un guion bajo y el nombre de la clase como prefijo, convirtiendo `__attribute` en `_ClassName__attribute`.
- **El propósito del name mangling**: El propósito principal del name mangling es evitar la sobrescritura accidental de atributos y métodos cuando usas herencia. Aquí tienes un código que lo hace más comprensible:

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

## ¿Qué es la abstracción y cómo ayuda a mantener organizados los sistemas complejos?

- **Abstracción**: Un concepto de programación en el que los detalles complejos de implementación de un objeto o sistema están ocultos y solo se muestran las características esenciales. En Python y otros lenguajes de programación, la abstracción simplifica sistemas complejos al aumentar la reutilización.
- **Ejemplo de Abstracción**: Un buen ejemplo de abstracción en la vida cotidiana es un coche que te permite usar solo el volante, los pedales y la palanca de cambios sin saber cómo funciona el motor o los frenos.
- **Cómo Python implementa la abstracción**: Python implementa la abstracción a través del módulo `abc`. El módulo proporciona la clase `ABC` (clase base abstracta) y el decorador `@abstractmethod`. Una clase base abstracta (ABC) define los métodos y propiedades comunes que las subclases deben implementar. No puede ser instanciada.
- **Cómo se Define un Método Abstracto**: Un método abstracto se define con `@abstractmethod` y debe ser sobrescrito en las subclases, incluso si tiene una implementación predeterminada. La sintaxis básica de la abstracción es la siguiente:

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

## Algoritmos y Notación Big O

- **Algoritmos**: Un conjunto de instrucciones inequívocas para resolver un problema o realizar una tarea. Los algoritmos deben terminar en un número finito de pasos y cada paso debe ser preciso e inequívoco.

- **Notación Big O**: Describe el rendimiento en el peor caso, o la tasa de crecimiento, de un algoritmo a medida que aumenta el tamaño de la entrada. Se enfoca en cómo crece el uso de recursos con el tamaño de la entrada, ignorando factores constantes y términos de orden inferior.

### Complejidades de Tiempo Comunes

- **O(1) - Tiempo constante**: El algoritmo toma la misma cantidad de tiempo sin importar el tamaño de la entrada.

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

- **O(log n) - Tiempo Logarítmico**: El tiempo aumenta lentamente a medida que crece la entrada. Común en algoritmos que reducen repetidamente el tamaño del problema por una fracción (como `Binary Search`).

- **O(n) - Tiempo lineal**: El tiempo de ejecución aumenta proporcionalmente al tamaño de la entrada.

```python
for grade in grades:
    print(grade)
```

- **O(n log n) - Tiempo log-lineal**: Complejidad temporal común de algoritmos de ordenamiento eficientes como Merge Sort y Quick Sort.

- **O(n²) - Tiempo cuadrático**: El tiempo de ejecución aumenta de forma cuadrática. Frecuentemente se observa en bucles anidados.

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

### Complejidad Espacial

- **O(1) - Espacio constante**: El algoritmo usa la misma cantidad de memoria sin importar el tamaño de la entrada.
- **O(n) - Espacio lineal**: El uso de memoria crece proporcionalmente con el tamaño de la entrada.
- **O(n²) - Espacio cuadrático**: El uso de memoria crece cuadráticamente con el tamaño de la entrada.

## Técnicas de resolución de problemas

- **Entendiendo el Problema**: Lee la declaración del problema varias veces. Identifica la entrada, la salida esperada y cómo transformar la entrada en salida.

- **Pseudocódigo**: Descripción de alto nivel de la lógica del algoritmo que es independiente del lenguaje. Usa lenguaje escrito común mezclado con estructuras de programación como `IF`, `ELSE`, `FOR`, `WHILE`.

```md
GET original_string
SET reversed_string = ""
FOR EACH character IN original_string:
  ADD character TO THE BEGINNING OF reversed_string
DISPLAY reversed_string
```

- **Casos límite**: Entradas específicas y válidas que ocurren en los límites de lo que un algoritmo debe manejar. Siempre considera y prueba los casos límite.

## Arreglos

- **Arreglos Estáticos**: Tienen un tamaño fijo determinado en la inicialización. Los elementos se almacenan en ubicaciones de memoria adyacentes. El tamaño no puede cambiarse durante la ejecución del programa.

- **Arreglos Dinámicos**: Pueden crecer o reducirse automáticamente durante la ejecución del programa. Maneja el cambio de tamaño mediante la copia automática a arreglos más grandes cuando sea necesario.

### Listas de Python (Arreglos Dinámicos)

```python
numbers = [3, 4, 5, 6]

# Access elements
numbers[0]  # 3

# Update elements
numbers[2] = 16

# Add elements
numbers.append(7)
numbers.insert(3, 15)  # Insert at specific index

# Remove elements
numbers.pop(2)  # Remove at specific index
numbers.pop()   # Remove last element
```

### Complejidades de Tiempo para Arreglos Dinámicos

- **Acceso**: O(1)
- **Insertar al final**: O(1) promedio, O(n) cuando se necesita redimensionar
- **Insertar en medio**: O(n)
- **Eliminar**: O(n) para medio, O(1) para final

## Pilas

- **Pilas**: estructura de datos Last-In, First-Out (LIFO). Los elementos se agregan y eliminan solo desde la parte superior.

- **Operación Push**: Agregar un elemento a la cima de la pila. Complejidad temporal: O(1).

- **Operación Pop**: Eliminar un elemento de la cima de la pila. Complejidad temporal: O(1).

```python
# Using Python list as stack
stack = []

# Push operations
stack.append(1)
stack.append(2)
stack.append(3)

# Pop operations
top_element = stack.pop()  # Returns 3
```

## Colas

- **Colas**: estructura de datos First-In, First-Out (FIFO). Los elementos se agregan al final y se eliminan desde el frente.

- **Operación Enqueue**: Agregar un elemento al final de la cola. Complejidad temporal: O(1).

- **Operación Dequeue**: Eliminar un elemento del frente de la cola. Complejidad temporal: O(1).

```python
from collections import deque

# Using deque for efficient queue operations
queue = deque()

# Enqueue operations
queue.append(1)
queue.append(2)
queue.append(3)

# Dequeue operations
first_element = queue.popleft()  # Returns 1
```

## Listas enlazadas

- **Listas enlazadas**: estructura de datos lineal donde cada nodo contiene datos y una referencia al siguiente nodo. Los nodos están conectados como una cadena.

### Listas enlazadas simples

- **Estructura**: Cada nodo tiene datos y una referencia al siguiente nodo.
- **Recorrido**: Solo se puede mover hacia adelante desde la cabeza hasta la cola.
- **Nodo Principal**: Primer nodo en la lista, usualmente el único nodo accesible directamente.
- **Nodo final**: Último nodo en la lista, apunta a `None`.

### Operaciones y Complejidades de Tiempo

- **Insertar al principio**: O(1)
- **Insertar al final**: O(n) - debe recorrer hasta el final
- **Insertar en medio**: O(n) - debe recorrer hasta la posición
- **Eliminar desde el principio**: O(1)
- **Eliminar desde el final**: O(n) - debe recorrer para encontrar el nodo anterior
- **Eliminar desde el medio**: O(n) - debe recorrer para encontrar el nodo

### Listas Doblemente Enlazadas

- **Estructura**: Cada nodo tiene datos y dos referencias: nodo siguiente y nodo anterior.
- **Recorrido**: Puede moverse en ambas direcciones.
- **Memoria**: Requiere más memoria que las listas enlazadas simples debido a la referencia adicional.

## Mapas Hash y Sets

### Mapas y Hash Maps

- **Mapa (Tipo Abstracto de Datos)**: Gestiona colecciones de pares clave-valor. Cada clave debe ser única, pero los valores pueden repetirse.

- **Hash Map**: Implementación concreta del ADT map usando la técnica de hashing. Usa una función hash para generar valores hash para las claves, que determinan la ubicación de almacenamiento en el arreglo subyacente.

### Diccionarios de Python (Mapas Hash)

```python
# Creating dictionaries
my_dictionary = {
    "A": 1,
    "B": 2, 
    "C": 3
}

# Alternative creation
my_dictionary = dict(A=1, B=2, C=3)

# Access and modify
value = my_dictionary["A"]  # 1
my_dictionary["A"] = 4      # Update value
del my_dictionary["A"]      # Remove key-value pair

# Check membership
"C" in my_dictionary

# Get keys, values, items
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

### Complejidades de tiempo para Hash Maps

- **Caso promedio**: O(1) para insert, get, delete
- **Peor caso**: O(n) cuando ocurren muchas colisiones de hash

### Conjuntos

- **Conjuntos**: Colecciones no ordenadas de elementos únicos. No se permiten duplicados, no se mantiene un orden específico.

- **Solo elementos inmutables**: Los conjuntos solo pueden contener tipos de datos inmutables (números, cadenas, tuplas) porque los valores hash deben permanecer constantes.

```python
# Creating sets
numbers = {1, 2, 3, 4}
empty_set = set()  # Must use set(), not {}

# Add and remove elements
numbers.add(5)
numbers.remove(4)      # Raises KeyError if not found
numbers.discard(4)     # No error if not found

# Set operations
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

# Union, intersection, difference, symmetric difference
set_a.union(set_b)                    # or set_a | set_b
set_a.intersection(set_b)             # or set_a & set_b
set_a.difference(set_b)               # or set_a - set_b
set_a.symmetric_difference(set_b)     # or set_a ^ set_b

# Subset and superset checks
set_a.issubset(set_b)
set_a.issuperset(set_b)
set_a.isdisjoint(set_b)

# Membership testing
5 in numbers
```

### Complejidades de tiempo para Sets

- **Caso promedio**: O(1) para add, remove, membership testing
- **Peor caso**: O(n) debido a colisiones de hash

## Colisiones de Hash

- **Colisión de Hash**: Ocurre cuando dos claves diferentes producen el mismo valor hash.

- **Estrategias de Resolución de Colisiones**:
  - **Encadenamiento**: Cada índice del arreglo apunta a una lista enlazada que almacena todos los elementos con el mismo valor hash
  - **Open Addressing**: Busca el siguiente índice disponible usando una secuencia predefinida

## Cuándo usar cada estructura de datos

- **Listas**: Cuando necesitas acceso ordenado e indexado y no conoces el tamaño de antemano
- **Pilas**: Para operaciones LIFO (funcionalidad de deshacer, evaluación de expresiones, retroceso)
- **Colas**: Para operaciones FIFO (planificación de tareas, búsqueda en anchura)
- **Listas enlazadas**: Cuando se requiere inserción/eliminación frecuente al inicio, tamaño desconocido, no se necesita acceso aleatorio
- **Mapas Hash**: Para búsquedas rápidas de clave-valor, contar ocurrencias, almacenamiento en caché
- **Conjuntos**: Para verificar unicidad, operaciones matemáticas de conjuntos, eliminar duplicados

## Algoritmos de búsqueda

Los algoritmos de búsqueda te permiten buscar un objetivo dentro de una lista determinada de elementos.

En ciencias de la computación, hay dos algoritmos de búsqueda que debes conocer. Son los algoritmos de **búsqueda lineal** y **búsqueda binaria**. Es importante entender las diferencias entre los dos algoritmos y cuándo usar cada uno.

### Búsqueda Lineal

- La búsqueda lineal itera a través de una lista de elementos, revisando cada elemento desde el principio hasta que se encuentra el elemento objetivo.
- Si se encuentra el elemento objetivo, se devuelve el índice donde está ubicado en la lista.
- Si no se encuentra el objetivo, devuelve `-1`, lo que significa **índice inválido** en la mayoría de los lenguajes de programación.
- Debido a que la búsqueda lineal revisa cada elemento hasta encontrar el objetivo, no es eficiente para una lista grande de elementos.
- La complejidad temporal de la búsqueda lineal es `O(n)` porque el tiempo que tarda en buscar en la lista crece linealmente con el tamaño de la lista.
- La complejidad espacial de la búsqueda lineal es `O(1)` porque no requiere espacio adicional para buscar en la lista.

### Búsqueda Binaria

- La búsqueda binaria funciona dividiendo una lista de elementos a la mitad y verificando si el valor objetivo está en el medio de la lista.
- La condición para que la búsqueda binaria funcione es que los elementos en la lista estén en orden ascendente.
- La búsqueda binaria es un algoritmo más eficiente para buscar en una lista grande de elementos porque divide la lista de elementos a la mitad e ignora cualquier mitad donde no se encuentre el objetivo.
- Si el elemento objetivo se encuentra en medio de la lista, se devuelve el índice del elemento objetivo.
- Si el elemento no se encuentra, el algoritmo verifica si el elemento objetivo está en la mitad izquierda o derecha de la lista.
- Continúa dividiendo las partes restantes de la lista en mitades hasta que se encuentre el elemento objetivo.
- Si el elemento objetivo finalmente no se encuentra en la lista, devuelve `-1`
- La complejidad temporal de la búsqueda binaria es `O(log n)` porque el tiempo que tarda en buscar en la lista crece logarítmicamente con el tamaño de la lista.
- La complejidad espacial de la búsqueda binaria es `O(1)` porque no requiere espacio adicional para buscar en la lista.

### Cómo la búsqueda lineal difiere de la búsqueda binaria

- La búsqueda binaria es más adecuada para una lista grande de elementos en comparación con la búsqueda lineal.
- La complejidad temporal de la búsqueda lineal es `O(n)` porque el tiempo que tarda en buscar en la lista crece linealmente con el tamaño de la lista.
- La complejidad temporal de la búsqueda binaria es `O(log n)` porque el tiempo que tarda en buscar en la lista crece logarítmicamente con el tamaño de la lista.

## Algoritmos de ordenamiento y divide y vencerás

En ciencias de la computación, divide-and-conquer es una técnica usada para descomponer un problema en subproblemas más pequeños para que sean más fáciles de resolver. La recursión es la técnica que se emplea frecuentemente en divide-and-conquer, y divide-and-conquer es una estrategia poderosa usada para implementar muchos algoritmos de ordenamiento eficientes como merge sort.

### Ordenamiento por mezcla

- Merge sort es un algoritmo de ordenamiento que sigue el enfoque de divide y vencerás.
- Funciona dividiendo recursivamente una lista en sublistas más pequeñas hasta que cada sublista contiene solo un elemento.
- Luego fusiona repetidamente las sublistas de nuevo en un orden ordenado.
- La complejidad temporal de merge sort es `O(n log n)` porque la lista se divide continuamente a la mitad `(log n)` y luego se combina `(O(n))`.
- La complejidad espacial de merge sort es `O(n)` porque no es un algoritmo de ordenamiento in-place.

## Resumen de Grafos

Un grafo es un conjunto de nodos (vértices) conectados por aristas (conexiones). Cada nodo puede conectarse a múltiples otros nodos, formando una red. Los diferentes tipos de grafos incluyen:

- Dirigido: los edges tienen una dirección (de un nodo a otro), a menudo representados con líneas rectas y flechas.
- No dirigido: las aristas no tienen dirección, se representan con líneas simples.
- Vértice: cada nodo está asociado a una etiqueta o identificador.
- Cíclico: contiene ciclos (un camino que comienza y termina en el mismo nodo).
- Acrílico (DAG): no contiene ciclos.
- Arista etiquetada: cada arista tiene una etiqueta que generalmente se dibuja junto a la arista correspondiente.
- Ponderado: los edges tienen pesos (valores) asociados que pueden usarse para realizar operaciones aritméticas.
- Desconectado: contiene dos o más nodos que no están conectados por ninguna arista.

Los gráficos se usan en varias aplicaciones como mapas, redes, sistemas de recomendación y resolución de dependencias.

## Recorridos de Grafos

Esto implica visitar todos los nodos en un grafo. Los dos algoritmos principales son:

- **Búsqueda en Anchura (BFS)**
  - Usa una cola.
  - Explora nivel por nivel.
  - Encuentra el camino más corto en grafos no ponderados.

- **Búsqueda en profundidad (DFS)**
  - Usa una pila (o recursión).
  - Explora completamente una rama antes de retroceder.
  - Útil para la detección de ciclos y la búsqueda de rutas.

## Representaciones de Grafos

Los gráficos pueden representarse de dos maneras principales:

- **Lista de Adyacencia**
  - Cada nodo tiene una lista de sus vecinos.
  - Eficiente en espacio para grafos dispersos.
  - Fácil de iterar sobre vecinos.

- **Matriz de Adyacencia**
  - Un arreglo 2D donde las filas y columnas representan nodos.
  - Intensivo en espacio para grafos grandes.
  - Rápido para verificar si existe una arista entre dos nodos.

## Árboles

Un árbol es un tipo especial de grafo que es acíclico y conectado. Las propiedades clave incluyen:

- No tienen bucles ni ciclos (caminos donde los nodos de inicio y fin son los mismos).
- Deben estar conectados (cada nodo puede ser alcanzado desde cualquier otro nodo).

### Tipos comunes de árboles

Los tipos de árboles más comunes son:

- Árboles Binarios
  - Cada nodo tiene como máximo dos hijos, un hijo izquierdo y un hijo derecho.

- Árboles Binarios de Búsqueda (BST)
  - Un árbol binario en el que cada hijo izquierdo es menor que su padre, y cada hijo derecho es mayor que su padre.


## Tries

También conocidos como árboles de prefijos, se usan para almacenar conjuntos de cadenas, donde cada nodo representa un carácter.

Los prefijos compartidos se almacenan solo una vez, lo que los hace eficientes para tareas como autocompletar y corrección ortográfica.

Las operaciones de búsqueda e inserción tienen una complejidad temporal de O(L), donde L es la longitud de la cadena.

## Colas de Prioridad

Una cola de prioridad es un tipo de dato abstracto donde cada elemento tiene una prioridad.

Las colas y pilas consideran solo el orden de inserción, mientras que las colas de prioridad consideran la prioridad de los elementos. 

Las colas estándar siguen FIFO (First In First Out) y las pilas siguen LIFO (Last In First Out). Sin embargo, en una cola de prioridad, los elementos con mayor prioridad se atienden antes que aquellos con menor prioridad, sin importar su orden de inserción.

## Montículos

Es una estructura de datos especializada basada en árboles con una propiedad muy específica llamada heap property. 

La propiedad heap determina la relación entre nodos padre e hijo. Hay dos tipos de heaps:

- Montículo Máximo
  - El valor de cada nodo padre es mayor o igual que los valores de sus hijos.
  - El elemento más grande está en la raíz.

- Montículo mínimo
  - El valor de cada nodo padre es menor o igual que los valores de sus hijos.
  - El elemento más pequeño está en la raíz.

### Ejemplo del módulo `heap` de Python

```py
import heapq

# Create empty heap
my_heap = []

# Insert elements
heapq.heappush(my_heap, 9)
heapq.heappush(my_heap, 3)
heapq.heappush(my_heap, 5)

# Remove smallest element
print(heapq.heappop(my_heap))  # 3

# Push + Pop in one step
print(heapq.heappushpop(my_heap, 2)) # 2

# Transform list into heap
nums = [5, 7, 3, 1]
heapq.heapify(nums)
```

### Uso de Prioridades

```py
my_heap = []
heapq.heappush(my_heap, (3, "A"))
heapq.heappush(my_heap, (2, "B"))
heapq.heappush(my_heap, (1, "C"))

# Removes lowest number = highest priority
print(heapq.heappop(my_heap))  # (1, "C")
```

## Introducción a la Programación Dinámica

- **Definición**: La programación dinámica es una técnica algorítmica que resuelve problemas complejos dividiéndolos en subproblemas más simples y almacenando los resultados para evitar cálculos redundantes.
- **Subproblemas Superpuestos**: Los mismos problemas más pequeños aparecen varias veces al resolver el problema más grande. En lugar de recalcular estos subproblemas repetidamente, almacenamos sus soluciones.
- **Estructura Óptima**: La solución óptima al problema contiene soluciones óptimas a sus subproblemas. Esto significa que podemos construir la mejor solución combinando las mejores soluciones a partes más pequeñas.

## Soluciones de Programación Dinámica

- **Memorización (Enfoque de arriba hacia abajo)**: La memorización almacena los resultados de llamadas a funciones costosas y devuelve el resultado en caché cuando ocurren las mismas entradas nuevamente.

```py
def climb_stairs_memo(n, memo={}):
    """Dynamic programming with memoization"""
    # Check if we've already calculated this value
    if n in memo:
        return memo[n]  # Return cached result - O(1) lookup!
    
    # Base cases
    if n <= 2:
        return n
    
    # Calculate once and store in memo for future use
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    return memo[n]
```

- **Tabulación (Enfoque de abajo hacia arriba)**: La tabulación construye la solución desde la base, llenando una tabla con soluciones a subproblemas.

```py
def climb_stairs_tabulation(n):
    """Dynamic programming with tabulation"""
    if n <= 2:
        return n
    
    # Create array to store results for all steps from 0 to n
    dp = [0] * (n + 1)
    dp[1] = 1  # 1 way to reach step 1
    dp[2] = 2  # 2 ways to reach step 2
    
    # Build up the solution iteratively
    for i in range(3, n + 1):
        # Ways to reach step i = ways to reach (i-1) + ways to reach (i-2)
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

## Aplicaciones del mundo real usando programación dinámica

- **Optimización de Rutas**: Los sistemas GPS usan algoritmos de programación dinámica para encontrar los caminos más cortos entre ubicaciones.
- **Procesamiento de Texto**: Los correctores ortográficos y las funciones de autocompletado a menudo dependen de la programación dinámica para calcular las distancias de edición entre palabras.
- **Modelado Financiero**: Las estrategias de inversión y la optimización de portafolios frecuentemente emplean técnicas de programación dinámica.
- **Asignación de Recursos**: El problema de la mochila y sus variantes aparecen en la programación, presupuestación y gestión de recursos.

## Cuándo usar programación dinámica

Deberías considerar usar programación dinámica en los siguientes escenarios:

- El problema puede dividirse en subproblemas superpuestos.
- El problema exhibe estructura óptima.
- Una solución recursiva ingenua implicaría cálculos repetidos.
- Necesitas optimizar para la complejidad temporal a costa de la complejidad espacial.

# --assignment--

Revise los temas y conceptos de Python.
