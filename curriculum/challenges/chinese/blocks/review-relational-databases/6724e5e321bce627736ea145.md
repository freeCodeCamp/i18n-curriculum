---
id: 6724e5e321bce627736ea145
title: 关系数据库回顾
challengeType: 31
dashedName: review-relational-databases
---

# --description--

## 终端、Shell 和命令行基础

- **命令行**：用户输入命令的文本接口。
- **Terminal**：提供访问命令行的应用。
- **终端模拟器**：为终端添加额外的特色。
- **Shell**：解释输入到终端的命令（例如，Bash）。
- **PowerShell / Command Prompt / Microsoft Terminal**：在 Windows 上访问命令行的选项。
- **Terminal (macOS)**：macOS 上的内置选项，具有 iTerm 或 Ghostty 等第三方备选。
- **终端（Linux）**：选项因发行（版本）而异，许多第三方模拟器如 kitty。
- **术语**：虽然“terminal”、“shell”和“command line”常被交替使用，但它们有特定含义。

## 命令行快捷

- **上/下箭头**：在历史记录中循环浏览前一个/下一个命令。
- **标签（页）**：自动完成命令。
- **`Control+L`**（Linux/macOS）或输入 `cls`（Windows）：清除终端屏幕。
- **`Control+C`**：中止正在运行的命令（如果选中了文本，在 PowerShell 中也用于拷贝）。
- **`Control+Z`**（仅限 Linux/macOS）：将任务挂起到后台；使用 `fg` 恢复它。
- **`!!`**：立即重新运行上一个执行的命令。

## Bash 基础

- **Bash**（Bourne Again Shell）：广泛使用的类 Unix shell。关键命令：

  - **`pwd`**：显示当前目录。
  - **`cd`**：切换目录。
    - **`..`** 指的是父目录（上一级目录）。
    - **`.`** 指当前目录。
  - **`ls`**：列出文件和文件夹。
    - **`-a`**：显示所有文件，包括隐藏文件。
    - **`-l`**：显示关于文件的详细信息。
  - **`less`**：以分页方式查看文件内容，带有包括向后滚动和查找在内的导航选项。
  - **`more`**：一次显示一个屏幕的文件内容，支持有限的向后滚动和基本导航。
  - **`cat`**：一次性显示整个文件内容，无需滚动或导航，适用于较小的文件。
  - **`mkdir`**：创建一个新建目录。
  - **`rmdir`**：删除一个空目录。
  - **`touch`**：创建一个新建文件。
  - **`mv`**：移动或重命名文件。
    - 重命名：`mv oldname.txt newname.txt`
    - 移动：`mv filename.txt /path/to/target/`
  - **`cp`**：拷贝文件。
    - **`-r`**：递归地拷贝目录及其内容。
  - **`rm`**：删除文件。
    - **`-r`**：递归地删除目录及其内容。
  - **`echo`**：显示一行文本或变量的值。
    - 使用 `>` 来覆盖文件中的现有内容。（例如，`echo "text" > file.txt`）
    - 使用 `>>` 将输出追加到文件 **而不覆盖现有内容**（例如，`echo "text" >> file.txt`）。
  - **`exit`**：退出终端会话。
  - **`clear`**：清除终端屏幕。
  - **`find`**：查找文件和目录。
    - **`-name`**：按名称模式查找文件（例如，`find . -name "*.txt"`）。
  - 使用 **`man`** 后跟一个命令（例如，`man ls`）来访问详细的手册/帮助页面。

## 命令选项和标记

- **选项**或**标记**：修改命令的行为，通常以连字符开头：
  - **长形式（两个连字符）**：
    - 示例：`--help`、`--version`
    - 值通过等号附加，例如 `--width=50`。
  - **短形式（一个连字符）**：
    - 示例：`-a`、`-l`
    - 值通过空格传递，例如 `-w 50`。
    - 多个短选项可以串联在一起，例如，`ls -alh`。
- **`--help`**：你总是可以使用带有此标记的命令来了解任何命令的可用选项。

## 关系数据库简介

- **关系数据库**：将数据组织成由行和列组成的相关表格。每行表现一个记录，每列表现数据的一个属性。
- **关系数据库的优势**：可扩展，广泛适用于各个域（例如，医疗、商业、游戏），并且结构化以维护可靠的数据。
- **常见使用分支**：网页开发、库存系统、电子商务、医疗保健和企业应用。

## 密钥概念

- **模式**：关系数据库需要一个模式来定义其结构——表格、列、数据类型、约束和关系。
- **主键**：表格中每行的唯一标识符。它们对于数据完整性至关重要，并用于通过外键关联表格之间的记录。
- **外键**：对另一个表格中主键的引用，用于链接跨表格的相关数据。
- **关系**：通过主键和外键连接表格，你可以构建规范化的数据并执行有意义的查询。
- **实体关系图（ERDs）**：可视化实体（表格）在数据库模式中如何相互关联。
- **数据完整性**：使用密钥和数据类型强制执行。确保保存数据的一致性和准确性。

## SQL 基础

- **查询**：用于从数据库中检索特定数据的请求。

```sql
SELECT * FROM dogs WHERE age < 3;
```

- **WHERE 子句**：根据条件过滤结果。使用比较操作符如 `<`、`=`、`>` 等。
- **使用 ORDER BY 选择**：基于某个列检索并排序结果。

```sql
SELECT columns FROM table_name ORDER BY column_name;
```

## 表格操作

- **`CREATE TABLE` 语句**：此语句用于在数据库中创建新建表格。

```sql
CREATE TABLE first_table();
```

- **`ALTER TABLE ADD COLUMN` 语句**：此语句用于为现有表格添加列。

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE;
```

- **`ALTER TABLE DROP COLUMN` 语句**：此语句用于从现有表格中删除一列。

```sql
ALTER TABLE table_name DROP COLUMN column_name;
```

- **`ALTER TABLE RENAME COLUMN` 语句**：此语句用于重命名表格中的列。

```sql
ALTER TABLE table_name RENAME COLUMN column_name TO new_name;
```

- **`DROP TABLE` 语句**：此语句用于从数据库中删除整个表格。

```sql
DROP TABLE table_name;
```

- **`ALTER DATABASE RENAME` 语句**：此语句用于重命名数据库。

```sql
ALTER DATABASE database_name RENAME TO new_database_name;
```

- **`DROP DATABASE` 语句**：此语句用于删除整个数据库。

```sql
DROP DATABASE database_name;
```

## 约束与数据完整性

- **带约束的 `ALTER TABLE ADD COLUMN`**：此语句用于为现有表格添加带约束的列。

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE CONSTRAINT;
```

- **`NOT NULL` 约束**：此约束确保某个列不能有 NULL 值。

```sql
column_name VARCHAR(50) NOT NULL
```

- **`ALTER TABLE ADD PRIMARY KEY` 语句**：此语句用于为表格添加主键约束。

```sql
ALTER TABLE table_name ADD PRIMARY KEY(column_name);
```

- **`ALTER TABLE DROP CONSTRAINT` 语句**：此语句用于从表格中删除约束。

```sql
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
```

- **`ALTER TABLE ADD COLUMN` 带外键**：此语句用于添加引用另一个表格的外键列。

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE REFERENCES referenced_table_name(referenced_column_name);
```

- **`ALTER TABLE ADD UNIQUE` 语句**：此语句用于为列添加 UNIQUE 约束。

```sql
ALTER TABLE table_name ADD UNIQUE(column_name);
```

- **`ALTER TABLE ALTER COLUMN SET NOT NULL` 语句**：此语句用于为现有列设置 NOT NULL 约束。

```sql
ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL;
```

- **带有 NULL 值的 `INSERT` 语句**：此语句演示如何将 NULL 值插入到表格中。

```sql
INSERT INTO table_name(column_a) VALUES(NULL);
-- or
INSERT INTO table_name(column_b) VALUES('value'); -- if column_a allows nulls
```

- **复合主键**：此约束定义由多个列组成的主键。

```sql
CREATE TABLE course_enrollments (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id)
);
```

## 数据操作（CRUD）

- **`INSERT` 语句**：此语句用于向表格中插入单行。

```sql
INSERT INTO table_name(column_1, column_2) VALUES(value1, value2);
```

- **省略列的 `INSERT` 语句**：此语句演示如何在不显式列出列名的情况下插入值，依赖于表格中的默认列顺序。

```sql
INSERT INTO dogs VALUES ('Gino', 3);
```

- **带有多行的 `INSERT` 语句**：此语句用于在单次操作中将多行插入到表格中。

```sql
INSERT INTO dogs (name, age) VALUES 
('Gino', 3),
('Nora', 2);
```

- **`UPDATE` 语句**：此语句用于根据条件更新表格中现有的数据。

```sql
UPDATE table_name SET column_name=new_value WHERE condition;
```

- **`DELETE` 语句**：此语句用于根据条件从表格中删除行。

```sql
DELETE FROM table_name WHERE condition;
```

## 数据类型

- **`NUMERIC` 数据类型**：此数据类型用于保存具有指定查准率和小数位数的精确十进制数。

```sql
price NUMERIC(10, 2)
```

- **`TEXT` 数据类型**：此数据类型用于保存可变长度且无特定长度限制的字符字串。

```sql
column_name TEXT
```

- **`INTEGER` 数据类型**：此数据类型用于保存没有小数位的整数。

```sql
units_sold INTEGER
```

- **`SMALLINT` 和 `BIGINT` 数据类型**：它们是具有较小和较大范围的 INTEGER 变体。

- **`SERIAL` 数据类型**：此数据类型用于在 PostgreSQL 中创建自动递增的整数列。

```sql
id SERIAL
```

- **`AUTO_INCREMENT` 属性**：此属性用于 MySQL 中创建自增整数列。

```sql
id INT AUTO_INCREMENT
```

- **`VARCHAR` 数据类型**：此数据类型用于保存具有指定最大长度的可变长度字符字串。

```sql
name VARCHAR(50)
```

- **`DATE` 数据类型**：此数据类型用于保存日期值（年、月、日）。

```sql
event_date DATE
```

- **`TIME` 数据类型**：此数据类型用于保存时间值（小时、分钟、秒）。

```sql
start_time TIME
```

- **`TIMESTAMP` 数据类型**：此数据类型用于保存日期和时间值，可选地包含时区信息。

```sql
event_timestamp TIMESTAMP
event_timestamp TIMESTAMP WITH TIME ZONE
```

- **`BOOLEAN` 数据类型**：此数据类型用于保存真/假值。

```sql
is_active BOOLEAN
```

## 数据库关系

- **关系类型**：这些是在关系数据库中表格之间可以相互关联的不同方式。
  - 一对一
  - 一对多
  - 多对一
  - 多对多
  - 自引用（递归的）

- **一对一关系**：这种关系类型意味着一个表格中的每条记录对应另一个表格中的唯一一条记录。

```md
One employee is assigned exactly one vehicle.
Tables: employees, vehicles
```

- **一对多关系**：这种关系类型意味着一个表格中的一条记录可以关联到另一个表格中的多条记录。

```md
One customer can have many orders.
Tables: customers → orders
```

- **通过连接表实现多对多关系**：这种关系类型是通过包含两个相关表的外键的连接表来实现的。

```sql
CREATE TABLE books_authors (
    author_id INT REFERENCES authors(id),
    book_id INT REFERENCES books(id)
);
```

- **自引用关系**：当一个表格引用它自身时，会产生这种关系类型，从而创建层次结构。

```md
An employee table where each employee may report to another employee.
```

## 高级的 SQL（连接）

- **`INNER JOIN` 语句**：此连接仅返回两个表格中具有匹配值的行。

```sql
SELECT *
FROM products
INNER JOIN sales ON products.product_id = sales.product_id;
```

- **`FULL OUTER JOIN` 语句**：此连接返回两个表格中的所有行，包括任一表格中未匹配的行。

```sql
SELECT *
FROM products
FULL OUTER JOIN sales ON products.product_id = sales.product_id;
```

- **`LEFT OUTER JOIN` 语句**：此连接返回左表中的所有行以及右表中匹配的行。

```sql
SELECT *
FROM products
LEFT JOIN sales ON products.product_id = sales.product_id;
```

- **`RIGHT OUTER JOIN` 语句**：此连接返回右表中的所有行以及左表中匹配的行。

```sql
SELECT *
FROM products
RIGHT JOIN sales ON products.product_id = sales.product_id;
```

- **`SELF JOIN` 语句**：此连接用于将表格与其自身连接，以比较同一表格中的行。

```sql
SELECT A.column_name, B.column_name
FROM table_name A
JOIN table_name B ON A.related_column = B.related_column;
```

- **`CROSS JOIN` 语句**：此连接返回两个表的笛卡尔积，将第一个表的每一行与第二个表的每一行组合。

```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

## PostgreSQL 特定命令

- **`psql` 登录命令**：此命令用于使用特定用户名和数据库登录 PostgreSQL。

```bash
psql --username=freecodecamp --dbname=postgres
```

- **`\l` 命令**：此命令列出 PostgreSQL 实例中的所有数据库。

```sql
\l
```

- **`CREATE DATABASE` 和 `\c` 命令**：这些命令用于创建一个新建数据库并连接到它。

```sql
CREATE DATABASE database_name;
\c database_name
```

- **`\d` 命令**：此命令列出当前数据库中的所有表格。

```sql
\d
```

- **`\d table_name` 命令**：此命令显示特定表格的架构/结构。

```sql
\d table_name
```

- **`\q` 命令**：此命令用于退出 PostgreSQL 客户端。

```bash
\q
```

## 关系型与非关系型

- **非关系型（NoSQL）数据库**：保存非结构化或半结构化数据。不需要严格的模式，对不断变化的数据模型更具灵活性。
- **关系型与非关系型的选择**：取决于你的数据和应用需求的性质。
- **关系型与非关系型**：为结构化数据和一致性选择关系型；为灵活性和快速变化的数据选择 NoSQL。

## 流行的 RDBMS 系统

- **MySQL**：开源、可靠、广泛用于网页开发，由庞大的社区支持。
- **PostgreSQL**：开源的、高级的、可扩展的。支持自定义数据类型和服务器端编程。
- **SQLite**：轻量级、基于文件、无服务器。适合小型应用。
- **Microsoft SQL Server**：专有的企业级数据库。
- **Oracle 数据库**：以大规模性能和可扩展性著称的商业关系型数据库管理系统。

## 最佳实践

- **命名规范**：为表格和列名使用 `snake_case`（例如，`delivery_orders`）。

## Bash 脚本基础

- **Bash 脚本**：在一个文件中编写一系列 Bash 命令，然后你可以使用 Bash 来运行该文件的内容。
- **Shebang**：脚本开头的注释行（例如 `#!/bin/bash`），用于指示脚本应使用哪个解释器。

  ```bash
  #!/bin/bash
  ```

- **变量赋值**：使用语法 `variable_name=value` 实例化变量。

  ```bash
  servers=("prod" "dev")
  ```

- **变量创建规则**：使用 `VARIABLE_NAME=VALUE` 语法创建变量。等号（`=`）两边不允许有空格。如果值包含空格，请使用双引号。

  ```bash
  NAME=John
  MESSAGE="Hello World"
  COUNT=5
  TEXT="The next number is, "
  ```

- **变量使用**：通过在变量名之前放置 `$` 来访问变量值。

  ```bash
  echo $NAME
  echo "The message is: $MESSAGE"
  ```

- **变量插值**：使用 `$variable_name` 来访问字串和命令中的变量值。

  ```bash
  TEXT="The next number is, "
  NUMBER=42
  echo $TEXT B:$NUMBER
  echo $TEXT I:$NUMBER
  
  echo "Pulling $server"
  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf
  ```

- **变量作用域**：Shell 脚本从上到下运行，因此变量只能在创建它们的下方使用。

  ```bash
  NAME="Alice"
  echo $NAME
  ```

- **用户输入**：使用 `read` 从用户处接受输入并将其保存到变量中。

  ```bash
  read USERNAME
  echo "Hello $USERNAME"
  ```

- **评论**：使用 `#` 后跟你的评论文本为你的脚本添加评论。
  - 单行评论以 `#` 开头，直到行尾结束
  - 评论会被 shell 忽略，不会影响脚本执行

  ```bash
  # This is a single-line comment
  NAME="John"  # Comment at end of line
  ```

- **多行评论**：使用冒号和引号注释代码块。

  ```bash
  : '
  This is a multi-line comment
  Everything between the quotes is ignored
  Useful for debugging or documentation
  '
  ```

- **内置命令和帮助**：
  - 使用 `help` 查看内置 bash 命令列表
  - 使用 `help <command>` 获取有关特定内置命令的信息
  - 有些命令（如 `if`）是内置的，没有手册页
  - 内置命令由 shell 直接执行，而不是作为外部程序执行
  - 使用 `help function` 查看有关创建函数的信息

  ```bash
  help
  help if
  help function
  ```

- **查找命令位置**：使用 `which` 来定位可执行文件的安装位置。
  - 显示可执行文件的完整路径
  - 有助于查找解释器位置（如 bash）
  - 帮助验证将执行哪个版本的命令

  ```bash
  which bash
  which python
  which ls
  ```

- **手册页**：使用 `man` 访问命令的详细文档。
  - 提供有关命令使用的全面信息
  - 显示所有可用的选项和示例
  - 使用方向键导航，按 'q' 退出
  - 并非所有命令都有手册页（内置命令使用 `help` 代替）

  ```bash
  man echo
  man ls
  man bash
  ```

- **帮助标记**：许多命令支持 `--help` 以快速获取帮助信息。
  - 作为快速引用的手册页备选
  - 显示命令语法和常用选项
  - 并非所有命令都支持此标记（某些可能显示误差）

  ```bash
  ls --help
  chmod --help
  mv --help
  ```

- **Echo 命令选项**：`echo` 命令支持各种选项：
  - `-e` 选项启用对斜线转义的解释
  - `\n` 创建一个新行
  - 只有当值被包含在引用中时，空行才会被打印
  - 有助于创建格式化输出和程序标题

  ```bash
  echo -e "Line 1\nLine 2"
  echo ""
  echo -e "\n~~ Program Title ~~\n"
  echo "Line 1\nLine 2"
  ```

- **脚本参数**：程序可以接受通过 `$` 变量访问的参数。
  - `$*` 打印传递给脚本的所有参数
  - `$@` 打印传递给脚本的所有参数，作为单独的引用字串
  - `$<number>` 按位置访问特定参数（例如，`$1`、`$2`、`$3`）

  ```bash
  echo $*
  echo $@
  echo $1
  echo $2
  ```

## 双重方括弧表达式 `[[ ]]`

- **双方括弧语法**：使用 `[[ ]]` 进行条件式测试和模式匹配。
  - 方括弧内和操作符周围必须有空格
  - 根据测试结果返回退出状态 0（true）或 1（false）

  ```bash
  [[ $variable == "value" ]]
  [[ $number -gt 10 ]]
  [[ -f filename.txt ]]
  ```

- **字串比较操作符**：在 `[[ ]]` 内使用各种操作符比较字串。
  - `==`（相等）：测试两个字串是否一致
  - `!=`（不相等）：测试两个字串是否不同
  - `<`（字典序较小）：按字母顺序进行字串比较
  - `>`（按字典序更大）：按字母顺序的字串比较

  ```bash
  [[ "apple" == "apple" ]]
  [[ "apple" != "orange" ]]
  [[ "apple" < "banana" ]]
  [[ "zebra" > "apple" ]]
  ```

- **数字比较操作符**：使用特定的数字操作符比较数字。
  - `-eq`（相等）：数值相等比较
  - `-ne`（不相等）：数值不相等比较
  - `-lt`（小于）：数字小于比较
  - `-le`（小于或相等）：数值小于或相等比较
  - `-gt`（大于）：数字大于比较
  - `-ge`（大于或相等）：数值大于或相等比较

  ```bash
  [[ $number -eq 5 ]]
  [[ $count -ne 0 ]]
  [[ $age -ge 18 ]]
  [[ $score -lt 100 ]]
  ```

- **逻辑操作符**：使用逻辑操作符组合多个条件。
  - `&&`（且）：两个条件都必须为真
  - `||`（或）：至少有一个条件必须为真
  - `!`（非）：取反条件（使 true 变为 false，false 变为 true）

  ```bash
  [[ $age -ge 18 && $age -le 65 ]]
  [[ $name == "John" || $name == "Jane" ]]
  [[ ! -f missing_file.txt ]]
  ```

- **文件测试操作符**：测试文件属性和存在性。
  - `-e file`：如果 `file` 存在则为真
  - `-f file`：如果 `file` 存在且是常规文件，则为真
  - `-d file`：如果 `file` 存在且是一个目录，则为真
  - `-r file`：如果文件存在且可读取，则为真
  - `-w file`：如果 `file` 存在且可写，则为真
  - `-x file`：如果 `file` 存在且可执行，则为真
  - `-s file`：如果 `file` 存在且大小大于零，则为真

  ```bash
  [[ -e /path/to/file ]]
  [[ -f script.sh ]]
  [[ -d /home/user ]]
  [[ -x program ]]
  ```

- **使用 `=~` 进行模式匹配**：使用正则表达式进行高级的模式匹配。
  - `=~` 操作符启用正则表达式模式匹配
  - 使用正则表达式元字符时，模式不应加引用
  - 支持完整的正则表达式语法
  - 默认情况下区分大小写

  ```bash
  [[ "hello123" =~ [0-9]+ ]]
  [[ "email@domain.com" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
  [[ "filename.txt" =~ \.txt$ ]]
  ```

- **变量存在性测试**：查看变量是否已设置或为空。
  - 测试变量是否为空：`[[ ! $variable ]]`

  ```bash
  [[ ! $undefined_var ]]
  ```

## 双重括号表达式 `(( ))`

- **算术求值**：使用 `(( ))` 进行数学计算和数字比较。
  - 使用 C 风格语法计算算术表达式
  - 变量在双括号内不需要 `$` 前缀
  - 如果结果非零，则返回退出状态 0；如果结果为零，则返回退出状态 1
  - 支持所有标准算术操作符

  ```bash
  (( result = 10 + 5 ))
  (( count++ ))
  (( total += value ))
  ```

- **算术操作符**：`(( ))` 中可用的数学操作符。
  - `+`（加法）：添加两个数字
  - `-`（减法）：用第一个数字减去第二个数字
  - `*`（乘法）：将两个数字相乘
  - `/`（除法）：用第一个数字除以第二个数字（整数除法）
  - `%`（取模）：除法后的余数
  - `**`（乘方）：将第一个数字引起第二个数字的幂

  ```bash
  (( sum = a + b ))
  (( diff = x - y ))
  (( product = width * height ))
  (( remainder = num % 10 ))
  (( power = base ** exponent ))
  ```

- **赋值操作符**：使用算术赋值操作符修改变量。
  - `=`（赋值）：为变量赋值
  - `+=`（添加并赋值）：为变量添加值
  - `-=`（减并赋值）：从变量中减去值
  - `*=`（乘并赋值）：将变量乘以值
  - `/=`（除并赋值）：将变量除以值
  - `%=`（取模并赋值）：将变量赋值为余数

  ```bash
  (( counter = 0 ))
  (( counter += 5 ))
  (( total -= cost ))
  (( area *= 2 ))
  (( value /= 3 ))
  ```

- **自增和自减操作符**：将变量增加或减少 1。
  - `++variable`（前置递增）：使用前递增
  - `variable++`（后置递增）：使用后递增
  - `--variable`（前置递减）：使用前递减
  - `variable--`（后置递减）：使用后递减

  ```bash
  (( ++counter ))
  (( index++ ))
  (( --remaining ))
  (( attempts-- ))
  ```

- **比较操作符**：使用算术比较来比较数字。
  - `==`（相等）：数字相等
  - `!=`（不相等）：数字不相等
  - `<`（小于）：第一个数字小于第二个数字
  - `<=`（小于或相等）：第一个数字小于或相等于第二个数字
  - `>`（大于）：第一个数字大于第二个数字
  - `>=`（大于或相等）：第一个数字大于或相等于第二个数字

  ```bash
  (( age >= 18 ))
  (( score < 100 ))
  (( count == 0 ))
  (( temperature > freezing ))
  ```

- **逻辑操作符**：组合算术条件。
  - `&&`（且）：两个条件都必须为真
  - `||`（或）：至少有一个条件必须为真
  - `!`（非）：取反条件

  ```bash
  (( age >= 18 && age <= 65 ))
  (( score >= 90 || extra_credit > 0 ))
  (( !(count == 0) ))
  ```

- **按位操作符**：对整数执行位级操作。
  - `&`（按位与）：对每个位执行 AND 操作
  - `|`（按位 OR）：对每个位执行 OR 操作
  - `^`（按位异或）：对每个位执行异或操作
  - `~`（按位非）：反转所有位
  - `<<`（左移）：将位向左移动
  - `>>`（右移）：将位向右移动

  ```bash
  (( result = a & b ))
  (( flags |= new_flag ))
  (( shifted = value << 2 ))
  ```

- **条件式（三元）操作符**：使用 `condition ? true_value : false_value` 语法。
  - 提供一种基于条件赋值的简洁方法
  - 类似于 C 风格语言中的三元操作符
  - 评估条件并返回两个值之一

  ```bash
  (( result = (score >= 60) ? 1 : 0 ))
  (( max = (a > b) ? a : b ))
  (( sign = (num >= 0) ? 1 : -1 ))
  ```

- **带算术的命令代换**：使用 `$(( ))` 来捕捉算术结果。
  - 返回算术表达式的结果作为字串
  - 可用于赋值或命令参数
  - 适用于需要在其他地方使用的计算

  ```bash
  result=$(( 10 + 5 ))
  echo "The answer is $(( a * b ))"
  array_index=$(( RANDOM % array_length ))
  ```

## 控件流程和条件式

- **条件式语句**：使用 `if` 语句根据条件执行代码。
  - 基本语法：`if [[ CONDITION ]] then STATEMENTS fi`
  - 完整语法：`if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`
  - 可以同时使用 `[[ ]]` 和 `(( ))` 表达式来表示不同类型的条件
  - **elif (else if)**：可选的，可以重复多次以按序列测试附加条件
  - **else**：可选的，当所有先前条件均为假时执行
  - 可以在同一条件式链中混合使用双括号 `(( ... ))` 和双方括弧 `[[ ... ]]`

  ```bash
  if (( NUMBER <= 15 ))
  then
      echo "B:$NUMBER"
  elif [[ $NUMBER -le 30 ]]
  then
      echo "I:$NUMBER"
  elif (( NUMBER < 46 ))
  then
      echo "N:$NUMBER"
  elif [[ $NUMBER -lt 61 ]]
  then
      echo "G:$NUMBER"
  else
      echo "O:$NUMBER"
  fi
  ```

## 命令执行和进程控件

- **命令分隔**：使用分号（`;`）在一行上运行多个命令。
  - 命令从左到右循序执行
  - 每个命令的退出状态可以单独查看

  ```bash
  [[ 4 -ge 5 ]]; echo $?
  ls -l; echo "Done"
  ```

- **退出状态**：每个命令都有一个退出状态，用于指示成功或失败。
  - 使用 `$?` 访问上一个命令的退出状态
  - 退出状态 `0` 表示成功（true/无误差）
  - 任何非零的 `exit` `status` 表示失败（发生了假/误差）
  - 常见误差代码：`127`（未找到命令）、`1`（通用的误差）

  ```bash
  echo $?
  [[ 4 -le 5 ]]; echo $?
  ls; echo $?
  bad_command; echo $?
  ```

- **子 Shell 和命令代换**：括号在执行上下文中的不同用法。
  - 单个括号 `( ... )` 创建一个子 shell
  - `$( ... )` 执行命令代换
  - 子 shell 在独立的环境中运行，不会影响父 shell 的变量。

  ```bash
  ( cd /tmp; echo "Current dir: $(pwd)" )
  current_date=$(date)
  file_count=$(ls | wc -l)
  echo "Today is $current_date"
  echo "Found $file_count files"
  ```

- **Sleep 命令**：暂停脚本执行指定秒数。
  - 适用于在脚本中创建延迟
  - 可用于小数值的亚秒延迟

  ```bash
  sleep 3
  sleep 0.5
  sleep 1
  ```

## 循环

- **While 循环**：当条件为真时重复执行代码。
  - 语法：`while [[ CONDITION ]] do STATEMENTS done`

  ```bash
  I=5
  while [[ $I -ge 0 ]]
  do
      echo $I
      (( I-- ))
      sleep 1
  done
  ```

- **直到循环**：重复执行代码直到条件变为真。
  - 语法：`until [[ CONDITION ]] do STATEMENTS done`

  ```bash
  until [[ $QUESTION =~ \?$ ]]
  do
      echo "Please enter a question ending with ?"
      read QUESTION
  done
  until [[ $QUESTION =~ \?$ ]]
  do
      GET_FORTUNE again
  done
  ```

- **For 循环**：使用带有 `do` 和 `done` 的 `for` 循环迭代数组或列表，以定义循环的逻辑块。

  ```bash
  for server in "${servers[@]}"
  do
      echo "Processing $server"
  done
  for (( i = 1; i <= 5; i++ ))
  do
      echo "Number: $i"
  done
  for (( i = 5; i >= 1; i-- ))
  do
      echo "Countdown: $i"
  done
  for i in {1..5}
  do
      echo "Count: $i"
  done
  ```

## 数组

- **数组**：在单个变量中保存多值。
  - 使用括号创建数组：`ARRAY=("value1" "value2" "value3")`
  - 通过索引访问元素：`${ARRAY[0]}`、`${ARRAY[1]}`
  - 访问所有元素：`${ARRAY[@]}` 或 `${ARRAY[*]}`
  - 数组索引从 0 开始

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Ask again later")

  echo ${RESPONSES[0]}     # Yes          
  echo ${RESPONSES[1]}     # No         
  echo ${RESPONSES[5]}     # Index 5 doesn't exist; empty string              
  echo ${RESPONSES[@]}     # Yes No Maybe Ask again later   
  echo ${RESPONSES[*]}     # Yes No Maybe Ask again later 
  ```

- **使用 declare 进行数组检查**：使用 `declare -p` 查看数组详情。
  - 显示带有 `-a` 标记的数组类型
  - 显示所有数组元素及其结构

  ```bash
  ARR=("a" "b" "c")
  declare -p ARR # ARR=([0]="a" [1]="b" [2]="c")
  ```

- **数组展开**：使用 `"${array_name[@]}"` 语法将数组展开为单个元素。

```bash
for server in "${servers[@]}"
```

## 函数

- **函数**：创建可重用的代码块。
  - 用 `FUNCTION_NAME() { STATEMENTS }` 定义
  - 通过使用函数名进行调用
  - 可以接受作为 `$1`、`$2` 等访问的参数。

  ```bash
  GET_FORTUNE() {
      echo "Ask a question:"
      read QUESTION
  }
  GET_FORTUNE
  ```

- **函数参数**：函数可以像脚本一样接受参数。
  - 调用函数时传递参数
  - 使用 `$1`、`$2` 等访问函数内的参数。
  - 使用条件式来处理不同的参数

  ```bash
  GET_FORTUNE() {
      if [[ ! $1 ]]
      then
          echo "Ask a yes or no question:"
      else
          echo "Try again. Make sure it ends with a question mark:"
      fi
      read QUESTION
  }
  GET_FORTUNE
  GET_FORTUNE again
  ```

## 随机数和数学操作

- **随机数**：使用 `$RANDOM` 变量生成随机值。
  - `$RANDOM` 生成 0 到 32767 之间的数字
  - 使用取模操作符限制范围：`$RANDOM % 75`
  - 为避免为零添加 1：`$(( RANDOM % 75 + 1 ))`
  - 必须使用 `$(( ... ))` 语法进行带有 `$RANDOM` 的计算

  ```bash
  NUMBER=$(( RANDOM % 6 ))
  DICE=$(( RANDOM % 6 + 1 ))
  BINGO=$(( RANDOM % 75 + 1 ))
  echo $(( RANDOM % 10 ))
  ```

- **随机数组访问**：使用随机数随机访问数组元素。
  - 在数组边界内生成随机索引
  - 使用随机索引访问数组元素
  - 适用于从预定义选项中随机选择

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Outlook good" "Don't count on it" "Ask again later")
  N=$(( RANDOM % 6 ))
  echo ${RESPONSES[$N]}
  ```

- **取模操作符**：使用 `%` 获取除法操作的余数。
  - 限制随机数范围的关键
  - 与 `$RANDOM` 一起使用以创建有边界的随机值
  - `RANDOM % n` 给出从 0 到 n-1 的数字

  ```bash
  echo $(( 15 % 4 ))
  echo $(( RANDOM % 100 ))
  echo $(( RANDOM % 10 + 1 ))
  ```

## 环境和系统信息

- **环境变量**：在 shell 环境中可用的预定义变量。
  - `$RANDOM`：生成 0 到 32767 之间的随机数
  - `$LANG`：系统语言设置
  - `$HOME`：用户的主目录路径
  - `$PATH`：用于查找可执行命令的目录
  - 使用 `printenv` 或 `declare -p` 查看全部

  ```bash
  echo $RANDOM
  echo $HOME
  echo $LANG
  printenv
  ```

- **变量检查**：使用 `declare` 来查看和操作变量。
  - `declare -p`：打印所有变量及其值
  - `declare -p VARIABLE`：打印特定变量的详细信息
  - 显示变量类型（字串、数组等）和属性

  ```bash
  declare -p
  declare -p RANDOM
  declare -p MY_ARRAY
  ```

- **命令类型**：bash 中可用的不同类别的命令。
  - **内置命令**：由 shell 直接执行（例如，`echo`、`read`、`if`）
  - **外部命令**：系统目录中的二进制文件（例如，`ls`、`sleep`、`bash`）
  - **Shell 关键字**：语言构造（例如，`then`、`do`、`done`）
  - 使用 `type <command>` 查看命令的类型

  ```bash
  type echo
  type ls
  type if
  type ./script.sh
  ```

## 文件创建与管理

- **文件创建**：使用 `touch` 创建新的空文件。
  - 如果不存在，则创建新建 `file`
  - 如果 `file` 已经存在，则更新 `timestamp`
  - 常用于在编辑前创建脚本文件

  ```bash
  touch script.sh
  touch bingo.sh
  touch filename.txt
  ```

## 创建和运行 Bash 脚本

- **脚本执行方法**：多种运行 bash 脚本的方式：
  - **`sh scriptname.sh`**：使用 sh 解释器运行。
  - **`bash scriptname.sh`**：使用 bash 解释器运行。
  - **`./scriptname.sh`**：直接执行（需要可执行权限）。

```bash
sh questionnaire.sh
bash questionnaire.sh
./questionnaire.sh
```

## 文件权限和脚本执行

- **权限被拒绝误差**：当使用 `./scriptname.sh` 时，如果该文件缺少可执行权限，你可能会收到“permission denied”。
- **查看权限**：使用 `ls -l` 查看文件权限。

  ```bash
  ls -l questionnaire.sh
  ```

- **权限形式**：输出显示权限为 `-rw-r--r--`，其中：
  - 第一个字符（`-`）：文件类型（`-` 表示普通文件，`d` 表示目录）
  - 接下来的 9 个字符：所有者、组和其他的权限
  - `r` = 读取，`w` = 写入，`x` = 执行
  
- **添加可执行权限**：使用 `chmod +x` 为所有人添加可执行权限。

  ```bash
  chmod +x questionnaire.sh
  ```

- **脚本组织**：结构化 bash 脚本的最佳实践。
  - 以 shebang (`#!/bin/bash`) 开始
  - 添加关于脚本用途的描述性评论
  - 在顶部定义变量
  - 将相关函数分组
  - 主脚本逻辑在底部

  ```bash
  #!/bin/bash
  NAME="value"
  ARRAY=("item1" "item2")
  my_function() {
      echo "Function code here"
  }
  my_function
  echo "Script complete"
  ```

- **循序的脚本执行**：创建运行多个程序的主脚本，按序列执行。
  - 适用于自动化涉及多个脚本的工作流
  - 每个脚本运行完成后，下一个脚本才开始运行
  - 可以将不同的程序组合成单一的执行流程
  - 可以根据需要将参数传递给各个脚本
  - 可以包含不同类型的程序（交互式、自动化等）。

  ```bash
  #!/bin/bash
  ./setup.sh
  ./interactive.sh
  ./processing.sh
  ./cleanup.sh
  ```

## 数据库归一化

这是组织关系数据库以减少数据冗余并提高完整性的过程。

它的优点包括：

- 最小化重复的 `data`，这可以节省 `storage` 并减少不一致性。
- 通过使用主键和外键来强制执行数据完整性。
- 让数据库更易于维护和理解。

### 范式

- **1NF（第一范式）**
  - 每个单元格包含一个单一的（原子的）值。
  - 每个记录都是唯一的（由主键强制执行）。
  - 行/列的顺序无关紧要。
  - 示例：将多个电话号码从 `students` 表格移动到单独的 `student_phones` 表格中。

- **2NF（第二范式）**
  - 满足 1NF 要求。
  - 没有**部分依赖**：每个非主键属性必须依赖于整个复合主键。
  - 示例：将 `orders` 表格拆分为 `order_header` 和 `order_items`，以避免属性仅依赖于部分密钥。

- **3NF（第三范式）**
  - 满足 2NF 要求。
  - 没有**传递依赖**：非关键属性不能依赖于其他非关键属性。
  - 示例：将 `city_postal_code` 移动到 `cities` 表格，而不是与每个订单一起存储。

- **BCNF（Boyce-Codd 范式）**
  - 满足 3NF 要求。
  - 每个决定因素（函数依赖的左侧）必须是超键。

**提示**：在大多数设计中，目标是达到 3NF，以实现完整性和性能的良好平衡。

## 关键 SQL 概念

- SQL 是一种用于与关系数据库通信的结构化查询语言。
- **基本命令** → `SELECT`、`INSERT`、`UPDATE`、`DELETE`、`CREATE TABLE`、`ALTER TABLE` 等。
- `Joins` → 组合来自多个表格的 数据（`INNER JOIN`、`LEFT JOIN`、`RIGHT JOIN`、`FULL JOIN`）。

## 在 Bash 中运行 SQL 命令

你可以使用 PostgreSQL 的 `psql` 命令行客户端或其他数据库的类似工具直接从命令行运行 SQL 命令。

例如，要在 PostgreSQL 中运行一个 SQL 文件：

```bash
psql -U username -d database_name -c "SELECT * FROM students;"
```

你也可以直接执行 MySQL 命令：

```bash
mysql -u username -p database_name -e "SELECT * FROM students;"
```

### 从文件运行 SQL

```bash
# PostgreSQL
psql -U username -d database_name -f script.sql

# MySQL
mysql -u username -p database_name < script.sql
```

### 在 Bash 脚本中嵌入 SQL

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Insert student data
psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'CS');"
```

### SQL 中变量的使用

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"
STUDENT_NAME="Bob"
AGE=21

psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age) VALUES ('$STUDENT_NAME', $AGE);"
```

**提示**：清理变量以避免 SQL 注入。

## 在 Bash 中检索和使用 SQL 查询结果

当你通过 `psql` 运行 SQL 查询时，你可以在你的 Bash 脚本中**捕捉**并**处理**返回的值。

### 捕获单个值

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get total student count
STUDENT_COUNT=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -c \
"SELECT COUNT(*) FROM students;")

echo "Total students: $STUDENT_COUNT"
```

输出 → 42

### 检索多个列

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get top 3 students' names and ages
RESULTS=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, age FROM students LIMIT 3;")

echo "Top 3 students:"
echo "$RESULTS"
```

输出

```bash
Alice,20
Bob,21
Charlie,22
```

### 循环遍历查询结果

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# Get student names and majors
psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, major FROM students;" | while IFS="," read -r name major
do
    echo "Student: $name | Major: $major"
done
```

输出形状

```bash
Student: Alice | Major: CS
Student: Bob   | Major: Math
Student: Carol | Major: Physics
```

## SQL 注入

这是一种网络安全漏洞，攻击者将恶意 SQL 代码插入到输入字段中以操纵数据库。

这可能导致诸如以下的高风险操作：

- 绕过认证。
- 窃取敏感数据。
- 修改或删除记录。

SQL 注入攻击的示例：

```sql
SELECT * FROM users WHERE username = ' " " OR "1"="1" -- ' AND password = 'anything';
```

此查询将返回所有用户，因为条件 `OR "1"="1"` 始终为真，允许攻击者绕过登录检查。

### 防止 SQL 注入

1. **使用预处理语句**：这些将 SQL 代码与数据分开，防止注入。以下是一个示例（Node.js 使用 pg）：

    ```sql
    client.query('SELECT * FROM users WHERE username = $1 AND password = $2', [username, password]);
    ```

2. **输入验证**：清理并验证所有用户输入，以确保它们符合预期的形式。

3. **最小权限**：使用具有应用所需最低权限的数据库账户。

**注意**：切勿授予应用账户管理员权限。

## N+1 问题

当一个应用发出一个查询以检索一个包含 N 个项的列表，然后对每个项发出额外的查询以检索相关数据时，就会发生 N+1 问题，导致总共发出 N+1 个查询。

**为什么这很糟糕**

- 每个查询都会添加网络和处理额外开销。
- 多个小查询比一个优化的查询更慢。

### N+1 模式示例

```sql
-- 1: Get list of orders
SELECT * FROM orders LIMIT 50;

-- N: For each order, get customer
SELECT * FROM customers WHERE customer_id = ...;
```

**方案**：使用 `JOINs` 或其他基于集合的操作。

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name,
  customers.email,
  customers.address
FROM orders
JOIN customers 
  ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50);
```

始终寻找将相关数据合并到单个查询中的机会。

## 版本控件简介

- **定义**：版本控制系统允许你跟踪和管理你项目中的更改。软件中使用的版本控制系统示例有 Git、SVN 或 Mercurial。

## 基于云的版本控制提供商

- **基于云的版本控制提供商列表**：GitHub 和 GitLab 是流行的基于云的版本控制提供商示例，允许软件团队协作并管理代码库。

## 安装和设置 Git

- **安装 Git**：要查看你的机器上是否已经安装了 Git，你可以在终端中运行以下命令：

```sh
git --version
```

如果你看到版本号，说明已安装 Git。如果没有，则需要安装它。

对于 Linux 系统，Git 通常随大多数发行版预装。如果你没有预装 Git，你应该能够使用你的包管理器命令安装它，例如 `sudo apt-get install git` 或 `sudo pacman -S git`。

对于 Mac 用户，你可以通过 Homebrew 使用 `brew install git` 来安装 Git，或者你可以从 Git 的网站下载可执行安装程序。

对于 Windows，你可以从 Git 的网站下载可执行安装程序。或者，如果你已经设置了 Chocolatey，你可以在 PowerShell 中运行 `choco install git.install`。请注意，在 Windows 上，你可能还想下载 Git Bash，以便拥有类似 Unix 的 shell 环境。

为了确保安装成功，请在终端中再次运行 `git --version` 命令。

- **Git 配置**：`git config` 用于设置负责 Git 在你的机器上如何运行的配置变量。要查看你当前的设置变量以及它们在系统中的存储位置，你可以运行以下命令：

```sh
git config --list --show-origin
```

现在如果你是第一次安装 Git，应该只看到系统级别的配置设置。 

要设置你的用户名，你可以运行以下命令：

```sh
git config --global user.name "Jane Doe"
```

这里使用 `--global` 标记来设置系统中所有使用 Git 的项目的用户名。如果你需要为特定项目覆写用户名，则可以在该特定项目目录中运行命令而不使用 `--global` 标记。

要设置用户电子邮件地址，你可以运行以下命令：

```sh
git config --global user.email janedoe@example.com
```

你还可以设置的另一个配置是你希望 Git 使用的首选编辑器。下面是如何将你的首选编辑器设置为 Emacs 的示例：

```sh
git config --global core.editor emacs
```

如果你选择不设置首选编辑器，那么 Git 将使用你系统的默认编辑器。

## 开源软件与闭源软件

- **定义**：“开源”意味着人们可以查看你发布的代码、提出更改建议、报告问题，甚至运行修改后的版本。“闭源”意味着唯一可以查看和操作该项目的人是你显式授权的人。

## GitHub

- **定义**：GitHub 是一个基于云的方案，提供名为“repositories”的版本控制项目存储，并启用与这些项目一起使用的协作特色。
- **GitHub CLI**：此工具用于在不离开命令行的情况下执行 GitHub 特定的任务。如果你尚未安装，可以从 GitHub 的文档中获取安装说明——但你应该在系统的包管理器中能找到它。
- **GitHub Pages**：GitHub Pages 是部署静态站点或不需要后端服务器来处理逻辑的应用的一个选项。也就是说，完全在客户端或用户浏览器中运行的应用可以完全部署在这个平台上。
- **GitHub Actions**：GitHub Actions 是一个特色，允许你直接在你的 GitHub 仓库中自动化工作流，包括创建、测试和部署你的代码。

## 常用 Git 命令

- **`git init`**：这将初始化一个空的 Git 仓库，以便 Git 可以开始跟踪该项目的更改。当你为一个项目初始化一个空的 Git 仓库时，会添加一个新的 `.git` 隐藏目录。该 `.git` 目录包含 Git 管理你的项目的重要信息。
- **`git status`**：此命令用于显示你工作目录的当前状态——你将在工作流程中频繁使用此命令。
- **`git add`**：此命令用于暂存你的更改。暂存区中的任何内容都将被添加到下一次提交中。如果你想暂存所有未暂存的更改，可以使用 `git add .`。句点（`.`）是你当前所在目录的别名。
- **`git commit`**：此命令用于提交你的更改。提交是你在特定时间点项目状态的屏幕截图。如果你运行 `git commit`，它将打开你在 Git 配置中设置的首选编辑器。编辑器打开后，你可以提供详细的更改消息。你也可以选择使用 `git commit -m` 命令来提供较短的消息，如下所示：

```sh
git commit -m "short message goes here"
```

- **`git log`**：这将列出所有之前的提交，包含作者、提交日期、提交消息和提交哈希等有用信息。提交哈希是一个长字串，用作提交的唯一标识符。
- **`git remote add`**：此命令用于设置到你的远程仓库的远程连接。
- **`git push`**：此命令用于将你的更改推送到远程仓库。
- **`git pull`**：此命令用于将远程仓库中的最新更改拉取到你的局部仓库中。
- **`git clone`**：此命令将克隆一个仓库。这意味着你将拥有该仓库的一个拷贝。此拷贝包括仓库历史记录、所有文件/文件夹和提交，保存在你的局部设备上。
- **`git remote -v`**：此命令将显示与你的局部 `Git` 仓库关联的远程仓库列表。
- **`git branch`**：此命令将列出你所有的局部的分支。
- **`git fetch upstream`**：此命令告诉 Git 获取你上游远程（即原始仓库）上的最新更改。
- **`git merge upstream/main`**：此命令告诉 Git 将上游远程的 `main` 分支中的最新更改合并到你当前的分支。
- **`git reset`**：此命令允许你重置分支的当前状态。传递 `--hard` 标记会告诉 Git 迫使局部的文件匹配分支状态。这确保你有一个干净的起点进行工作。
- **`git rebase`**：Git 中的 rebase 是将一系列提交从一个分支移动或合并到另一个分支的方法。
  
## 使用分支

- **定义**：Git 中的分支是一个独立的工作区，你可以在其中进行更改。`main` 分支通常表现为真实应用中的主分支或生产分支。开发团队会为新特色和错误修复创建多个分支，然后将这些更改合并回 `main` 分支。
- **创建新分支**：要创建新分支，你可以运行以下命令：

```sh
git branch feature
```

要检出该分支，你可以运行以下命令：

```sh
git checkout feature
```

大多数开发者会使用用于创建和切换分支的简写 `Command`，如下所示：

```sh
git checkout -b new-branch-name
```

一个更新且备选的命令是 `git switch` 命令。以下是创建并切换到一个新建分支的示例：

```sh
git switch -c new-branch-name
```

- **分支策略**：你的 `main` 分支是你的默认分支，通常相当稳定。所以最好从那里分支出来，为错误修复、新建特色或其他杂项工作创建新分支。
- **合并冲突**：当 Git 尝试自动合并来自不同分支的更改但无法决定保留哪些更改时，会发生这种情况。通常发生在同一文件部分存在冲突更改时。

## Git 跟踪的文件的五种状态

- **“Untracked”**：这意味着该文件是仓库中新建的，且 Git 之前未“见过”它。
- **"Modified"**：此文件存在于上一个提交中，且有未提交的更改。
- **"Ignored"**：你可能不会在 Git 中看到被忽略的文件，但你的 IDE 可能会有相应的指示。被忽略的文件被排除在 Git 操作之外，通常是因为它们包含在 `.gitignore` 文件中。
- **“Deleted”**：已删除的 `file` 是未跟踪 `file` 的相反——它是之前存在但已被移除的 `file`。
- **“重命名”**：重命名的文件是指内容未更改，但文件的名称或位置被修改的文件。在某些情况下，即使文件有少量更改，也可以视为重命名。

## `.gitignore` 文件

- **定义**：`.gitignore` 文件是一种与 Git 操作相关的特殊类型文件。名称表明该文件用于告诉 Git 忽略某些内容，这也是常见的用例。但它实际上是告诉 Git 停止跟踪某个文件。

## 使用仓库

- **定义**：仓库就像一个项目的容器——如果你正在开发一个应用程序，你会将该应用程序的文件保存在一个仓库中。仓库可以是你计算机上的局部的，也可以是像 GitHub 这样的服务上的远程仓库。
- **公共仓库与私有仓库**：公共仓库可以被任何人查看和下载。私有仓库只能被你和你显式授予访问权限的任何人访问。
- **在 GitHub 上创建仓库**：要在 GitHub 上创建一个新仓库，你可以点击 `"New Repository"` 按钮，然后按照 GitHub 的界面步骤设置新仓库。
- **将局部的仓库推送到 GitHub**：如果你在你的计算机上有一个局部的项目，你可以将该仓库推送到 GitHub。以下是该进程的逐步概述：

1. 在项目目录中初始化一个空的 git 仓库（`git init`）。
2. 对你的项目进行更改。
3. 运行 `git status` 命令以查看所有被 git 跟踪的更改。
4. 暂存你的更改（`git add`）。
5. 提交你的更改（`git commit`）。
6. 设置远程连接（`git remote add`）。
7. 将你的更改推送到 GitHub（`git push`）。

## 拉取请求

- **拉取请求**：拉取请求是将更改从你的分支拉取到目标分支的请求。拉取请求是你想为项目贡献代码更改时使用的流程。这种方法允许项目维护者审查你的更改。他们可以留下评论、提出问题并建议调整。然后，一旦审查过程完成，它可以被批准并合并到主分支。

## 为其他仓库贡献

- **进程**：有成千上万个项目你可以贡献。以下是如何为另一个仓库贡献的基本进程：

1. 读取贡献文档
2. 查找一个可处理的问题
3. 派生该仓库
4. 克隆你分叉的仓库拷贝
5. 创建一个新建分支
6. 根据该问题进行更改
7. 创建一个 PR（Pull Request）
8. 等待对该 PR 的审核

## 使用 SSH 和 GPG 密钥

- **GPG 密钥**：GPG，或称 Gnu Privacy Guard，密钥通常用于对文件或提交进行签名。然后，其他人可以使用你的公用 GPG 密钥来验证文件签名是否来自你的密钥，以及文件内容是否未被修改或篡改。

要生成 GPG 密钥，你需要运行：

```sh
gpg --full-generate-key
```

- **SSH 密钥**：SSH，或称安全外壳，密钥通常用于通过 `ssh` 工具验证到服务器的远程连接。你也可以使用 SSH 密钥来签署提交。

对于 SSH 密钥，你将运行：

```sh
ssh-keygen -t ed25519 -C "your_email@example.com"
```

`ed25519` 是一种现代公钥签名算法。

- **使用 GPG 密钥签署提交**：为了使用你的 GPG 密钥签署提交，你需要将你的公钥上传到你的 GitHub 账户，而不是私钥。要列出你的公钥，你需要运行以下命令：

```sh
gpg --list-secret-keys --keyid-format=long
```

然后，要获取公钥，请使用：

```sh
gpg --armor --export "<key id>"
```
  
然后，使用从列出密钥中获得的短 ID 运行此命令，将其设置为你的 git 签名密钥：

```sh
git config --global user.signingkey <your_gpg_key_id>
```

然后，你可以将 `-S` 标记传递给你的 `git commit` 命令以签署特定的提交——你需要提供你的密码短语。备选地，如果你想自动签署每个提交，你可以将 autosign 配置设置为 `true`：

```sh
git config --global commit.gpgsign true
```

- **使用 SSH 密钥对提交进行签名**：要使用 SSH 密钥进行签名，这是 GitHub 上一个相对新建的特色，你需要先将密钥上传到你的 GitHub 账户。然后你需要为 git 设置使用 SSH 的签名模式：

```sh
git config --global gpg.format ssh
```

然后，要设置签名密钥，你将传递文件路径而不是 ID：

```sh
git config --global user.signingkey <path_to_your_ssh_keys>
```

# --assignment--

复习 Bash、SQL 及其他关系数据库主题和概念。
