---
id: 67d3018062fe6ba92b7d8299
title: TypeScript 中不同型別如何運作？
challengeType: 19
dashedName: how-do-the-different-types-work-in-typescript
---

# --description--

你已經在上一課看到過一個：`string[]`，它表述一個字串的陣列。但這到底是如何運作的？

對於原始資料型別 `string`、`null`、`undefined`、`number`、`boolean` 和 `bigint`，TypeScript 提供對應的型別關鍵字。在我們的範例中，我們使用這些型別來註解我們的變數：

```js
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

現在，我們已經明確地宣告 `str` 為 `string`－這可能看起來有點混淆，因為我們已經為它指定了一個字串值，但這個註解確保我們不能將不同的值型別（例如數字）重新指定給該變數。

那陣列和物件呢？你已經看過陣列的語法了！你可以用兩種不同的語法定義特定型別的陣列：

```js
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

基本上，這兩種語法是相同的，兩者之間的選擇通常是偏好的問題。

物件變得稍微複雜一些。你可以定義物件的精確結構：

```js
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

這個語法表示屬性 `a` 必須永遠是字串，屬性 `b` 必須永遠是數字，且你不能新增或移除屬性。

但是也許你不想限制這些屬性？也許你想要一個擁有任意鍵的物件，但所有值都必須是字串。你可以用兩種方法做到這點：

```js
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

像陣列型別一樣，這些基本上是相似的。對於這些物件型別，你必須定義鍵的型別和值的型別。鍵必須永遠是字串，但你可以定義訂製字串型別來進一步限制那些鍵。

除了這些類型之外，TypeScript 還提供另外四種有用的類型。第一種是 `any`，它顯示該值可以有任何類型。這實際上是 TypeScript 的 Konami Code——它告訴編譯器停止關注該變數的類型，讓你可以隨意操作。

第二種是 `unknown`，通常比 `any` 更受推薦。`unknown` 型別告訴 TypeScript 你確實在意該值的型別，但你實際上不知道它是什麼。如果你接著嘗試執行特定型別的操作（例如減法運算子，或使用 `slice()` 方法來執行特定的字串操作），TypeScript 會期望你先縮小該值的型別。你將在接下來的課程中學習更多關於型別縮小的內容。

第三種是 `void`。這是一種特殊的型別，你通常只會在定義函式時使用。它實際上是 `any` 的相反——它表述完全沒有任何型別。沒有返回值的函式，例如 `console.log()`，其返回型別為 `void`。

最後，還有 `never` 型別。這大概是你不常使用的東西－它表現一種永遠不會存在的型別。 例如，在你的測試套件中將一個模擬物件傳遞給函式，可能是使用 `never` 的好例子，用來顯示這樣的物件永遠不會真正被傳遞給該函式。

在這些類型的基礎上，你可以存取 `type` 關鍵字。這個關鍵字類似於 `const`，但你不是宣告變數，而是可以宣告一個型別：

```js
type myString = string;
```

這本身看起來可能不是非常有用，但當與聯集（數學）型別結合時，它就變得強大。聯集（數學）型別允許你將兩個或更多型別合併成一個。以下是一個範例：

```js
type stringOrNumber = string | number;
```

我們的 `stringOrNumber` 型別符合字串和數字的值。你接著可以將你的型別與其他型別結合，例如陣列：

```js
const stuff: stringOrNumber[] = ["a", 2, "c", 1000];
```

你也可以定義只包含特定值的更嚴格型別：

```js
type bot = "camperchan" | "camperbot" | "naomi";
type digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
```

你接著可以將那些型別組合起來，為物件創建更具體的限制：

```js
const artificialIntelligence: Record<bot, digit> = { camperchan: 5 }
```

不過如果你需要對物件的結構有更多控制，很可能你會使用我們最後一種型別：`interface`。介面實際上是類別，但用於型別。它們可以實作或擴充其他介面，是專門的物件型別，除非你需要型別宣告式所提供的特定功能，否則通常會優先使用介面。

```js
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

最後，函式（程式）也可以被賦予型別標記。在前一課中，你已經看到如何定義特定參數的型別：

```js
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

但你也可以定義該函式的返回型別。

```js
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

在這個範例中，我們告訴 TypeScript 該函式應該傳回一個字串。如果我們嘗試傳回其他任何東西，TypeScript 將會提供編譯器錯誤來提醒我們。

這就涵蓋了 TypeScript 型別系統的基礎。它相當複雜，並且有許多運作中的零件，但通常可以將它視為反映 JavaScript 型別。

# --questions--

## --text--

以下哪一項不是 TypeScript 中的原始資料型別？

## --answers--

`string`

### --feedback--

原始資料型別是 TypeScript 中最基本的資料型別。

---

`number`

### --feedback--

原始資料型別是 TypeScript 中最基本的資料型別。

---

`boolean`

### --feedback--

原始資料型別是 TypeScript 中最基本的資料型別。

---

`array`

## --video-solution--

4

## --text--

在 TypeScript 中，`unknown` 型別的目的為何？

## --answers--

它允許指定任何類型的值而不進行型別檢查。

### --feedback--

與 `any` 不同，`unknown` 需要先進行型別縮小，才能執行特定的操作。

---

它顯示你不知道型別，並且需要在使用前先縮小範圍。

---

它表述完全沒有任何型別的狀態。

### --feedback--

與 `any` 不同，`unknown` 需要先進行型別縮小，才能執行特定的操作。

---

它表述一個永遠不會存在的型別。

### --feedback--

與 `any` 不同，`unknown` 需要先進行型別縮小，才能執行特定的操作。

## --video-solution--

2

## --text--

在 TypeScript 中，哪個關鍵字用來宣告訂製型別？

## --answers--

`interface`

### --feedback--

此關鍵字用於定義物件形狀的合約，而非宣告訂製型別。

---

`type`

---

`custom`

### --feedback--

這不是 TypeScript 中有效的關鍵字。

---

`define`

### --feedback--

這不是 TypeScript 中有效的關鍵字。

## --video-solution--

2
