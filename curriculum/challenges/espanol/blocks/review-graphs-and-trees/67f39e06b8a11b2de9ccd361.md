---
id: 67f39e06b8a11b2de9ccd361
title: Revisión de Gráficas y Árboles
challengeType: 31
dashedName: review-graph-and-trees
---

# --description--

## Resumen de Grafos

Un grafo es un conjunto de nodos (vértices) conectados por aristas (conexiones). Cada nodo puede conectarse a múltiples otros nodos, formando una red. Los diferentes tipos de grafos incluyen:

- Dirigido: los edges tienen una dirección (de un nodo a otro), a menudo representados con líneas rectas y flechas.
- No dirigido: las aristas no tienen dirección, se representan con líneas simples.
- Vértice: cada nodo está asociado a una etiqueta o identificador.
- Cíclico: contiene ciclos (un camino que comienza y termina en el mismo nodo).
- Acrílico (DAG): no contiene ciclos.
- Arista etiquetada: cada arista tiene una etiqueta que generalmente se dibuja junto a la arista correspondiente.
- Ponderado: los edges tienen pesos (valores) asociados que pueden usarse para realizar operaciones aritméticas.
- Desconectado: contiene dos o más nodos que no están conectados por ninguna arista.

Los gráficos se usan en varias aplicaciones como mapas, redes, sistemas de recomendación y resolución de dependencias.

## Recorridos de Grafos

Esto implica visitar todos los nodos en un grafo. Los dos algoritmos principales son:

- **Búsqueda en Anchura (BFS)**
  - Usa una cola.
  - Explora nivel por nivel.
  - Encuentra el camino más corto en grafos no ponderados.

- **Búsqueda en profundidad (DFS)**
  - Usa una pila (o recursión).
  - Explora completamente una rama antes de retroceder.
  - Útil para la detección de ciclos y la búsqueda de rutas.

## Representaciones de Grafos

Los gráficos pueden representarse de dos maneras principales:

- **Lista de Adyacencia**
  - Cada nodo tiene una lista de sus vecinos.
  - Eficiente en espacio para grafos dispersos.
  - Fácil de iterar sobre vecinos.

- **Matriz de Adyacencia**
  - Un arreglo 2D donde las filas y columnas representan nodos.
  - Intensivo en espacio para grafos grandes.
  - Rápido para verificar si existe una arista entre dos nodos.

## Árboles

Un árbol es un tipo especial de grafo que es acíclico y conectado. Las propiedades clave incluyen:

- No tienen bucles ni ciclos (caminos donde los nodos de inicio y fin son los mismos).
- Deben estar conectados (cada nodo puede ser alcanzado desde cualquier otro nodo).

### Tipos comunes de árboles

Los tipos de árboles más comunes son:

- Árboles Binarios
  - Cada nodo tiene como máximo dos hijos, un hijo izquierdo y un hijo derecho.

- Árboles Binarios de Búsqueda (BST)
  - Un árbol binario en el que cada hijo izquierdo es menor que su padre, y cada hijo derecho es mayor que su padre.


## Tries

También conocidos como árboles de prefijos, se usan para almacenar conjuntos de cadenas, donde cada nodo representa un carácter.

Los prefijos compartidos se almacenan solo una vez, lo que los hace eficientes para tareas como autocompletar y corrección ortográfica.

Las operaciones de búsqueda e inserción tienen una complejidad temporal de O(L), donde L es la longitud de la cadena.

## Colas de Prioridad

Una cola de prioridad es un tipo de dato abstracto donde cada elemento tiene una prioridad.

Las colas y pilas consideran solo el orden de inserción, mientras que las colas de prioridad consideran la prioridad de los elementos. 

Las colas estándar siguen FIFO (First In First Out) y las pilas siguen LIFO (Last In First Out). Sin embargo, en una cola de prioridad, los elementos con mayor prioridad se atienden antes que aquellos con menor prioridad, sin importar su orden de inserción.

## Montículos

Es una estructura de datos especializada basada en árboles con una propiedad muy específica llamada heap property. 

La propiedad heap determina la relación entre nodos padre e hijo. Hay dos tipos de heaps:

- Montículo Máximo
  - El valor de cada nodo padre es mayor o igual que los valores de sus hijos.
  - El elemento más grande está en la raíz.

- Montículo mínimo
  - El valor de cada nodo padre es menor o igual que los valores de sus hijos.
  - El elemento más pequeño está en la raíz.

### Ejemplo del módulo `heap` de Python

```py
import heapq

# Create empty heap
my_heap = []

# Insert elements
heapq.heappush(my_heap, 9)
heapq.heappush(my_heap, 3)
heapq.heappush(my_heap, 5)

# Remove smallest element
print(heapq.heappop(my_heap))  # 3

# Push + Pop in one step
print(heapq.heappushpop(my_heap, 2)) # 2

# Transform list into heap
nums = [5, 7, 3, 1]
heapq.heapify(nums)
```

### Uso de Prioridades

```py
my_heap = []
heapq.heappush(my_heap, (3, "A"))
heapq.heappush(my_heap, (2, "B"))
heapq.heappush(my_heap, (1, "C"))

# Removes lowest number = highest priority
print(heapq.heappop(my_heap))  # (1, "C")
```

# --assignment--

Revise los temas y conceptos de las Gráficas y Árboles.
