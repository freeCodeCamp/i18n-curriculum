---
id: 6724e296dceca21b82426229
title: Typescript 审查
challengeType: 31
dashedName: review-typescript
---

# --description--

## 什么是 TypeScript

- **JavaScript**：JavaScript 是一种动态类型语言。这意味着变量可以在运行时接收任何值。动态类型语言的挑战在于缺乏类型安全可能会引入误差。

例如，即使你的 JavaScript 函数期望一个数组，你仍然可以用一个数字来调用它：

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

上面示例的 `console` 输出将是 `undefined`。

- **TypeScript**：TypeScript 扩展了 JavaScript 语言，包含静态类型指派，这有助于在你运行代码之前捕获由类型不匹配引起的误差。

例如，你可以为 `array` 参数定义一个类型，如下所示：

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

此类型定义告诉 TypeScript，`array` 参数必须是一个字串数组。然后，当你调用 `getRandomValue` 并传入一个数字时，你会得到一个称为编译器误差的误差。

- **编译器**：你首先需要将 TypeScript 代码编译成普通的 JavaScript。当你运行编译器时，TypeScript 会评估你的代码，并在任何类型不匹配的问题上抛出误差。

## TypeScript 中的数据类型

- **TypeScript 中的原语数据类型**：对于原语数据类型 `string`、`null`、`undefined`、`number`、`boolean` 和 `bigint`，TypeScript 提供了相应的类型关键字。

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **数组**：你可以用两种不同的语法定义特定类型的数组。

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **对象**：你可以定义对象的精确结构。

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

如果你想要一个具有任意密钥，但所有值必须是字串的对象，有两种方法可以定义它：

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **TypeScript 中的其他有用类型**：
  - **`any`**：`any` 表示一个值可以具有任何类型。它告诉编译器不再关心该变量的类型。
  - **`unknown`**：`unknown` 告诉 TypeScript 你*确实*关心该值的类型，但你实际上不知道它是什么。通常推荐使用 `unknown` 而不是 `any`。
  - **`void`**：这是一种特殊的类型，通常只在定义函数时使用。没有返回值的函数使用返回类型为 `void`。
  - **`never`**：它表现为一种永远不会存在的类型。

- **`type` 关键字**：这个关键字类似于 `const`，但不是声明变量，而是声明类型。

它对于声明自定义类型非常有用，例如并集类型或仅包含特定值的类型：

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interface`**：接口就像类型的类。它们可以实现或扩展其他接口，专门是对象类型，通常优先使用，除非你需要 `type` 声明提供的特定特色。

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **定义返回类型**：你也可以定义函数的*返回类型*。

下面的示例将返回值定义为字串。如果你尝试返回其他任何内容，TypeScript 将给出编译器误差。

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## 泛型

- **定义通用的类型**：你可以定义一个通用的类型并在你的函数中参考它。它可以被视为你提供给函数的一个特殊参数，用于控制函数类型定义的行为。

下面是为函数定义通用的类型的示例：

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

`<T>` 语法告诉 TypeScript 你正在为函数定义一个通用的类型 `T`。`T` 是通用类型的常用名称，但你可以使用任何名称。

然后，你告诉 TypeScript `array` 参数是一个匹配通用类型的值数组，并且返回值是同一类型的单个元素。

- **在函数调用中指定类型参数**：你可以在函数名和其参数之间使用尖括弧传递类型参数。

下面是将类型参数传递给函数调用的示例：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

这告诉 TypeScript 你期望查找的元素将是一个输入元素。

## 类型缩小

- **通过真值缩小类型**：在下面的示例中，你尝试访问 `email` 的 `value` 属性时会得到编译器误差，因为 `email` *可能* 是 `null`。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

你可以使用条件式语句来确认 `email` 是 *truthy*，然后再访问该属性：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

真值检查也可以反向工作：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

抛出误差会结束此代码的逻辑执行，这意味着当你达到 `console.log()` 调用时，TypeScript 知道 `email` *不可能* 是 `null`。

- **可选链**：可选链 `?.` 也是一种类型缩小的形式，前提是如果 `email` 值为 `null`，则属性访问不会发生。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **`typeof` 操作符**：你可以使用条件式通过 `typeof` 操作符查看变量的类型。

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **`instanceof` 关键字**：如果对象来自某个类，你可以使用 `instanceof` 关键字来缩小类型。

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **类型转换**：当 TypeScript 无法自动确定一个值的类型时，例如下面示例中 `request.json()` 方法的结果，你会遇到编译器误差。解决此问题的一种方法是进行类型转换，但这样会削弱 TypeScript 捕捉潜在误差的能力。

```typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **类型保护**：你可以编写类型保护，而不是进行类型转换：

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

`user is User` 语法表示你的函数返回一个布尔值，当为 true 时表示 `user` 值满足 `User` 接口。

## `tsconfig` 文件

- **`tsconfig.json`**：TypeScript 的编译器设置存放在你项目根目录下的 `tsconfig.json` 文件中。

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

以下是上述示例中使用的编译器选项的描述：

- **`compilerOptions`**：`compilerOptions` 属性是你控制 TypeScript 编译器行为的地方。
- **`rootDir` 和 `outDir`**：`rootDir` 和 `outDir` 告诉 TypeScript 哪个目录包含你的源文件，哪个目录应包含转译后的 JavaScript 代码。
- **`lib`**：`lib` 属性决定编译器使用哪些类型定义，并允许你包含对特定 ES 版本、DOM 等的支持。
- **`module` 和 `moduleResolution`**：`module` 和 `moduleResolution` 协同工作以管理你的包如何使用模块——无论是 CommonJS 还是 ECMAScript。
- **`esModuleInterop`**：`esModuleInterop` 通过自动为导入创建命名空间对象，实现 CommonJS 和 ES 模块之间更顺畅的互操作性。
- **`skipLibCheck`**：`skipLibCheck` 选项跳过验证未被你的代码中的导入引用的 `.d.ts` 文件。
- **`strict`**：`strict` 标记启用多项查看，例如确保正确处理可空类型以及当 TypeScript 回退到 `any` 时发出警告。
- **`exclude`**：顶层的 `exclude` 属性告诉编译器在编译期间忽略这些 TypeScript 文件。

# --assignment--

查看 Typescript 主题和概念。
