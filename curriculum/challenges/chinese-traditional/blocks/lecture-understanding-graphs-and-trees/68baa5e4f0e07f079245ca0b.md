---
id: 68baa5e4f0e07f079245ca0b
title: 優先權佇列和堆積如何運作？
challengeType: 19
dashedName: how-do-priority-queues-and-heaps-work
---

# --description--

**優先權佇列** 是一種抽象的資料型別（ADT），其運作方式類似於佇列或堆疊，但有一個關鍵的差異。

如你所知，標準佇列遵循 FIFO（先進先出）方法，其中第一個加入佇列的元素是第一個從佇列中移除的元素。

堆疊遵循 LIFO（後進先出）方法，其中最後添加到堆疊的元素是第一個從堆疊中移除的元素。

佇列和堆疊只考慮元素的插入順序。

然而，優先權佇列會考慮元素的「優先權」。優先權用來決定下一個應該被移除的元素。

通常會先移除具有最高優先權的元素，但某些實作也可能選擇先移除具有最低優先權的元素。這將取決於你的程式需求。

優先權佇列對於實際應用非常有幫助，例如尋找兩個位置之間的最短路徑、在作業系統中排程任務、模擬交通、壓縮資料以及管理網路。

在實務上，優先權佇列通常使用堆積資料結構來實作。

**堆積** 是一種具有非常特定屬性稱為 **heap property** 的樹狀資料結構。此屬性根據堆積的型別決定每個節點與其子節點之間的關係。

堆積有兩種主要型別：

* 最大堆積
    
* 最小堆積
    

在 **max-heap** 中，每個節點的值都大於或相等於其子節點的值。

在此範例中，你可以看到一個包含節點 8、7、5、2 和 1 的樹狀結構。請注意節點 7 大於節點 2 和節點 1，符合堆積屬性。其他所有節點也皆符合此規則。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-1.png" alt="A max-heap tree structure showing nodes with values 8 at the root, 7 and 5 as children of 8, and 2 and 1 as children of 7, demonstrating that each parent node is greater than its children.">

相反地，在 **min-heap** 中，每個節點的值小於或相等於其子節點的值。

在這個範例中，我們有值為 4、7、9、12 和 15 的節點。 例如，節點 7 小於節點 12 和節點 15，符合堆積屬性。所有其他節點也同樣如此。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-2.png" alt="A min-heap tree structure showing nodes with values 4 at the root, 7 and 9 as children of 4, and 12 and 15 as children of 7, demonstrating that each parent node is less than its children.">

堆積屬性是關鍵，因為它確保最大（或最小）元素（取決於堆積的型別）總是保持在頂端，這使得移除變得非常容易。

在實務上，堆積通常實作為陣列，以高效存取父節點和子節點。

使用陣列簡化了存取這些值或「節點」的邏輯，因為在背後，如果堆積維護完整二元樹的結構，陣列實作只需要基於其索引的簡單數學運算來找到元素在記憶體中的位置。

Python 有一個內建的 `heapq` 模組，你可以用來操作一個最小堆積的實作。

它透過直接操作 Python 列表來運作，遵循特定步驟，將元素視為堆積般處理，並維護堆積屬性。

要使用這個模組，你只需要匯入它：

```python
import heapq
```

接著，你需要定義一個空的列表。這將是堆積的底層資料結構：

```python
my_heap = []
```

要將元素添加到堆積，請呼叫 `heappush()`，並將堆積的名稱和你想添加的元素作為引數傳入。這將自動將元素添加到應該在的位置的列表中，以維持堆積屬性：

```python
heapq.heappush(my_heap, 9)
```

要取得具有最低優先權（在此情況下為最小值）的元素，你會呼叫 `heappop()`：

```python
heapq.heappop(my_heap)
```

`heappushpop()` 將兩個操作行為合併成一次呼叫。

這比起分別依序呼叫它們更高效，特別是在堆積很大時，因為它只執行一次「heapify」操作來將列表重新排序為堆積：

```python
heapq.heappushpop(my_heap, 15)
```

如果你已經有一個列表並且想將它轉換成堆積，你可以呼叫 `heapify()`，並將堆積作為引數傳入：

```python
heapq.heapify(my_heap)
```

但目前，我們是依照它們的值來排序元素，對吧？

如果我們想依照它們的「優先權」排序呢？

你可以透過儲存具有此結構的元組來做到這一點：`(priority, element)`。

由於元組是從左到右逐元素比較，優先順序將會先被比較，並根據它們做出決定。

請注意，在此情況下，較低的數值將表述較高的優先權。這表示優先權為 1 的元組將比優先權為 3 的元組具有**較高**的優先權：

```python
my_heap = []

heapq.heappush(my_heap, (3, "A"))
heapq.heappush(my_heap, (2, "B"))
heapq.heappush(my_heap, (1, "C"))
```

如果你需要以插入的順序移除具有相同優先權的元素，你可以考慮將唯一計數器作為你的元組的第二個元素來打破平手，像這樣 `(priority, counter, element)`。

現在讓我們來談談堆積的效率。

從堆積中插入和擷取最小值或最大值（取決於堆積的型別）的平均和最壞情況時間複雜度是對數級的，`O(log n)`，因為所需的交換次數通常與堆積的高度成正比，而高度為 log(n)。

「peek」操作的平均和最壞情況時間複雜度是常數時間，O(1)。peek 涉及在不移除的情況下取得最小值或最大值（取決於堆積的型別）。

「heapify」操作行為，即從未排序的列表建立堆積，在平均和最壞情況下具有線性時間複雜度 O(n)。

同樣地，搜尋和刪除任意元素的平均及最壞情況時間複雜度皆為 O(n)，因為它們可能需要遍歷整個堆積。

它們需要多少空間？

堆積的空間複雜度是線性的，O(n)，其中 `n` 是它所包含的元素數量。它只需要儲存元素和列表物件本身的一點額外開銷。

優先權佇列和堆積在電腦科學中非常重要。它們讓你能快速找到並使用列表中最重要的元素。這種效率對於許多執行關鍵現實任務的電腦程式至關重要，例如尋找地圖上最快的路徑。

# --questions--

## --text--

優先權佇列與標準佇列或堆疊最主要的區別特性是什麼？

## --answers--

它允許透過索引來存取元素。

### --feedback--

思考決定下一個被移除元素的主要因素。

---

它總是以插入的順序處理元素。

### --feedback--

思考決定下一個被移除元素的主要因素。

---

它根據指定的優先權擷取元素。

---

它只儲存相同資料型別的元素。

### --feedback--

思考決定下一個被移除元素的主要因素。

## --video-solution--

3

## --text--

以下哪一項是優先權佇列會有幫助的常見實際應用？

## --answers--

在作業系統中排程任務，其中某些任務較為緊急。

---

管理一個歌曲以固定順序播放的播放列表。

### --feedback--

思考某些項目較為重要且需要優先處理的情境。

---

儲存雜貨項目列表。

### --feedback--

思考某些項目較為重要且需要優先處理的情境。

---

以字母順序追蹤客戶名稱。

### --feedback--

思考某些項目較為重要且需要優先處理的情境。

## --video-solution--

1

## --text--

儘管堆積被概念化為樹狀結構，但在實務上通常以陣列實作的主要原因是什麼？

## --answers--

陣列總是比任何其他資料結構更快。

### --feedback--

思考如何將堆積的樹狀結構高效地映射到線性資料結構。

---

陣列使用數學公式簡化存取父節點和子節點的邏輯。

---

陣列允許直接隨機存取任何元素，這是堆積的核心操作行為。

### --feedback--

思考如何將堆積的樹狀結構高效地映射到線性資料結構。

---

陣列是唯一能保證堆積屬性的資料結構。

### --feedback--

思考如何將堆積的樹狀結構高效地映射到線性資料結構。

## --video-solution--

2
