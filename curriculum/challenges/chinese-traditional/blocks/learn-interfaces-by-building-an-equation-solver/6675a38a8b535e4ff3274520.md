---
id: 6675a38a8b535e4ff3274520
title: 第 11 步
challengeType: 20
dashedName: step-11
---

# --description--

內建函式 `hasattr` 以物件作為第一個引數，以表述屬性名稱的字串作為第二個引數。它傳回一個布林值，表示該物件是否具有指定的屬性。

現在你將使用 `__init_subclass__` 方法來檢查子類別在具現體時是否具有 `degree` 屬性。

創建一個 `if` 述語來檢查 `cls` 是否沒有 `degree` 屬性。如果是，則引發一個 `AttributeError`，並使用字串 `f"Cannot create '{cls.__name__}' class: missing required attribute 'degree'"` 來提供訂製的訊息。

接著，透過在 `LinearEquation` 類別內宣告一個 `degree` 類別屬性來修正終端機中出現的錯誤。此屬性應該表述方程式的次數，也就是最高次方 \\( x \\) 項的指數。因此，為 `degree` 屬性指定整數 `1`。

# --hints--

你應該在 `__init_subclass__` 方法內創建一個 `if` 述語，檢查 `cls` 是否沒有屬性 `degree`。

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("__init_subclass__").find_ifs()[0].find_conditions()[0].is_equivalent("not hasattr(cls, 'degree')")`)) })
```

你應該在你的 `if` 述語中使用提供的字串引發 `AttributeError`。

```js
({ test: () => runPython(`
raise_stmt = 'raise AttributeError(f"Cannot create \\'{cls.__name__}\\' class: missing required attribute \\'degree\\'")'
node = _Node(_code).find_class("Equation").find_function("__init_subclass__").find_ifs()[0].find_bodies()[0]
assert node.has_stmt(raise_stmt) 
`) })
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod


class Equation(ABC):
    degree: int
    
    def __init__(self):
        pass
--fcc-editable-region--
    def __init_subclass__(cls):
        pass

    @abstractmethod
    def solve(self):
        pass
        
    @abstractmethod
    def analyze(self):
        pass


class LinearEquation(Equation):
    
--fcc-editable-region--
    def solve(self):
        pass

    def analyze(self):
        pass


lin_eq = LinearEquation()
```
