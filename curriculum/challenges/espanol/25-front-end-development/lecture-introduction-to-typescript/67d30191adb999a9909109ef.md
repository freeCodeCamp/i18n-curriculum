---
id: 67d30191adb999a9909109ef
title: '¿Qué son los genéricos y cómo funcionan?'
challengeType: 19
dashedName: what-are-generics-and-how-do-they-work
---

# --description--

En realidad, ya has visto un tipo genérico en una conferencia anterior: `Array<string>`. Pero generalmente usarás tipos genéricos en funciones. De hecho, se pueden considerar como un parámetro especial que le proporcionas a una función para controlar el comportamiento de la definición del tipo de la función.

Volvamos a nuestro ejemplo anterior de una función para obtener un valor aleatorio de un arreglo:

```js
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Nuestra función acepta un arreglo de cadenas y devuelve una cadena. Pero, ¿qué pasa si queremos pasar un arreglo de números y devolver un número?

Podrías usar un tipo de unión:

```js
const getRandomValue = (array: (string|number)[]): (string|number) => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

Pero con este enfoque, aunque hemos pasado un arreglo de solo números, TypeScript determina que la variable `val` podría ser un número O una cadena.

En su lugar, puedes definir un tipo genérico para la función:

```js
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

Hay un par de componentes importantes en nuestro nuevo ejemplo. Primero, la sintaxis `<T>` le indica a TypeScript que estás definiendo un tipo genérico `T` para la función. `T` es un nombre común para tipos genéricos, pero de hecho puedes nombrarlo como quieras (dentro de las convenciones de variables de JavaScript).

Luego, le indicamos a TypeScript que el parámetro del arreglo es un arreglo de valores que coinciden con el tipo genérico, y que el valor devuelto es un solo elemento de ese mismo tipo. Esto permite que TypeScript detecte correctamente que `val` será un número, porque el arreglo que pasamos consiste únicamente de números.

¿Pero qué pasa con funciones que no controlas? Echemos un vistazo al método `document.querySelector()`:

```js
const email = document.querySelector("#email");
console.log(email.value);
```

Debido a que estamos consultando con un selector de ID, TypeScript no sabe qué tipo de elemento estamos consultando. Sabe que es un `Elemento` de alguna clase, pero nuestro intento de acceder a la propiedad `valor` generará un error porque la interfaz de elemento de nivel superior no tiene esa propiedad.

Afortunadamente, podemos pasar un argumento de tipo a la llamada de la función:

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Nota cómo estamos usando nuevamente la sintaxis del corchete angular (`<HTMLInputElement>`), pero esta vez en una llamada de función. Esto le dice a TypeScript que el elemento que esperamos encontrar será un elemento `input`, y ya no recibimos un error en la propiedad valor porque los elementos de input tienen esa propiedad. Por supuesto, `querySelector` puede devolver `null` si no se encuentra un elemento, y TypeScript generará un error de compilador aquí porque no manejamos ese caso.

Pero aprenderás más sobre eso en la próxima conferencia.

# --questions--

## --text--

¿Cuál es la sintaxis correcta para definir un tipo genérico en una función?

## --answers--

```ts
function<T>
```

---

```ts
<T>function
```

### --feedback--

El tipo genérico se define usando corchetes angulares antes de la lista de parámetros de la función.

---

```ts
(T)function
```

### --feedback--

El tipo genérico se define usando corchetes angulares antes de la lista de parámetros de la función.

---

```ts
function(T)
```

### --feedback--

El tipo genérico se define usando corchetes angulares antes de la lista de parámetros de la función.

## --video-solution--

1

## --text--

¿Qué representa `T[]` en el siguiente ejemplo?

```ts
const getRandomValue = <T>(array: T[]): T => { ... }
```

## --answers--

Un arreglo de cualquier tipo.

### --feedback--

Los corchetes cuadrados después de `T` indican un arreglo de ese tipo.

---

Un arreglo del tipo genérico `T`.

---

Una tupla del tipo `T`.

### --feedback--

Los corchetes cuadrados después de `T` indican un arreglo de ese tipo.

---

Un solo elemento del tipo `T`.

### --feedback--

Los corchetes cuadrados después de `T` indican un arreglo de ese tipo.

## --video-solution--

2

## --text--

¿Cómo se puede especificar un argumento de tipo al llamar a `document.querySelector()`?

## --answers--

```js
document.querySelector("#email", HTMLInputElement)
```

### --feedback--

El argumento de tipo se pasa usando corchetes angulares entre el nombre de la función y sus parámetros.

---

```js
document.querySelector("#email"): HTMLInputElement
```

### --feedback--

El argumento de tipo se pasa usando corchetes angulares entre el nombre de la función y sus parámetros.

---

```js
document.querySelector<HTMLInputElement>("#email")
```

---

```js
document.querySelector("#email" as HTMLInputElement)
```

### --feedback--

El argumento de tipo se pasa usando corchetes angulares entre el nombre de la función y sus parámetros.

## --video-solution--

3
