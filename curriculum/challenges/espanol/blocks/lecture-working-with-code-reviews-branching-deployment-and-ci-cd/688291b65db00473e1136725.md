---
id: 688291b65db00473e1136725
title: ¿Qué es CI/CD y cómo funciona CI con GitHub Actions?
challengeType: 19
dashedName: what-is-ci-cd-and-how-does-ci-work-with-github-actions
---

# --description--

CI significa Integración Continua, y CD significa Entrega Continua o Despliegue Continuo. Juntos, estos procesos te permiten desplegar automáticamente cambios en tu aplicación después de asegurarte de que esos cambios funcionan.

En una pipeline de CI, podrías ejecutar tu linter y pruebas contra el código. Las pipelines de CI normalmente se ejecutan en pull requests para asegurar que los cambios realizados no rompan la app, y también en la rama `main` para asegurar que esté lista para desplegar.

Una pipeline de CD también podría ejecutarse en pull requests, si configuras un entorno de vista previa para que puedas ver los cambios en vivo. Pero también la ejecutarás en tu rama `main` para desplegar continuamente los cambios a medida que se aceptan y se fusionan.

¿Pero cómo funcionan realmente con GitHub Actions? Primero, necesitamos entender qué son realmente GitHub Actions. GitHub Actions proporciona runners efímeros (piensa en una computadora temporal) que te permiten ejecutar comandos específicos.

Las acciones se configuran con un archivo YAML. Puedes tener varios archivos para especificar diferentes acciones que se ejecuten. Por ejemplo, podrías tener un archivo para tu CI y otro para tu CD.

Veamos un ejemplo básico de CI:

```yml
name: Node.js CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  lint:
    name: Lint and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Source Files
        uses: actions/checkout@v4

      - name: Use Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10

      - name: Install Dependencies
        run: pnpm install

      - name: Lint Source Files
        run: pnpm run lint

      - name: Verify Build
        run: pnpm run build

      - name: Run Tests
        run: pnpm run test
```

Esto es mucho, así que vamos a desglosarlo. Mirando la primera sección:

```yml
name: Node.js CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
```

El `name` define el nombre de la acción en sí. Esto aparece en áreas como la sección de verificaciones de estado de un PR. Las propiedades `on` definen lo que se llama "workflow triggers": estos son los eventos que harán que tu acción se ejecute.

En este ejemplo, ejecutamos la acción cuando se envían commits a `main`, y cuando una solicitud de extracción apunta a `main`. Esto significa que el CI se ejecuta cuando alguien crea una solicitud de extracción, y nuevamente cuando la fusionamos.

La sección `jobs` es donde defines lo que tu acción realmente hace. La clave `lint:` es una clave arbitraria que define el nombre interno para ese trabajo. La propiedad `name` define el nombre externo para este trabajo en particular. Y la propiedad `runs-on` define en qué tipo de entorno debe ejecutarse tu acción; en este caso, la estamos ejecutando en la versión más reciente soportada de Ubuntu.

La propiedad `steps` es donde ocurre la magia. Este bloque define los pasos reales que tu acción debe seguir. Echemos un vistazo al primer bloque allí:

```yml
      - name: Checkout Source Files
        uses: actions/checkout@v4
```

Este paso tiene dos propiedades, el `name` que debe tener el paso, y una propiedad `uses`. Esta propiedad `uses` es especial, ya que le indica al ejecutor de acciones que obtenga una acción pública de GitHub y la ejecute, en lugar de ejecutar un comando. La acción `actions/checkout` se encarga de clonar y configurar el repositorio dentro de tu ejecutor.

```yml
      - name: Use Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10
```

Los siguientes dos bloques también usan acciones de terceros. Estos pasos configuran Node y el gestor de paquetes pnpm. Ambos tienen una clave `with`, que puedes usar para pasar argumentos a esas acciones de terceros. Piensa en esto como pasar argumentos a una función.

Los últimos cuatro bloques son donde realmente sucede la magia.

```yml
      - name: Install Dependencies
        run: pnpm install

      - name: Lint Source Files
        run: pnpm run lint

      - name: Verify Build
        run: pnpm run build

      - name: Run Tests
        run: pnpm run test
```

Tenemos un bloque `Install Dependencies`, que instala los paquetes npm. Nuestro bloque `Lint Source Files` ejecuta el linter, el bloque `Verify Build` asegura que el código Typescript pueda compilar, y el bloque `Run Tests` ejecuta las pruebas unitarias.

Lo importante que debes saber sobre las acciones es que, por defecto, si uno de estos pasos falla, los restantes se omitirán y toda la ejecución se marcará como un fallo.

¿Dónde colocas tus archivos YAML para poder ejecutar estas acciones? Necesitan ir en un directorio `.github/workflows` dentro de tu repositorio para que GitHub los encuentre y los utilice.

Hay muchas cosas adicionales que las acciones pueden hacer, y te animo a leer la documentación y explorar las acciones existentes en proyectos como el repositorio de freeCodeCamp. ¡Pero por ahora, deberías tener un buen entendimiento de los conceptos básicos de GitHub Actions y CI/CD!

# --questions--

## --text--

¿Qué define la propiedad on en un archivo de flujo de trabajo de GitHub Actions?

## --answers--

El nombre de la acción.

### --feedback--

Piensa en cuándo quieres que tus acciones se ejecuten automáticamente.

---

Los eventos que desencadenan la ejecución del workflow.

---

El sistema operativo en el que se ejecutará.

### --feedback--

Piensa en cuándo quieres que tus acciones se ejecuten automáticamente.

---

Los pasos para ejecutar.

### --feedback--

Piensa en cuándo quieres que tus acciones se ejecuten automáticamente.

## --video-solution--

2

## --text--

¿Dónde deben colocarse los archivos YAML de flujo de trabajo de GitHub Actions en un repositorio?

## --answers--

En el directorio raíz.

### --feedback--

GitHub busca archivos de flujo de trabajo en una estructura de directorios específica.

---

En un directorio `.github/actions`.

### --feedback--

GitHub busca archivos de flujo de trabajo en una estructura de directorios específica.

---

En un directorio `.github/workflows`.

---

En un directorio `workflows`.

### --feedback--

GitHub busca archivos de flujo de trabajo en una estructura de directorios específica.

## --video-solution--

3

## --text--

¿Qué sucede por defecto cuando un paso falla en un flujo de trabajo de GitHub Actions?

## --answers--

El flujo de trabajo continúa con una advertencia.

### --feedback--

Considera cómo GitHub Actions maneja los errores en la ejecución del flujo de trabajo.

---

Solo ese paso específico está marcado como fallido.

### --feedback--

Considera cómo GitHub Actions maneja los errores en la ejecución del flujo de trabajo.

---

El flujo de trabajo se reinicia desde el principio.

### --feedback--

Considera cómo GitHub Actions maneja los errores en la ejecución del flujo de trabajo.

---

Los pasos restantes se omiten y la ejecución se marca como un fallo.

## --video-solution--

4
