---
id: 692aba0a78ca391f10455b4b
title: Como Funcionam as Importações e Exportações com Módulos CommonJS?
challengeType: 19
dashedName: how-do-imports-and-exports-work-with-commonjs-modules
---

# --description--

No desenvolvimento web moderno, você pode dividir seu código em vários arquivos chamados "modules."

Você pode pensar em um módulo como um bloco de código autocontido e reutilizável.

Ao importar módulos em outros módulos, você pode reutilizar sua funcionalidade mantendo o código em arquivos separados, o que é mais fácil de manter, especialmente para aplicações web grandes e complexas.

No Node.js, cada arquivo é considerado um módulo.

Node possui dois sistemas diferentes para trabalhar com módulos: CommonJS e ES.

CommonJS é a forma original e padrão de trabalhar com pacotes no Node.js. Ele carrega módulos de forma síncrona, o que significa que ele precisa esperar que um módulo seja totalmente carregado antes de começar a carregar o próximo ou continuar executando o código.

Ainda é amplamente usado, mas está sendo gradualmente substituído pela sintaxe mais recente do ES.

CommonJS usa a função `require()` para importar um módulo, recebendo seu caminho relativo como argumento.

Por exemplo, digamos que temos um módulo chamado `math.js`, onde definimos operações matemáticas básicas.

Aqui usaremos apenas uma função de multiplicação para manter este exemplo simples e focado:

```js
function multiply(a, b) {
  return a * b;
}
```

Como podemos reutilizar essa função fora do nosso módulo atual? Por padrão, funções e variáveis definidas em um módulo Node.js são **privadas** — outros módulos não podem acessá-las a menos que as exportemos explicitamente. Existem várias maneiras de fazer isso.

Uma maneira comum é atribuir um valor a `module.exports`. Este objeto representa o que o módulo retornará quando for importado em outro lugar, dando a outros módulos acesso às funções, variáveis ou objetos que você escolheu expor.

Neste exemplo, atribuímos um objeto com uma propriedade `multiply` a `module.exports`. O valor dessa propriedade é uma referência à função `multiply` que definimos anteriormente. Isso exportará a função, para que possamos chamá-la de outros módulos se precisarmos.

```javascript
function multiply(a, b) {
  return a * b;
}

module.exports = {
  multiply: multiply
};
```

Vamos supor que tentemos importar o módulo `math.js` para outro módulo. Chamamos a função `require()` e passamos o caminho relativo como argumento. Em seguida, atribuímos o objeto retornado por `require()` à variável `math`.

```javascript
const math = require('./math');
```

Vamos verificar o valor de `math` no console imprimindo-o com `console.log()`:

```javascript
console.log(math);
```

Esta é a saída. É um objeto com uma propriedade `multiply` e uma função como valor:

```javascript
{ multiply: [Function: multiply] }
```

Se chamarmos essa função com `math.multiply()`, passando os números `6` e `7` como argumentos, a saída é `42`. A função é executada com sucesso e ainda assim, está em outro arquivo! Então nossa declaração de importação funcionou corretamente.

```javascript
const math = require('./math');

console.log(math.multiply(6, 7)); // 42
```

Mas existem outras formas de exportar uma função, variável ou objeto.

Por exemplo, se você precisar exportar apenas uma função, variável ou objeto, você pode atribuí-la diretamente como o valor de `module.exports`:

```javascript
function multiply(a, b) {
  return a * b;
}

module.exports = multiply;
```

Se você precisar exportar múltiplas funções, basta adicioná-las ao objeto `module.exports`, separadas por vírgula.

Aqui, você pode ver que o objeto exportado tem duas propriedades: `subtract` e `multiply`. Seus valores são referências para suas funções correspondentes, então você terá acesso a ambas em qualquer módulo que importe `math.js`:

```javascript
function subtract(a, b) {
  return a - b;
}

function multiply(a, b) {
  return a * b;
}

module.exports = {
  subtract: subtract,
  multiply: multiply
};
```

Quando o objeto `module.exports` tem múltiplas propriedades, você terá a opção de escolher se deseja importar tudo ou importar as propriedades individualmente.

Neste exemplo, estamos importando o objeto inteiro que foi exportado por `math.js`, então teremos acesso tanto a `subtract` e `multiply`:

```javascript
const math = require('./math');

console.log(math.subtract(6, 7));  // -1
console.log(math.multiply(6, 7));  // 42
```

Se quisermos importar apenas `multiply`, basta escrever seu nome entre chaves, após a palavra-chave `const`. Basicamente, você está usando a sintaxe de atribuição por desestruturação para obter seu valor do objeto exportado. Então, podemos nos referir a ele diretamente pelo nome no nosso código:

```javascript
const { multiply } = require('./math');

console.log(multiply(6, 7));
```

Isso funciona para múltiplos elementos também. Você só precisa separá-los com uma vírgula dentro das chaves. Aqui, estamos importando as funções `subtract` e `multiply`:

```javascript
const { subtract, multiply } = require('./math');
```

Por padrão, o Node.js tratará o seguinte como módulos CommonJS:

* Arquivos com extensão `.cjs`.
    
* Arquivos com extensão `.js` quando o arquivo `package.json` pai mais próximo contém um campo de nível superior `"type"` com valor `"commonjs"`.
    
* Arquivos com extensão `.js` ou sem extensão, quando o arquivo `package.json` pai mais próximo não contém um campo de nível superior `"type"`, ou não há `package.json` em nenhuma pasta pai.
    
* Arquivos com uma extensão que não seja `.mjs`, `.cjs`, `.json`, `.node` ou `.js`.
    

Embora os ES Modules estejam gradualmente substituindo os módulos CommonJS, entendê-los ainda é essencial para desenvolvedores que trabalham com bases de código Node.js existentes e muitos pacotes npm.

# --questions--

## --text--

Qual função é usada para importar módulos em CommonJS?

## --answers--

`import()`

### --feedback--

Pense em qual palavra-chave é usada para importar código externo em ambientes Node.js.

---

`require()`

---

`export()`

### --feedback--

Pense em qual palavra-chave é usada para importar código externo em ambientes Node.js.

---

`include()`

### --feedback--

Pense em qual palavra-chave é usada para importar código externo em ambientes Node.js.

## --video-solution--

2

## --text--

Qual das seguintes é a principal forma de exportar um módulo em CommonJS?

## --answers--

`export default`

### --feedback--

Pense em qual objeto é usado para definir o que um módulo disponibiliza para outros arquivos.

---

`module.exports`

---

`export const`

### --feedback--

Pense em qual objeto é usado para definir o que um módulo disponibiliza para outros arquivos.

---

`import from`

### --feedback--

Pense em qual objeto é usado para definir o que um módulo disponibiliza para outros arquivos.

## --video-solution--

2

## --text--

Que tipo de carregamento o CommonJS usa?

## --answers--

Carregamento assíncrono

### --feedback--

O código espera um módulo carregar completamente antes de retomar sua execução?

---

Carregamento preguiçoso

### --feedback--

O código espera um módulo carregar completamente antes de retomar sua execução?

---

Carregamento síncrono

---

Carregamento condicional

### --feedback--

O código espera um módulo carregar completamente antes de retomar sua execução?

## --video-solution--

3
