---
id: 587d8257367417b2b2512c7c
title: 檢查元素是否存在於二元搜尋樹中
challengeType: 1
forumTopicId: 301623
dashedName: check-if-an-element-is-present-in-a-binary-search-tree
---

# --description--

現在我們對二元搜尋樹有一個大致的了解，讓我們來更詳細地討論它。二元搜尋樹在平均情況下，對於查找、插入和刪除這些常見操作提供對數時間，而在最壞情況下則是線性時間。為什麼會這樣？這些基本操作都需要我們在樹中找到一個項目（或在插入的情況下找到它應該放置的位置），而由於樹的結構，在每個父節點我們會向左或向右分支，有效地排除剩餘樹的一半大小。這使得搜尋與樹中節點數量的對數成正比，從而在平均情況下為這些操作創造對數時間。好，那最壞情況呢？考慮從以下值構建一棵樹，從左到右添加：`10`、`12`、`17`、`25`。根據我們對二元搜尋樹的規則，我們會將 `12` 添加到 `10` 的右邊，`17` 添加到它的右邊，`25` 添加到它的右邊。現在我們的樹看起來像一個鏈結串列，巡訪它以找到 `25` 需要我們以線性方式巡訪所有項目。因此，最壞情況下是線性時間。這裡的問題是樹不平衡。我們將在接下來的挑戰中更深入探討這是什麼意思。

# --instructions--

在這個挑戰中，我們將為我們的樹創建一個工具。撰寫一個 `isPresent` 方法，該方法接受一個整數值作為輸入，並傳回一個布林值，表示該值是否存在於二元搜尋樹中。

# --hints--

應該存在 `BinarySearchTree` 資料結構。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    }
    return typeof test == 'object';
  })()
);
```

二元搜尋樹應該有一個名為 `isPresent` 的方法。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    return typeof test.isPresent == 'function';
  })()
);
```

`isPresent` 方法應正確檢查新增到樹中的元素是否存在。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    if (typeof test.isPresent !== 'function') {
      return false;
    }
    test.add(4);
    test.add(7);
    test.add(411);
    test.add(452);
    return (
      test.isPresent(452) &&
      test.isPresent(411) &&
      test.isPresent(7) &&
      !test.isPresent(100)
    );
  })()
);
```

`isPresent` 應該處理樹為空的情況。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    if (typeof test.isPresent !== 'function') {
      return false;
    }
    return test.isPresent(5) == false;
  })()
);
```

# --seed--

## --after-user-code--

```js
BinarySearchTree.prototype = Object.assign(
  BinarySearchTree.prototype,
  {
    add: function(value) {
      var node = this.root;
      if (node == null) {
        this.root = new Node(value);
        return;
      } else {
        function searchTree(node) {
          if (value < node.value) {
            if (node.left == null) {
              node.left = new Node(value);
              return;
            } else if (node.left != null) {
              return searchTree(node.left);
            }
          } else if (value > node.value) {
            if (node.right == null) {
              node.right = new Node(value);
              return;
            } else if (node.right != null) {
              return searchTree(node.right);
            }
          } else {
            return null;
          }
        }
        return searchTree(node);
      }
    }
  }
);
```

## --seed-contents--

```js
var displayTree = tree => console.log(JSON.stringify(tree, null, 2));
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}
function BinarySearchTree() {
  this.root = null;
  // Only change code below this line
  
  // Only change code above this line
}
```

# --solutions--

```js
var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}
function BinarySearchTree() {
  this.root = null;
  this.isPresent = function (value) {
    var current = this.root
    while (current) {
      if (value === current.value) {
        return true;
      }
      current = value < current.value ? current.left : current.right;
    }
    return false;
  }
}
```
