---
id: 67f39dac6c3fac29c3d54918
title: Revisión de la Programación Orientada a Objetos
challengeType: 31
dashedName: review-object-oriented-programming
---

# --description--

## ¿Qué es la Programación Orientada a Objetos?

- **Programación orientada a objetos**: Un estilo de programación en el que los desarrolladores tratan todo en su código como un objeto del mundo real. Popularmente se llama OOP. Los cuatro principios clave que te ayudan a organizar y gestionar el código de manera efectiva son **encapsulación**, **herencia**, **polimorfismo** y **abstracción**
- **Clases**: La estructura para crear objetos. Cada objeto creado a partir de una clase tiene atributos que definen datos y métodos que determinan los comportamientos de los objetos.

## ¿Qué es la Encapsulación?

- **Encapsulación**: La agrupación de los atributos y métodos de un objeto en una sola unidad. Te permite ocultar el estado interno del objeto detrás de un conjunto simple de métodos y atributos públicos que actúan como puertas. Detrás de esas puertas están los atributos y métodos privados que controlan cómo cambian los datos y quién puede verlos.
- **Ejemplo de Encapsulación**: Si quieres rastrear el saldo de una billetera, permitirás depósitos y retiros, pero no querrás que nadie manipule el saldo de la billetera en sí:

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

- **Diferencia entre prefijar atributos con un guion bajo simple y doble**: Prefijar atributos y métodos con un guion bajo simple significa que están destinados para uso interno. Esto es una convención y no impide el acceso a los atributos desde el exterior. Prefijar atributos y métodos con un guion bajo doble evita efectivamente que sean accedidos desde fuera de su clase.

## ¿Qué son los Getters y Setters?

- **Getters y Setters**: Métodos que te permiten controlar cómo se accede y modifica los atributos de una clase. Recuperas valores con getters y estableces valores con setters.
- **Propiedades**: Conectan getters y setters, y permiten el acceso a datos. Ejecutan lógica adicional en segundo plano cuando obtienes, estableces o eliminas valores.
- **Por qué Propiedades en lugar de Métodos**: Las propiedades se usan en lugar de métodos para una mejor legibilidad y un código más limpio. Permiten acceder a valores con notación de punto, como atributos regulares, sin paréntesis.
- **Crear un Getter**: Para crear un getter, usa el decorador `@property`. Aquí tienes un getter que obtiene el radio de un círculo:

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

- **Creando un Setter**: Para crear el setter que establecerá el radio, tienes que definir otro método con el mismo nombre y usar `@<property_name>.setter` encima de él:

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

- **Cómo Python maneja los getters y setters**: Una vez que defines getters y setters, Python los llama automáticamente en segundo plano cada vez que usas la sintaxis normal de atributos de esta manera:

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

 Al establecer un valor, no debes asignar al nombre de la propiedad en sí porque eso causará un `RecursionError`. Usa un nombre interno separado, a menudo con un guion bajo, para almacenar el valor.

- **Deleter**: Después de establecer y obtener un valor con setter y getter, puedes controlar cómo se elimina con un `deleter`. Un deleter ejecuta lógica personalizada cuando usas la instrucción `del` en una propiedad. Para crear un deleter, usas el decorador `@<property_name>.deleter`.

```py
  # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

## ¿Qué es la herencia y cómo promueve la reutilización de código?

- **Herencia**: El proceso por el cual una clase hija usa los atributos y métodos de una clase padre. La herencia promueve la reutilización de código, proporciona jerarquías claras y personaliza el comportamiento sin reescribir todo. Para implementar la herencia, una clase hija recibe el nombre de una clase padre:

```py
class Parent:
    # Parent attributes and methods

class Child(Parent):
    # Child inherits, extends, and/or overrides where necessary
```

- **Herencia Simple y Múltiple**: Cuando una clase hija hereda propiedades y métodos de un solo padre, como puedes ver arriba, el proceso se llama **herencia simple**. Cuando una clase hija hereda propiedades y métodos de más de un padre, eso es **herencia múltiple**. Aquí está la sintaxis para eso:

```py
class Parent:
    # Attributes and methods for Parent

class Child:
    # Attributes and methods for Child

class GrandChild(Parent, Child):
    # GrandChild inherits from both Parent and Child
    # GrandChild can combine or override behavior from each
```

- **Función `super()`**: Una función que te permite sobrescribir un método de un padre dentro de una clase hija.

## ¿Qué es el Polimorfismo y Cómo Promueve la Reutilización de Código?

- **Polimorfismo**: El principio de POO que permite que diferentes clases usen el mismo nombre de método, pero cada clase lo implementa de manera diferente cuando se llama. Aquí está la sintaxis para ello:

```py
class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # Works for A, B, or C
```

- **Polimorfismo basado en herencia**: Un padre establece un método, y cada clase hija lo adapta a su uso.

## ¿Qué es Name Mangling y cómo funciona?

- **Name Mangling**: Un proceso en el que Python renombra internamente un atributo que comienza con doble guion bajo agregando un guion bajo y el nombre de la clase como prefijo, convirtiendo `__attribute` en `_ClassName__attribute`.
- **El propósito del name mangling**: El propósito principal del name mangling es evitar la sobrescritura accidental de atributos y métodos cuando usas herencia. Aquí tienes un código que lo hace más comprensible:

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

## ¿Qué es la abstracción y cómo ayuda a mantener organizados los sistemas complejos?

- **Abstracción**: Un concepto de programación en el que los detalles complejos de implementación de un objeto o sistema están ocultos y solo se muestran las características esenciales. En Python y otros lenguajes de programación, la abstracción simplifica sistemas complejos al aumentar la reutilización.
- **Ejemplo de Abstracción**: Un buen ejemplo de abstracción en la vida cotidiana es un coche que te permite usar solo el volante, los pedales y la palanca de cambios sin saber cómo funciona el motor o los frenos.
- **Cómo Python implementa la abstracción**: Python implementa la abstracción a través del módulo `abc`. El módulo proporciona la clase `ABC` (clase base abstracta) y el decorador `@abstractmethod`. Una clase base abstracta (ABC) define los métodos y propiedades comunes que las subclases deben implementar. No puede ser instanciada.
- **Cómo se Define un Método Abstracto**: Un método abstracto se define con `@abstractmethod` y debe ser sobrescrito en las subclases, incluso si tiene una implementación predeterminada. La sintaxis básica de la abstracción es la siguiente:

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

# --assignment--

Revise los temas y conceptos de Programación Orientada a Objetos.
