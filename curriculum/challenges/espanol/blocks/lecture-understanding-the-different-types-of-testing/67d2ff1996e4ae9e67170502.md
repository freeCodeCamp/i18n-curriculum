---
id: 67d2ff1996e4ae9e67170502
title: ¿Qué es una Prueba Unitaria?
challengeType: 19
dashedName: what-is-unit-testing
---

# --description--

Mientras diseñas tus aplicaciones, a menudo tendrás una serie de funciones pequeñas responsables de una sola cosa. Esto se conoce como el "principio de responsabilidad única." Cuando tienes una serie de funciones pequeñas, es mejor probar estas funciones para asegurarte de que todo funcione como se espera. En esta lección, veremos cómo crear una prueba unitaria usando el popular framework de pruebas Jest.

En este ejemplo, vamos a crear una función que se encarga de devolver una cadena nueva formateada:

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

Esta función `getFormattedWord` tiene un parámetro llamado `str` y primero comprobará si `str` está vacío. Si es así, entonces se devuelve una cadena vacía. De lo contrario, se devuelve una nueva cadena donde la primera letra está en mayúscula. Estamos exportando esta función para que podamos usarla en un archivo de prueba.

En un archivo separado `getFormattedWord.test.js`, podemos escribir algunas pruebas para verificar que la función está haciendo lo que se supone que debe hacer.

Al inicio del archivo `getFormattedWord.test.js`, primero necesitamos importar la función de esta manera:

```js
import { getFormattedWord } from "./getFormattedWord.js";
```

Luego debemos instalar el paquete Jest usando `npm i jest`. Luego podemos agregar una prueba para verificar que una palabra compuesta por caracteres en minúscula, `hello`, se formatea correctamente a `Hello`, que comienza con una `H` mayúscula:

```js
test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

La función `expect` se usa para probar un valor. Se combina con un emparejador, que es una función que verifica si el valor se comporta como se espera. En este caso, el emparejador es `toBe()`. Jest tiene una variedad de emparejadores para ayudarte a probar veracidad, cadenas, números y más.

Una forma de ejecutar tus pruebas es agregando un script npm a tu archivo `package.json`. Aquí hay un ejemplo de script para el marco de trabajo Jest:

```js
"scripts": {
  "test": "jest"
},
```

Solo ejecuta `npm run test` en tu terminal para correr tus pruebas. Si tus pruebas son exitosas, deberías ver algo en el terminal como esto:

```sh
PASS ./getFormattedWord.test.js
  ✓ capitalizes the first letter of a word (1 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.103 s, estimated 1 s
Ran all test suites.
```

Para ver cómo se ve una prueba fallida, podemos romper intencionalmente la prueba actualizando la función a lo siguiente:

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return "This is incorrect";
}
```

Ahora, cuando ejecutes el comando `npm run test`, aparecerá un mensaje de error porque la prueba esperaba un resultado diferente:

```sh
FAIL ./getFormattedWord.test.js
  ✕ capitalizes the first letter of a word (1 ms)

  ● capitalizes the first letter of a word

  expect(received).toBe(expected) // Object.is equality

  Expected: "Hello"
  Received: "This is incorrect"

    2 |
    3 | test('capitalizes the first letter of a word', () => {
    4 |   expect(getFormattedWord('hello')).toBe('Hello');
                                            ^
    5 | });
    6 |

    at Object.toBe (getFormattedWord.test.js:4:37)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        0.121 s, estimated 1 s
Ran all test suites.
```

Ahora podemos actualizar nuestra función de nuevo al original aquí:

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

Agrega otra prueba para verificar casos donde no se proporcione un argumento a `getFormattedWord`:

```js
test("returns an empty string when no argument is provided", () => {
  expect(getFormattedWord()).toBe("");
});
```

Hay otras pruebas que puedes agregar para hacer más robusto el proceso, pero estas primeras pruebas son una buena introducción a las pruebas unitarias.

Cuando se trata de probar aplicaciones JavaScript, algunos marcos de prueba comunes incluyen Jest, Mocha y Vitest.

Las pruebas unitarias son importantes porque te ayudarán a encontrar más errores en tus programas y garantizarán que todo funcione como se espera. También puede servir como una forma de documentación para tu aplicación, ya que está destinado a representar el comportamiento esperado de tu código.

# --questions--

## --text--

¿Cuál de los siguientes se refiere al principio donde una función debe ser responsable de una sola cosa?

## --answers--

Principio de responsabilidad única

---

Principio de responsabilidad múltiple

### --feedback--

Consulta nuevamente el principio de la lección donde se discutió esto.

---

Principio de solicitud única

### --feedback--

Consulta nuevamente el principio de la lección donde se discutió esto.

---

Principio de respuesta múltiple

### --feedback--

Consulta nuevamente el principio de la lección donde se discutió esto.

## --video-solution--

1

## --text--

¿Cuál de los siguientes NO es un marco de prueba comúnmente usado en el ecosistema JavaScript?

## --answers--

JUnit

---

Jest

### --feedback--

Consulta al final de la lección donde se discutió esto.

---

Vitest

### --feedback--

Consulta al final de la lección donde se discutió esto.

---

Mocha

### --feedback--

Consulta al final de la lección donde se discutió esto.

## --video-solution--

1

## --text--

¿Qué puedes agregar a un archivo `package.json` para ejecutar tus pruebas en el terminal?

## --answers--

```json
"test": {
  "test": "run test"
},
```

### --feedback--

Recuerda que puedes crear scripts personalizados en tu archivo `package.json`.

---

```json
"scriptings": {
  "jest"
},
```

### --feedback--

Recuerda que puedes crear scripts personalizados en tu archivo `package.json`.

---

```json
"run": {
  "test"
},
```

### --feedback--

Recuerda que puedes crear scripts personalizados en tu archivo `package.json`.

---

```json
"scripts": {
  "test": "jest"
}
```

## --video-solution--

4
