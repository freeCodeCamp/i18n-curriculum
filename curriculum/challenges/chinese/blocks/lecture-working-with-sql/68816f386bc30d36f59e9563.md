---
id: 68816f386bc30d36f59e9563
title: 什么是 SQL 中的归一化？
challengeType: 19
dashedName: what-is-normalization-in-sql
---

# --description--

归一化是使用已建立的范式组织关系数据库的进程，以减少数据冗余并提高数据完整性。

要对数据库进行归一化，你需要分析表格结构中的属性和关系，以根据归一化规则识别简化的机会。然后，你将数据划分为更小、更专注的表格，并使用主键和外键建立它们之间的关系。这些更小的表格将保存你原本拥有的所有数据，但与较大的表格相比，它们更易于管理、组织和使用。

通过最小化数据冗余，归一化减少了存储空间并防止不一致。例如，如果客户的地址发生变化，你只需在一个客户表格中更新，而不是在每个订单记录中都更新。 

它还通过确保依赖关系由主键和外键约束强制执行来帮助保持数据完整性。这减少了插入、更新和删除异常的可能性。

规范化的数据库更易于理解和维护，有助于构建良好设计的数据库系统。

你应该遵循的一组规则来组织你的表格称为范式。每个范式都建立在前一个范式的基础上，随着你向更高的范式移动，规则变得更加严格。第一范式（1NF）是基础形式，具有最基本的规则。

如果一个表格满足第一范式（1NF）：

- 每个单元格应只包含一个值。例如，如果你有一个 `students` 表格，可能有一个学生有多个电话号码。你不应将它们作为逗号分隔的列表保存在一个单元格中，而应创建一个单独的 `phone_numbers` 表格，使用外键指向 `students` 表格，并且每个单元格只保存一个值。这样可以保持每个值的原子性并使设计规范化。
- 每条记录（行）必须是唯一的。虽然主键迫使满足此要求，但 1NF 显式规定表格中不存在副本行。
- 行和列的顺序不应相关。数据不应依赖于其物理位置。

本质上，第一范式（1NF）侧重于使值简单且原子的。

第二范式（2NF）建立在 1NF 之上，要求满足所有 1NF 的要求以及额外的约束。

理解 2NF 需要熟悉两个关键概念：超键和候选键。超键是任何能够唯一标识表格中每一行的属性集合，这意味着没有两行在超键的所有列中具有一致的值。

例如，如果我们有一个包含三列的 `customers` 表格：

```sql
customer_id | name | email
```

假设 `customer_id` 和 `email` 必须对每条记录唯一。该表格的一些超键示例包括：

- `customer_id`
- `{ customer_id, name }`，这个组合唯一标识行，因为单独的 `customer_id` 是唯一的，无论 `name` 是否唯一。
- `{ customer_id, name, email }`
- `email`，由于我们也为这列添加了唯一约束，每条记录都可以通过 email 唯一标识。

任何一组属性，只要能够共同标识每一行，都可以是超键。

候选密钥类似但又有些不同。它是一组一个或多个表格中的列，可以唯一标识每条记录。一个表格可以有多个候选密钥，但你需要选择一个作为主密钥。

它们听起来非常相似，对吧？它们的区别在于，`superkey` 还可以包含不必需用于唯一标识每一行的额外属性，而 `candidate key` 只包含用于唯一标识该行的属性。

在我们的 `customers` 示例中，我们提到 `customer_id`、`{ customer_id, name }`、`{ customer_id, name, email }` 和 `email` 都可以是超键。在这种情况下，只有 `customer_id` 和 `email` 可以是候选密钥，因为候选密钥不能包含无法唯一标识行的属性，比如 `name`。这说明了区分候选密钥和超键的最小性原则。

既然你已经熟悉了这些概念，我们回到第二范式（2NF）。

第二范式（2NF）基于解决部分依赖。当一个属性不是主键的一部分且仅依赖于复合主键的一部分时（复合主键是由多个列组成的主键），表中就会出现部分依赖。这可能导致数据冗余和更新异常。

例如，假设我们有一个带有这些列的 `orders` 表格：

```sql
order_id | item_id | order_date | quantity | order_shipping_city
```

在此表格中，主键是 `order_id` 和 `item_id` 的组合，因为相同的项 ID 可以出现在不同的订单中，但它们的组合将是唯一的。你可以看到 `order_id` 和 `order_shipping_city` 之间存在部分依赖关系。`order_id` 是主键的一部分。`order_shipping_city` 依赖于 `order_id`，因为每个具有相同 ID 的订单都会有相同的送货城市。然而，送货城市不依赖于 `item_id`，但这也是主键的一部分。因此，`order_shipping_city` 不依赖于整个主键。

为了解决这个问题，你可以将表格拆分成两个更小的表格，比如 `order_header` 和 `order_items`。在 `order_header` 表格中，你可以保存关于订单的顶层信息： 

```sql
order_id | order_date | order_shipping_city
```

在 `order_items` 表格中，你可以保存有关已提交的不同订单中项的信息：

```sql
order_id | item_id | quantity
```

通过这些更改，两个表格都将处于第二范式（2NF）。

这就引出了第三范式（3NF）。这种范式是在第二范式的基础上建立的。

要使一个表格达到第三范式，它必须：

- 处于第二范式。
- 所有非密钥属性应直接依赖于主密钥，意味着没有非密钥属性应依赖于另一个非密钥属性。

要理解第三范式（3NF），你需要理解传递依赖。当一个不属于主键的属性依赖于另一个不属于主键的属性，而该属性又依赖于主键时，就发生了传递依赖。

例如，让我们修改我们的 `orders` 表格，使其具有这些列：

```sql
order_id | customer_id | customer_city | city_postal_code | order_date | quantity
```

这个新建表格中的主键是 `order_id`，因为它唯一标识每一行。

此表格中存在传递依赖：

```sql
order_id > customer_id > customer_city > city_postal_code
```

城市的邮政编码由客户的城市决定，客户的城市由客户的 ID 决定，客户的 ID 由订单的 ID 决定。`city_postal_code` 是一个不属于主键的属性，由同样不属于主键的 `customer_city` 决定，但 `customer_city` 是通过 `customer_id` 由 `order_id` 决定的。这意味着居住在同一城市的客户每下一个订单，城市的邮政编码都会被重复。这将导致数据冗余。此外，任何对城市邮政编码的更改都需要更新多个记录。

为了解决传递依赖，你需要将表格拆分成多个表格。首先，是一个 `orders` 表格：

```sql
order_id | customer_id | order_date | quantity
```

然后，一个 `customers` 表格：

```sql
customer_id | city_name
```

以及一个 `cities` 表格：

```sql
city_name | city_postal_code
```

这将从 `table` 中移除传递依赖。

最后，我们有 Boyce-Codd 范式（BCNF）。这也被称为范式 3.5，因为它解决了第三范式可能无法解决的一些异常。为了使一个表格符合 Boyce-Codd 范式（BCNF），它必须：

- 处于第三范式。
- 确保每个函数依赖的左侧都是超键。

该范式的目标是确保每个决定另一个属性的属性或属性集都是一个超密钥，即候选密钥或其超集。

理解和应用范式对于设计健壮且高效的关系数据库至关重要。通过消除数据冗余并确保逻辑数据依赖，归一化能够提升数据完整性、减少存储需求并简化数据库维护。你通常应当目标达到第三范式（3NF）。

# --questions--

## --text--

哪个范式主要关注用单个值替换单行内的数据组？

## --answers--

第一范式（1NF）

---

第二范式（2NF）

### --feedback--

考虑表格中最基本的组织层级以及构成单个不可分割的数据片段的内容。

---

第三范式（3NF）

### --feedback--

考虑表格中最基本的组织层级以及构成单个不可分割的数据片段的内容。

---

Boyce-Codd 范式（BCNF）

### --feedback--

考虑表格中最基本的组织层级以及构成单个不可分割的数据片段的内容。

## --video-solution--

1

## --text--

如果一个表格处于第一范式（1NF），并且以下哪项为真，则该表格处于第二范式（2NF）？

## --answers--

所有非密钥属性都传递依赖于主密钥。

### --feedback--

考虑当一个表格有复合主键时，第二范式（2NF）所解决的问题。

---

所有非密钥属性完全函数依赖于整个主键。

---

每个行列式都是候选密钥。

### --feedback--

考虑当一个表格有复合主键时，第二范式（2NF）所解决的问题。

---

没有重复的数据组。

### --feedback--

考虑当一个表格有复合主键时，第二范式（2NF）所解决的问题。

## --video-solution--

2

## --text--

哪种范数解决了传递依赖，即非密钥属性依赖于另一个非密钥属性？

## --answers--

第一范式（1NF）

### --feedback--

考虑该范式旨在消除的非密钥属性与主键之间的间接关系。

---

第二范式（2NF）

### --feedback--

考虑该范式旨在消除的非密钥属性与主键之间的间接关系。

---

第三范式（3NF）

---

Boyce-Codd 范式（BCNF）

### --feedback--

考虑该范式旨在消除的非密钥属性与主键之间的间接关系。

## --video-solution--

3
