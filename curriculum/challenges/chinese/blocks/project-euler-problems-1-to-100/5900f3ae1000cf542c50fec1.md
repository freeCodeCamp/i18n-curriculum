---
id: 5900f3ae1000cf542c50fec1
title: '问题 66：丢番图方程'
challengeType: 1
forumTopicId: 302178
dashedName: problem-66-diophantine-equation
---

# --description--

考虑形如二次丢番图方程的方程：

<div style='text-align: center;'>x<sup>2</sup> – Dy<sup>2</sup> = 1</div>

考虑形式的二次丢番图方程：x2  -  Dy2 = 1例如，当D = 13时，x中的最小解是6492  -  13×1802 = 1.可以假设当D是正整数时没有解广场。

通过在D中找到D = {2,3,5,6,7}的最小解，我们得到以下结果：32  -  2×22 = 1 22  -  3×12 = 192  -  5×42 = 1 52  -  6× 22 = 1 82  -  7×32 = 1因此，通过考虑D中对于D≤7的最小解，当D = 5时获得最大的x。

在x的最小解中找到D≤1000的值，其中获得x的最大值。

<div style='margin-left: 2em;'>
  3<sup>2</sup> – 2×2<sup>2</sup> = 1<br>
  2<sup>2</sup> – 3×1<sup>2</sup> = 1<br>
  <strong><span style='color: red;'>9</span></strong><sup>2</sup> – 5×4<sup>2</sup> = 1<br>
  5<sup>2</sup> – 6×2<sup>2</sup> = 1<br>
  8<sup>2</sup> – 7×3<sup>2</sup> = 1<br>
</div>

因此，通过考虑 D ≤ 7 时 `x` 的最小方案，当 D=5 时获得最大的 `x`。

查找在 `x` 的最小方案中使 `x` 的最大值被获得的 `D ≤ n` 的值。

# --hints--

`diophantineEquation(7)` 应该返回一个数字。

```js
assert(typeof diophantineEquation(7) === 'number');
```

`diophantineEquation(7)` 应该返回 `5`。

```js
assert.strictEqual(diophantineEquation(7), 5);
```

`diophantineEquation(100)` 应该返回 `61`。

```js
assert.strictEqual(diophantineEquation(100), 61);
```

`diophantineEquation(409)` 应该返回 `409`。

```js
assert.strictEqual(diophantineEquation(409), 409);
```

`diophantineEquation(500)` 应该返回 `421`。

```js
assert.strictEqual(diophantineEquation(500), 421);
```

`diophantineEquation(1000)` 应该返回 `661`。

```js
assert.strictEqual(diophantineEquation(1000), 661);
```

# --seed--

## --seed-contents--

```js
function diophantineEquation(n) {

  return true;
}

diophantineEquation(7);
```

# --solutions--

```js
function diophantineEquation(n) {
  // Based on https://www.mathblog.dk/project-euler-66-diophantine-equation/
  function isSolution(D, numerator, denominator) {
    return numerator * numerator - BigInt(D) * denominator * denominator === 1n;
  }

  let result = 0;
  let biggestX = 0;

  for (let D = 2; D <= n; D++) {
    let boundary = Math.floor(Math.sqrt(D));
    if (boundary ** 2 === D) {
      continue;
    }

    let m = 0n;
    let d = 1n;
    let a = BigInt(boundary);

    let [numerator, prevNumerator] = [a, 1n];

    let [denominator, prevDenominator] = [1n, 0n];

    while (!isSolution(D, numerator, denominator)) {
      m = d * a - m;
      d = (BigInt(D) - m * m) / d;
      a = (BigInt(boundary) + m) / d;

      [numerator, prevNumerator] = [a * numerator + prevNumerator, numerator];
      [denominator, prevDenominator] = [
        a * denominator + prevDenominator,
        denominator
      ];
    }

    if (numerator > biggestX) {
      biggestX = numerator;
      result = D;
    }
  }
  return result;
}
```
