---
id: 6723d3cfdd0717d3f1bf27e3
title: Revisión de JavaScript
challengeType: 31
dashedName: review-javascript
---

# --description--

Revise los conceptos a continuación para prepararse para el próximo examen de preparación.


## Trabajando con HTML, CSS y JavaScript

Mientras que HTML y CSS proporcionan la estructura del sitio web, JavaScript aporta interactividad al permitir funcionalidades complejas, como manejar la entrada del usuario, animar elementos e incluso construir aplicaciones web completas.

## Tipos de datos en JavaScript

Los tipos de datos ayudan al programa a entender el tipo de datos con los que está trabajando, ya sea un número, un texto o algo más.

- **Número**: Un número representa tanto valores enteros como de punto flotante. Los ejemplos de enteros incluyen 7, 19 y 90.
- **Punto flotante**: Un número de punto flotante es un número con punto decimal. Los ejemplos incluyen 3.14, 0.5 y 0.0001.
- **Cadena**: Una cadena es una secuencia de caracteres o texto, encerrado entre comillas. `"Me gusta programar"` y `'JavaScript es divertido'` son ejemplos de cadenas.
- **Booleano**: Un booleano representa uno de dos posibles valores: `true` o `false`. Puedes usar un booleano para representar una condición, como `isLoggedIn = true`.
- **Undefined y Null**: Un valor undefined es una variable que ha sido declarada pero no ha sido asignada un valor. Un valor null es un valor vacío o una variable a la que se le ha asignado intencionadamente el valor `null`.
- **Objeto**: Un objeto es una colección de pares clave-valor. La clave es el nombre de la propiedad y el valor es el valor de la propiedad.

Aquí, el objeto `pet` tiene tres propiedades o claves: `name`, `age` y `type`. Los valores son `Fluffy`, `3` y `perro`, respectivamente.

```js
let pet = {
  name: 'Fluffy',
  age: 3,
  type: 'dog'
};
```

- **Símbolo**: El tipo de dato Symbol es un valor único e inmutable que puede usarse como un identificador para propiedades de objetos.

En el ejemplo a continuación, se crean dos símbolos con la misma descripción, pero no son iguales.

```js
const crypticKey1= Symbol('saltNpepper');
const crypticKey2= Symbol('saltNpepper');
console.log(crypticKey1 === crypticKey2); // false
```

- **BigInt**: Cuando el número es demasiado grande para el tipo de dato `Number`, se puede usar el tipo de dato BigInt para representar enteros de longitud arbitraria.

Al agregar una `n` al final del número, se puede crear un BigInt.

```js
const veryBigNumber = 1234567890123456789012345678901234567890n;
```

## Variables en JavaScript

- Las variables pueden ser declaradas usando la palabra clave `let`.

```js
let cityName;
```

- Para asignar un valor a una variable, se puede usar el operador de asignación `=`.

```js
cityName = 'New York';
```

- Las variables declaradas usando `let` pueden ser reasignadas a un nuevo valor.

```js
cityName = 'Los Angeles';
console.log(cityName); // Los Angeles
```

- Además de `let`, se puede usar `const` para declarar una variable. Sin embargo, una variable `const` no puede ser reasignada a un nuevo valor.

```js
const cityName = 'New York';
cityName = 'Los Angeles'; // TypeError: Assignment to constant variable.
```

- Las variables declaradas usando `const` se utilizan para declarar constantes que no se permiten cambiar a lo largo del código, como `PI` o `MAX_SIZE`.

## Convenciones para la denominación de variables

- Los nombres de las variables deben ser descriptivos y significativos.
- Los nombres de variables deben ser camelCase como `cityName`, `isLoggedIn` y `veryBigNumber`.
- Los nombres de las variables no deben comenzar con un número. Deben comenzar con una letra, `_` o `$`.
- Los nombres de las variables no deben contener espacios ni caracteres especiales, excepto por `_` y `$`.
- Los nombres de las variables no deben ser palabras reservadas.
- Los nombres de las variables distinguen entre mayúsculas y minúsculas. `age` y `Age` son variables diferentes.

## Cadenas e inmutabilidad de cadenas en JavaScript

- Las cadenas son secuencias de caracteres encerradas entre comillas. Se pueden crear usando comillas simples y comillas dobles.

```js
let correctWay = 'This is a string';
let alsoCorrect = "This is also a string";
```

- Las cadenas son inmutables en JavaScript. Esto significa que una vez creada una cadena, no se pueden cambiar los caracteres de la cadena. Sin embargo, aún se pueden reasignar cadenas a un nuevo valor.

```js
let firstName = 'John';
firstName = 'Jane'; // Reassigning the string to a new value
```

## Concatenación de Cadenas en JavaScript

- La concatenación es el proceso de unir múltiples cadenas o combinar cadenas con variables que contienen texto. El operador `+` es uno de los métodos más simples y más frecuentemente usados para concatenar cadenas.

```js
let studentName = 'Asad';
let studentAge = 25;
let studentInfo = studentName + ' is ' + studentAge + ' years old.';
console.log(studentInfo); // Asad is 25 years old.
```

- Si necesitas agregar o adjuntar a una cadena existente, entonces puedes usar el operador `+=`. Esto es útil cuando quieres construir sobre una cadena añadiendo más texto a lo largo del tiempo.

```js
let message = 'Welcome to programming, ';
message += 'Asad!';
console.log(message); // Welcome to programming, Asad!
```

- Otra manera de concatenar cadenas de texto es usar el método `concat()`. Este método une dos o más cadenas.

```js
let firstName = 'John';
let lastName = 'Doe';
let fullName = firstName.concat(' ', lastName);
console.log(fullName); // John Doe
```

## Registro de Mensajes con `console.log()`

- El método `console.log()` se usa para registrar mensajes en la consola. Es una herramienta útil para depurar y probar tu código.

```js
console.log('Hello, World!');
// Output: Hello, World!
```

## Punto y Coma en JavaScript

- Los puntos y comas se usan principalmente para marcar el final de una sentencia. Esto ayuda al motor de JavaScript a entender la separación de instrucciones individuales, lo cual es crucial para una ejecución correcta.

```js
let message = 'Hello, World!'; // first statement ends here
let number = 42; // second statement starts here
```

- Los puntos y comas ayudan a prevenir ambigüedades en la ejecución del código y aseguran que las sentencias se terminen correctamente.

## Comentarios en JavaScript

- Cualquier línea de código que está comentada es ignorada por el motor de JavaScript. Los comentarios se usan para explicar el código, hacer notas o desactivar temporalmente el código.
- Los comentarios de una sola línea se crean utilizando `//`.

```js
// This is a single-line comment and will be ignored by the JavaScript engine
```

- Los comentarios de varias líneas se crean usando `/*` para iniciar el comentario y `*/` para finalizar el comentario.

```js
/*
This is a multi-line comment.
It can span multiple lines.
*/
```

## JavaScript como un Lenguaje de Tipado Dinámico

- JavaScript es un lenguaje de tipado dinámico, lo que significa que no necesitas especificar el tipo de dato de una variable cuando la declaras. El motor de JavaScript determina automáticamente el tipo de dato basado en el valor asignado a la variable.

```js
let error = 404; // JavaScript treats error as a number
error = "Not Found"; // JavaScript now treats error as a string
```

- Otros lenguajes, como Java, que no son de tipado dinámico resultarían en un error:

```java
int error = 404; // value must always be an integer
error = "Not Found"; // This would cause an error in Java
```

## Uso del Operador `typeof`

- El operador `typeof` se usa para verificar el tipo de dato de una variable. Devuelve una cadena que indica el tipo de la variable.

```js
let age = 25;
console.log(typeof age); // number

let isLoggedIn = true;
console.log(typeof isLoggedIn); // boolean
```

- Sin embargo, hay una peculiaridad bien conocida en JavaScript cuando se trata de null. El operador `typeof` devuelve `object` para valores nulos.

```js
let user = null;
console.log(typeof user); // object
```

## Fundamentos de las Cadenas

- **Definición**: Una cadena es una secuencia de caracteres envueltos en comillas simples, dobles o comillas invertidas. Las cadenas son tipos de datos primitivos y son inmutables. La inmutabilidad significa que una vez creada una cadena, no se puede cambiar.
- **Accediendo a Caracteres de una Cadena**: Para acceder a un carácter de una cadena, puedes usar la notación de corchetes y pasar el número de índice. Un índice es la posición de un carácter dentro de una cadena y comienza desde cero.

```js
const developer = "Jessica";
developer[0] // J
```

- **`\n` (Carácter de Nueva Línea)**: Pueds crear una nueva línea en una cadena usando el carácter de nueva línea `\n`.

```js
const poem = "Roses are red,\nViolets are blue,\nJavaScript is fun,\nAnd so are you.";
console.log(poem);
```

- **Escapando Cadenas**: Puedes escapar caracteres en una cadena colocando barras inclinadas (`\`) antes de las comillas.

```js
const statement = "She said, \"Hello!\"";
console.log(statement); // She said, "Hello!"
```

## Literales de Plantilla y Interpolación de Cadenas

- **Definición**: Los literales de plantilla se definen con acentos graves (`). Permiten una manipulación de cadenas más fácil, incluyendo la inserción directamente de variables dentro de una cadena, característica conocida como interpolación de cadenas.

```js
const name = "Jessica";
const greeting = `Hello, ${name}!`; // "Hello, Jessica!"
```

## ASCII, el Método `charCodeAt()` y el Método `fromCharCode()`

- **ASCII**: ASCII, abreviatura de American Standard Code for Information Interchange, es un estándar de codificación de caracteres usado en computadoras para representar texto. Asigna un valor numérico a cada carácter, que es universalmente reconocido por las máquinas.
- **El Método `charCodeAt()`**: Este método se llama sobre una cadena y devuelve el código ASCII del carácter en el índice especificado.

```js
const letter = "A";
console.log(letter.charCodeAt(0));  // 65
```

- **El Método `fromCharCode()`**: Este método convierte un código ASCII en su carácter correspondiente.

```js
const char = String.fromCharCode(65);
console.log(char);  // A
```

## Otros Métodos Comunes de Cadenas

- **El método `indexOf`**: Este método se usa para buscar una subcadena dentro de una cadena. Si se encuentra la subcadena, `indexOf` devuelve el índice (o posición) de la primera aparición de esa subcadena. Si la subcadena no se encuentra, `indexOf` devuelve -1, lo que indica que la búsqueda no tuvo éxito.

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.indexOf("fox")); // 16
console.log(text.indexOf("cat")); // -1
```

- **El Método `includes()`**: Este método se usa para verificar si una cadena contiene una subcadena específica. Si la subcadena se encuentra dentro de la cadena, el método devuelve verdadero. De lo contrario, devuelve falso.

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.includes("fox")); // true
console.log(text.includes("cat")); // false
```

- The **`slice()` Method**: This method returns a new array containing a shallow copy of a portion of the original array, specified by start and end indices. The new array contains references to the same elements as the original array (not duplicates). This means that if the elements are primitives (like numbers or strings), the values are copied; but if the elements are objects or arrays, the references are copied, not the objects themselves.

```js
const text = "freeCodeCamp";
console.log(text.slice(0, 4));  // "free"
console.log(text.slice(4, 8));  // "Code"
console.log(text.slice(8, 12)); // "Camp"
```

- **El Método `toUpperCase()`**: Este método convierte todos los caracteres a letras mayúsculas y devuelve una nueva cadena con todos los caracteres en mayúsculas.

```js
const text = "Hello, world!";
console.log(text.toUpperCase()); // "HELLO, WORLD!"
```

- **El Método `toLowerCase()`**: Este método convierte todos los caracteres de una cadena a minúsculas.

```js
const text = "HELLO, WORLD!"
console.log(text.toLowerCase()); // "hello, world!"
```

- **The `replace()` Method**: This method allows you to find a specified value (like a word or character) in a string and replace it with another value. The method returns a new string with the replacement and leaves the original unchanged because JavaScript strings are immutable.

```js
const text = "I like cats";
console.log(text.replace("cats", "dogs")); // "I like dogs"
```

- **El Método `repeat()`**: Este método se usa para repetir una cadena un número especificado de veces.

```js
const text = "Hello";
console.log(text.repeat(3)); // "HelloHelloHello"
```

- **El método `trim()`**: Este método se usa para eliminar espacios en blanco tanto del principio como del final de una cadena.

```js
const text = "  Hello, world!  ";
console.log(text.trim()); // "Hello, world!"
```

- **El método `trimStart()`**: Este método elimina espacios en blanco del inicio (o "comienzo") de la cadena.

```js
const text = "  Hello, world!  ";
console.log(text.trimStart()); // "Hello, world!  "
```

- **El método `trimEnd()`**: Este método elimina espacios en blanco del final de la cadena.

```js
const text = " Hello, world! ";
console.log(text.trimEnd()); // "  Hello, world!"
```

- **El método `prompt()`**: Este método del `window` se usa para obtener información de un usuario a través de un cuadro de diálogo. Este método toma dos argumentos. El primer argumento es el mensaje que aparecerá dentro del cuadro de diálogo, típicamente solicitando al usuario que ingrese información. El segundo es un valor por defecto que es opcional y llenará el campo de entrada inicialmente.

```js
const answer = window.prompt("What's your favorite animal?"); // This will change depending on what the user answers
```

## Trabajando con el Tipo de Dato Number

- **Definición**: El tipo `Number` de JavaScript incluye números enteros, números de punto flotante, `Infinity` y `NaN`. Los números de punto flotante son números con punto decimal. El `Infinity` positivo es un número mayor que cualquier otro número, mientras que `-Infinity` es un número menor que cualquier otro número. `NaN` (`Not a Number`) representa un valor numérico inválido como la cadena `"Jessica"`.

## Operaciones Aritméticas Comunes

- **Operador de Suma**: Este operador (`+`) se usa para calcular la suma de dos o más números.
- **Operador de Resta**: Este operador (`-`) se usa para calcular la diferencia entre dos números.
- **Operador de Multiplicación**: Este operador (`*`) se usa para calcular el producto de dos o más números.
- **Operador de División**: Este operador (`/`) se usa para calcular el cociente entre dos números.
- **División por Cero**: Si intentas dividir por cero, JavaScript devolverá `Infinity`.
- **Operador de Resto**: Este operador (`%`) devuelve el resto de una división.
- **Operador de Exponenciación**: Este operador (`**`) eleva un número a la potencia de otro.

## Cálculos con Números y Cadenas

- **Explicación**: Cuando usas el operador `+` con un número y una cadena, JavaScript convertirá el número en una cadena y concatenará los dos valores.  Cuando usas los operadores `-`, `*` o `/` con una cadena y un número, JavaScript convertirá la cadena en un número y el resultado será un número. Para `null` y `undefined`, JavaScript trata `null` como 0 y undefined como `NaN` en operaciones matemáticas.

```js
const result = 5 + '10';

console.log(result); // 510
console.log(typeof result); // string

const subtractionResult = '10' - 5;
console.log(subtractionResult); // 5
console.log(typeof subtractionResult); // number

const multiplicationResult = '10' * 2;
console.log(multiplicationResult); // 20
console.log(typeof multiplicationResult); // number

const divisionResult = '20' / 2;
console.log(divisionResult); // 10
console.log(typeof divisionResult); // number

const result1 = null + 5;
console.log(result1); // 5
console.log(typeof result1); // number

const result2 = undefined + 5;
console.log(result2); // NaN
console.log(typeof result2); // number
```

## Precedencia de Operadores

- **Definición**: La precedencia de los operadores determina el orden en que se evalúan las operaciones en una expresión. Los operadores con mayor precedencia se evalúan antes que aquellos con menor precedencia. Los valores dentro de los paréntesis se evaluarán primero y la multiplicación/división tendrá mayor precedencia que la suma/resta. Si los operadores tienen la misma precedencia, entonces JavaScript usará la asociatividad. La asociatividad es lo que indica a JavaScript si debe evaluar los operadores de izquierda a derecha o de derecha a izquierda. Por ejemplo, el operador de exponenciación también es asociativo de derecha a izquierda:

```js
const result = (2 + 3) * 4;

console.log(result); // 20

const result2 = 10 - 2 + 3;

console.log(result2); // 11

const result3 = 2 ** 3 ** 2;

console.log(result3); // 512
```

## Operadores de Incremento y Decremento

- **Operador de Incremento**: Este operador se usa para aumentar el valor en uno. La notación de prefijo `++num` aumenta el valor de la variable primero, luego devuelve un nuevo valor. La notación de sufijo `num++` devuelve el valor actual de la variable primero, luego lo incrementa.

```js
let x = 5;

console.log(++x); // 6
console.log(x); // 6


let y = 5;

console.log(y++); // 5
console.log(y); // 6
```

- **Operador de Decremento**: Este operador se usa para disminuir el valor en uno. La notación de prefijo y sufijo funciona de la misma manera que antes con el operador de incremento.

```js
let num = 5;

console.log(--num); // 4
console.log(num--); // 4
console.log(num); // 3
```

## Operadores de Asignación Compuestos

- **Operador de Asignación de Suma (`+=`)**: Este operador realiza la suma sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de Resta (`-=`)**: Este operador realiza la resta sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de Multiplicación (`*=`)**: Este operador realiza la multiplicación sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de División (`/=`)**: Este operador realiza la división sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de Resto (`%=`)**: Este operador divide una variable por el número especificado y asigna el resto a la variable.
- **Operador de Asignación de Exponenciación (`**=`)**: Este operador eleva una variable a la potencia del número especificado y reasigna el resultado a la variable.

## Booleanos e Igualdad

- **Definición de Booleano**: Un booleano es un tipo de dato que solo puede tener dos valores: `true` o `false`.
- **Operador de Igualdad (`==`)**: Este operador usa la coerción de tipos antes de verificar si los valores son iguales.

```js
console.log(5 == '5'); // true
```

- **Operador de Igualdad Estricta (`===`)**: Este operador no realiza la coerción de tipos y verifica si tanto los tipos como los valores son iguales.

```js
console.log(5 === '5'); // false
```

- **Operador de Desigualdad (`!=`)**: Este operador usa la coerción de tipos antes de verificar si los valores no son iguales.
- **Operador de Desigualdad Estricta (`!==`)**: Este operador no realiza la coerción de tipos y verifica si tanto los tipos como los valores no son iguales.

## Operadores de Comparación

- **Operador Mayor Que (`>`)**: Este operador verifica si el valor de la izquierda es mayor que el de la derecha.
- **Operador Mayor Que o Igual (`>=`)**: Este operador verifica si el valor de la izquierda es mayor o igual que el de la derecha.
- **Operador Menor Que (`<`)**: Este operador verifica si el valor de la izquierda es menor que el de la derecha.
- **Operador Menor Que o Igual (`<=`)**: Este operador verifica si el valor de la izquierda es menor o igual que el de la derecha.

## Operadores Unarios

- **Operador Unario de Suma**: Este operador convierte su operando en un número. Si el operando ya es un número, se mantiene sin cambios.

```js
const str = '42';
const num = +str;

console.log(num); // 42
console.log(typeof num); // number
```

- **Operador de Negación Unaria (`-`)**: Este operador niega el operando.

```js
const num = 4;
console.log(-num); // -4
```

- **Operador Lógico NO (`!`)**: Este operador invierte el valor booleano de su operando. Entonces, si el operando es `true`, se convierte en `false`, y si es `false`, se convierte en `true`. 

## Operadores Bit a Bit

- **Operador AND Bit a Bit (`&`)**: Este operador devuelve un 1 en cada posición de bit para la cual los bits correspondientes de ambos operandos son 1.
- **Operador de Asignación AND Bit a Bit (`&=`)**: Este operador realiza una operación `bitwise AND` con el número especificado y reasigna el resultado a la variable.
- **Operador OR a nivel de bit (`|`)**: Este operador devuelve un 1 en cada posición de bit para la cual los bits correspondientes de cualquiera o ambos operandos son 1.
- **Operador de asignación OR a nivel de bit (`|=`)**: Este operador realiza una operación `OR a nivel de bit` con el número especificado y reasigna el resultado a la variable.
- **Operador XOR a nivel de bit (`^`)**: Este operador devuelve un 1 en cada posición de bit para la cual los bits correspondientes de uno, pero no de ambos, operandos son 1.
- **Operador NOT a nivel de bit (`~`)**: Este operador invierte la representación binaria de un número.
- **Operador de desplazamiento a la izquierda (`<<`)**: Este operador desplaza todos los bits a la izquierda por un número especificado de posiciones.
- **Operador de desplazamiento a la derecha (`>>`)**: Este operador desplaza todos los bits a la derecha.

## Sentencias condicionales, valores truthy, valores falsy y el operador ternario

- **`if/else if/else`**: Una sentencia `if` toma una condición y ejecuta un bloque de código si esa condición es `truthy`. Si la condición es `false`, entonces pasa al bloque `else if`. Si ninguna de esas condiciones es `true`, entonces ejecutará la cláusula `else`. Los valores `truthy` son aquellos valores que resultan en `true` cuando se evalúan en un contexto booleano como una sentencia `if`. Los valores `falsy` son valores que evalúan como `false` en un contexto booleano.

```js
const score = 87;

if (score >= 90) {
 console.log('You got an A'); 
} else if (score >= 80) {
 console.log('You got a B'); // You got an B
} else if (score >= 70) {
 console.log('You got a C');
} else {
 console.log('You failed! You need to study more!');
}
```

- **Operador Ternario**: Este operador se utiliza a menudo como una forma más corta de escribir sentencias `if else`.

```js
const temperature = 30;
const weather = temperature > 25 ? 'sunny' : 'cool';

console.log(`It's a ${weather} day!`); // It's a sunny day!
```

## Operadores lógicos binarios

- **Operador lógico AND (`&&`)**: Este operador verifica si ambos operandos son truthy. Si el primer valor es truthy, entonces devolverá el segundo valor. Si el primer valor es falsy, entonces devolverá el primer valor.

```js
const result = true && 'hello';

console.log(result); // hello
```

- **Operador lógico OR (`||`)**: Este operador verifica si al menos uno de los operandos es truthy. Si el primer valor es truthy, entonces se devuelve. Si el primer valor es falsy, entonces se devuelve el segundo valor.
- **Operador de coalescencia nula (`??`)**: Este operador devolverá un valor solo si el primero es `null` o `undefined`.

```js
const userSettings = {
 theme: null,
 volume: 0,
 notifications: false,
};

let theme = userSettings.theme ?? 'light';
console.log(theme); // light
```

## El objeto `Math`

- **El método `Math.random()`**: Este método genera un número aleatorio de punto flotante entre 0 (inclusive) y 1 (exclusivo). Esto significa que la salida posible puede ser 0, pero nunca llegará realmente a 1.
- **El método `Math.max()`**: Este método toma un conjunto de números y devuelve el valor máximo.
- **El método `Math.min()`**: Este método toma un conjunto de números y devuelve el valor mínimo.
- **El método `Math.ceil()`**: Este método redondea un valor al alza al entero más cercano.
- **El método `Math.floor()`**: Este método redondea un valor a la baja al entero más cercano.
- **El método `Math.round()`**: Este método redondea un valor al entero más cercano.

```js
console.log(Math.round(2.3)); // 2
console.log(Math.round(4.5)); // 5
console.log(Math.round(4.8)); // 5
```

- **El método `Math.trunc()`**: Este método elimina la parte decimal de un número, devolviendo solo la porción entera, sin redondear.
- **El método `Math.sqrt()`**: Este método devuelve la raíz cuadrada de un número.
- **El método `Math.cbrt()`**: Este método devuelve la raíz cúbica de un número.
- **El método `Math.abs()`**: Este método devuelve el valor absoluto de un número.
- **El método `Math.pow()`**: Este método toma dos números y eleva el primero a la potencia del segundo.

## Métodos numéricos comunes

- **`isNaN()`**: `NaN` significa "Not-a-Number" (No es un número). Es un valor especial que representa un resultado numérico no representable o indefinido. La propiedad de función `isNaN()` se utiliza para determinar si un valor es `NaN` o no.  `Number.isNaN()` proporciona una forma más confiable de verificar valores `NaN`, especialmente en casos donde la coerción de tipos podría llevar a resultados inesperados con la función global `isNaN()`.

```js
console.log(isNaN(NaN));       // true
console.log(isNaN(undefined)); // true
console.log(isNaN({}));        // true

console.log(isNaN(true));      // false
console.log(isNaN(null));      // false
console.log(isNaN(37));        // false


console.log(Number.isNaN(NaN));        // true
console.log(Number.isNaN(Number.NaN)); // true
console.log(Number.isNaN(0 / 0));      // true

console.log(Number.isNaN("NaN"));      // false
console.log(Number.isNaN(undefined));  // false
```

- **El método `parseFloat()`**: Este método analiza un argumento cadena y devuelve un número de punto flotante. Está diseñado para extraer un número desde el principio de una cadena, incluso si la cadena contiene caracteres no numéricos más adelante.
- **El método `parseInt()`**: Este método analiza un argumento cadena y devuelve un entero. `parseInt()` deja de analizar al primer carácter no dígito que encuentra. Para números de punto flotante, solo devuelve la parte entera. Si no puede encontrar un entero válido al principio de la cadena, devuelve `NaN`.
- **El método `toFixed()`**: Este método se llama en un número y toma un argumento opcional, que es el número de dígitos que aparecerán después del punto decimal. Devuelve una representación en cadena del número con la cantidad de decimales especificada.

## Comparaciones y los tipos de datos `null` y `undefined`

- **Comparaciones y `undefined`**: Una variable es `undefined` cuando ha sido declarada pero no se le ha asignado un valor. Es el valor predeterminado de variables no inicializadas y parámetros de funciones a los que no se les proporcionó un argumento. `undefined` se convierte en `NaN` en contextos numéricos, lo que hace que todas las comparaciones numéricas con `undefined` devuelvan `false`.

```js
console.log(undefined < 0); // false (NaN < 0 is false)
console.log(undefined >= 0); // false (NaN >= 0 is false)
```

- **Comparaciones y `null`**: El tipo `null` representa la ausencia intencional de un valor. `null` converts to `0` in numeric contexts, which may result in unexpected behavior in numeric comparisions:

```js
console.log(null < 0); // false (0 < 0 is false)
console.log(null >= 0); // true (0 >= 0 is true)
```

- When using the equality operator (`==`), `null` and `undefined` only equal each other and themselves:

```js
console.log(null == undefined); // true
console.log(null == 0); // false
console.log(undefined == NaN); // false
```

- Sin embargo, cuando se utiliza el operador de igualdad estricta (`===`), que verifica tanto el valor como el tipo sin realizar coerción de tipos, `null` y `undefined` no son iguales.

```js
console.log(null === undefined); // false
```

## Sentencias `switch`

- **Definición**: Una sentencia `switch` evalúa una expresión y compara su valor contra una serie de cláusulas `case`. Cuando se encuentra una coincidencia, se ejecuta el bloque de código asociado a ese caso.

```js
const dayOfWeek = 3; 

switch (dayOfWeek) {
  case 1:
    console.log("It's Monday! Time to start the week strong.");
    break;
  case 2:
    console.log("It's Tuesday! Keep the momentum going.");
    break;
  case 3:
    console.log("It's Wednesday! We're halfway there.");
    break;
  case 4:
    console.log("It's Thursday! Almost the weekend.");
    break;
  case 5:
    console.log("It's Friday! The weekend is near.");
    break;
  case 6:
    console.log("It's Saturday! Enjoy your weekend.");
    break;
  case 7:
    console.log("It's Sunday! Rest and recharge.");
    break;
  default:
    console.log("Invalid day! Please enter a number between 1 and 7.");
}
```

## Funciones de JavaScript

- Las funciones son bloques de código reutilizables que realizan una tarea específica.
- Las funciones se pueden definir usando la palabra clave `function` seguida de un nombre, una lista de parámetros y un bloque de código que realiza la tarea.
- Los argumentos son valores que se pasan a una función cuando se llama.
- Cuando una función termina su ejecución, siempre devolverá un valor.
- Por defecto, el valor de retorno de una función es `undefined`.
- La palabra clave `return` se utiliza para especificar el valor que se devolverá de la función y finaliza la ejecución de la función.

## Funciones flecha

- Las funciones flecha son una forma más concisa de escribir funciones en JavaScript.
- Las funciones flecha se definen usando la sintaxis `=>` entre los parámetros y el cuerpo de la función.
- Al definir una función flecha, no necesitas la palabra clave `function`.
- Si estás utilizando un solo parámetro, puedes omitir los paréntesis alrededor de la lista de parámetros.
- Si el cuerpo de la función consiste en una sola expresión, puedes omitir las llaves y la palabra clave `return`.

## Ámbito en la programación

- **Ámbito global**: Este es el ámbito más externo en JavaScript. Las variables declaradas en el ámbito global son accesibles desde cualquier parte del código y se denominan variables globales.
- **Ámbito local**: Esto refiere a variables declaradas dentro de una función. Estas variables solo son accesibles dentro de la función donde se declaran y se les llama variables locales.
- **Ámbito de bloque**: Un bloque es un conjunto de sentencias encerradas en llaves `{}` como en las sentencias `if` o los bucles.
- El ámbito de bloque con `let` y `const` proporciona un control aún más fino sobre la accesibilidad de variables, ayudando a prevenir errores y haciendo que tu código sea más predecible.

## Conceptos básicos de arreglos en JavaScript

- **Definición**: Un arreglo en JavaScript es una colección ordenada de valores, cada uno identificado por un índice numérico. Los valores en un arreglo de JavaScript pueden ser de diferentes tipos de datos, incluidos números, cadenas, booleanos, objetos e incluso otros arreglos. Los arreglos son continuos en memoria, lo que significa que todos los elementos se almacenan en un solo bloque continuo de ubicaciones de memoria, lo que permite una indexación eficiente y un acceso rápido a los elementos por su índice.

```js
const developers = ["Jessica", "Naomi", "Tom"];
```

- **Accediendo a elementos desde arreglos**: Para acceder a elementos de un arreglo, necesitas referenciar el arreglo seguido de su número de índice dentro de corchetes. Los arreglos en JavaScript tienen indexación basada en cero, lo que significa que el primer elemento está en el índice 0, el segundo elemento está en el índice 1, etc. Si intentas acceder a un índice que no existe para el arreglo, entonces JavaScript devolverá `undefined`.

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers[0] // "Jessica"
developers[1] // "Naomi"

developers[10] // undefined
```

- **Propiedad `length`**: Esta propiedad se utiliza para devolver el número de elementos en un arreglo.

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers.length // 3
```

- **Actualizando elementos en un arreglo**: Para actualizar un elemento en un arreglo, usas el operador de asignación (`=`) para asignar un nuevo valor al elemento en un índice específico.

```js
const fruits = ['apple', 'banana', 'cherry'];
fruits[1] = 'blueberry';

console.log(fruits); // ['apple', 'blueberry', 'cherry']
```

## Arreglos bidimensionales

- **Definición**: Un arreglo bidimensional es esencialmente un arreglo de arreglos. Se usa para representar datos que tienen una estructura natural en forma de cuadrícula, como un tablero de ajedrez, una hoja de cálculo o píxeles en una imagen. Para acceder a un elemento en un arreglo bidimensional, necesitas dos índices: uno para la fila y otro para la columna.

```js
const chessboard = [
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']
];

console.log(chessboard[0][3]); // "Q"
```

## Desestructuración de arreglos

- **Definición**: La desestructuración de arreglos es una característica en JavaScript que te permite extraer valores de arreglos y asignarlos a variables de una manera más concisa y legible. Proporciona una sintaxis conveniente para desempacar elementos de arreglos en variables distintas.

```js
const fruits = ["apple", "banana", "orange"];

const [first, second, third] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(third); // "orange"
```

- **Sintaxis de propagación**: Esto te permite capturar los elementos restantes de un arreglo que no han sido desestructurados en un nuevo arreglo.

```js
const fruits = ["apple", "banana", "orange", "mango", "kiwi"];
const [first, second, ...rest] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(rest); // ["orange", "mango", "kiwi"]
```

## Métodos comunes de arreglos

- **Método `push()`**: Este método se utiliza para agregar elementos al final del arreglo y devolverá la nueva longitud.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.push("ice cream");

console.log(desserts); // ["cake", "cookies", "pie", "ice cream"];
```

- **Método `pop()`**: Este método se utiliza para eliminar el último elemento de un arreglo y devolverá ese elemento eliminado. If the array is empty, then the return value will be `undefined`.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.pop();

console.log(desserts); // ["cake", "cookies"];
```

- **Método `shift()`**: Este método se utiliza para eliminar el primer elemento de un arreglo y devolverá ese elemento eliminado. Si el arreglo está vacío, el valor de retorno será `undefined`.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.shift();

console.log(desserts); // ["cookies", "pie"];
```

- **Método `unshift()`**: Este método se utiliza para agregar elementos al principio del arreglo y devolverá la nueva longitud.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.unshift("ice cream");

console.log(desserts); // ["ice cream", "cake", "cookies", "pie"];
```

- **Método `indexOf()`**: Este método es útil para encontrar el primer índice de un elemento específico dentro de un arreglo. If the element cannot be found, then it will return `-1`.

```js
const fruits = ["apple", "banana", "orange", "banana"];
const index = fruits.indexOf("banana");

console.log(index); // 1
console.log(fruits.indexOf("not found")); // -1
```

- **Método `splice()`**: Este método se utiliza para agregar o eliminar elementos de cualquier posición en un arreglo. El valor de retorno del método `splice()` será un arreglo de los elementos eliminados del arreglo. Si no se eliminó nada, se devolverá un arreglo vacío. Este método mutará el arreglo original, modificándolo en su lugar en lugar de crear un nuevo arreglo. El primer argumento especifica el índice en el que comenzar a modificar el arreglo. El segundo argumento es el número de elementos que deseas eliminar. Los siguientes argumentos son los elementos que deseas agregar.

```js
const colors = ["red", "green", "blue"];
colors.splice(1, 0, "yellow", "purple");

console.log(colors); // ["red", "yellow", "purple", "green", "blue"]
```

- **Método `includes()`**: Este método se utiliza para verificar si un arreglo contiene un valor específico. Este método devuelve `true` si el arreglo contiene el elemento especificado, y `false` de otra manera.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];

console.log(programmingLanguages.includes("Python")); // true
console.log(programmingLanguages.includes("Perl")); // false
```

- **Método `concat()`**: Este método crea un nuevo arreglo fusionando dos o más arreglos.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.concat("Perl");

console.log(newList); // ["JavaScript", "Python", "C++", "Perl"]
```

- **`slice()` Method**: This method returns a shallow copy of a portion of the array, starting from a specified index or the entire array. Una copia superficial copiará la referencia al arreglo en lugar de duplicarlo.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.slice(1);

console.log(newList); // ["Python", "C++"]
```

- **Sintaxis de propagación**: La sintaxis de propagación se utiliza para crear copias superficiales de un arreglo.

```js
const originalArray = [1, 2, 3];
const shallowCopiedArray = [...originalArray];

shallowCopiedArray.push(4);

console.log(originalArray); // [1, 2, 3]
console.log(shallowCopiedArray); // [1, 2, 3, 4]
```

- **Método `split()`**: Este método divide una cadena en un arreglo de subcadenas y especifica dónde debe ocurrir cada división según un separador dado. Si no se proporciona un separador, el método devuelve un arreglo que contiene la cadena original como un solo elemento.

```js
const str = "hello";
const charArray = str.split("");

console.log(charArray); // ["h", "e", "l", "l", "o"]
```

- **Método `reverse()`**: Este método invierte un arreglo en su lugar.

```js
const desserts = ["cake", "cookies", "pie"];
console.log(desserts.reverse()); // ["pie", "cookies", "cake"]
```

- **Método `join()`**: Este método concatena todos los elementos de un arreglo en una sola cadena, con cada elemento separado por un separador especificado. Si no se proporciona un separador o se utiliza una cadena vacía (`""`), los elementos se unirán sin ningún separador.

```js
const reversedArray = ["o", "l", "l", "e", "h"];
const reversedString = reversedArray.join("");

console.log(reversedString); // "olleh"
```

## Conceptos básicos de objetos

- **Definición**: Un objeto es una estructura de datos que se compone de propiedades. Una propiedad consta de una clave y un valor. Para acceder a datos de un objeto, puedes usar notación de punto o notación de corchetes.

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};

console.log(person.name);  // Alice
console.log(person["name"]); // Alice
```

Para establecer una propiedad de un objeto existente, puedes usar tanto la notación de punto como la notación de corchetes junto con el operador de asignación.

```js
const person = {
  name: "Alice",
  age: 30
};

person.job = "Engineer"
person["hobby"] = "Knitting"
console.log(person);  // {name: 'Alice', age: 30, job: 'Engineer', hobby: 'Knitting'}
```

## Eliminar propiedades de un objeto

- **Operador `delete`**: Este operador se usa para eliminar una propiedad de un objeto.

```js
const person = {
  name: "Alice",
  age: 30,
  job: "Engineer"
};

delete person.job;

console.log(person.job); // undefined
```

## Comprobando si un objeto tiene una propiedad

- **Método `hasOwnProperty()`**: Este método devuelve un valor booleano que indica si el objeto tiene la propiedad especificada como su propia propiedad.

```js
const person = {
  name: "Alice",
  age: 30
};

console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("job")); // false
```

- **Operador `in`**: Este operador devolverá `true` si la propiedad existe en el objeto.

```js
const person = {
  name: "Bob",
  age: 25
};

console.log("name" in person);  // true
```

## Accediendo a propiedades de objetos anidados

- **Accediendo a Datos**: Acceder a propiedades de objetos anidados implica usar la notación de punto o la notación de corchetes, similar al acceso a propiedades de objetos simples. Sin embargo, necesitarás encadenar estos accesores para profundizar en la estructura anidada.

```js
const person = {
  name: "Alice",
  age: 30,
  contact: {
    email: "alice@example.com",
    phone: {
      home: "123-456-7890",
      work: "098-765-4321"
    }
  }
};

console.log(person.contact.phone.work); // "098-765-4321"
```

## Tipos de datos primitivos y no primitivos

- **Tipos de datos primitivos**: Estos tipos de datos incluyen números, cadenas, booleanos, `null`, `undefined` y símbolos. Estos tipos se llaman "primitivos" porque representan valores únicos y no son objetos. Los valores primitivos son inmutables, lo que significa que una vez que se crean, su valor no se puede cambiar.
- **Tipos de datos no primitivos**: En JavaScript, estos son objetos, que incluyen objetos regulares, arreglos y funciones. A diferencia de los primitivos, los tipos no primitivos pueden contener múltiples valores como propiedades o elementos.

## Métodos de objetos

- **Definición**: Los métodos de objeto son funciones que están asociadas a un objeto. Se definen como propiedades de un objeto y pueden acceder y manipular los datos del objeto. La palabra clave `this` dentro del método se refiere al propio objeto, lo que permite el acceso a sus propiedades.

```js
const person = {
  name: "Bob",
  age: 30,
  sayHello: function() {
    return "Hello, my name is " + this.name;
  }
};

console.log(person.sayHello()); // "Hello, my name is Bob"
```

## Constructor de objetos

- **Definición**: En JavaScript, un constructor es un tipo especial de función utilizado para crear e inicializar objetos. Se invoca con la palabra clave `new` y puede inicializar propiedades y métodos en el objeto recién creado. El constructor `Object()` crea un nuevo objeto vacío.

```js
new Object()
```

## Trabajando con el operador de encadenamiento opcional (`?.`)

- **Definición**: Este operador te permite acceder de forma segura a las propiedades de un objeto o llamar métodos sin preocuparte de si existen.

```js
const user = {
  name: "John",
  profile: {
    email: "john@example.com",
    address: {
      street: "123 Main St",
      city: "Somewhere"
    }
  }
};

console.log(user.profile?.address?.street); // "123 Main St"
console.log(user.profile?.phone?.number);   // undefined
```

## Desestructuración de Objeto

- **Definición**: La desestructuración de objetos te permite extraer valores de objetos y asignarlos a variables de manera más concisa y legible.

```js
const person = { name: "Alice", age: 30, city: "New York" };

const { name, age } = person;

console.log(name); // Alice
console.log(age);  // 30
```

## Trabajar con JSON

- **Definición**: JSON significa Notación de Objetos JavaScript. Es un formato de datos ligero y basado en texto que se usa comúnmente para intercambiar datos entre un servidor y una aplicación web.

```js
{
  "name": "Alice",
  "age": 30,
  "isStudent": false,
  "list of courses": ["Mathematics", "Physics", "Computer Science"]
}
```

- **`JSON.stringify()`**: Este método se usa para convertir un objeto JavaScript en una cadena JSON. Esto es útil cuando quieres almacenar o transmitir datos en un formato que pueda ser fácilmente compartido o transferido entre sistemas.

```js
const user = {
  name: "John",
  age: 30,
  isAdmin: true
};

const jsonString = JSON.stringify(user);
console.log(jsonString); // '{"name":"John","age":30,"isAdmin":true}'
```

- **`JSON.parse()`**: Este método convierte una cadena JSON de nuevo a un objeto de JavaScript. Esto es útil cuando recuperas datos JSON de un servidor web o localStorage y necesitas manipular los datos en tu aplicación.

```js
const jsonString = '{"name":"John","age":30,"isAdmin":true}';
const userObject = JSON.parse(jsonString);

// result: { name: 'John', age: 30, isAdmin: true }
console.log(userObject);
```


## Trabajar con Bucles

- **`for` Loop**: Este tipo de bucle se usa para repetir un bloque de código un cierto número de veces. Este bucle se divide en tres partes: la declaración de inicialización, la condición y la declaración de incremento/decremento. La sentencia de inicialización se ejecuta antes de que comience el bucle. Normalmente se utiliza para inicializar una variable contadora. La condición se evalúa antes de cada iteración del bucle. Una iteración es un único paso a través del bucle. Si la condición es `true`, el bloque de código dentro del bucle se ejecuta. Si la condición es `false`, el bucle se detiene y se pasa al siguiente bloque de código. La sentencia de incremento/decremento se ejecuta después de cada iteración del bucle. Normalmente se utiliza para incrementar o decrementar la variable contadora.

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

- **`for...of` Loop**: Este tipo de bucle se usa cuando necesitas iterar sobre valores de un iterable. Ejemplos de iterables son arreglos y cadenas.

```js
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num);
}
```

- **`for...in` Loop**: Este tipo de bucle es mejor usarlo cuando necesitas iterar sobre las propiedades de un objeto. Este bucle iterará sobre todas las propiedades enumerables de un objeto, incluidas propiedades heredadas y propiedades no numéricas.

```js
const fruit = {
  name: 'apple',
  color: 'red',
  price: 0.99
};

for (const prop in fruit) {
  console.log(fruit[prop]);
}
```

- **`while` Loop**: Este tipo de bucle ejecutará un bloque de código mientras la condición sea `true`.

```js
let i = 5;

while (i > 0) {
  console.log(i);
  i--;
}
```

- **`do...while` Loop**: Este tipo de bucle ejecutará el bloque de código al menos una vez antes de comprobar la condición.

```js
let userInput;

do {
  userInput = prompt("Please enter a number between 1 and 10");
} while (Number(userInput) < 1 || Number(userInput) > 10);

alert("You entered a valid number!");
```

## `break` y `continue` Sentencias

- **Definición**: Una sentencia `break` se usa para salir de un bucle anticipadamente, mientras que una sentencia `continue` se usa para saltar la iteración actual de un bucle y pasar a la siguiente.

```js
// Example of break statement
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, and 4

// Example of continue statement 
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    continue;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, 4, 6, 7, 8, and 9
```

## Constructor de Cadena y `toString()` Método

- **Definición**: Un objeto cadena se usa para representar una secuencia de caracteres. Los objetos cadena se crean usando la función constructora `String`, que envuelve el valor primitivo en un objeto.

```js
const greetingObject = new String("Hello, world!");

console.log(typeof greetingObject); // "object"
```

- **`toString()` Método**: Este método convierte un valor a su representación de cadena. Es un método que puedes usar para números, booleanos, arreglos y objetos.

```js
const num = 10;
console.log(num.toString()); // "10"

const arr = [1, 2, 3];
console.log(arr.toString()); // "1,2,3"
```

Este método acepta un radix opcional que es un número del 2 al 36. Este radix representa la base, como la base 2 para binario o base 8 para octal. Si el radix no se especifica, se establece por defecto en base 10, que es decimal.


```js
const num = 10;
console.log(num.toString(2)); // "1010"(binary)
```

## Constructor de Número

- **Definición**: El constructor `Number` se usa para crear un objeto número. El objeto número contiene algunas propiedades y métodos útiles como el método `isNaN` y `toFixed`. La mayor parte del tiempo, utilizarás el constructor `Number` para convertir otros tipos de datos al tipo de dato número.

```js
const myNum = new Number("34");
console.log(typeof myNum); // "object"

const num = Number('100');
console.log(num); // 100

console.log(typeof num); // number
```

## Mejores Prácticas para Nombrar Variables y Funciones

- **camelCasing**: Por convención, los desarrolladores de JavaScript usarán camel casing para nombrar variables y funciones. El camel casing es donde la primera palabra está en minúsculas y las palabras siguientes comienzan con una mayúscula. Ej. `isLoading`.

- **Nombrando Booleans**: Para variables booleanas, es una práctica común usar prefijos como "is", "has", o "can".

```js
let isLoading = true;
let hasPermission = false;
let canEdit = true;
```

- **Nombrando Funciones**: Para funciones, el nombre debe indicar claramente lo que hace la función. Para funciones que retornan un booleano (a menudo llamadas predicados), puedes usar los mismos prefijos "is", "has", o "can". Cuando tienes funciones que recuperan datos, es común comenzar con la palabra "get". Cuando tienes funciones que establecen datos, es común comenzar con la palabra "establecer". Para funciones manejadoras de eventos, podrías prefijar con "handle" o sufijar con "Handler".

```js
function getUserData() { /* ... */ }

function isValidEmail(email) { /* ... */ }

function getProductDetails(productId) { /* ... */ }

function setUserPreferences(preferences) { /* ... */ }

function handleClick() { /* ... */ }
```

- **Nombrando Variables Dentro de Bucles**: Al nombrar variables iteradoras en bucles, es común usar letras individuales como `i`, `j`, o `k`.

```js
for (let i = 0; i < array.length; i++) { /* ... */ }
```

## Trabajar con Arreglos Dispersos

- **Definición**: Es posible tener arreglos con posiciones vacías. Las posiciones vacías se definen como posiciones sin nada en ellas. Esto es diferente de las posiciones de un arreglo con el valor `undefined`. Estos tipos de arreglos se conocen como arreglos dispersos.

```js
const sparseArray = [1, , , 4];
console.log(sparseArray.length); // 4
```

## Linter y Formateadores

- **Linter**: Un linter es una herramienta de análisis de código estático que marca errores de programación, errores de estilo y construcciones sospechosas. Un ejemplo de un linter común sería ESLint.
- **Formateadores**: Los formateadores son herramientas que formatean tu código automáticamente para adherirse a una guía de estilo específica. Un ejemplo de un formateador común es Prettier.

## Gestión de Memoria

- **Definición**: La gestión de memoria es el proceso de controlar la memoria, asignándola cuando es necesaria y liberándola cuando ya no es necesaria. JavaScript usa gestión de memoria automática. Esto significa que JavaScript (más específicamente, el motor de JavaScript en tu navegador web) se encarga de la asignación y liberación de memoria por ti.  No tienes que liberar explícitamente la memoria en tu código. Este proceso automático se llama a menudo "recolección de basura".

## Clausuras

- **Definición**: Una clausura es una función que tiene acceso a variables en su ámbito léxico externo (envolvente), incluso después de que la función externa haya devuelto.

```js
function outerFunction(x) {
  let y = 10;
  function innerFunction() {
    console.log(x + y);
  }
  return innerFunction;
}

let closure = outerFunction(5);
closure(); // 15
```

## `var` Palabra Clave y Elevación

- **Definición**: `var` era la forma original de declarar variables antes de 2015. Pero había algunos problemas que surgían con `var` en términos de ámbito, redeclaración y más. Por eso, la programación moderna en JavaScript utiliza `let` y `const` en su lugar.
- **Redeclaración de Variables con `var`**: Si intentas redeclarar una variable usando `let`, entonces obtendrías un `SyntaxError`. Pero con `var`, se te permite redeclarar una variable.

```js
// Uncaught SyntaxError: Identifier 'num' has already been declared 
let num = 19;
let num = 18;

var myNum = 5;
var myNum = 10; // This is allowed and doesn't throw an error

console.log(myNum) // 10
```

- **`var` y Ámbito**: Las variables declaradas con `var` dentro de un bloque (como una sentencia `if` o un bucle `for`) aún son accesibles fuera de ese bloque.

```js
if (true) {
  var num = 5;
}
console.log(num); // 5
```

- **Elevación**: Este es el comportamiento predeterminado de JavaScript de mover las declaraciones al principio de sus respectivos ámbitos durante la fase de compilación antes de que se ejecute el código. Cuando declaras una variable usando la palabra clave `var`, JavaScript eleva la declaración al inicio de su ámbito.

```js
console.log(num); // undefined
var num = 5;
console.log(num); // 5
```

Cuando declaras una función usando la sintaxis de declaración de función, tanto el nombre de la función como el cuerpo de la función son elevados. Esto significa que puedes invocar una función antes de haberla declarado en tu código.

```js
sayHello(); // "Hello, World!"

function sayHello() {
  console.log("Hello, World!");
}
```

Las declaraciones de variables hechas con `let` o `const` son elevadas, pero no están inicializadas, y no puedes acceder a ellas antes de la declaración real en tu código. Este comportamiento se refiere a menudo como la "zona muerta temporal".

```js
console.log(num); // Throws a ReferenceError
let num = 10;
```

## Trabajar con Importaciones, Exportaciones y Módulos

- **Módulo**: Esta es una unidad de código autónoma que encapsula funciones relacionadas, clases o variables. Para crear un módulo, escribe tu código JavaScript en un archivo separado.
- **Exportaciones**: Cualquier variable, función o clase que desees poner a disposición de otras partes de tu aplicación debe exportarse explícitamente usando la palabra clave `export`. Hay dos tipos de exportación: exportación nombrada y exportación por defecto.
- **Importaciones**: Para usar los elementos exportados en otra parte de tu aplicación, necesitas importarlos usando la palabra clave `import`. Los tipos pueden ser importación nombrada, importación por defecto e importación de espacio de nombre.

```js
// Within a file called math.js, we export the following functions:

// Named export
export function add(num1, num2) {
  return num1 + num2;
}

// Default export
export default function subtract(num1, num2) {
  return num1 - num2;
}

// Within another file, we can import the functions from math.js.

// Named import - This line imports the add function.
// The name of the function must exactly match the one exported from math.js.
import { add } from './math.js';

// Default import - This line imports the subtract function.
// The name of the function can be anything.
import subtractFunc from './math.js';

// Namespace import - This line imports everything from the file.
import * as Math from './math.js';

console.log(add(5, 3)); // 8
console.log(subtractFunc(5, 3)); // 2
console.log(Math.add(5, 3)); // 8
console.log(Math.subtract(5, 3)); // 2
```

## Funciones de Retrollamada y el Método `forEach`

- **Definición**: En JavaScript, una función de retrollamada es una función que se pasa como argumento a otra función y se ejecuta después de que la función principal ha finalizado su ejecución.
- **`forEach()` Método**: Este método se usa para iterar sobre cada elemento en un arreglo y realizar una operación en cada elemento. La función de retrollamada en `forEach` puede tomar hasta tres argumentos: el elemento actual, el índice del elemento actual y el arreglo sobre el cual se llamó `forEach`.

```js
const numbers = [1, 2, 3, 4, 5];

// Result: 2 4 6 8 10
numbers.forEach((number) => {
  console.log(number * 2);
});
```

## Funciones de Orden Superior

- **Definición**: Una función de orden superior toma una o más funciones como argumentos y devuelve una función o valor como resultado.

```js
function operateOnArray(arr, operation) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(operation(arr[i]));
  }
  return result;
}

function double(x) {
  return x * 2;
}

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = operateOnArray(numbers, double);
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
```

- **`map()` Método**: Este método se usa para crear un nuevo arreglo aplicando una función dada a cada elemento del arreglo original. La función de retrollamada puede aceptar hasta tres argumentos: el elemento actual, el índice del elemento actual y el arreglo sobre el cual se llamó `map`.

```js
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);

console.log(numbers); // [1, 2, 3, 4, 5]
console.log(doubled); // [2, 4, 6, 8, 10]
```

- **`filter()` Método**: Este método se usa para crear un nuevo arreglo con elementos que pasan una prueba especificada, siendo útil para extraer elementos de manera selectiva según criterios. Al igual que el método `map`, la función de retrollamada para el método `filter` acepta los mismos tres argumentos: el elemento actual procesado, el índice, y el arreglo.

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter((num) => num % 2 === 0);

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

- **`reduce()` Método**: Este método se usa para procesar un arreglo y condensarlo en un único valor. Este único valor puede ser un número, una cadena, un objeto o incluso otro arreglo. El método `reduce()` funciona aplicando una función a cada elemento en el arreglo, en orden, pasando el resultado de cada cálculo al siguiente. Esta función se llama a menudo la función reductora. La función reductora toma dos parámetros principales: un acumulador y el valor actual. El acumulador es donde almacenas el resultado de tus operaciones, y el valor actual es el elemento del arreglo que se está procesando.

```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0
);

console.log(sum); // 15
```

## Encadenamiento de Métodos

- **Definición**: El encadenamiento de métodos es una técnica de programación que te permite llamar a múltiples métodos sobre el mismo objeto en una sola línea de código. Esta técnica puede hacer que tu código sea más legible y conciso, especialmente cuando realizas una serie de operaciones en el mismo objeto.

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

## Trabajar con el Método `sort`

- **Definición**: El método `sort` se utiliza para ordenar los elementos de un arreglo y devolver una referencia al arreglo ordenado. No se hace una copia en este caso porque los elementos se ordenan en su lugar.

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();

console.log(fruits); // ["Apple", "Banana", "Mango", "Orange"]
```

Si necesitas ordenar números, entonces deberás pasar una función de comparación. El método `sort` convierte los elementos a cadenas y luego compara sus secuencias de valores de unidades de código UTF-16. Las unidades de código UTF-16 son los valores numéricos que representan los caracteres en la cadena. Ejemplos de unidades de código UTF-16 son los números 65, 66, y 67 que representan respectivamente los caracteres "A", "B", y "C". Así, el número 200 aparece antes que el número 3 en un arreglo, porque la cadena "200" viene antes que la cadena "3" al comparar sus unidades de código UTF-16.

```js
const numbers = [414, 200, 5, 10, 3];

numbers.sort((a, b) => a - b);

console.log(numbers); // [3, 5, 10, 200, 414]
```

Los parámetros `a` y `b` son los dos elementos que se están comparando. La función de comparación deberá devolver un valor negativo si `a` debe estar antes de `b`, un valor positivo si `a` debe estar después de `b`, y cero si `a` y `b` son iguales.

## Trabajar con los Métodos `every` y `some`

- **`every()` Método**: Este método prueba si todos los elementos en un arreglo pasan una prueba implementada por una función proporcionada. El método `every()` devuelve `true` si la función proporcionada devuelve `true` para todos los elementos del arreglo. Si algún elemento no pasa la prueba, el método inmediatamente devuelve `false` y deja de verificar los elementos restantes.

```js
const numbers = [2, 4, 6, 8, 10];
const hasAllEvenNumbers = numbers.every((num) => num % 2 === 0);

console.log(hasAllEvenNumbers); // true
```

- **`some()` Método**: Este método verifica si al menos un elemento pasa la prueba. El método `some()` devuelve `true` tan pronto como encuentra un elemento que pasa la prueba. Si ningún elemento pasa la prueba, devuelve `false`.

```js
const numbers = [1, 3, 5, 7, 8, 9];
const hasSomeEvenNumbers = numbers.some((num) => num % 2 === 0);

console.log(hasSomeEvenNumbers); // true
```

## Trabajar con el DOM y Web APIs

- **API**: una API (Interfaz de Programación de Aplicaciones) es un conjunto de reglas y protocolos que permiten a las aplicaciones de software comunicarse entre sí e intercambiar datos de manera eficiente.
- **API Web**: Las API web están específicamente diseñadas para aplicaciones web. Estos tipos de API a menudo se dividen en dos categorías principales: API de navegadores y API de terceros.
- **API de Navegadores**: Estas API exponen datos del navegador. Como desarrollador web, puedes acceder y manipular estos datos usando JavaScript.
- **API Terceros**: Estas no están integradas en el navegador por defecto. Debes obtener su código de alguna manera. Por lo general, tendrán documentación detallada que explique cómo usar sus servicios. Un ejemplo es la API de Google Maps, que puedes usar para mostrar mapas interactivos en tu sitio web.
- **DOM**: El DOM significa Modelo de Objeto de Documento. Es una interfaz de programación que te permite interactuar con documentos HTML. Con el DOM, puedes agregar, modificar o eliminar elementos en una página web. La raíz del árbol DOM es el elemento `html`. Es el contenedor de nivel superior para todo el contenido de un documento HTML. Todos los demás nodos son descendientes de este nodo raíz. Luego, debajo del nodo raíz, encontramos otros nodos en la jerarquía. Un nodo primario es un elemento que contiene otros elementos. Un nodo hijo es un elemento que se encuentra dentro de otro elemento.
- **`navigator` Interfaz**: Esto proporciona información sobre el entorno del navegador, como la cadena del agente de usuario, la plataforma y la versión del navegador. Una cadena de agente de usuario es una cadena de texto que identifica el navegador y el sistema operativo que se está utilizando.
- **`window` Interfaz**: Esto representa la ventana del navegador que contiene el documento DOM. Proporciona métodos y propiedades para interactuar con la ventana del navegador, como cambiar el tamaño de la ventana, abrir nuevas ventanas y navegar a diferentes URL.

## Trabajar con los Métodos `querySelector()`, `querySelectorAll()` y `getElementById()`

- **`getElementById()` Método**: Este método se usa para obtener un objeto que representa el elemento HTML con el `id` especificado. Recuerda que los ID deben ser únicos en cada documento HTML, por lo que este método solo devolverá un objeto Element.

```html
<div id="container"></div>
```

```js
const container = document.getElementById("container");
```

- **Método `querySelector()`**: Este método se utiliza para obtener el primer elemento en el documento HTML que coincide con el selector CSS pasado como argumento.

```html
<section class="section"></section>
```

```js
const section = document.querySelector(".section");
```

- **`querySelectorAll()` Método**: Puedes usar este método para obtener una lista de todos los elementos DOM que coinciden con un selector CSS específico.

```html
<ul class="ingredients">
  <li>Sugar</li>
  <li>Milk</li>
  <li>Eggs</li>
</ul>
```

```js
const ingredients = document.querySelectorAll('ul.ingredients li');
```

## Trabajar con los Métodos `innerText()`, `innerHTML()`, `createElement()` y `textContent()`

- **`innerHTML` Propiedad**: Es una propiedad del `Elemento` que se usa para establecer o actualizar partes de la marca HTML.

```html
<div id="container">
  <!-- Add new elements here -->
</div>
```

```js
const container = document.getElementById("container");
container.innerHTML = '<ul><li>Cheese</li><li>Tomato</li></ul>';
```

- **`createElement` Método**: Esto se usa para crear un elemento HTML.

```js
const img = document.createElement("img");
```

- **`innerText`**: Esto representa el contenido de texto visible del elemento HTML y sus descendientes.

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.innerText);
```

- **`textContent`**: Esto devuelve el contenido de texto plano de un elemento, incluyendo todo el texto dentro de sus descendientes.

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.textContent);
```

## Trabajar con los Métodos `appendChild()` y `removeChild()`

- **`appendChild()` Método**: Este método se usa para añadir un nodo al final de la lista de hijos de un nodo padre especificado.

```html
<ul id="desserts">
  <li>Cake</li>
  <li>Pie</li>
</ul>
```

```js
const dessertsList = document.getElementById("desserts");
const listItem = document.createElement("li");

listItem.textContent = "Cookies";
dessertsList.appendChild(listItem);
```

- **`removeChild()` Método**: Este método se usa para eliminar un nodo del DOM.

```html
<section id="example-section">
  <h2>Example sub heading</h2>
  <p>first paragraph</p>
  <p>second paragraph</p>
</section>
```

```js
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");

sectionEl.removeChild(lastParagraph);
```

## Trabajar con el Método `setAttribute`

- **Definición**: Este método se usa para establecer el atributo para un elemento dado. Si el atributo ya existe, entonces se actualiza el valor. De lo contrario, se añade un nuevo atributo con un valor.

```html
<p id="para">I am a paragraph</p>
```

```js
const para = document.getElementById("para");
para.setAttribute("class", "my-class");
```

## Objeto Evento

- **Definición**: El objeto `Event` es un payload que se activa cuando un usuario interactúa con tu página web de alguna manera. Estas interacciones pueden ser cualquier cosa, desde hacer clic en un botón o enfocarse en una entrada hasta agitar su dispositivo móvil. Todos los objetos de `Evento` tendrán la propiedad `type`. Esta propiedad revela el tipo de evento que activó la carga útil, como pulsar una tecla o hacer clic. These values will correspond to the same values you might pass to `addEventListener()`, where you can capture and utilize the `Event` object.

## Métodos de `addEventListener()` y `removeEventListener()`

- **Método `addEventListener`**: Este método se usa para escuchar eventos. Toma dos argumentos: el evento que deseas escuchar y una función que será llamada cuando ocurra el evento. Algunos ejemplos comunes de eventos son los eventos de clic, eventos de entrada y eventos de cambio.

```js
const btn = document.getElementById("btn");

btn.addEventListener("click", () => alert("You clicked the button"));
```

- **Método `removeEventListener`**: Este método se usa para eliminar un escuchador de eventos que fue previamente añadido a un elemento utilizando el método `addEventListener`. Esto es útil cuando deseas dejar de escuchar un evento particular en un elemento.

```js
const bodyEl = document.querySelector("body");
const para = document.getElementById("para");
const btn = document.getElementById("btn");

let isBgColorGrey = true;

function toggleBgColor() {
  bodyEl.style.backgroundColor = isBgColorGrey ? "blue" : "grey";
  isBgColorGrey = !isBgColorGrey;
}

btn.addEventListener("click", toggleBgColor);

para.addEventListener("mouseover", () => {
  btn.removeEventListener("click", toggleBgColor);
});
```

- **Manejadores de Eventos Inline**: Los manejadores de eventos inline son atributos especiales de un elemento HTML que se utilizan para ejecutar código de JavaScript cuando ocurre un evento. En JavaScript moderno, los manejadores de eventos inline no se consideran la mejor práctica. Se prefiere usar el método `addEventListener` en su lugar.

```html
<button onclick="alert('Hello World!')">Show alert</button>
```

## DOMContentLoaded

- **Definición**: El evento `DOMContentLoaded` se dispara cuando todo el documento HTML ha sido cargado y analizado. Si tienes hojas de estilo o imágenes externas, el evento `DOMContentLoaded` no esperará a que se carguen. Solo esperará a que se cargue el HTML.

## Trabajando con `style` y `classList`

- **Propiedad `Element.style`**: Esta propiedad es una propiedad de solo lectura que representa el estilo en línea de un elemento. Puedes usar esta propiedad para obtener o establecer el estilo de un elemento.

```js
const paraEl = document.getElementById("para");
paraEl.style.color = "red";
```

- **Propiedad `Element.classList`**: Esta propiedad es una propiedad de solo lectura que se puede usar para agregar, quitar o alternar clases en un elemento.

```js
// Example adding a class
const paraEl = document.getElementById("para");
paraEl.classList.add("highlight");

// Example removing a class
paraEl.classList.remove("blue-background");

// Example toggling a class
const menu = document.getElementById("menu");
const toggleBtn = document.getElementById("toggle-btn");

toggleBtn.addEventListener("click", () => menu.classList.toggle("show"));
```


## Trabajando con los Métodos `setTimeout` y `setInterval`

- **Método `setTimeout()`**: Este método te permite retrasar una acción por un tiempo especificado.

```js
setTimeout(() => {
 console.log('This runs after 3 seconds'); 
}, 3000);
```

- **Método `setInterval()`**: Este método sigue ejecutando un bloque de código repetidamente a un intervalo establecido. Dado que `setInterval()` continúa ejecutando la función proporcionada en el intervalo especificado, podrías querer detenerlo. Para esto, debes utilizar el método `clearInterval()`.

```js
setInterval(() => {
 console.log('This runs every 2 seconds');
}, 2000);

// Example using clearInterval
const intervalID = setInterval(() => {
 console.log('This will stop after 5 seconds');
}, 1000);

setTimeout(() => {
 clearInterval(intervalID);
}, 5000);
```

## El Método `requestAnimationFrame()`

- **Definición**: Este método te permite programar el próximo paso de tu animación antes de la siguiente actualización de pantalla, resultando en una experiencia visual fluida y atractiva. La siguiente actualización de pantalla se refiere al momento en que el navegador refresca la visualización de la página web. Esto ocurre múltiples veces por segundo, típicamente alrededor de 60 veces (o 60 cuadros por segundo) en la mayoría de las pantallas.

```js
function animate() {
 // Update the animation...
 // for example, move an element, change a style, and more.
 update();
 // Request the next frame
 requestAnimationFrame(animate);
}
```

## API de Animaciones Web

- **Definición**: La API de Animaciones Web te permite crear y controlar animaciones directamente dentro de JavaScript. 

```js
const square = document.querySelector('#square');

const animation = square.animate(
 [{ transform: 'translateX(0px)' }, { transform: 'translateX(100px)' }],
 {
   duration: 2000, // makes animation lasts 2 seconds
   iterations: Infinity, // loops indefinitely
   direction: 'alternate', // moves back and forth
   easing: 'ease-in-out', // smooth easing
 }
);
```

## La API Canvas

- **Definición**: La API de Canvas es una herramienta poderosa que te permite manipular gráficos directamente dentro de tu archivo JavaScript. Para trabajar con la API de Canvas, primero necesitas proporcionar un elemento `canvas` en HTML. Este elemento actúa como una superficie de dibujo que puedes manipular con los métodos de instancia y propiedades de las interfaces en la API de Canvas. Esta API tiene interfaces como `HTMLCanvasElement`, `CanvasRenderingContext2D`, `CanvasGradient`, `CanvasPattern` y `TextMetrics` que contienen métodos y propiedades que puedes usar para crear gráficos en tu archivo JavaScript.

```html
<canvas id="my-canvas" width="400" height="400"></canvas>
```

```js
const canvas = document.getElementById('my-canvas');

// Access the drawing context of the canvas. 
// "2d" allows you to draw in two dimensions 
const ctx = canvas.getContext('2d');

// Set the background color
ctx.fillStyle = 'crimson';

// Draw a rectangle
ctx.fillRect(1, 1, 150, 100);
```

## Abrir y cerrar diálogos y modales con JavaScript

- **Definiciones de Modal y Dialog**: Los diálogos te permiten mostrar información o acciones importantes a los usuarios. Con el elemento de diálogo incorporado en HTML, puedes crear fácilmente estos diálogos (tanto modales como no modales) en tus aplicaciones web. Un diálogo modal es un tipo de diálogo que obliga al usuario a interactuar con él antes de que puedan acceder al resto de la aplicación o página web. En cambio, un diálogo no modal permite al usuario seguir interactuando con otras partes de la página o aplicación incluso cuando el diálogo está abierto. No impide el acceso al resto del contenido.
- **Método `showModal()`**: Este método se usa para abrir un modal.

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');

openButton.addEventListener('click', () => {
  dialog.showModal();
});
```

- **Método `close()`**: Este método se usa para cerrar el modal.

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
   <button id="close-modal">Close Modal</button>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');
const closeButton = document.getElementById('close-modal');

openButton.addEventListener('click', () => {
  dialog.show();
});

closeButton.addEventListener('click', () => {
  dialog.close();
});
```

## El Evento de Cambio

- **Definición**: El evento de cambio es un evento especial que se activa cuando el usuario modifica el valor de ciertos elementos de entrada. Los ejemplos incluirían cuando se marca una casilla de verificación o un botón de opción. O cuando el usuario hace una selección de algo como un selector de fechas o un menú desplegable.

```html
<label>
  Choose a programming language:
  <select class="language" name="language">
    <option value="">---Select One---</option>
    <option value="JavaScript">JavaScript</option>
    <option value="Python">Python</option>
    <option value="C++">C++</option>
  </select>
</label>

<p class="result"></p>
```

```js 
const selectEl = document.querySelector(".language");
const result = document.querySelector(".result");

selectEl.addEventListener("change", (e) => {
  result.textContent = `You enjoy programming in ${e.target.value}.`;
});
```

## Propagación de Eventos

- **Definición**: La burbuja de eventos, o propagación, se refiere a cómo un evento "sube" hacia los objetos padre cuando se activa.

## Delegación de Eventos

- **Definición**: La delegación de eventos es el proceso de escuchar eventos que se han propagado a un elemento padre, en lugar de manejarlos directamente en el elemento que los activó.

## JavaScript and Accessibility

### Common ARIA Accessibility Attributes

- **`aria-expanded` attribute**: Used to convey the state of a toggle (or disclosure) feature to screen reader users.
- **`aria-haspopup` attribute**: This state is used to indicate that an interactive element will trigger a pop-up element when activated. You can only use the `aria-haspopup` attribute when the pop-up has one of the following roles: `menu`, `listbox`, `tree`, `grid`, or `dialog`. The value of `aria-haspopup` must be either one of these roles or `true`, which is the same as `menu`.
- **`aria-checked` attribute**: This attribute is used to indicate whether an element is in the checked state. It is most commonly used when creating custom checkboxes, radio buttons, switches, and listboxes.
- **`aria-disabled` attribute**: This state is used to indicate that an element is disabled only to people using assistive technologies, such as screen readers.
- **`aria-selected` attribute**: This state is used to indicate that an element is selected. You can use this state on custom controls like a tabbed interface, a listbox, or a grid.
- **`aria-controls` attribute**: Used to associate an element with another element that it controls. This helps people using assistive technologies understand the relationship between the elements.
- **`hidden` attribute**: Hides inactive panels from both visual and assistive technology users.

### Working with Live Regions and Dynamic Content

- **`aria-live` attribute**: Makes part of a webpage a live region, meaning any updates inside that area will be announced by a screen reader so users don't miss important changes.
- **`polite` value**: Most live regions use this value. This value means that the update is not urgent, so the screen reader can wait until it finishes any current announcement or the user completes their current action before announcing the update.

Here is an example of a live region that is dynamically updated by JavaScript:

```html
<div aria-live="polite" id="status"></div>
```

```js
const statusEl = document.getElementById("status");
statusEl.textContent = "Your file has been successfully uploaded.";
```

- **`contenteditable` attribute**: Turns the element into a live editor, allowing users to update its content as if it were a text field. When there is no visible label or heading for a contenteditable region, add an accessible name using the `aria-label` attribute to help screen reader users understand the purpose of the editable area.

```html
<div contenteditable="true" aria-label="Note editor">
  Editable content goes here
</div>
```

## `focus` and `blur` Events

- **`blur` event**: Fires when an element loses focus.

```js
element.addEventListener("blur", () => {
  // Handle when user leaves the element
});
```

- **`focus` event**: Fires when an element receives focus.

```js
element.addEventListener("focus", () => {
  // Handle when user enters the element
});
```

## Common Types of Error Messages

- **SyntaxError**: These errors happen when you write something incorrectly in your code, like missing a parenthesis, or a bracket. Think of it like a grammar mistake in a sentence.

```js
const arr = ["Beau", "Quincy" "Tom"]
```

- **ReferenceError**: There are several types of Reference Errors, triggered in different ways. The first type of reference error would be not defined variables. Another example of a ReferenceError is trying to access a variable, declared with `let` or `const`, before it has been defined.

```js
console.log(num);
const num = 50;
```

- **TypeError**: These errors occur when you try to perform an operation on the wrong type.

```js
const developerObj = {
  name: "Jessica",
  country: "USA",
  isEmployed: true
};

developerObj.map()
```

- **RangeError**: These errors happen when your code tries to use a value that's outside the range of what JavaScript can handle.

```js
const arr = [];
arr.length = -1; 
```

## The `throw` Statement

- **Definition**: The `throw` statement in JavaScript is used to throw a user-defined exception. An exception in programming, is when an unexpected event happens and disrupts the normal flow of the program.

```js
function validateNumber(input) {
  if (typeof input !== "number") {
    throw new TypeError("Expected a number, but received " + typeof input);
  }
  return input * 2;
}
```

## `try...catch...finally`

- **Definition**: The `try` block is used to wrap code that might throw an error. It acts as a safe space to try something that could fail. The `catch` block captures and handles errors that occur in the try block. You can use the error object inside catch to inspect what went wrong. The `finally` block runs after the try and catch blocks, regardless of whether an error occurred. It's commonly used for cleanup tasks, such as closing files or releasing resources.

```js
function processInput(input) {
  if (typeof input !== "string") {
    throw new TypeError("Input must be a string.");
  }

  return input.toUpperCase();
}

try {
  console.log("Starting to process input...");
  const result = processInput(9);
  console.log("Processed result:", result);
} catch (error) {
  console.error("Error occurred:", error.message);
} 
```

## Debugging Techniques

- **`debugger` Statement**: This statement lets you pause your code at a specific line to investigate what's going on in the program.

```js
let firstNumber = 5;
let secondNumber = 10;

debugger; // Code execution pauses here
let sum = firstNumber + secondNumber;

console.log(sum);
```

- **Breakpoints**: Breakpoints let you pause the execution of your code at a specific line of your choice. After the pause, you can inspect variables, evaluate expressions, and examine the call stack.
- **Watchers**: Watch expressions lets you monitor the values of variables or expressions as the code runs even if they are out of the current scope.
- **Profiling**: Profiling helps you identify performance bottlenecks by letting you capture screenshots and record CPU usage, function calls, and execution time.
- **`console.dir()`**: This method is used to display an interactive list of the properties of a specified JavaScript object. It outputs a hierarchical listing that can be expanded to see all nested properties.

```js
console.dir(document);
```

- **`console.table()`**: This method displays tabular data as a table in the console. It takes one mandatory argument, which must be an array or an object, and one optional argument to specify which properties (columns) to display.

## Regular Expressions and Common Methods

- **Definition**: Regular Expressions, or Regex, are used to create a "pattern", which you can then use to check against a string, extract text, and more.

```js
const regex = /freeCodeCamp/;
```

- **`test()` Method**: This method accepts a string, which is the string to test for matches against the regular expression. This method will return a boolean if the string matches the regex.

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test); // false
```

- **`match()` Method**: This method accepts a regular expression, although you can also pass a string which will be constructed into a regular expression. The `match` method returns the match array for the string.

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match); // ["freeCodeCamp"]
```

- **`replace()` Method**: This method accepts two arguments: the regular expression to match (or a string), and the string to replace the match with (or a function to run against each match).

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced); // "freeCodeCamp is rly kewl"
```

- **`replaceAll` Method**: This method is used to replace all occurrences of a specified pattern with a new string. This method will throw an error if you give it a regular expression without the global modifier.

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

- **`matchAll` Method**: This method is used to retrieve all matches of a given regular expression in a string, including capturing groups, and returns them as an iterator. An iterator is an object that allows you to go through (or "iterate over") a collection of items.

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

## Regular Expression Modifiers

- **Definition**: Modifiers, often referred to as "flags", modify the behavior of a regular expression.
- **`i` Flag**: This flag makes a regex ignore case.

```js
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
```

- **`g` Flag**: This flag, or global modifier, allows your regular expression to match a pattern more than once.

```js
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
```

- **Anchor Definition**: The `^` anchor, at the beginning of the regular expression, says "match the start of the string". The `$` anchor, at the end of the regular expression, says "match the end of the string".

```js
const start = /^freeCodeCamp/i;
const end = /freeCodeCamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
```

- **`m` Flag**: Anchors look for the beginning and end of the entire string. But you can make a regex handle multiple lines with the `m` flag, or the multi-line modifier.flag, or the multi-line modifier.

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const str = `I love 
freecodecamp
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true

```

- **`d` Flag**: This flag expands the information you get in a match object.

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

- **`u` Flag**: This expands the functionality of a regular expression to allow it to match special unicode characters. The `u` flag gives you access to special classes like the `Extended_Pictographic` to match most emoji. There is also a `v` flag, which further expands the functionality of the unicode matching.
- **`y` Flag**: The sticky modifier behaves very similarly to the global modifier, but with a few exceptions. The biggest one is that a global regular expression will start from lastIndex and search the entire remainder of the string for another match, but a sticky regular expression will return null and reset the lastIndex to 0 if there is not immediately a match at the previous lastIndex.
- **`s` Flag**: The single-line modifier allows a wildcard character, represented by a `.` in regex, to match linebreaks - effectively treating the string as a single line of text.

## Character Classes

- **Wildcard `.`**: Character classes are a special syntax you can use to match sets or subsets of characters. The first character class you should learn is the wild card class. The wild card is represented by a period, or dot, and matches ANY single character EXCEPT line breaks. To allow the wildcard class to match line breaks, remember that you would need to use the `s` flag.

```js
const regex = /a./;
```

- **`\d`**: This will match all digits (`0-9`) in a string.

```js
const regex = /\d/;
```

- **`\w`**: This is used to match any word character (`a-z0-9_`) in a string. A word character is defined as any letter, from a to z, or a number from 0 to 9, or the underscore character.

```js
const regex = /\w/;
```

- **`\s`**: The white-space class `\s`, represented by a backslash followed by an `s`. This character class will match any white space, including new lines, spaces, tabs, and special unicode space characters.
- **Negating Special Character Classes**: To negate one of these character classes, instead of using a lowercase letter after the backslash, you can use the uppercase equivalent. The following example does not match a numerical character. Instead, it matches any single character that is NOT a numerical character.

```js
const regex = /\D/;
```

- **Custom Character Classes**: You can create custom character classes by placing the character you wish match inside a set of square brackets.

```js
const regex = /[abcdf]/;
```

## Lookahead and Lookbehind Assertions

- **Definition**: Lookahead and lookbehind assertions allow you to match specific patterns based on the presence or lack of surrounding patterns.
- **Positive Lookahead Assertion**: This assertion will match a pattern when the pattern is followed by another pattern. To construct a positive lookahead, you need to start with the pattern you want to match. Then, use parentheses to wrap the pattern you want to use as your condition. After the opening parenthesis, use `?=` to define that pattern as a positive lookahead.

```js
const regex = /free(?=code)/i;
```

- **Negative Lookahead Assertion**: This is a type of condition used in regular expressions to check that a certain pattern does not occur ahead in the string.

```js
const regex = /free(?!code)/i;
```

- **Positive Lookbehind Assertion**: This assertion will match a pattern only if it is preceded by another specific pattern, without including the preceding pattern in the match.

```js
const regex = /(?<=free)code/i;
```

- **Negative Lookbehind Assertion**: This assertion ensures that a pattern is not preceded by another specific pattern. It matches only if the specified pattern is not immediately preceded by the given sequence, without including the preceding sequence in the match.

```js
const regex = /(?<!free)code/i;
```

## Regex Quantifiers

- **Definition**: Quantifiers in regular expressions specify how many times a pattern (or part of a pattern) should appear. They help control the number of occurrences of characters or groups in a match. The following example is used to match the previous character exactly four times.

```js
const regex = /^\d{4}$/;
```

- **`*`** : Matches 0 or more occurrences of the preceding element.
- **`+`**: Matches 1 or more occurrences of the preceding element.
- **`?`**: Matches 0 or 1 occurrence of the preceding element.
- **`{n}`**: Matches exactly n occurrences of the preceding element.
- **`{n,}`**: Matches n or more occurrences of the preceding element.
- **`{n,m}`**: Matches between n and m occurrences of the preceding element.

## Capturing Groups and Backreferences

- **Capturing Groups**: A capturing group allows you to "capture" a portion of the matched string to use however you might need. Capturing groups are defined by parentheses containing the pattern to capture, with no leading characters like a lookahead.

```js
const regex = /free(code)camp/i;
```

- **Backreferences**: A backreference in regular expressions refers to a way to reuse a part of the pattern that was matched earlier in the same expression. It allows you to refer to a captured group (a part of the pattern in parentheses) by its number. For example, `$1` refers to the first captured group.

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

## Validating Forms with JavaScript

- **Constraint Validation API**: Certain HTML elements, such as the `textarea` and `input` elements, expose a constraint validation API. This API allows you to assert that the user's provided value for that element passes any HTML-level validation you have written, such as minimum length or pattern matching.
- **`checkValidity()` method**: This method returns `true` if the element matches all HTML validation (based on its attributes), and `false` if it fails.

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.setCustomValidity("You must use a .com email.")
  }
})
```

- **`reportValidity()` Method**: This method tells the browser that the `input` is invalid.

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.reportValidity();
  }
})
```

- **`validity` Property**: This property is used to get or set the validity state of form controls (like `<input>`, `<select>`, etc.) and provides information about whether the user input meets the constraints defined for that element (e.g., `required` fields, pattern constraints, maximum length, etc.).

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.validity);
})
```

- **`patternMismatch` Property**: This will be `true` if the value doesn't match the specified regular expression pattern.

## `preventDefault()` Method

- **Definition**: Every event that triggers in the DOM has some sort of default behavior. The click event on a checkbox toggles the state of that checkbox, by default. Pressing the space bar on a focused button activates the button. The `preventDefault()` method on these `Event` objects stops that behavior from happening.

```js
button.addEventListener('click', (event) => {
  // Prevent the default button click behavior  
  event.preventDefault(); 
  alert('Button click prevented!');
});
```

## Submitting Forms

- **Definition**: There are three ways a form can be submitted. The first is when the user clicks a button in the form which has the `type` attribute set to `submit`. The second is when the user presses the `Enter` key on any editable `input` field in the form. The third is through a JavaScript call to the `requestSubmit()` or `submit()` methods of the `form` element.
- **`action` Attribute**: The `action` attribute should contain either a URL or a relative path for the current domain. This value determines where the form attempts to send data - if you do not set an `action` attribute, the form will send data to the current page's URL.

```html
<form action="https://freecodecamp.org">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`method` Attribute**: This attribute accepts a standard `HTTP` method, such as `GET` or `POST`, and uses that method when making the request to the action URL. When a method is not set, the form will default to a `GET` request. The data in the form will be URL encoded as `name=value` pairs and appended to the action URL as query parameters.

```html
<form action="/data" method="POST">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`enctype` Attribute**: The `form` element accepts an `enctype` attribute, which represents the encoding type to use for the data. This attribute only accepts three values: `application/x-www-form-urlencoded` (which is the default, sending the data as a URL-encoded form body), `text/plain` (which sends the data in plaintext form, in `name=value` pairs separated by new lines), or `multipart/form-data`, which is specifically for handling forms with a file upload.

## The `date()` Object and Common Methods

- **Definition**: The `date()` object is used to create, manipulate, and format dates and times in JavaScript. In the following example, the `new` keyword is used to create a new instance of the `Date` object, and the `Date` object is then assigned to the variable `now`. If you were to log the value of `now` to the console, you would see the current date and time based on the system clock of the computer running the code.

```js
const now = new Date();
```

- **`Date.now()` Method**: This method is used to get the current date and time. `Date.now()` returns the number of milliseconds since January 1, 1970, 00:00:00 UTC. This is known as the Unix epoch time. Unix epoch time is a common way to represent dates and times in computer systems because it is an integer that can be easily stored and manipulated. UTC stands for Universal Time Coordinated, which is the primary time standard by which the world regulates clocks and time.
- **`getDate()` Method**: This method is used to get a day of the month based on the current date. `getDate()` will return an integer value between 1 and 31, depending on the day of the month. If the date is invalid, it will return `NaN` (Not a Number).

```js
const now = new Date();
const date = now.getDate();
console.log(date); // 15
```

- **`getMonth()` Method**: This method is used to get the month. The month is zero-based, so January is 0, February is 1, and so on. In this example, the output is 2, which corresponds to March. If the month is invalid, it will return `NaN`.

```js
const now = new Date();
const month = now.getMonth();
console.log(month); // 2
```

- **`getFullYear()` Method**: This method is used to get the full year. If the year is invalid, it will return `NaN`.

```js
const now = new Date();
const year = now.getFullYear();
console.log(year); // 2024
```

## Different Ways to Format Dates

- **`toISOString()` Method**: This method is used to format the date in an extended `ISO` (ISO 8601) format. ISO 8601 is an international standard for representing dates and times. The format is `YYYY-MM-DDTHH:mm:ss.sssZ`.

```js
const date = new Date();
console.log(date.toISOString());
```

- **`toLocaleDateString()` Method**: This method is used to format the date based on the user's locale.

```js
const date = new Date();
console.log(date.toLocaleDateString());  // 11/23/2024
```

The `toLocaleDateString()` method accepts two optional parameters: locales and options.

The locales parameter is a string representing the locale to use. For example, you can pass in `"en-US"` for English (United States) or `"fr-FR"` for French (France). If you don't pass in a locales parameter, the default locale is used. The second optional parameter is the options parameter. Este parámetro es un objeto que te permite especificar el formato de la cadena de fecha.

```js
const date = new Date();
const options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(date.toLocaleDateString("en-GB", options)); // Saturday, November 23, 2024
```

## `Audio` Constructor and Common Methods

- **Definition**: The `Audio` constructor, like other constructors, is a special function called with the `new` keyword. It returns an `HTMLAudioElement`, which you can then use to play audio for the user, or append to the DOM for the user to control themselves. When you call the constructor, you can optionally pass a URL as the (only) argument. This URL should point to the source of the audio file you want to play. Or, if you need to change the source dynamically, you can assign the URL to the `src` property of the returned audio element.
- **`play()` Method**: This method is used with the `audio` or `video` elements to begin playback for the media.

```js
const audio = document.getElementById('audio');

// Starts playing the audio
audio.play();  
```

- **`pause()` Method**: This method is used with the `audio` or `video` elements to pause playback for the media.

```js
function pauseAudio() {
  const audio = document.getElementById('myAudio');
  audio.pause();  // Pauses the audio playback
}
```

- **`addTextTrack()` Method**: This method allows you to specify a text track to associate with the media element - which is especially helpful for adding subtitles to a video.
- **`fastSeek()` Method**: This method allows you to move the playback position to a specific time within the media.

## Different Audio and Video Formats

- **MIME type**: A MIME type, standing for Multipurpose Internet Mail Extensions, is a standardized way to programmatically indicate a file type. The MIME type can tell an application, such as your browser, how to handle a specific file. In the case of audio and video, the MIME type indicates it is a multimedia format that can be embedded in the web page.
- **`source` Element**: This is used to specify a file type and source - and can include multiple different types by using multiple source elements. When you do this, the browser will determine the best format to use for the user's current environment.
- **MP3**: This is a type of digital file format used to store music, audio, or sound. It's a compressed version of a sound recording that makes the file size smaller, so it's easier to store and share. An MP3 file has the MIME type audio/mp3
- **MP4**: An MP4 is a type of digital file format used to store video and audio. It serves as a container that holds both the video (images) and the sound (music or speech) in one file. An MP4, can have the MIME type audio/mp4 OR video/mp4, depending on whether it's a video file or audio-only.

## codecs

- **Definition**: A codec, short for "encoder/decoder", is an algorithm or software that can convert audio and video between analogue and digital formats. Codecs can be specified as part of the MIME type. The basic syntax to define a codec is to add a semi-colon after the media type, then `codecs=` and the codec.

## HTMLMediaElement API

- **Definition**: The `HTMLMediaElement` API is used to control the behavior of audio and video elements on your page. It extends the base `HTMLElement` interface, so you have access to the base properties as well as these helpful methods. Examples of these methods include `play()`, `fastSeek()`, and `pause()`.

## Media Capture and Streams API

- **Definition**: The Media Capture and Streams API, or the MediaStream API, is used to capture audio and video from your device. In order to use the API, you need to create the `MediaStream` object. You could do this with the constructor, but it would not be tied to the user's hardware. Instead, the `mediaDevices` property of the `global` navigator object has a `getUserMedia()` method for you to use.

```js
window.navigator.mediaDevices.getUserMedia({
  audio: true,
  video: {
    width: {
      min: 1280,
      ideal: 1920,
      max: 3840
    },
    height: {
      min: 720,
      ideal: 1080,
      max: 2160
    }
  }
});
```

## Screen Capture API

- **Definition**: The Screen Capture API is used to record a user's screen. This API is exposed by calling the `getDisplayMedia()` method of the `mediaDevices` object and consuming the returned media stream.

## MediaStream Recording API

- **Definition**: The MediaStream Recording API works in tandem with the MediaStreams APIs, allowing you to record a MediaStream (or even an `HTMLMediaElement` directly).

## Media Source Extensions API

- **topic**: The Media Source Extensions API is what allows you to directly pass a user's webcam feed to a video element with the `srcObject` property.

## Web Audio API

- **Definition**: The Web Audio API which powers everything audible on the web. This API includes important objects like an `AudioBuffer` (representing a Buffer specifically containing audio data) or the `AudioContext`.

## Sets in JavaScript

- A `Set` is a built-in option for managing data collection.
- Sets ensure that each value in it appears only once, making it useful for eliminating duplicates from an array or handling collections of distinct values.
- You can create a `Set` using the `Set()` constructor:

```js
const set = new Set([1, 2, 3, 4, 5]);
console.log(set); // Set { 1, 2, 3, 4, 5 }
```

- Sets can be manipulated using these methods:

  - `add()`: Adds a new element to the `Set`.
  - `delete()`: Removes an element from the `Set`.
  - `has()`: Checks if an element exists in the `Set`.
  - `clear()`: Removes all elements from the `Set`.

## Weaksets in JavaScript

- `WeakSet` is a collection of objects that allows you to store weakly held objects.

## Sets vs WeakSets

- Unlike Sets, a `WeakSet` does not support primitives like numbers or strings.
- A `WeakSet` only stores objects, and the references to those objects are "weak," meaning that if the object is not being used anywhere else in your code, it is removed automatically to free up memory.

## Maps in JavaScript

- A `Map` is a built-in object that holds key-value pairs just like an object.
- Maps differ from the standard JavaScript objects with their ability to allow keys of any type, including objects, and functions.
- A `Map` provides better performance over the standard object when it comes to frequent addition and removals of key-value pairs.
- You can create a `Map` using the `Map()` constructor:

```js
const map = new Map([
  ['flower', 'rose'],
  ['fruit', 'apple'],
  ['vegetable', 'carrot']
]);
console.log(map); // Map(3) { 'flower' => 'rose', 'fruit' => 'apple', 'vegetable' => 'carrot' }
```

- Maps can be manipulated using these methods:

  - `set()`: Adds a new key-value pair to the `Map`.
  - `get()`: Retrieves the value of a key from the `Map`.
  - `delete()`: Removes a key-value pair from the `Map`.
  - `has()`: Checks if a key exists in the `Map`.
  - `clear()`: Removes all key-value pairs from the `Map`.

## WeakMaps in JavaScript

- A `WeakMap` is a collection of key-value pairs just like `Map`, but with weak references to the keys. The keys must be an object and the values can be anything you like.

## Maps vs WeakMaps

- WeakMaps are similar to WeakSets in that they only store objects and the references to those objects are "weak."

## Persistent Storage

- **Definition**: Persistent storage refers to a way of saving data in a way that it stays available even after the power is turned off or the device is restarted.

## Create, Read, Update, Delete (CRUD)

- **Create**: This refers to the process of creating new data. For example, in a web app, this could be when a user adds a new post to a blog.
- **Read**: This is the operation where data is retrieved from a database. For instance, when you visit a blog post or view your profile on a website, you're performing a read operation to fetch and display data stored in the database.
- **Update**: This involves modifying existing data in the database. An example would be editing a blog post or updating your profile information.
- **Delete**: This is the operation that removes data from a database. For instance, when you delete a blog post or account, you're performing a delete operation.

## HTTP Methods

- **Definition**: HTTP stands for Hypertext Transfer Protocol and it is the foundation for data communication on the web. There are HTTP methods which define the actions that can be performed on resources over the web. The common methods are GET, POST, PUT, PATCH, DELETE.
- **`GET` Method**: This is used to fetch data from a server.
- **`POST` Method**: This is used to submit data to a server which creates a new resource.
- **`PUT` Method**: This is used to update a resource by replacing it entirely.
- **`PATCH` Method**: This is used to partially update a resource.
- **`DELETE` Method**: This is used to remove records from a database.

## `localStorage` and `sessionStorage` Properties

- **Web Storage API**: This API provides a mechanism for browsers to store key-value pairs right within the browser, allowing developers to store information that can be used across different page reloads and sessions. The two main components for the Web Storage API are the `localStorage` and `sessionStorage` properties.
- **`localStorage` Property**: `localStorage` is the part of the Web Storage API that allows data to persist even after the browser window is closed or the page is refreshed. This data remains available until it is explicitly removed by the application or the user.
- **`localStorage.setItem()` Method**: This method is used to store a key-value pair in `localStorage`.

```js
localStorage.setItem('username', 'Jessica');
```

- **`localStorage.getItem()` Method**: This method is used to retrieve the value of a given key from `localStorage`.

```js
localStorage.setItem('username', 'codingRules');

let username = localStorage.getItem('username');
console.log(username); // codingRules
```

- **`localStorage.removeItem()` Method**: This method is used to remove a specific item from `localStorage` using its key.

```js
localStorage.removeItem('username');
```

- **`localStorage.clear()` Method**: This method is used to clear all of the stored data in `localStorage`.

```js
localStorage.clear();
```

- **`sessionStorage` Property**: Stores data that lasts only for the current session and is cleared when the browser tab or window is closed.
- **`sessionStorage.setItem()` Method**: This method is used to store a key-value pair in `sessionStorage`.

```js
sessionStorage.setItem('cart', '3 items');
```

- **`sessionStorage.getItem()` Method**: This method is used to retrieve the value of a given key from `sessionStorage`.

```js
sessionStorage.setItem('cart', '3 items');

let cart = sessionStorage.getItem('cart');
console.log(cart); // '3 items'
```

- **`sessionStorage.removeItem()` Method**: This method is used to remove a specific item from `sessionStorage` using its key.

```js
sessionStorage.removeItem('cart');
```

- **`sessionStorage.clear()` Method**: This method is used to clear all data stored in `sessionStorage`.

```js
sessionStorage.clear();
```

## Working with Cookies

- **Definition**: Cookies, also known as web cookies or browser cookies, are small pieces of data that a server sends to a user's web browser. These cookies are stored on the user's device and sent back to the server with subsequent requests. Cookies are essential in helping web applications maintain state and remember user information, which is especially important since HTTP is a stateless protocol.
- **Session Cookies**: These cookies only last for the duration of the user's session on the website. Once the user closes the browser or tab, the session cookie is deleted. These cookies are typically used for tasks like keeping a user logged in during their visit.
- **Secure Cookies**: These cookies are only sent over HTTPS, ensuring that they cannot be intercepted by an attacker in transit.
- **HttpOnly Cookies**: These cookies cannot be accessed or modified by JavaScript running in the browser, making them more secure against cross-site scripting (XSS) attacks.
- **Set-Cookie Header**: When you visit a website, the server can send a Set-Cookie header in the HTTP response. This header tells your browser to save a cookie with specific information. For example, it might store a unique ID that helps the site recognize you the next time you visit. You can manually set a cookie in JavaScript using `document.cookie`:

```js
document.cookie = "organization=freeCodeCamp; expires=Fri, 31 Dec 2021 23:59:59 GMT; path=/";
```

To delete a cookie, you can set its expiration date to a time in the past.

```js
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
```

## Cache API

- **Definition**: Caching is the process of storing copies of files in a temporary storage location, so that they can be accessed more quickly.  The Cache API is used to store network requests and responses, making web applications work more efficiently and even function offline. It is part of the broader Service Worker API and is crucial for creating Progressive Web Apps (PWAs) that can work under unreliable or slow network conditions. The Cache API is a storage mechanism that stores Request and Response objects. When a request is made to a server, the application can store the response and later retrieve it from the cache instead of making a new network request. This reduces load times, saves bandwidth, and improves the overall user experience.
- **Cache Storage**: This is used to store key-value pairs of HTTP requests and their corresponding responses. This enables efficient retrieval of previously requested resources, reducing the need to fetch them from the network on subsequent visits and improving performance.
- **Cache-Control**: Developers can define how long a cached resource should be kept, and if it should be revalidated or served directly from cache.
- **Offline Support**: By using the Cache API, you can create offline-first web applications. For example, a PWA can serve cached assets when the user is disconnected from the network.

## Negative Patterns and Client Side Storage

- **Excessive Tracking**: This refers to the practice of collecting and storing an overabundance of user data in client-side storage (such as cookies, local storage, or session storage) without clear, informed consent or a legitimate need. This often involves tracking user behavior, preferences, and interactions across multiple sites or sessions, which can infringe on user privacy.
- **Browser Fingerprinting**: A technique used to track and identify individual users based on unique characteristics of their device and browser, rather than relying on cookies or other traditional tracking methods. Unlike cookies, which are stored locally on a user's device, fingerprinting involves collecting a range of information that can be used to create a distinctive "fingerprint" of a user's browser session.
- **Setting Passwords in LocalStorage**: This might seem like a more obvious negative pattern, but setting any sensitive data like passwords in local storage posses a security risk. Local Storage is not encrypted and can be accessed easily. So you should never store any type of sensitive data in there.

## IndexedDB

- **Definition**: IndexedDB is used for storing structured data in the browser. This is built into modern web browsers, allowing web apps to store and fetch JavaScript objects efficiently.

## Cache/Service Workers

- **Definition**: A Service Worker is a script that runs in the background which is separate from your web page. It can intercept network requests, access the cache, and make the web app work offline. This is a key component of Progressive Web Apps.

## Basics of Working with Classes

- **Definition**: Classes in JavaScript are used to define blueprints for creating objects, and encapsulating data. Classes include a constructor which is a special method that gets called automatically when a new object is created from the class. It is used to initialize the properties of the object. The `this` keyword is used here to refer to the current instance of the class. Below the constructor, you can have what are called methods. Methods are functions defined inside a class that perform actions or operations on the class's data or state. They are used to define behaviors that instances of the class can perform.

```js
class Dog {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
}
```

To create a new instance of the class, you will use the `new` keyword followed by the class name:

```js
const dog = new Dog("Gino");
```

You can also create classes as class expressions. This is where the class is anonymous and assigned to a variable.

```js
const Dog = class {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
};
```

## Class Inheritance

- **Definition**: In programming, inheritance allows you to define classes that inherit properties and methods from parent classes. This promotes code reuse and establishes a hierarchical relationship between classes. A parent class is a class that acts like a blueprint for other classes. It defines properties and methods that are inherited by other classes. A child class is a class that inherits the properties and methods of another class. Child classes can also extend the functionality of their parent classes by adding new properties and methods. In JavaScript, we use the `extends` keyword to implement inheritance. This keyword indicates that a class is the child class of another class.

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

The `super` keyword is used to access the parent class's methods, constructors, and fields.


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

## Working with Static Methods and Static Properties

- **Static methods**: These methods are often used for utility functions that don't need access to the specific state of an object. They are defined within classes to encapsulate related functionality. Static methods are also helpful for implementing "factory" methods. A factory method is a method that you define in addition to the constructor to create objects based on specific criteria.

```js
class Movie {
  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }
}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);

Movie.compareMovies(movieA, movieB);
```

- **Static Properties**: These properties are used to define values or attributes that are associated with a class itself, rather than with instances of the class. Static properties are shared across all instances of the class and can be accessed without creating an instance of the class.

```js
class Car {
  // Static property
  static numberOfWheels = 4;

  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  // Instance method
  getCarInfo() {
    return `${this.make} ${this.model}`;
  }

  // Static method
  static getNumberOfWheels() {
    return Car.numberOfWheels;
  }
}

// Accessing static property directly from the class
console.log(Car.numberOfWheels); 
```


- Recursion is programming concept that allows you to call a function repeatedly until a base-case is reached.

Here is an example of a recursive function that calculates the factorial of a number:

```js
function findFactorial(n) {
  if (n === 0) {
    return 1;
  }
  return n * findFactorial(n - 1);
}
```

In the above example, the `findFactorial` function is called recursively until `n` reaches `0`. When `n` is `0`, the base case is reached and the function returns `1`. The function then returns the product of `n` and the result of the recursive call to `findFactorial(n - 1)`.

- Recursion allows you to handle something with an unknown depth, such as deeply nested objects/arrays, or a file tree.
- A call stack is used to keep track of the function calls in a recursive function. Each time a function is called, it is added to the call stack. When the base case is reached, the function calls are removed from the stack.
- You should carefully define the base case as calling it indefinitely can cause your code to crash. This is because the recursion keeps piling more and more function calls till the system runs out of memory.
- Recursions find their uses in solving mathematical problems like factorial and Fibonacci, traversing trees and graphs, generating permutations and combinations and much more.

## Pure vs Impure Functions

- A pure function is one that always produces the same output for the same input and doesn't have any side effects. Its output depends only on its input, and it doesn't modify any external state.
- Impure functions have side effects, which are changes to the state of the program that are observable outside the function.

## Functional programming

- Functional Programming is an approach to software development that emphasizes the use of functions to solve problems, focusing on what needs to be done rather than how to do it.
- Functional programming encourages the use of techniques that help avoid side effects, such as using immutable data structures and higher-order functions.
- When used correctly, functional programming principles lead to cleaner and more maintainable code

## Currying

- Currying is a functional programming technique that transforms a function with multiple arguments into a sequence of functions, each taking a single argument.

Here is an example of a regular function vs a curried function:

```js
// Regular function

function average(a, b, c) {
  return (a + b + c) / 3;
}

// Curried function

function curriedAverage(a) {
  return function(b) {
    return function(c) {
      return (a + b + c) / 3;
    };
  };
}

// Usage of curried function

const avg = curriedAverage(2)(3)(4);
```

- Currying can be particularly powerful when working with functions that take many arguments.
- Currying makes your code more flexible and easier to reuse.
- You can use arrow functions to create curried functions more concisely:

```js
const curriedAverage = a => b => c => (a + b + c) / 3;
```

- While currying can lead to more flexible and reusable code, it can also make code harder to read if overused.

- **Synchronous JavaScript** is executed sequentially and waits for the previous operation to finish before moving on to the next one.
- **Asynchronous JavaScript** allows multiple operations to be executed in the background without blocking the main thread.
- **Thread** is a sequence of instructions that can be executed independently of the main program flow.
- **Callback functions** are functions that are passed as arguments to other functions and are executed after the completion of the operation or as a result of an event.

## The JavaScript engine and JavaScript runtime

- The **JavaScript engine** is a program that executes JavaScript code in a web browser. It works like a converter that takes your code, turns it into instructions that the computer can understand and work accordingly.
- V8 is an example of a JavaScript engine developed by Google.
- The **JavaScript runtime** is the environment in which JavaScript code is executed. It includes the JavaScript engine which processes and executes the code, and additional features like a web browser or Node.js.

## The Fetch API

- The Fetch API allows web apps to make network requests, typically to retrieve or send data to the server. It provides a `fetch()` method that you can use to make these requests.
- You can retrieve text, images, audio, JSON, and other types of data using the Fetch API.

## HTTP methods for Fetch API

The Fetch API supports various HTTP methods to interact with the server. The most common methods are:

- **GET**: Used to retrieve data from the server. By default, the Fetch API uses the `GET` method to retrieve data.

```js
fetch('https://api.example.com/data')
```

To use the fetched data, it must be converted to JSON format using the `.json()` method:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

In this code, the response coming from the Fetch API is a promise and the `.then` handler is converting the response to a JSON format.

- **POST**: Used to send data to the server. The `POST` method is used to create new resources on the server.

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

In this example, we're sending a `POST` request to create a new user. We have specified the method as `POST`, set the appropriate headers, and included a body with the data we want to send. The body needs to be a string, so we use `JSON.stringify()` to convert our object to a JSON string.

- **PUT**: Used to update data on the server. The `PUT` method is used to update existing resources on the server.

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

In this example, we are updating the ID `45` that is specified at the end of the URL. We have used the `PUT` method on the code and also specified the data as the body which will be used to update the identified data.

- **DELETE**: Used to delete data on the server. The `DELETE` method is used to delete resources on the server.

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

In this example, we're sending a `DELETE` request to remove a user with the ID `45`.

## Promise and promise chaining

- **Promises** are objects that represent the eventual completion or failure of an asynchronous operation and its resulting value. The value of the promise is known only when the `async` operation is completed.
- Here is an example to create a simple promise:

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- The `.then()` method is used in a Promise to specify what should happen when the Promise is fulfilled, while `.catch()` is used to handle any errors that occur.
- Here is an example of using `.then()` and `.catch()` with a Promise:

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

In the above example, the `.then()` method is used to log the data received from the Promise, while the `.catch()` method is used to log any errors that occur.

- **Promise chaining**: One of the powerful features of Promises is that we can chain multiple asynchronous operations together. Each `.then()` can return a new Promise, allowing you to perform a sequence of asynchronous operations one after the other.
- Here is an example of Promise chaining:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

In the above example, we first fetch data from one URL, then fetch data from another URL based on the first response, and finally log the second data received.

The `catch` method would handle any errors that occur during the process. This means you don't need to add error handling to each individual step, which can greatly simplify your code.

## Using `async/await` to handle promises

Async/await makes writing & reading asynchronous code easier which is built on top of Promises.

- **async**: The `async` keyword is used to define an asynchronous function. An `async` function returns a Promise, which resolves with the value returned by the `async` function.
- **await**: The `await` keyword is used inside an `async` function to pause the execution of the function until the Promise is resolved. It can only be used inside an `async` function.
- Here is an example of using `async/await`:

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

In the above example, the `delayedGreeting` function is an `async` function that pauses for 2 seconds before printing the greeting message. The `await` keyword is used to pause the function execution until the `Promise` is resolved.

- One of the biggest advantages of `async/await` is error handling via `try/catch` blocks. Here's an example:

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

In the above example, the `try` block contains the code that might throw an error, and the `catch` block handles the error if it occurs. This makes error handling more straightforward and readable.

## The `async` attribute

- The `async` attribute tells the browser to download the script file asynchronously while continuing to parse the HTML document.
- Once the script is downloaded, the HTML parsing is paused, the script is executed, and then HTML parsing resumes.
- You should use `async` for independent scripts where the order of execution doesn't matter

## The `defer` attribute

- The `defer` attribute also downloads the script asynchronously, but it defers the execution of the script until after the HTML document has been fully parsed.
- The `defer` scripts maintain the order of execution as they appear in the HTML document.

- It's important to note that both `async` and `defer` attributes are ignored for inline scripts and only work for external script files.

- When both `async` and `defer` attributes are present, the `async` attribute takes precedence.

## Geolocation API

- The Geolocation API provides a way for websites to request the user's location.

- The example below demonstrates the API's  `getCurrentPosition()` method which is used to get the user's current location.

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

In this code, we're calling `getCurrentPosition` and passing it a function which will be called when the position is successfully obtained.

The `position` object contains a variety of information, but here we have selected `latitude` and `longitude` only.

If there is an issue with getting the `position`, then the error will be logged to the console. It is important to respect the user's privacy and only request their location when necessary.


# --assignment--

Review the JavaScript topics and concepts.
