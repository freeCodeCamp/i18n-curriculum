---
id: 68d275dd800f404d22a07564
title: Implementa el Algoritmo de Búsqueda en Profundidad
challengeType: 27
dashedName: lab-depth-first-search
---

# --description--

En este laboratorio, implementarás un algoritmo de recorrido de grafos llamado <dfn>depth-first search</dfn>.

Mientras que la <dfn>breadth-first search</dfn> busca incrementando la longitud de las aristas desde el nodo fuente, la <dfn>depth-first search</dfn> primero sigue un camino de aristas tan lejos como puede.

Una vez que alcance el extremo de una ruta, la búsqueda retrocederá al último nodo con una arista no visitado y continuará la búsqueda.

A diferencia de la búsqueda en anchura, cada vez que se visita un nodo, no visita todos sus vecinos. En cambio, primero visita a uno de sus vecinos y continúa por ese camino hasta que no haya más nodos por visitar en ese camino.

Para implementar este algoritmo, querrás usar una pila (un arreglo donde el último elemento agregado es el primero en ser removido, siguiendo el principio <dfn>Last-In-First-Out</dfn>). Una pila es útil en algoritmos de búsqueda en profundidad porque, al agregar vecinos a la pila, quieres visitar primero a los vecinos agregados más recientemente y removerlos de la pila.

Un salida simple de este algoritmo es una lista de nodos los cuales son alcanzables desde un nodo determinado. Por lo tanto, también querrá llevar un seguimiento de los nodos que visita.

**Objetivo**: Cumple las historias de usuario a continuación y logra que todas las pruebas pasen para completar el laboratorio.

**Historias de usuario:**

1. Debes tener una función llamada `dfs`.
1. La función `dfs` debe tomar dos argumentos:
   - Una matriz de adyacencia no dirigida.
   - Una etiqueta de nodo, que es el valor numérico del nodo entre `0` y `n - 1`, donde `n` es el número total de nodos en el grafo.
1. La función `dfs` debe implementar el algoritmo de búsqueda en profundidad para generar una lista de todos los nodos accesibles desde el nodo que se le pasa.

# --hints--

Debes tener una función llamada `dfs` que tome dos argumentos.

```js
({ test: () => runPython(`
  import inspect
  assert inspect.isfunction(dfs)
  sig = inspect.signature(dfs)
  assert len(sig.parameters) == 2
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1)` debería devolver una lista con `1`, `2`, `3` y `0`.

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1)
  assert isinstance(result, list)
  assert len(result) == 4
  assert set(result) == {1, 2, 3, 0}
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3)` debería devolver una lista con `1`, `2`, `3` y `0`.

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3)
  assert isinstance(result, list)
  assert len(result) == 4
  assert set(result) == {3, 2, 1, 0}
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], 3)` debería devolver `[3]`.

```js
({ test: () => runPython(`
  assert dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], 3) == [3]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 3)` debería devolver una lista con `3` y `2`.

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 3)
  assert result == [3, 2] or result == [2, 3]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 0)` debería devolver una lista con `0` y `1`.

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 0)
  assert result == [0, 1] or result == [1, 0]
`) })
```

La función `dfs` debe devolver los resultados correctos.

```js
({ test: () => runPython(`
  import random

  def solve(g, s):
      v, q = set(), [s]
      while q:
          u = q.pop()
          if u not in v:
              v.add(u)
              q.extend([i for i, x in enumerate(g[u]) if x == 1 and i not in v])
      return v

  random.seed(0)

  for _ in range(10):
      n = 6
      mat = [[0]*n for _ in range(n)]
      for i in range(n):
          for j in range(i+1, n):
              if random.random() > 0.5:
                  mat[i][j] = mat[j][i] = 1

      start = random.randint(0, n-1)
      assert set(dfs(mat, start)) == solve(mat, start), "Random graph check failed"
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def dfs(graph, root):
    stack = []
    temp_v = None
    visited = []
    temp_v_neighbors = []
    stack.append(root)
    while stack:
        temp_v = stack.pop()
        if temp_v not in visited:
            visited.append(temp_v)
            temp_v_neighbors = graph[temp_v]
            for n, is_neighbor in enumerate(temp_v_neighbors):
                if is_neighbor == 1:
                    stack.append(n)
    return visited
```
