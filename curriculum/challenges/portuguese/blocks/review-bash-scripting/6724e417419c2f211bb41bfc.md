---
id: 6724e417419c2f211bb41bfc
title: Revisão de Bash Scripting
challengeType: 31
dashedName: review-bash-scripting
---

# --description--

## Noções Básicas de Bash Scripting

- **Script Bash**: Escrever uma sequência de comandos Bash em um arquivo, que você pode então executar com Bash para rodar o conteúdo do arquivo.
- **Shebang**: A linha comentada no início de um script (por exemplo, `#!/bin/bash`) que indica qual interpretador deve ser usado para o script.

  ```bash
  #!/bin/bash
  ```

- **Atribuição de variável**: Instancie variáveis usando a sintaxe `variable_name=value`.

  ```bash
  servers=("prod" "dev")
  ```

- **Regras para criação de variáveis**: Crie variáveis com a sintaxe `VARIABLE_NAME=VALUE`. Não são permitidos espaços ao redor do sinal de igual (`=`). Use aspas duplas se o valor contiver espaços.

  ```bash
  NAME=John
  MESSAGE="Hello World"
  COUNT=5
  TEXT="The next number is, "
  ```

- **Uso de variáveis**: Acesse os valores das variáveis colocando `$` na frente do nome da variável.

  ```bash
  echo $NAME
  echo "The message is: $MESSAGE"
  ```

- **Interpolação de variável**: Use `$variable_name` para acessar o valor de uma variável dentro de strings e comandos.

  ```bash
  TEXT="The next number is, "
  NUMBER=42
  echo $TEXT B:$NUMBER
  echo $TEXT I:$NUMBER
  
  echo "Pulling $server"
  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf
  ```

- **Escopo de variável**: Scripts shell são executados de cima para baixo, então variáveis só podem ser usadas abaixo de onde são criadas.

  ```bash
  NAME="Alice"
  echo $NAME
  ```

- **Entrada do usuário**: Use `read` para aceitar entrada dos usuários e armazená-la em uma variável.

  ```bash
  read USERNAME
  echo "Hello $USERNAME"
  ```

- **Comentários**: Adicione comentários aos seus scripts usando `#` seguido do texto do seu comentário.
  - Comentários de linha única começam com `#` e continuam até o final da linha
  - Comentários são ignorados pelo shell e não afetam a execução do script

  ```bash
  # This is a single-line comment
  NAME="John"  # Comment at end of line
  ```

- **Comentários multilinha**: Comente blocos de código usando dois pontos e aspas.

  ```bash
  : '
  This is a multi-line comment
  Everything between the quotes is ignored
  Useful for debugging or documentation
  '
  ```

- **Comandos embutidos e ajuda**: 
  - Use `help` para ver uma lista de comandos bash embutidos
  - Use `help <command>` para obter informações sobre comandos internos específicos
  - Alguns comandos (como `if`) são internos e não possuem páginas de manual
  - Comandos embutidos são executados diretamente pelo shell em vez de como programas externos
  - Use a `help function` para ver informações sobre como criar funções

  ```bash
  help
  help if
  help function
  ```

- **Encontrando localizações de comandos**: Use `which` para localizar onde os executáveis estão instalados.
  - Mostra o caminho completo para arquivos executáveis
  - Útil para encontrar localizações de interpretadores (como bash)
  - Ajuda a verificar qual versão de um comando será executada

  ```bash
  which bash
  which python
  which ls
  ```

- **Páginas de manual**: Use `man` para acessar documentação detalhada de comandos.
  - Fornece informações abrangentes sobre o uso de comandos
  - Mostra todas as opções e exemplos disponíveis
  - Use as teclas de seta para navegar e 'q' para sair
  - Nem todos os comandos têm páginas de manual (built-ins usam `help` em vez disso)

  ```bash
  man echo
  man ls
  man bash
  ```

- **Flags de ajuda**: Muitos comandos suportam `--help` para informações rápidas de ajuda.
  - Alternativa às páginas manuais para referência rápida
  - Mostra a sintaxe do comando e as opções comuns
  - Nem todos os comandos suportam esta flag (alguns podem mostrar erro)

  ```bash
  ls --help
  chmod --help
  mv --help
  ```

- **Opções do comando Echo**: O comando `echo` suporta várias opções:
  - A opção `-e` habilita a interpretação de escapes com barra invertida
  - `\n` cria uma nova linha
  - Linhas vazias são impressas apenas quando os valores estão entre aspas
  - Útil para criar saída formatada e títulos de programas

  ```bash
  echo -e "Line 1\nLine 2"
  echo ""
  echo -e "\n~~ Program Title ~~\n"
  echo "Line 1\nLine 2"
  ```

- **Argumentos do script**: Programas podem aceitar argumentos que são acessíveis usando variáveis `$`.
  - `$*` imprime todos os argumentos passados para o script
  - `$@` imprime todos os argumentos passados para o script como strings separadas entre aspas
  - `$<number>` acessa argumentos específicos pela posição (por exemplo, `$1`, `$2` e `$3`)

  ```bash
  echo $*
  echo $@
  echo $1
  echo $2
  ```

## Expressões de Dupla Colchete `[[ ]]`

- **Sintaxe de colchetes duplos**: Use `[[ ]]` para testes condicionais e correspondência de padrões.
  - Deve haver espaços dentro dos colchetes e ao redor dos operadores
  - Retorna o status de saída 0 (true) ou 1 (false) com base no resultado do teste

  ```bash
  [[ $variable == "value" ]]
  [[ $number -gt 10 ]]
  [[ -f filename.txt ]]
  ```

- **Operadores de comparação de strings**: Compare strings usando vários operadores dentro de `[[ ]]`.
  - `==` (equal): Testa se duas strings são idênticas
  - `!=` (diferente): Testa se duas strings são diferentes
  - `<` (lexicograficamente menor): Comparação de strings em ordem alfabética
  - `>` (lexicograficamente maior): Comparação de strings em ordem alfabética

  ```bash
  [[ "apple" == "apple" ]]
  [[ "apple" != "orange" ]]
  [[ "apple" < "banana" ]]
  [[ "zebra" > "apple" ]]
  ```

- **Operadores de comparação numérica**: Compare números usando operadores numéricos específicos.
  - `-eq` (equal): Comparação de igualdade numérica
  - `-ne` (not equal): Comparação de desigualdade numérica
  - `-lt` (less than): Comparação numérica menor que
  - `-le` (menor ou igual): comparação numérica menor ou igual
  - `-gt` (greater than): Comparação numérica maior que
  - `-ge` (greater than or equal): Comparação numérica maior ou igual

  ```bash
  [[ $number -eq 5 ]]
  [[ $count -ne 0 ]]
  [[ $age -ge 18 ]]
  [[ $score -lt 100 ]]
  ```

- **Operadores lógicos**: Combine múltiplas condições usando operadores lógicos.
  - `&&` (e): Ambas as condições devem ser verdadeiras
  - `||` (ou): Pelo menos uma condição deve ser verdadeira
  - `!` (not): Nega a condição (torna true em false, false em true)

  ```bash
  [[ $age -ge 18 && $age -le 65 ]]
  [[ $name == "John" || $name == "Jane" ]]
  [[ ! -f missing_file.txt ]]
  ```

- **Operadores de teste de arquivo**: Teste propriedades e existência de arquivo.
  - `-e file`: Verdadeiro se o arquivo existir
  - `-f file`: Verdadeiro se o arquivo existir e for um arquivo regular
  - `-d file`: Verdadeiro se o arquivo existir e for um diretório
  - `-r file`: Verdadeiro se o arquivo existir e for legível
  - `-w file`: Verdadeiro se o arquivo existir e for gravável
  - `-x file`: Verdadeiro se o arquivo existir e for executável
  - `-s file`: Verdadeiro se o arquivo existir e tiver tamanho maior que zero

  ```bash
  [[ -e /path/to/file ]]
  [[ -f script.sh ]]
  [[ -d /home/user ]]
  [[ -x program ]]
  ```

- **Correspondência de padrão com `=~`**: Use expressões regulares para correspondência avançada de padrões.
  - O operador `=~` permite correspondência de padrão regex
  - O padrão não deve ser colocado entre aspas ao usar metacaracteres de regex
  - Suporta a sintaxe completa de expressões regulares
  - Sensível a maiúsculas e minúsculas por padrão

  ```bash
  [[ "hello123" =~ [0-9]+ ]]
  [[ "email@domain.com" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
  [[ "filename.txt" =~ \.txt$ ]]
  ```

- **Teste de existência de variável**: Verifique se as variáveis estão definidas ou vazias.
  - Teste se a variável está vazia: `[[ ! $variable ]]`

  ```bash
  [[ ! $undefined_var ]]
  ```

## Expressões de Parênteses Duplos `(( ))`

- **Avaliação aritmética**: Use `(( ))` para cálculos matemáticos e comparações numéricas.
  - Avalia expressões aritméticas usando sintaxe estilo C
  - Variáveis não precisam do prefixo `$` dentro de parênteses duplos
  - Retorna o status de saída 0 se o resultado for diferente de zero, 1 se o resultado for zero
  - Suporta todos os operadores aritméticos padrão

  ```bash
  (( result = 10 + 5 ))
  (( count++ ))
  (( total += value ))
  ```

- **Operadores aritméticos**: Operadores matemáticos disponíveis em `(( ))`.
  - `+` (adição): Soma dois números
  - `-` (subtração): Subtrai o segundo número do primeiro
  - `*` (multiplicação): Multiplica dois números
  - `/` (divisão): Divide o primeiro número pelo segundo (divisão inteira)
  - `%` (modulus): Resto após a divisão
  - `**` (exponenciação): Elevar o primeiro número à potência do segundo

  ```bash
  (( sum = a + b ))
  (( diff = x - y ))
  (( product = width * height ))
  (( remainder = num % 10 ))
  (( power = base ** exponent ))
  ```

- **Operadores de atribuição**: Modifique variáveis usando operadores de atribuição aritmética.
  - `=` (atribuição): Atribuir valor à variável
  - `+=` (adicionar e atribuir): Adiciona valor à variável
  - `-=` (subtrair e atribuir): Subtrai valor da variável
  - `*=` (multiplicar e atribuir): Multiplica a variável pelo valor
  - `/=` (divide e atribui): Divide a variável pelo valor
  - `%=` (módulo e atribuição): Define a variável como o resto

  ```bash
  (( counter = 0 ))
  (( counter += 5 ))
  (( total -= cost ))
  (( area *= 2 ))
  (( value /= 3 ))
  ```

- **Operadores de incremento e decremento**: Modificam variáveis em uma unidade.
  - `++variable` (pré-incremento): Incrementa antes do uso
  - `variable++` (pós-incremento): Incrementa após o uso
  - `--variable` (pré-decremento): Decrementa antes do uso
  - `variable--` (pós-decremento): Decrementa após o uso

  ```bash
  (( ++counter ))
  (( index++ ))
  (( --remaining ))
  (( attempts-- ))
  ```

- **Operadores de comparação**: Compare números usando comparação aritmética.
  - `==` (equal): Números são iguais
  - `!=` (not equal): Números não são iguais
  - `<` (menor que): O primeiro número é menor que o segundo
  - `<=` (menor ou igual): O primeiro número é menor ou igual ao segundo
  - `>` (maior que): O primeiro número é maior que o segundo
  - `>=` (maior ou igual): O primeiro número é maior ou igual ao segundo

  ```bash
  (( age >= 18 ))
  (( score < 100 ))
  (( count == 0 ))
  (( temperature > freezing ))
  ```

- **Operadores lógicos**: Combine condições aritméticas.
  - `&&` (e): Ambas as condições devem ser verdadeiras
  - `||` (ou): Pelo menos uma condição deve ser verdadeira
  - `!` (not): Nega a condição

  ```bash
  (( age >= 18 && age <= 65 ))
  (( score >= 90 || extra_credit > 0 ))
  (( !(count == 0) ))
  ```

- **Operadores bit a bit**: Executam operações em nível de bit em inteiros.
  - `&` (bitwise AND): operação AND em cada bit
  - `|` (bitwise OR): operação OR em cada bit
  - `^` (bitwise XOR): operação XOR em cada bit
  - `~` (bitwise NOT): Inverte todos os bits
  - `<<` (left shift): Desloca os bits para a esquerda
  - `>>` (right shift): Desloca bits para a direita

  ```bash
  (( result = a & b ))
  (( flags |= new_flag ))
  (( shifted = value << 2 ))
  ```

- **Operador condicional (ternário)**: Use a sintaxe `condition ? true_value : false_value`.
  - Fornece uma maneira concisa de atribuir valores com base em condições
  - Semelhante ao operador ternário em linguagens do estilo C
  - Avalia a condição e retorna um dos dois valores

  ```bash
  (( result = (score >= 60) ? 1 : 0 ))
  (( max = (a > b) ? a : b ))
  (( sign = (num >= 0) ? 1 : -1 ))
  ```

- **Substituição de comando com aritmética**: Use `$(( ))` para capturar resultados aritméticos.
  - Retorna o resultado da expressão aritmética como uma string
  - Pode ser usado em atribuições ou argumentos de comando
  - Útil para cálculos que precisam ser usados em outro lugar

  ```bash
  result=$(( 10 + 5 ))
  echo "The answer is $(( a * b ))"
  array_index=$(( RANDOM % array_length ))
  ```

## Fluxo de Controle e Condicionais

- **Instruções condicionais**: Use `if` statements para executar código com base em condições.
  - Sintaxe básica: `if [[ CONDITION ]] then STATEMENTS fi`
  - Sintaxe completa: `if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`
  - Pode usar tanto expressões `[[ ]]` e `(( ))` para diferentes tipos de condições
  - **elif (else if)**: Opcional, pode ser repetido várias vezes para testar condições adicionais em sequência
  - **else**: Opcional, executa quando todas as condições anteriores são falsas
  - Pode misturar parênteses duplos `(( ... ))` e colchetes duplos `[[ ... ]]` na mesma cadeia condicional

  ```bash
  if (( NUMBER <= 15 ))
  then
      echo "B:$NUMBER"
  elif [[ $NUMBER -le 30 ]]
  then
      echo "I:$NUMBER"
  elif (( NUMBER < 46 ))
  then
      echo "N:$NUMBER"
  elif [[ $NUMBER -lt 61 ]]
  then
      echo "G:$NUMBER"
  else
      echo "O:$NUMBER"
  fi
  ```

## Execução de Comandos e Controle de Processos

- **Separação de comandos**: Use ponto e vírgula (`;`) para executar múltiplos comandos em uma única linha.
  - Os comandos são executados sequencialmente da esquerda para a direita
  - O status de saída de cada comando pode ser verificado individualmente

  ```bash
  [[ 4 -ge 5 ]]; echo $?
  ls -l; echo "Done"
  ```

- **Status de saída**: Todo comando tem um status de saída que indica sucesso ou falha.
  - Acesse o status de saída do último comando com `$?`
  - O status de saída `0` significa sucesso (verdadeiro/sem erros)
  - Qualquer status de saída diferente de zero significa falha (ocorreram erros/falso)
  - Códigos de erro comuns: `127` (comando não encontrado) e `1` (erro geral)

  ```bash
  echo $?
  [[ 4 -le 5 ]]; echo $?
  ls; echo $?
  bad_command; echo $?
  ```

- **Subshells e substituição de comando**: Usos diferentes de parênteses para contextos de execução.
  - Parênteses simples `( ... )` criam uma subshell
  - `$( ... )` realiza substituição de comando
  - Subshells são executados em ambientes separados e não afetam as variáveis do shell pai

  ```bash
  ( cd /tmp; echo "Current dir: $(pwd)" )
  current_date=$(date)
  file_count=$(ls | wc -l)
  echo "Today is $current_date"
  echo "Found $file_count files"
  ```

- **Comando Sleep**: Pausa a execução do script por um número especificado de segundos.
  - Útil para criar atrasos em scripts
  - Pode ser usado com valores decimais para atrasos de subsegundos

  ```bash
  sleep 3
  sleep 0.5
  sleep 1
  ```

## Laços

- **Laços while**: Execute o código repetidamente enquanto uma condição for verdadeira.
  - Sintaxe: `while [[ CONDITION ]] do STATEMENTS done`

  ```bash
  I=5
  while [[ $I -ge 0 ]]
  do
      echo $I
      (( I-- ))
      sleep 1
  done
  ```

- **Laços Until**: Execute o código repetidamente até que uma condição se torne verdadeira.
  - Sintaxe: `until [[ CONDITION ]] do STATEMENTS done`

  ```bash
  until [[ $QUESTION =~ \?$ ]]
  do
      echo "Please enter a question ending with ?"
      read QUESTION
  done
  until [[ $QUESTION =~ \?$ ]]
  do
      GET_FORTUNE again
  done
  ```

- **Laços for**: Itere por arrays ou listas usando laços `for` com `do` e `done` para definir o bloco lógico do laço.

  ```bash
  for server in "${servers[@]}"
  do
      echo "Processing $server"
  done
  for (( i = 1; i <= 5; i++ ))
  do
      echo "Number: $i"
  done
  for (( i = 5; i >= 1; i-- ))
  do
      echo "Countdown: $i"
  done
  for i in {1..5}
  do
      echo "Count: $i"
  done
  ```

## Arrays

- **Arrays**: Armazenam múltiplos valores em uma única variável.
  - Crie arrays com parênteses: `ARRAY=("value1" "value2" "value3")`
  - Acesse elementos pelo índice: `${ARRAY[0]}`, `${ARRAY[1]}`
  - Acesse todos os elementos: `${ARRAY[@]}` ou `${ARRAY[*]}`
  - O índice de arrays começa em 0

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Ask again later")
  echo ${RESPONSES[0]}     # Yes          
  echo ${RESPONSES[1]}     # No         
  echo ${RESPONSES[5]}     # Index 5 doesn't exist; empty string              
  echo ${RESPONSES[@]}     # Yes No Maybe Ask again later   
  echo ${RESPONSES[*]}     # Yes No Maybe Ask again later 
  ```

- **Inspeção de array com declare**: Use `declare -p` para visualizar detalhes do array.
  - Mostra o tipo do array com a flag `-a`
  - Exibe todos os elementos do array e sua estrutura

  ```bash
  ARR=("a" "b" "c")
  declare -p ARR # ARR=([0]="a" [1]="b" [2]="c")
  ```

- **Expansão de array**: Use a sintaxe `"${array_name[@]}"` para expandir um array em elementos individuais.

```bash
for server in "${servers[@]}"
```

## Funções

- **Funções**: Crie blocos reutilizáveis de código.
  - Defina com `FUNCTION_NAME() { STATEMENTS }`
  - Chame usando o nome da função
  - Pode aceitar argumentos acessíveis como `$1`, `$2`, etc.

  ```bash
  GET_FORTUNE() {
      echo "Ask a question:"
      read QUESTION
  }
  GET_FORTUNE
  ```

- **Argumentos de função**: Funções podem aceitar argumentos assim como scripts.
  - Os argumentos são passados ao chamar a função
  - Acesse os argumentos dentro da função usando `$1`, `$2`, etc.
  - Use lógica condicional para lidar com diferentes argumentos

  ```bash
  GET_FORTUNE() {
      if [[ ! $1 ]]
      then
          echo "Ask a yes or no question:"
      else
          echo "Try again. Make sure it ends with a question mark:"
      fi
      read QUESTION
  }
  GET_FORTUNE
  GET_FORTUNE again
  ```

## Números Aleatórios e Operações Matemáticas

- **Números aleatórios**: Gere valores aleatórios usando a variável `$RANDOM`.
  - `$RANDOM` gera números entre 0 e 32767
  - Use o operador módulo para limitar o intervalo: `$RANDOM % 75`
  - Adicione 1 para evitar zero: `$(( RANDOM % 75 + 1 ))`
  - Deve usar a sintaxe `$(( ... ))` para cálculos com `$RANDOM`

  ```bash
  NUMBER=$(( RANDOM % 6 ))
  DICE=$(( RANDOM % 6 + 1 ))
  BINGO=$(( RANDOM % 75 + 1 ))
  echo $(( RANDOM % 10 ))
  ```

- **Acesso aleatório a arrays**: Use números aleatórios para acessar elementos do array de forma aleatória.
  - Gerar índice aleatório dentro dos limites do array
  - Use índice aleatório para acessar elementos do array
  - Útil para seleções aleatórias a partir de opções predefinidas

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Outlook good" "Don't count on it" "Ask again later")
  N=$(( RANDOM % 6 ))
  echo ${RESPONSES[$N]}
  ```

- **Operador módulo**: Use `%` para obter o resto das operações de divisão.
  - Essencial para limitar os intervalos de números aleatórios
  - Funciona com `$RANDOM` para criar valores aleatórios limitados
  - `RANDOM % n` gera números de 0 a n-1

  ```bash
  echo $(( 15 % 4 ))
  echo $(( RANDOM % 100 ))
  echo $(( RANDOM % 10 + 1 ))
  ```

## Ambiente e Informações do Sistema

- **Variáveis de ambiente**: Variáveis predefinidas disponíveis no ambiente do shell.
  - `$RANDOM`: Gera números aleatórios entre 0 e 32767
  - `$LANG`: Configuração do idioma do sistema
  - `$HOME`: caminho do diretório home do usuário
  - `$PATH`: Diretórios pesquisados para comandos executáveis
  - Veja todos com `printenv` ou `declare -p`

  ```bash
  echo $RANDOM
  echo $HOME
  echo $LANG
  printenv
  ```

- **Inspeção de variáveis**: Use `declare` para visualizar e trabalhar com variáveis.
  - `declare -p`: Imprime todas as variáveis e seus valores
  - `declare -p VARIABLE`: Exibe detalhes específicos da variável
  - Mostra o tipo da variável (string, array, etc.) e os atributos

  ```bash
  declare -p
  declare -p RANDOM
  declare -p MY_ARRAY
  ```

- **Tipos de comando**: Diferentes categorias de comandos disponíveis no bash.
  - **Comandos embutidos**: Executados diretamente pelo shell (por exemplo, `echo`, `read` e `if`)
  - **Comandos externos**: Arquivos binários em diretórios do sistema (por exemplo, `ls`, `sleep` e `bash`)
  - **Palavras-chave do Shell**: Construções da linguagem (por exemplo, `then`, `do`, `done`)
  - Use `type <command>` para ver qual é o tipo de um comando

  ```bash
  type echo
  type ls
  type if
  type ./script.sh
  ```

## Criação e Gerenciamento de Arquivos

- **Criação de arquivo**: Use `touch` para criar novos arquivos vazios.
  - Cria um novo arquivo se ele não existir
  - Atualiza o carimbo de data/hora se o arquivo já existir
  - Comumente usado para criar arquivos de script antes da edição

  ```bash
  touch script.sh
  touch bingo.sh
  touch filename.txt
  ```

## Criando e Executando Scripts Bash

- **Métodos de execução de script**: Múltiplas formas de executar scripts bash:
  - **`sh scriptname.sh`**: Execute com o interpretador de shell sh.
  - **`bash scriptname.sh`**: Execute com o interpretador de shell bash.
  - **`./scriptname.sh`**: Execute diretamente (requer permissões de execução).

```bash
sh questionnaire.sh
bash questionnaire.sh
./questionnaire.sh
```

## Permissões de Arquivo e Execução de Script

- **Erro de permissão negada**: Ao usar `./scriptname.sh`, você pode receber "permission denied" se o arquivo não tiver permissões de execução.
- **Verificando permissões**: Use `ls -l` para visualizar as permissões do arquivo.

  ```bash
  ls -l questionnaire.sh
  ```

- **Formato de permissão**: A saída mostra as permissões como `-rw-r--r--` onde:
  - Primeiro caractere (`-`): Tipo de arquivo (- para arquivo regular, d para diretório)
  - Próximos 9 caracteres: Permissões para proprietário, grupo e outros
  - `r` = read, `w` = write, `x` = execute
  
- **Adicionando permissões de execução**: Use `chmod +x` para dar permissões de execução a todos.

  ```bash
  chmod +x questionnaire.sh
  ```

- **Organização de script**: Melhores práticas para estruturar scripts bash.
  - Comece com shebang (`#!/bin/bash`)
  - Adicione comentários descritivos sobre o propósito do script
  - Defina variáveis no topo
  - Agrupe funções relacionadas juntas
  - Lógica principal do script na parte inferior

  ```bash
  #!/bin/bash
  NAME="value"
  ARRAY=("item1" "item2")
  my_function() {
      echo "Function code here"
  }
  my_function
  echo "Script complete"
  ```

- **Execução sequencial de scripts**: Crie scripts mestre que executem múltiplos programas em sequência.
  - Útil para automatizar fluxos de trabalho que envolvem múltiplos scripts
  - Cada script é executado até a conclusão antes que o próximo comece
  - Pode combinar diferentes programas em um único fluxo de execução
  - Argumentos podem ser passados para scripts individuais conforme necessário
  - Pode incluir diferentes tipos de programas (interativos, automatizados, etc.)

  ```bash
  #!/bin/bash
  ./setup.sh
  ./interactive.sh
  ./processing.sh
  ./cleanup.sh
  ```

# --assignment--

Revise os tópicos e conceitos de Bash Scripting.
