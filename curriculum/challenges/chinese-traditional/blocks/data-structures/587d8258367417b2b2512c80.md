---
id: 587d8258367417b2b2512c80
title: 刪除二元搜尋樹中的葉節點
challengeType: 1
forumTopicId: 301637
dashedName: delete-a-leaf-node-in-a-binary-search-tree
---

# --description--

這是三個挑戰中的第一個，我們將在二元搜尋樹中實作一個較困難的操作行為：刪除。刪除困難的原因是移除節點會破壞樹中的連結。這些連結必須小心地重新建立，以確保二元樹結構得以維護。對於某些刪除，這表示樹必須重新排列。一般來說，當你嘗試刪除節點時，會遇到以下三種情況之一：葉節點：要刪除的標的沒有子節點。單一子節點：要刪除的標的只有一個子節點。兩個子節點：要刪除的標的有兩個子節點。移除葉節點很簡單，我們只需將它移除。刪除只有一個子節點的節點也相對簡單，我們只需將它移除，並將其父節點連結到被刪除節點的子節點。然而，移除有兩個子節點的節點較為困難，因為這會產生兩個子節點需要重新連結到父樹。我們會在第三個挑戰中看到如何處理這種情況。此外，當控制代碼刪除時，你需要注意一些邊界情況。如果樹是空的怎麼辦？如果要刪除的節點是根節點怎麼辦？如果樹中只有兩個元素怎麼辦？現在，讓我們先處理第一種情況，也就是刪除葉節點。

# --instructions--

在我們的二元樹上創建一個名為 `remove` 的方法。我們將在這裡建置刪除操作的邏輯。首先，你會想在 `remove` 中創建一個函式，用來尋找我們試圖刪除的節點是否存在於目前的樹中。如果節點不在樹中，`remove` 應該傳回 `null`。現在，如果標的節點是沒有子節點的葉節點，則指向它的父節點引用應該設為 `null`。這樣就有效地從樹中刪除了該節點。為了做到這點，你必須同時追蹤我們試圖刪除的節點的父節點。創建一種方式來追蹤標的節點有多少子節點也會很有用，因為這將決定我們的刪除屬於哪一種情況。我們會在接下來的挑戰中處理第二和第三種情況。祝你好運！

# --hints--

應該存在 `BinarySearchTree` 資料結構。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    }
    return typeof test == 'object';
  })()
);
```

二元搜尋樹應該有一個名為 `remove` 的方法。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    return typeof test.remove == 'function';
  })()
);
```

嘗試從空樹中移除元素應該傳回 `null`。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    if (typeof test.remove !== 'function') {
      return false;
    }
    return test.remove(100) == null;
  })()
);
```

嘗試移除不存在的元素應該傳回 `null`。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    if (typeof test.remove !== 'function') {
      return false;
    }
    test.add(15);
    test.add(30);
    return test.remove(100) == null;
  })()
);
```

如果根節點沒有子節點，刪除它應該將根設為 `null`。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    if (typeof test.remove !== 'function') {
      return false;
    }
    test.add(500);
    test.remove(500);
    return test.inorder() == null;
  })()
);
```

`remove` 方法應該從樹中移除葉節點。

```js
assert(
  (function () {
    var test = false;
    if (typeof BinarySearchTree !== 'undefined') {
      test = new BinarySearchTree();
    } else {
      return false;
    }
    if (typeof test.remove !== 'function') {
      return false;
    }
    test.add(5);
    test.add(3);
    test.add(7);
    test.add(6);
    test.add(10);
    test.add(12);
    test.remove(3);
    test.remove(12);
    test.remove(10);
    return test.inorder().join('') == '567';
  })()
);
```

# --seed--

## --after-user-code--

```js
BinarySearchTree.prototype = Object.assign(
  BinarySearchTree.prototype,
  {
    add: function(value) {
      var node = this.root;
      if (node == null) {
        this.root = new Node(value);
        return;
      } else {
        function searchTree(node) {
          if (value < node.value) {
            if (node.left == null) {
              node.left = new Node(value);
              return;
            } else if (node.left != null) {
              return searchTree(node.left);
            }
          } else if (value > node.value) {
            if (node.right == null) {
              node.right = new Node(value);
              return;
            } else if (node.right != null) {
              return searchTree(node.right);
            }
          } else {
            return null;
          }
        }
        return searchTree(node);
      }
    },
    inorder: function() {
      if (this.root == null) {
        return null;
      } else {
        var result = new Array();
        function traverseInOrder(node) {
          if (node.left != null) {
            traverseInOrder(node.left);
          }
          result.push(node.value);
          if (node.right != null) {
            traverseInOrder(node.right);
          }
        }
        traverseInOrder(this.root);
        return result;
      }
    }
  }
);
```

## --seed-contents--

```js
var displayTree = tree => console.log(JSON.stringify(tree, null, 2));
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

function BinarySearchTree() {
  this.root = null;
  // Only change code below this line
}
```

# --solutions--

```js
// solution required
```
