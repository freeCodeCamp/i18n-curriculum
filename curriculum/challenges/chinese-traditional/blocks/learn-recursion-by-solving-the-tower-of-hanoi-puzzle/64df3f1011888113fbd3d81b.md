---
id: 64df3f1011888113fbd3d81b
title: 步驟 44
challengeType: 20
dashedName: step-44
---

# --description--

要用遞歸解決難題，首先要做的就是將原始問題分解爲更小的子問題。

通過移動可以獲得最終配置，其中 `n` 個圓盤按降序堆疊到第三根杆：

- `n - 1` 個圓盤從源到輔助杆
- 從源到目標的最大圓盤
- 然後將 `n - 1` 個圓盤從輔助杆移到目標。

因此，`move` 函數應該做的第一件事就是以 `n - 1` 作爲第一個參數調用自身。 但是如果你嘗試這樣做而不定義基本情況，那麼你將得到 `RecursionError`。 發生這種情況是因爲該函數不斷無限地調用自身。

在你的註釋和 `print()` 調用之前，添加以 `n - 1` 作爲第一個參數的遞歸函數調用，並確保僅當 `n` 大於零時才執行函數體。 現在，保持其他參數的順序不變。

# --hints--

`move` 函數主體應以 `if` 語句開頭，該語句在 `n` 大於零時觸發。

```js
({ test: () => assert.match(code, /def\s+move\(\s*n\s*,\s*source\s*,\s*auxiliary\s*,\s*target\s*\)\s*:\s+if\s+n\s*>\s*0\s*:/) })
```

你應該在 `if` 語句內調用 `move(n - 1, source, auxiliary, target)`。 記得縮進你的 `print()` 調用。

```js
const transformedCode = "\n" + code.replace(/\r/g, '');
const move = __helpers.python.getDef(transformedCode, "move");
const { function_parameters, function_body } = move;

assert.match(function_parameters, /n\s*,\s*source\s*,\s*auxiliary\s*,\s*target/);
const functionBodyIndent = function_body.match(/ +/)[0];
const re = new RegExp(`${functionBodyIndent}if\\s+n\\s*>\\s*0\\s*:\\s+^${functionBodyIndent}( +)move\\(\\s*n\\s*-\\s*1\\s*,\\s*source\\s*,\\s*auxiliary\\s*,\\s*target\\s*\\).+?^${functionBodyIndent}\\1print\\s*\\(\\s*rods\\s*,\\s*("|')\\\\n\\2\\s*\\)`, "ms");
assert.match(function_body, re);
```

# --seed--

## --seed-contents--

```py
NUMBER_OF_DISKS = 4
rods = {
    'A': list(range(NUMBER_OF_DISKS, 0, -1)),
    'B': [],
    'C': []
}

--fcc-editable-region--
def move(n, source, auxiliary, target):
    # display starting configuration
    print(rods, '\n')

--fcc-editable-region--
# initiate call from source A to target C with auxiliary B
move(NUMBER_OF_DISKS, 'A', 'B', 'C')
```
