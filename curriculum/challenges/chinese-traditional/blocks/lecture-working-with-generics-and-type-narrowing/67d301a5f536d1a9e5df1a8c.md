---
id: 67d301a5f536d1a9e5df1a8c
title: 什麼是型別縮小，且它如何運作？
challengeType: 19
dashedName: what-is-type-narrowing-and-how-does-it-work
---

# --description--

有時你會有一個廣泛型別的值，並且你需要將它縮小到更具體的型別。 例如，也許你需要確保一個物件符合你定義的介面。或者一個字串位於特定的值列表中。 有很多方法可以達成這個目的。

第一種是透過真值縮小範圍。請參考我們上一課的範例：

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

我們嘗試存取 `email` 的 `value` 屬性時會得到編譯器錯誤，因為 `email` 可能是 `null`。不過，我們可以使用條件述語來確認 `email` 為真值後再存取該屬性：

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

在這個更新的範例中，因為 `null` 不是一個真值，TypeScript 能夠推斷 `email` 在條件區塊內必須是 `input` 元素。所以它不再發出編譯器錯誤。

真值檢查也可以反向運作：

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

使用這種方法，如果 `email` 是 falsy，我們會發出錯誤。`null` 是 falsy 值。發出錯誤會結束此程式碼的邏輯執行，這表示當我們到達 `console.log()` 呼叫時，TypeScript 知道 `email` 不可能是 `null`。

選用串鏈也是一種型別縮小，前提是在 `email` 值為 `null` 時，該屬性的存取不會發生。

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

那其他型別呢？你也可以使用 `typeof` 運算子來縮小型別。讓我們來看一個我們已經顯示可能是字串或數字的變數範例：

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
console.log(myVal / 10)
```

在這個範例中，我們看到一個編譯器錯誤，因為我們無法對字串值執行算術運算。但我們可以使用條件來檢查 `myVal` 變數的 `typeof`：

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

因為我們使用了 `typeof` 關鍵字，TypeScript 現在知道 `myVal` 必須是數字，並且我們可以安全地對它進行算術運算。

但是更複雜的物件類型呢？如果該物件恰好來自某個類別，你其實可以使用 `instanceof` 關鍵字來縮小型別。回到我們的 `querySelector()` 範例：

```js
const email = document.querySelector("#email");
```

與其傳遞泛型並告訴 TypeScript 元素是什麼，我們可以使用 `instanceof` 來縮小型別並撰寫更安全的程式碼：

```js
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

這種方法看起來可能和我們之前的方法相同，但 `instanceof` 是執行期驗證－這表示，如果我們以某種方式錯誤地取得 TypeScript 型別，我們的 JavaScript 程式碼仍會確認 `email` 是一個 `input` 元素。

接下來，讓我們看一個範例，從 API 取得 `User` 物件並嘗試列印該資訊：

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json();
printAge(myUser);
```

我們嘗試將 `myUser` 傳入函式時會得到編譯器錯誤，因為即使我們知道 API 傳回正確的物件，TypeScript 並不知道。而且 `.json()` 方法不接受泛型型別。

解決此問題的「簡單」方法是轉型該型別：

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

但是每當你進行型別轉換時，實際上是在削弱 TypeScript 偵測潛在錯誤的能力。所以你可以寫一個型別守衛，而不是進行型別轉換：

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

這裡的返回類型是此函式定義的關鍵組件。`user is User` 語法顯示我們的函式傳回一個布林值，當為 `true` 時表示 `user` 值符合 `User` 介面。接著我們進行一些基本檢查以確保 `user` 物件的結構相符——注意使用了真值判斷（`!!user`）縮小範圍和 `typeof` 縮小範圍。我們必須這麼做，因為 `typeof null` 會傳回 `"object"`：

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
if (isValidUser(myUser)) {
    printAge(myUser);
}
```

現在，如果我們將所有邏輯結合在一起，就不會再出現編譯器錯誤，並且可以成功建置我們的程式碼。

型別縮小是一個強大的特性，能幫助你撰寫更安全、錯誤較少的程式碼－但請記得 `TypeScript` 的型別並非完全僵硬，因此避免像是在未縮小型別的情況下強制轉換值的型別這類做法。

# --questions--

## --text--

以下哪一項不是課程中討論的型別縮小方法？

## --answers--

真值檢查。

### --feedback--

雖然這些都可以用來縮小型別，但其中一個沒有被提到。

---

選用串鏈。

### --feedback--

雖然這些都可以用來縮小型別，但其中一個沒有被提到。

---

`typeof` 運算子。

### --feedback--

雖然這些都可以用來縮小型別，但其中一個沒有被提到。

---

Switch 述語。

## --video-solution--

4

## --text--

`user is User` 語法在型別守衛函式中的目的為何？

## --answers--

它將 `user` 參數轉換為 `User` 型別。

### --feedback--

思考字 `is`，以及片語 `user is User` 如何運作。

---

它指出該函式傳回一個布林值。

### --feedback--

思考字 `is`，以及片語 `user is` 使用者的運作方式。

---

它顯示 `user` 符合 `User` 介面。

---

它會創建一個新的 `User` 介面實體。

### --feedback--

思考字 `is`，以及片語 `user is` 使用者的運作方式。

## --video-solution--

3

## --text--

以下關於 TypeScript 中的型別轉換，哪一項是正確的？

## --answers--

這是解決型別問題的推薦方式。

### --feedback--

型別轉換應該作為最後的手段。

---

它強化了 TypeScript 捕捉錯誤的能力。

### --feedback--

型別轉換應該作為最後的手段。

---

這是使用 `as` 關鍵字完成的。

---

它應該永遠用來取代型別守衛。

### --feedback--

型別轉換應該作為最後的手段。

## --video-solution--

3
