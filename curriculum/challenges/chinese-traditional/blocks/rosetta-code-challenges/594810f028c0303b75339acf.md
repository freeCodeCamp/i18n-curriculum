---
id: 594810f028c0303b75339acf
title: 阿克曼函數（Ackermann function）
challengeType: 1
forumTopicId: 302223
dashedName: ackermann-function
---

# --description--

Ackermann 函式（程式）是一個經典的遞迴函式（程式）範例，特別值得注意的是它不是原始遞迴函式（程式）。它的數值增長非常快，呼叫樹的大小也是如此。

Ackermann 函式（程式）通常定義如下：

$A(m, n) = \\begin{cases} n+1 & \\mbox{如果 } m = 0 \\\\ A(m-1, 1) & \\mbox{如果 } m > 0 \\mbox{ 且 } n = 0 \\\\ A(m-1, A(m, n-1)) & \\mbox{如果 } m > 0 \\mbox{ 且 } n > 0. \\end{cases}$

它的引數永遠不會是負數，且它總是會終止。

# --instructions--

撰寫一個函式（程式），傳回 $A(m, n)$ 的值。建議使用任意精度（因為該函式增長非常快），但非必要。

# --hints--

`ack` 應該是一個函式（程式）。

```js
assert(typeof ack === 'function');
```

`ack(0, 0)` 應該傳回 1。

```js
assert(ack(0, 0) === 1);
```

`ack(1, 1)` 應該傳回 3。

```js
assert(ack(1, 1) === 3);
```

`ack(2, 5)` 應該傳回 13。

```js
assert(ack(2, 5) === 13);
```

`ack(3, 3)` 應該傳回 61。

```js
assert(ack(3, 3) === 61);
```

# --seed--

## --seed-contents--

```js
function ack(m, n) {

}
```

# --solutions--

```js
function ack(m, n) {
  return m === 0 ? n + 1 : ack(m - 1, n === 0 ? 1 : ack(m, n - 1));
}
```
