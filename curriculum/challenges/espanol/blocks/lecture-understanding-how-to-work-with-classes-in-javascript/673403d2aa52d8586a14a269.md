---
id: 673403d2aa52d8586a14a269
title: ¿Qué es la herencia de clases y cómo funciona?
challengeType: 19
dashedName: what-is-class-inheritance-and-how-does-it-work
---

# --interactive--

En la programación, la herencia permite definir clases que heredan propiedades y métodos de otras clases.

Por ejemplo, un `Coche` es un tipo de `Vehículo`, por lo que podrías definir una clase `Vehículo` con las propiedades y métodos más generales comunes a todos los tipos de vehículos, y luego definir una clase `Coche` que hereda las propiedades y métodos de la clase `Vehículo`.

Esta relación "es un" es característica de la herencia. En este ejemplo, `Coche` es una forma más especializada de `Vehículo`.

Hay dos conceptos principales que debes conocer para comenzar a trabajar con herencia: clase padre y clase hija.

Una clase padre es una clase que actúa como un plano para otras clases. Define propiedades y métodos que son heredados por otras clases.

Una clase hija es una clase que hereda las propiedades y métodos de otra clase. Las clases hija también pueden extender la funcionalidad de sus clases padre agregando nuevas propiedades y métodos.

En nuestro ejemplo anterior, `Vehículo` sería la clase padre de la clase `Coche` mientras que la clase `Coche` sería la clase hija de `Vehículo`.

Una clase padre puede tener múltiples clases hija.

En JavaScript, usamos la palabra clave `extends` para implementar herencia. Esta palabra clave indica que una clase es la clase hija de otra clase.

En este ejemplo, en el que solo tenemos las primeras líneas de las definiciones de clase, puedes ver que la clase `Coche` extiende la clase `Vehículo`, por lo que `Coche` hereda de `Vehículo`.

```js
class Vehicle {
  // Implementation of Vehicle...
}

class Car extends Vehicle {
  // Implementation of Car...
}
```

Digamos que la clase `Vehículo` tiene dos propiedades: `marca` y `año`. Puedes ver esto en el código actualizado.

`Coche` tiene un método llamado `tocarClaxon`. Sin embargo, observa que la clase `Coche` no tiene su propio constructor. Veamos si realmente hereda las propiedades.

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

Para definir una instancia de `Coche`, necesitarás pasar dos argumentos: `marca` y `año`. En este caso, la marca es `freeCodeCamp Motors` y el año es `2019`.

```js
let myCar = new Car("freeCodeCamp Motors", 2019);
```

Si intentas acceder a estas propiedades y llamar al método usando la notación de punto:

```js
console.log(myCar.brand);
console.log(myCar.year);
myCar.honk();
```

Aquí está el ejemplo completo:

:::interactive_editor

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}

let myCar = new Car("freeCodeCamp Motors", 2019);
console.log(myCar.brand);
console.log(myCar.year);
myCar.honk();
```

:::

De hecho, la salida es correcta, por lo que estas propiedades y método están definidos en la instancia de `Coche` y te has ahorrado mucha repetición de código al heredar estas propiedades desde la clase `Vehículo`.

En este ejemplo, la clase hija no tenía propiedades adicionales. Por eso la clase no tenía un constructor, solo un método.

Si necesitas agregar propiedades adicionales, tendrás que definir un constructor.

Veamos un ejemplo.


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

Esta vez, agregaremos una propiedad `numPuertas` a la subclase `Coche`.

Puedes ver que ahora esta clase tiene un constructor en el código actualizado. Dentro del constructor, hay una llamada a `super()`, pasando los argumentos `marca` y `año`.

`super()` invoca el constructor de la superclase, por lo que al usar `super(marca, año)` estarás definiendo esencialmente las propiedades de la superclase en la subclase. Esta es otra terminología que puedes usar: superclase es la clase padre y subclase es la clase hija.

Después, la línea `esto.numPuertas = numPuertas` define una nueva propiedad que pertenece exclusivamente a la clase `Coche`, el número de puertas (`numPuertas`).

Esta es una forma de extender la clase `Vehículo`, agregando una propiedad que es exclusiva para instancias de `Coche`.

Eso es un ejemplo de extensibilidad, una de las ventajas fundamentales de la herencia.

Ahora, si creas una instancia de la clase `Coche`, verás que tiene las tres propiedades: `marca`, `año` y `numPuertas`. También tendrás que pasar los argumentos necesarios al crear la instancia.

```js
let myCar = new Car("freeCodeCamp Motors", 2019, 4);
```

Si imprimes los valores de estas propiedades con `console.log()`:

```js
console.log(myCar.brand);
console.log(myCar.year);
console.log(myCar.numDoors);
```

Aquí está el ejemplo completo:

:::interactive_editor

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}

let myCar = new Car("freeCodeCamp Motors", 2019, 4);
console.log(myCar.brand);
console.log(myCar.year);
console.log(myCar.numDoors);
```

:::

Las principales ventajas de la herencia son la reutilización de código, la modularidad, la extensibilidad y la mejora en la estructura del código.

Al implementar una jerarquía, puedes reutilizar el código que ya escribiste para una clase padre en la clase hija, evitando repeticiones.

La herencia también promueve la modularidad al descomponer sistemas complejos en componentes más simples en la jerarquía.

Además, poder extender la funcionalidad de la clase padre facilita la adaptación a los requisitos cambiantes y agregar nuevas características más adelante en el proceso de desarrollo.

Finalmente, la estructura jerárquica puede hacer que tu código sea más fácil de entender y mantener.

Esos son los fundamentos de la herencia. Al comprender cómo funciona la herencia, puedes diseñar programas orientados a objetos bien estructurados, mantenibles y extensibles.

# --questions--

## --text--

¿Cuál es el propósito principal de la herencia en la programación orientada a objetos?

## --answers--

Para crear nuevos objetos.

### --feedback--

Piensa en cómo la herencia ayuda con la reutilización y organización del código.

---

Para definir métodos para una clase.

### --feedback--

Piensa en cómo la herencia ayuda con la reutilización y organización del código.

---

Para reutilizar el código y crear relaciones jerárquicas entre clases.

---

Para encapsular datos dentro de objetos.

### --feedback--

Piensa en cómo la herencia ayuda con la reutilización y organización del código.

## --video-solution--

3

## --text--

¿Cuál es la palabra clave utilizada para heredar de una clase padre en JavaScript?

## --answers--

`inherit`

### --feedback--

Piensa en la palabra clave que establece la relación de herencia.

---

`extends`

---

`super`

### --feedback--

Piensa en la palabra clave que establece la relación de herencia.

---

`prototype`

### --feedback--

Piensa en la palabra clave que establece la relación de herencia.

## --video-solution--

2

## --text--

¿Cuál es la diferencia entre una clase padre y una clase hija?

## --answers--

Una clase padre es una versión especializada de una clase hija.

### --feedback--

Piensa en la relación jerárquica entre clases.

---

Una clase hija es una versión especializada de una clase padre.

---

No hay diferencia entre clases padre e hija.

### --feedback--

Piensa en la relación jerárquica entre clases.

---

Las clases padre son siempre más extensas que las clases hija.

### --feedback--

Piensa en la relación jerárquica entre clases.

## --video-solution--

2
