---
id: 67d3018062fe6ba92b7d8299
title: TypeScript 中不同类型如何工作？
challengeType: 19
dashedName: how-do-the-different-types-work-in-typescript
---

# --description--

你已经在上一课中看到过一个：`string[]`，它表现为一个字串数组。但这到底是如何工作的？

对于原语数据类型 `string`、`null`、`undefined`、`number`、`boolean` 和 `bigint`，TypeScript 提供了相应的类型关键字。在我们的示例中，我们使用这些类型来注解我们的变量：

```js
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

现在，我们显式地将 `str` 声明为 `string` —— 这可能看起来有些混淆，因为我们已经为它赋值了一个字串，但这个注解确保我们不能将不同类型的值（比如数字）重新赋值给该变量。

但是数组和对象呢？你已经见过数组的语法了！你可以用两种不同的语法定义特定类型的数组：

```js
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

从根本上讲，这两种语法是相同的，选择哪一种通常是个人偏好问题。

对象变得稍微复杂一些。你可以定义对象的确切结构：

```js
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

此语法表示属性 `a` 必须始终是字串，属性 `b` 必须始终是数字，且你不能添加或删除属性。

但是也许你不想限制属性？也许你想要一个具有任意密钥的对象，但所有值都必须是字串。有两种方法可以做到这一点：

```js
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

像数组类型一样，这些本质上是相似的。对于这些对象类型，你必须定义密钥的类型和值的类型。密钥必须始终是字串，但你可以定义自定义字串类型以进一步限制这些密钥。

除了这些类型之外，TypeScript 还提供了另外四种有用的类型。第一种是 `any`，它表示一个值可以具有任何类型。这实际上是 TypeScript 的 Konami Code——它告诉编译器停止关心该变量的类型，让你随意操作。

第二个是 `unknown`，通常比 `any` 更受推荐。`unknown` 类型告诉 TypeScript 你确实关心该值的类型，但你实际上不知道它是什么。如果你随后尝试执行特定类型的操作（比如减法操作符，或使用 `slice()` 方法执行特定的字串操作），TypeScript 会要求你先缩小该值的类型。你将在即将到来的课程中学习更多关于类型缩小的内容。

第三个是 `void`。这是一种特殊的类型，你通常只在定义函数时使用。它实际上是 `any` 的相反——它表现为完全没有任何类型。没有返回值的函数，例如 `console.log()`，其返回类型为 `void`。

最后，还有 `never` 类型。这可能是你不常用的东西——它表现一种永远不会存在的类型。例如，在你的测试套件中将一个模拟对象传递给函数，可能是使用 `never` 的一个好例子，用来表示这样的对象实际上永远不会被传递给该函数。

在这些类型的基础上，你可以访问 `type` 关键字。这个关键字类似于 `const`，但你不是声明一个变量，而是声明一个类型：

```js
type myString = string;
```

这单独看起来可能没什么用，但当与并集类型结合时，它变得非常强大。并集类型允许你将两个或多个类型合并为一个。下面是一个例子：

```js
type stringOrNumber = string | number;
```

我们的 `stringOrNumber` 类型匹配字串和值为数字的值。然后你可以将你的类型与其他类型组合，比如数组：

```js
const stuff: stringOrNumber[] = ["a", 2, "c", 1000];
```

你也可以定义只包含特定值的更严格类型：

```js
type bot = "camperchan" | "camperbot" | "naomi";
type digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
```

你可以将这些类型组合起来，为一个对象创建更具体的限制：

```js
const artificialIntelligence: Record<bot, digit> = { camperchan: 5 }
```

不过，如果你需要对对象的结构有更多的控件，极有可能你会使用我们的最后一种类型：`interface`。接口实际上是类，但用于类型。它们可以实现或扩展其他接口，专门是对象类型，通常优先使用，除非你需要类型声明提供的特定特色。

```js
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

最后，函数也可以被赋予类型签名。在上一课中，你看到了如何定义特定参数的类型：

```js
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

但你也可以定义函数的返回类型。

```js
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

在这个例子中，我们告诉 TypeScript 该函数应返回一个字串。如果我们尝试返回其他任何内容，TypeScript 会提供编译器误差以提醒我们。

这涵盖了 TypeScript `type` 系统的基础知识。它相当复杂，包含许多动态部分，但通常可以将其视为镜射 JavaScript 的 `type`。

# --questions--

## --text--

以下哪项不是 TypeScript 中的原语数据类型？

## --answers--

`string`

### --feedback--

原语数据类型是 TypeScript 中最基本的数据类型。

---

`number`

### --feedback--

原语数据类型是 TypeScript 中最基本的数据类型。

---

`boolean`

### --feedback--

原语数据类型是 TypeScript 中最基本的数据类型。

---

`array`

## --video-solution--

4

## --text--

TypeScript 中 `unknown` 类型的目的是什么？

## --answers--

它允许赋值任何类型的值而不进行类型检查。

### --feedback--

与 `any` 不同，`unknown` 需要在执行特定操作之前进行类型缩小。

---

它表示你不知道 `type`，需要在使用前进行缩小。

---

它表现为完全没有任何类型。

### --feedback--

与 `any` 不同，`unknown` 需要在执行特定操作之前进行类型缩小。

---

它表现一种永远不会存在的类型。

### --feedback--

与 `any` 不同，`unknown` 需要在执行特定操作之前进行类型缩小。

## --video-solution--

2

## --text--

在 TypeScript 中，哪个关键字用于声明自定义类型？

## --answers--

`interface`

### --feedback--

此关键字用于定义对象形状的契约，而不是声明自定义类型。

---

`type`

---

`custom`

### --feedback--

这不是 TypeScript 中的有效关键字。

---

`define`

### --feedback--

这不是 TypeScript 中的有效关键字。

## --video-solution--

2
