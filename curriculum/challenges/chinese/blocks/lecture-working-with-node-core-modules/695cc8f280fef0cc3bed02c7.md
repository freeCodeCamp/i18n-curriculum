---
id: 695cc8f280fef0cc3bed02c7
title: 什么是 `Buffer` 模块及其工作原理？
challengeType: 19
dashedName: what-is-the-buffer-module-and-how-does-it-work
---

# --description--

JavaScript 最初是为在网页浏览器中运行而创建的，其主要作用是使网页具有交互性。正因为如此，早期的 JavaScript 主要集中在处理表单中的文本和操作 Document Object Model（DOM）。

但是，网络上的数据并非全部是文本。文件、图像和视频是二进制数据，需要不同的处理机制。在浏览器中，这些类型的数据通常由浏览器的特化组件处理，而不是由 JavaScript 本身处理。

现代浏览器使用渲染引擎和 JavaScript 引擎来管理这些任务——例如，Chrome 中的 Blink（配合 V8）、Safari 中的 WebKit（配合 JavaScriptCore）以及 Firefox 中的 Gecko（配合 SpiderMonkey）。

Node.js 不在浏览器中运行，因此它需要自己处理二进制数据的方式，特别是在处理文件输入和输出（I/O）以及 TCP 流时，数据以块的形式传入。这就是 `Buffer` 模块的作用。

Node.js 的 `Buffer` 模块让你可以直接处理像文件、图像或网络流这样的二进制数据。通过它，你可以直接在内存中保存和操作二进制数据。

就像 `fs` 模块一样，`Buffer` 是 Node.js 的核心模块之一，因此你无需在使用前单独安装它。

要使用它，首先通过解构导入该模块：

```js
const { Buffer } = require("buffer");
```

然后使用它提供的方法调用 `Buffer`。例如，`Buffer.from()` 允许你从字串、数组或其他未经处理的数据创建缓冲区。

以下是如何从字串和数组创建 `Buffer`：

```js
// Create a buffer from a string
const myStrBuffer = Buffer.from("freeCodeCamp");
console.log(myStrBuffer); // <Buffer 66 72 65 65 43 6f 64 65 43 61 6d 70>

// Create a buffer from an array of numbers
const myNumBuffer = Buffer.from([
  70, 82, 69, 69, 67, 79, 68, 69, 67, 65, 77, 80,
]);

console.log(myNumBuffer); // <Buffer 46 52 45 45 43 4f 44 45 43 41 4d 50>
```

虽然可以在不先导入 `Buffer` 的情况下使用该模块的一些方法，但其他方法除非你显式导入 `Buffer`，否则无法使用。因此，建议你在项目中使用 `Buffer` 时始终导入它。

你可以像访问数组一样访问单个 `buffer` 元素：

```js
console.log(myNumBuffer[0]); // 70
console.log(myStrBuffer[0]); // 102
```

你也可以对缓冲区使用 `toString()` 方法来查看它们的真实样子：

```js
console.log(myStrBuffer.toString()); // freeCodeCamp
console.log(myNumBuffer.toString()); // FREECODECAMP
```

`Buffer.alloc()` 让你创建一个指定大小（字节数）的新缓冲区。其内部的每个字节都会自动填充为 `0`：

```js
const someBuffer = Buffer.alloc(10);
console.log(someBuffer); // <Buffer 00 00 00 00 00 00 00 00 00 00>
```

你可以看到缓冲区是根据传入 `alloc()` 方法的大小用零初始化的。

你可以直接使用 `Buffer.write()` 方法写入此缓冲区：

```js
someBuffer.write("Hello fCC");

console.log(someBuffer); // <Buffer 48 65 6c 6c 6f 20 66 43 43 00>
console.log(someBuffer.toString()); // Hello fCC
```

如果你写入的数据超过缓冲区能容纳的大小，它将被截断：

```js
someBuffer.write("Hello freeCodeCamp");

console.log(someBuffer); // <Buffer 48 65 6c 6c 6f 20 66 72 65 65>
console.log(someBuffer.toString()); // Hello free
```

最后，你可以使用 `Buffer.byteLength()` 来显示以某种编码保存字串所需的字节数：

```js
console.log(Buffer.byteLength("Hello freeCodeCamp")); // 18
```

其他 `Buffer` 方法包括：

- `Buffer.isBuffer()`：查看给定的对象是否为缓冲区
- `Buffer.compare()`：比较两个缓冲区并返回它们的排序顺序
- `Buffer.concat()`：将多个缓冲区连接成一个

# --questions--

## --text--

以下哪项 **不是** Node.js `Buffer` 方法？

## --answers--

`Buffer.from()`

### --feedback--

考虑 Node.js 如何在浏览器外处理二进制 `data`。

---

`Buffer.alloc()`

### --feedback--

考虑 Node.js 如何在浏览器外处理二进制 `data`。

---

`Buffer.concat()`

### --feedback--

考虑 Node.js 如何在浏览器外处理二进制 `data`。

---

`Buffer.insert()`

## --video-solution--

4

## --text--

为什么 Node.js 提供 `Buffer` 模块？

## --answers--

为了提升浏览器中 JavaScript 的性能。

### --feedback--

考虑 Node.js 如何处理不仅仅是文本的数据。

---

使用基于二进制的 CSS 来设计网页样式。

### --feedback--

考虑 Node.js 如何处理不仅仅是文本的数据。

---

用于处理二进制 `data`，如 `files`、`images` 和 TCP `streams`。

---

将 JavaScript 代码转换为机器代码。

### --feedback--

考虑 Node.js 如何在浏览器外处理二进制 `data`。

## --video-solution--

3

## --text--

如果你写入的数据超过了缓冲区的容量，会发生什么？

## --answers--

缓冲区会自动调整大小以适应所有数据。

### --feedback--

想想在其中一个示例中 `"Hello freeCodeCamp"` 是如何变成 `"Hello free"` 的。

---

额外的数据被截断，只保存适合的数据。

---

Node.js 抛出一个误差并停止执行。

### --feedback--

想想在其中一个示例中 `"Hello freeCodeCamp"` 是如何变成 `"Hello free"` 的。

---

缓冲区会覆盖附近内存位置中的数据。

### --feedback--

想想在其中一个示例中 `"Hello freeCodeCamp"` 是如何变成 `"Hello free"` 的。

## --video-solution--

2

