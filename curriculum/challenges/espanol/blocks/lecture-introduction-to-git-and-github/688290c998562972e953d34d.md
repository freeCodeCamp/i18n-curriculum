---
id: 688290c998562972e953d34d
title: ¿Cómo creas una nueva rama para tu repositorio?
challengeType: 19
dashedName: how-do-you-create-a-new-branch-for-your-repository
---

# --description--

Ya aprendiste cómo hacer commit de los cambios y subirlos a tu repositorio remoto, pero todo eso ha sido en tu rama `main` por defecto. Eso puede funcionar para un proyecto pequeño, pero a medida que contribuyes a otros proyectos de código abierto, o a medida que tu proyecto crece, las ramas son esenciales.

Por ejemplo, si haces un fork de un repositorio y haces commits en la rama `main` de tu fork, puedes terminar con cambios en tu fork que el repositorio original no aceptó. Esto puede hacer que sea increíblemente difícil actualizar tu rama con los cambios del fork que sí fueron aceptados. O, cuando trabajas en tu propio proyecto, cambiar entre diferentes tareas se vuelve mucho más difícil si no usas ramas. En cambio, tienes que llevar un seguimiento manual de qué cambios están relacionados con qué característica o corrección.

Pero, ¿qué es exactamente una branch? Considera tu branch `main` como una autopista, donde cada commit es un coche que entra en la autopista. Puede que decidas que quieres ir a ver algo, como crear una nueva funcionalidad, así que necesitas salir de la autopista por un momento para ir a verlo.

Una rama es esencialmente una desviación de tu historial principal, donde puedes experimentar libremente con cambios para una nueva característica o una corrección de errores. Si estás satisfecho con tus cambios, puedes volver a la vía principal fusionando la rama en `main`. Si no estás satisfecho con tus cambios, puedes eliminar la rama y volver a `main` sin aceptar los cambios.

Antes de crear una nueva rama, ves tus ramas con el comando `git branch`. La salida podría verse así:

```sh
* main
```

Por ahora solo tenemos una rama, nuestra rama predeterminada `main`. El asterisco (`*`) significa que esa es la rama que tienes "checked out" actualmente. Aprenderás más sobre eso en un momento.

Puedes crear una nueva rama con el comando `git branch`, con un argumento para especificar el nombre de la nueva rama:

```sh
git branch feature
```

Esto crea una nueva rama llamada `feature`. Veamos nuestras ramas nuevamente con `git branch`:

```sh
  feature
* main
```

Ahora podemos ver nuestra nueva rama, pero todavía estamos en la rama `main`. Necesitamos cambiar a nuestra nueva rama haciendo un "checkout". Cuando haces checkout de una nueva rama, le estás diciendo a Git que cargue los archivos en el estado exacto en que estaban en ese momento.

Vamos a revisar nuestra nueva rama con:

```sh
git checkout feature
```

o

```sh
git switch feature
```

Y ejecuta `git branch` de nuevo para ver:

```sh
* feature
  main
```

Observa que el asterisco ahora se ha movido a la rama que tienes actualmente "checked out".
 
A menudo, cuando creas una nueva rama, querrás cambiar a ella de inmediato. En lugar de crear la rama y luego cambiar a ella usando dos comandos, puedes crear y cambiar a una rama en un solo comando con:

```sh
git checkout -b feature
```

o

```sh
git switch -c feature
```

Entonces, ahora hemos creado y cambiado a una nueva rama. Esta rama es una copia de la rama `main`, tiene todo el mismo código que `main` tenía en el momento en que creaste la rama. Ahora, podemos agregar cualquier código a esta rama sin afectar la rama `main`. Básicamente, nos hemos salido de la autopista para crear una característica. Si revisas tu `git status`, verás algo como esto:

```sh
On branch feature
nothing to commit, working tree clean
```

Crea un nuevo archivo `feature.md` ejecutando esto:

```sh
echo "This is our new feature" > feature.md
```

Y ahora el estado se verá así:

```sh
On branch feature
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	feature.md

nothing added to commit but untracked files present (use "git add" to track)
```

A continuación, es momento de confirmar tu nueva función. Primero, agrega el archivo al staging:

```sh
git add feature.md
```

Luego, confirma los cambios:

```sh
git commit -m "my new feature"
```

Finalmente, sube tu rama `feature` a tu repositorio:

```sh
git push -u origin feature
```

La bandera `-u` conecta tu rama local `feature` con la remota, para que futuros envíos se puedan hacer solo con `git push`.

¡A continuación, aprenderemos cómo hacer un pull request para nuestra nueva característica!

# --questions--

## --text--

¿Qué te permite hacer crear una nueva rama en Git?

## --answers--

Elimina permanentemente la rama `main`.

### --feedback--

No quieres eliminar tu rama `main`.

---

Haz cambios sin afectar la rama `main`.

---

Comparte tu código directamente con usuarios de GitHub.

### --feedback--

Compartir código implica subir ramas y posiblemente hacer pull requests.

---

Cambia la versión de Git en tu máquina local.

### --feedback--

Las ramas no cambian la versión del software Git.

## --video-solution--

2

## --text--

¿Qué indica el símbolo `*` junto al nombre de una rama en la salida de `git branch`?

## --answers--

La rama está a punto de ser eliminada.

### --feedback--

El asterisco indica que la rama está "checked out".

---

La rama es la más antigua en el repo.

### --feedback--

El asterisco indica que la rama está "checked out".

---

La rama se está enviando a GitHub.

### --feedback--

El asterisco indica que la rama está "checked out".

---

La rama está actualmente "checked out".

## --video-solution--

4

## --text--

¿Qué hace el siguiente comando?

```sh
git push -u origin feature
```

## --answers--

Elimina la rama `feature` del repositorio remoto.

### --feedback--

Este comando no elimina nada.

---

Envía la rama `feature` y la configura para rastrear la rama remota.

---

Fusiona la rama de características en `main`.

### --feedback--

La fusión es una acción separada que no se realiza con este comando.

---

Envía todas las ramas al repositorio remoto.

### --feedback--

Este comando empuja solo una rama específica.

## --video-solution--

2
