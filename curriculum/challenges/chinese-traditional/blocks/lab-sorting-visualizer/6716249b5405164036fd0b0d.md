---
id: 6716249b5405164036fd0b0d
title: 建置一個排序視覺化工具
challengeType: 25
dashedName: build-a-sorting-visualizer
demoType: onClick
---

# --description--

泡沫排序演算法透過從序列開頭開始比較相鄰元素對來排序整數序列。如果第一個元素大於第二個元素，則交換它們。接著，繼續比較下一對元素。當序列的最後一個元素被比較後，從序列開頭開始新一輪循環，並重複此過程直到元素排序完成。當一輪循環結束時沒有任何交換，演算法即停止。

在這個實驗中，你已經獲得所有的 HTML 和 CSS。你將使用 JavaScript 完成泡沫排序視覺化工具，使其能夠視覺化泡沫排序演算法排序五個整數陣列所需的每個步驟。

**目標：** 完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 你應該有一個名為 `generateElement` 的函式（程式），它會傳回介於 `1` 和 `100`（包含）之間的隨機整數。
1. 你應該有一個名為 `generateArray` 的函式（程式），該函式（程式）使用 `generateElement` 函式（程式）來傳回一個包含五個隨機整數的陣列。
1. 你應該有一個名為 `generateContainer` 的函式（程式），用來創建並傳回一個空的 `div` 元素。
1. 你應該有一個名為 `fillArrContainer` 的函式（程式），它以 HTML 元素作為第一個引數，以陣列作為第二個引數。
1. `fillArrContainer` 應該將一個元素作為第一個參數，將一個整數陣列作為第二個參數，然後用五個 `span` 元素填充該元素，每個 `span` 顯示陣列中的一個整數。
1. 你應該有一個名為 `isOrdered` 的函式（程式），它接受兩個整數並傳回一個布林值，表示第一個整數是否小於或相等於第二個整數。
1. 你應該有一個名為 `swapElements` 的函式（程式），它接受一個整數陣列和一個數字索引。
1. `swapElements` 函式（程式）應該透過交換傳入索引處的元素與下一個元素來就地修改陣列，前提是 `isOrdered` 傳回 `false`。
1. 你應該有一個名為 `highlightCurrentEls` 的函式（程式），它接受一個 HTML 元素和一個數字索引。
1. `highlightCurrentEls` 函式（程式）應該將指定元素在指定索引的子元素，以及該索引後緊接的子元素的 `border` 設為 `dashed` 樣式、`red` 顏色，並設定你選擇的寬度。
1. 當你點擊 `#generate-btn` 時，應該使用 `fillArrContainer` 函式（程式）將五個帶有隨機數文字的 `span` 元素填入 `#starting-array`。如果存在其他元素，應該從 `#array-container` 中移除。
1. 你應該實作泡沫排序演算法，使得在你點擊 `#sort-btn` 後，`#array-container` 包含一個 `div` 元素，代表泡沫排序演算法排序起始陣列所需的每個步驟，包括表述起始陣列的 `div` 和表述排序後陣列的 `div`。你目前創建的函式（程式）在這裡會很有用。
1. 每個 `div` 應該包含五個 `span` 元素，表述該陣列當前的排序狀態。
1. 在你點擊 `#sort-btn` 後，`#starting-array` 應該表述起始步驟，並將初始陣列中的前兩個整數凸顯標示。
1. 在每個排序步驟中，你應該使用 `highlightCurrentEls` 來凸顯標示正在比較的兩個數字，並在下一步使用 `swapElements` 將它們交換。

# --hints--

你應該有一個名為 `generateElement` 的函式（程式）。

```js
assert.isFunction(generateElement);
```

你的 `generateElement` 函式應該傳回介於 `1` 和 `100`（含）之間的隨機整數。

```js
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {    
    assert.strictEqual(generateElement(), 26);
    assert.strictEqual(generateElement(), 9);
} finally {
    randomMocker.restore();
}
```

你應該有一個名為 `generateArray` 的函式（程式）。

```js
assert.isFunction(generateArray)
```

你的 `generateArray` 函式（程式）應該使用 `generateElement` 函式（程式）。

```js
let flag = false;
const temp = generateElement;
generateElement = () => flag = true;
try {
    generateArray();
    assert.isTrue(flag);
} finally {
    generateElement = temp;
}
```

你的 `generateArray` 函式（程式）應該傳回一個包含 5 個介於 `1` 和 `100` 之間隨機整數的陣列。

```js
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {
    assert.deepEqual(generateArray(), [26, 9, 58, 23, 38])
} finally {
    randomMocker.restore();
}
```

你應該有一個名為 `generateContainer` 的函式（程式）。

```js
assert.isFunction(generateContainer);
```

你的 `generateContainer` 函式應該傳回一個空的 `div` 元素。

```js
const div = generateContainer();
assert.equal(div.tagName, "DIV");
assert.isEmpty(div.children);
```

你應該有一個名為 `fillArrContainer` 的函式（程式）。

```js
assert.isFunction(fillArrContainer);
```

你的 `fillArrContainer()` 應該將一個元素作為第一個參數，並將一個整數陣列作為第二個參數，然後用五個 `span` 元素填充該元素，每個 `span` 顯示陣列中的一個整數。

```js
const testDiv = document.createElement("div");
const testArr = [15, 98, 17, 5, 63]
fillArrContainer(testDiv, testArr);
const children = testDiv.children;
assert.lengthOf(children, 5);
Array.from(children).forEach((el, i) => {
    assert.equal(el.tagName, "SPAN");
    assert.equal(el.innerText.trim(), testArr[i])
})
```

你應該有一個名為 `isOrdered` 的函式（程式）。

```js
assert.isFunction(isOrdered);
```

你的 `isOrdered` 函式（程式）應該接受兩個整數，並應傳回一個布林值，表示第一個整數是否小於或相等於第二個整數。

```js
assert.lengthOf(isOrdered, 2);
assert.isTrue(isOrdered(2, 60));
assert.isFalse(isOrdered(10, 3));
assert.isTrue(isOrdered(5, 5));
```

你應該有一個名為 `swapElements` 的函式（程式）。

```js
assert.isFunction(swapElements);
```

你的 `swapElements` 函式（程式）接受一個整數陣列和一個數字索引作為引數。若第一個元素大於第二個元素，應該就地修改傳入的陣列，交換給定索引處的元素和下一個元素。

```js
const testArr = [22, 4, 87, 47, 33];
swapElements(testArr, 0);
assert.deepEqual(testArr, [4, 22, 87, 47, 33]);
swapElements(testArr, 1);
assert.deepEqual(testArr, [4, 22, 87, 47, 33]);
swapElements(testArr, 2);
assert.deepEqual(testArr, [4, 22, 47, 87, 33]);
swapElements(testArr, 3);
assert.deepEqual(testArr, [4, 22, 47, 33, 87]);
```

你應該有一個名為 `highlightCurrentEls` 的函式（程式）。

```js
assert.isFunction(highlightCurrentEls);
```

你的 `highlightCurrentEls` 函式應該為指定元素的子孫中，位於給定索引和下一個索引的元素，設定一個 `dashed`、`red` 且寬度由你選擇的邊框。

```js
const testDiv = document.createElement("div");
document.querySelector("body").appendChild(testDiv)
for (let i = 0; i < 5; i++) {
    testDiv.appendChild(document.createElement("span"));
}
const redBorderRegex = /dashed (rgb\(255,\s*0,\s*0\)|#FF0000|#F00|hsl\(0,\s*100%,\s*50%\))/;
const revertBorder = () => {
    for (const el of children) {
        el.style.border = "revert";
    }
}
const children = testDiv.children;

for (let i = 0; i < 3; i++) {
    highlightCurrentEls(testDiv, i);
    for (let j = 0; j < 5; j++) {
        let b = getComputedStyle(children[j]).border;
        if (j == i || j == i + 1) {            
            assert.match(b, redBorderRegex);
            assert.isAbove(parseFloat(b), 0);
        } else {
            assert.notMatch(b, redBorderRegex);
        }
    }
    revertBorder();
}
testDiv.remove();
```

當你點擊 `#generate-btn` 時，你應該用五個 `span` 元素填滿 `#starting-array`，每個元素的文字為介於 `1` 和 `100` 之間的隨機數。

```js
const genBtn = document.querySelector("#generate-btn");
genBtn.click();
const children = document.querySelector("#starting-array").querySelectorAll("span");
assert.lengthOf(children, 5);
Array.from(children).forEach(el => {
    assert.equal(el.tagName, "SPAN");
    const num = Number(el.innerText.trim());
    assert.isAtMost(num, 100);
    assert.isAtLeast(num, 1);
})
```

當 `#starting-array` 已經包含產生的陣列，或 `#array-container` 包含排序後的陣列時，點擊 `#generate-btn` 應該移除 `#array-container` 中的其他元素，只保留帶有新產生數字的 `#starting-array`。

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
genBtn.dispatchEvent(new Event("click"));

const prevNumbers = Array.from(document.querySelector("#starting-array").querySelectorAll("span")).map(el => Number(el.innerText.trim()));

sortBtn.dispatchEvent(new Event("click"));
genBtn.dispatchEvent(new Event("click"));

const container = document.querySelector("#array-container");
assert.lengthOf(container.children, 1);
const numbers = Array.from(document.querySelector("#starting-array").querySelectorAll("span")).map(el => Number(el.innerText.trim()));
assert.lengthOf(numbers, 5);
assert.isTrue(prevNumbers.some((num, index) => num !== numbers[index]))
```

在你點擊 `#sort-btn` 之後，`#array-container` 應該包含與泡沫排序演算法排序起始陣列所需步驟數量相同的 `div` 元素，包括表述起始陣列的 `div` 和表述已排序陣列的 `div`。

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
// using randomMocker to be sure that the starting array requires 13 steps to be sorted
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {    
    genBtn.dispatchEvent(new Event("click"));
    sortBtn.dispatchEvent(new Event("click"));
    const container = document.querySelector("#array-container");
    assert.lengthOf(container.children, 13)
    Array.from(container.children).forEach(el => {assert.equal(el.tagName, "DIV")})
} finally {
    randomMocker.restore();
}
```

當你點擊 `#sort-btn` 後，`#array-container` 中的每個 `div` 應該包含五個 `span`，每個 `span` 的文字為一個數字，並排列以表述泡沫排序演算法排序起始陣列所需的步驟。

```js
const finalArr = [9, 23, 26, 38, 58];
const arrays = [
    [26, 9, 58, 23, 38],
    [9, 26, 58, 23, 38],
    [9, 26, 58, 23, 38],
    [9, 26, 23, 58, 38],
    [9, 26, 23, 38, 58],
    [9, 26, 23, 38, 58],
    finalArr,
    finalArr,
    finalArr,
    finalArr,
    finalArr,
    finalArr,
    finalArr
]
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {    
    genBtn.dispatchEvent(new Event("click"));
    sortBtn.dispatchEvent(new Event("click"));
    const container = document.querySelector("#array-container");
    assert.isNotEmpty(container.children);
    Array.from(container.children).forEach((el, i) => {
        Array.from(el.children).forEach((j, k) => {
            assert.strictEqual(Number(j.innerText.trim()), arrays[i][k])
        })
    })
} finally {
    randomMocker.restore();
}
```

當你點擊 `#sort-btn` 時，應該使用 `highlightCurrentEls` 函式（程式）來凸顯標示每個步驟中被比較的元素。

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
let flag = false;
const temp = highlightCurrentEls;
highlightCurrentEls = () => flag = true;
try {
    genBtn.dispatchEvent(new Event("click"));
    sortBtn.dispatchEvent(new Event("click"));
    assert.isTrue(flag);
} finally {
    highlightCurrentEls = temp;
}
```

在你點擊 `#sort-btn` 後，`#starting-array` 應該表述起始步驟，並使用 `highlightCurrentEls` 凸顯標示初始陣列和前兩個整數。

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");   
genBtn.dispatchEvent(new Event("click"));
sortBtn.dispatchEvent(new Event("click"));
const firstContainer = document.querySelector("#starting-array");
const children = firstContainer.children
const redBorderRegex = /dashed (rgb\(255,\s*0,\s*0\)|#FF0000|hsl\(0,\s*100%,\s*50%\))/;
assert.match(getComputedStyle(children[0]).border, redBorderRegex);
assert.match(getComputedStyle(children[1]).border, redBorderRegex);
```

# --seed--

## --seed-contents--

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sorting Visualizer</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <main>
        <div id="array-container">
            <div id="starting-array"></div>
        </div>
        <div id="btn-container">
            <button id="generate-btn" type="button">Generate Array</button>
            <button id="sort-btn" type="button">Sort Array</button>
        </div>
    </main>
    <script src="script.js"></script>
</body>

</html>
```

```css
* {
    box-sizing: border-box;
}

main {
    height: 100vh;
    display: flex;
    justify-content: center;
    flex-direction: column;
    align-items: center;
}

#array-container {
    max-height: 95vh;
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    gap: 2px;

}

#array-container>div {
    min-width: 8rem;
    height: 2rem;
    box-shadow: rgba(50, 50, 93, 0.25) 0px 2px 5px -1px, rgba(0, 0, 0, 0.3) 0px 1px 3px -1px;
    border-radius: 10px;
    margin-bottom: 0.2rem;
    border: 2px solid darkgray;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
}

#starting-array {
    border: 4px solid darkblue !important;
}

#btn-container {
    display: flex;
    justify-content: space-around;
}

button {
    padding: 2px;
    margin: 5px;
}

span {
    border-radius: 2px;
    padding: 0.5px;
    margin: 0
}

@media (min-width: 430px) {
  #array-container>div {
    min-width: 12rem;    
  }
  span {
    padding: 1px;
    margin: 1px;
  }
}
```

```js

```

# --solutions--

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sorting Visualizer</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <main>
        <div id="array-container">
            <div id="starting-array"></div>
        </div>
        <div id="btn-container">
            <button id="generate-btn" type="button">Generate Array</button>
            <button id="sort-btn" type="button">Sort Array</button>
        </div>
    </main>
    <script src="script.js"></script>
</body>

</html>
```

```css
* {
    box-sizing: border-box;
}

main {
    height: 100vh;
    display: flex;
    justify-content: center;
    flex-direction: column;
    align-items: center;
}

#array-container {
    max-height: 95vh;
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    gap: 2px;

}

#array-container>div {
    min-width: 8rem;
    height: 2rem;
    box-shadow: rgba(50, 50, 93, 0.25) 0px 2px 5px -1px, rgba(0, 0, 0, 0.3) 0px 1px 3px -1px;
    border-radius: 10px;
    margin-bottom: 0.2rem;
    border: 2px solid darkgray;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
}

#starting-array {
    border: 4px solid darkblue !important;
}

#btn-container {
    display: flex;
    justify-content: space-around;
}

button {
    padding: 2px;
    margin: 5px;
}

#sort-btn {
   display: none 
}

span {
    border-radius: 2px;
    padding: 0.5px;
    margin: 0
}

@media (min-width: 430px) {
  #array-container>div {
    min-width: 12rem;    
  }
  span {
    padding: 1px;
    margin: 1px;
  }
}
```

```js
const arrayContainer = document.getElementById("array-container");
const generateArrayBtn = document.getElementById("generate-btn");
const sortArrayBtn = document.getElementById("sort-btn");
const arrayLength = 5;
const minVal = 1;
const maxVal = 100;
const isStart = () => arrayContainer.children.length === 1;
const clearArrayContainer = () => { arrayContainer.innerHTML = '<div id="starting-array"></div>' };
const showSortBtn = () => {sortArrayBtn.style.display = "inline-block"};
const hideSortBtn = () => {sortArrayBtn.style.display = "none"};
const generateElement = () => Math.floor(Math.random() * maxVal + minVal);
const generateArray = () => Array.from({ length: arrayLength }, generateElement);
const fillArrContainer = (container, arr) => {
    container.innerHTML = "";
    arr.forEach(i => {
        const el = document.createElement("span");
        el.innerText = i;
        el.id = `number-${i}`
        container.appendChild(el);
    })
}
const isOrdered = (el1, el2) => el1 <= el2;

const swapElements = (arr, n = 0) => {
    if (n < arr.length - 1 && !isOrdered(arr[n], arr[n + 1])) {
        const temp = arr[n];
        arr[n] = arr[n + 1];
        arr[n + 1] = temp;
    }
}
const getLastChildren = () => arrayContainer.lastElementChild;
const getLastArr = () => {
    const els = Array.from(getLastChildren().children);
    const arr = els.map(el => Number(el.id.replace("number-", "")));
    return arr;
}
const generateContainer = () => {
    const container = document.createElement("div");
    arrayContainer.appendChild(container);
    return container;
}
const highlightCurrentEls = (container, n = 0) => {
    const children = container.children;
    children[n].style.border = "2px dashed red";
    children[n + 1].style.border = "2px dashed red";
}

const highlightSorted = () => {
    getLastChildren().style.border = "4px solid green";
}

const bubbleSort = () => {
    let swapped = true;
    while (swapped) {
        const startingArr = getLastArr();
        startingArr.forEach((_, i) => {
            if (i + 1 < arrayLength) {
                highlightCurrentEls(getLastChildren(), i);
                const arr = getLastArr();
                swapElements(arr, i);
                fillArrContainer(generateContainer(), arr);
            }
        })
        const lastArr = getLastArr()
        if (startingArr.every((el, i) => el === lastArr[i])) swapped = false;
    }
}


generateArrayBtn.addEventListener("click", () => {
    if (!isStart()) {
        clearArrayContainer();
    }
    fillArrContainer(document.getElementById("starting-array"), generateArray());
    showSortBtn();
});

sortArrayBtn.addEventListener("click", () => {
    bubbleSort();
    highlightSorted();
    hideSortBtn();
})
```

