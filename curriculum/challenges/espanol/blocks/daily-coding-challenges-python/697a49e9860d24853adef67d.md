---
id: 697a49e9860d24853adef67d
title: "Desafío 192: Juegos de Invierno 2026 Día 13: Combinada Nórdica"
challengeType: 29
dashedName: challenge-192
---

# --description--

Dado un arreglo de puntuaciones de salto para atletas, calcula sus tiempos de retraso de inicio para la parte de campo a través del Combinado Nórdico.

El atleta con la puntuación de salto más alta comienza primero (0 segundos de retraso). Todos los demás atletas comienzan más tarde según la diferencia de su puntuación de salto con respecto al mejor salto.

Para calcular el retraso de cada atleta, resta la puntuación de salto del atleta a la mejor puntuación de salto general y multiplica el resultado por 1.5. Redondea el retraso hacia arriba al entero más cercano.

# --hints--

`calculate_start_delays([120, 110, 125])` debería devolver `[8, 23, 0]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(calculate_start_delays([120, 110, 125]), [8, 23, 0])`)
}})
```

`calculate_start_delays([118, 125, 122, 120])` debería devolver `[11, 0, 5, 8]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(calculate_start_delays([118, 125, 122, 120]), [11, 0, 5, 8])`)
}})
```

`calculate_start_delays([100, 105, 95, 110, 120, 115, 108])` debería devolver `[30, 23, 38, 15, 0, 8, 18]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(calculate_start_delays([100, 105, 95, 110, 120, 115, 108]), [30, 23, 38, 15, 0, 8, 18])`)
}})
```

`calculate_start_delays([130, 125, 128, 120, 118, 122, 127, 115, 132, 124])` debería devolver `[3, 11, 6, 18, 21, 15, 8, 26, 0, 12]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(calculate_start_delays([130, 125, 128, 120, 118, 122, 127, 115, 132, 124]), [3, 11, 6, 18, 21, 15, 8, 26, 0, 12])`)
}})
```

# --seed--

## --seed-contents--

```py
def calculate_start_delays(jump_scores):

    return jump_scores
```

# --solutions--

```py
import math
def calculate_start_delays(jump_scores):
    best_jump = max(jump_scores)
    return [math.ceil((best_jump - score) * 1.5) for score in jump_scores]
```
