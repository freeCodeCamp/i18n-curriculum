---
id: 6639fdcc701833a54c364211
title: Paso 17
challengeType: 20
dashedName: step-17
---

# --description--

Después de validar los coeficientes, necesitas almacenarlos en un atributo de instancia. Usa una comprensión de diccionario para crear un diccionario en el que la clave sea el grado del coeficiente y el valor correspondiente sea el coeficiente, y asígnalo a un atributo llamado `coefficients`.

Por ejemplo; un objeto `LinearEquation` instanciado con `2` y `4` debe tener los siguientes atributos en `coefficients`: `{1: 2, 0: 4}`, porque `2` corresponde al primer grado de `x` y `4` corresponde al grado de cero de `x`.

Crea los pares clave-valor en tu nuevo diccionario siguiendo el mismo orden que en `args`.

# --hints--

Debes declarar un atributo llamado `coefficients` dentro de tu método `__init__`.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("__init__").has_variable("self.coefficients")`)) })
```

Debes usar una comprensión de diccionario para almacenar tus coeficientes.

```js
({ test: () => runPython(`
import ast
node = _Node(_code).find_class("Equation").find_function("__init__").find_variable("self.coefficients")
assert isinstance(node.tree.value, ast.DictComp)
`) })
```

Tu atributo `coefficients` debe ser un diccionario que contenga pares clave-valor en la forma grado-coeficiente. Recuerda seguir el mismo orden en el que los coeficientes se almacenan dentro de `args`.

```js
({ test: () => runPython(`
actual1 = list(LinearEquation(1, 6).coefficients.items())
expected1 = list({1: 1, 0: 6}.items())
actual2 = list(LinearEquation(-3.5, 0).coefficients.items())
expected2 = list({1: -3.5, 0: 0}.items())
assert actual1 == expected1
assert actual2 == expected2
`) })
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod

class Equation(ABC):
    degree: int
    
    def __init__(self, *args):
        if (self.degree + 1) != len(args):
            raise TypeError(
                f"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given"
            )
        if any(not isinstance(arg, (int, float)) for arg in args):
            raise TypeError("Coefficients must be of type 'int' or 'float'")
        if args[0] == 0:
            raise ValueError("Highest degree coefficient must be different from zero")
--fcc-editable-region--
        
--fcc-editable-region--
    def __init_subclass__(cls):
        if not hasattr(cls, "degree"):
            raise AttributeError(
                f"Cannot create '{cls.__name__}' class: missing required attribute 'degree'"
            )
    
    @abstractmethod
    def solve(self):
        pass
        
    @abstractmethod
    def analyze(self):
        pass
        
class LinearEquation(Equation):
    degree = 1
    
    def solve(self):
        pass
    
    def analyze(self):
        pass

    
lin_eq = LinearEquation(2, 3)
```
