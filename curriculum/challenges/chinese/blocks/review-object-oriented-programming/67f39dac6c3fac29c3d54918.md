---
id: 67f39dac6c3fac29c3d54918
title: 面向对象编程回顾
challengeType: 31
dashedName: review-object-oriented-programming
---

# --description--

## 什么是面向对象编程？

- **面向对象编程**：一种编程风格，开发者将代码中的所有内容视为现实世界中的对象。它通常被称为 OOP。帮助你有效组织和管理代码的四个关键原则是 **封装**、**继承**、**多态** 和 **抽象**。
- **类**：用于创建对象的蓝图。每个由类创建的对象都有定义数据的属性和决定对象行为的方法。

## 什么是封装？

- **封装**：将对象的属性和方法捆绑成一个单一单元。它允许你通过一组简单的公共方法和属性隐藏对象的内部状态，这些方法和属性就像门一样。在这些门后面是私有属性和方法，它们控制数据如何变化以及谁可以查看数据。
- **封装示例**：如果你想跟踪钱包余额，你会允许存款和取款，但你不会希望任何人篡改钱包余额本身：

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

- **单下划线和双下划线前缀属性的区别**：为属性和方法添加单下划线前缀意味着它们是供内部使用的。这是一种约定，并不强制禁止从外部访问属性。为属性和方法添加双下划线前缀则有效地阻止了它们被类外部访问。

## 什么是 Getter 和 Setter？

- **Getter 和 Setter**：允许你控制如何访问和修改类的属性的方法。你使用 getter 来获取值，使用 setter 来设置值。
- **属性**：它们连接 getter 和 setter，并允许访问数据。当你获取、设置或删除值时，它们会在后台运行额外的逻辑。
- **为什么使用属性而不是方法**：属性用于替代方法，以提高可读性和使代码更简洁。它们允许你像访问普通属性一样使用点符号访问值，而无需使用括号。
- **创建 Getter**：要创建 getter，你使用 `@property` 装饰器。下面是一个获取圆半径的 getter：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

- **创建 Setter**：要创建设置半径的 setter，你必须定义另一个同名的方法，并在其上方使用 `@<property_name>.setter`：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

- **Python 如何处理 getter 和 setter**：一旦你定义了 getter 和 setter，Python 会在你以这种方式使用普通属性语法时自动在后台调用它们：

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

 设置值时，你不应将值赋值给属性名本身，因为那会导致 `RecursionError`。使用一个单独的内部名称，通常带有下划线，来保存该值。

- **删除器**：在使用 setter 和 getter 设置和获取值之后，你可以使用 `deleter` 控制它如何被删除。当你对属性使用 `del` 语句时，删除器会运行自定义逻辑。要创建删除器，你需要使用 `@<property_name>.deleter` 装饰器。

```py
  # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

## 什么是继承以及它如何促进代码重用？

- **继承**：子类使用父类的属性和方法的过程。继承促进代码重用，提供清晰的层次结构，并且无需重写所有内容即可自定义行为。要实现继承，子类需要接受父类的名称：

```py
class Parent:
    # Parent attributes and methods

class Child(Parent):
    # Child inherits, extends, and/or overrides where necessary
```

- **单继承和多继承**：当一个子类从单个父类继承属性和方法时，如上所示，该过程称为**单继承**。当一个子类从多个父类继承属性和方法时，这就是**多继承**。以下是其语法：

```py
class Parent:
    # Attributes and methods for Parent

class Child:
    # Attributes and methods for Child

class GrandChild(Parent, Child):
    # GrandChild inherits from both Parent and Child
    # GrandChild can combine or override behavior from each
```

- **`super()` 函数**：一个允许你在子类中覆写父类方法的函数。

## 什么是多态以及它如何促进代码重用？

- **多态**：面向对象编程的原则，允许不同的类使用相同的方法名，但每个类在被调用时以不同的方式实现它。以下是它的语法：

```py
class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # Works for A, B, or C
```

- **基于继承的多态**：父类设置一个方法，每个子类根据自己的需要进行调整。

## 什么是 Name Mangling 及其工作原理？

- **名称重整**：Python 内部通过添加下划线和类名作为前缀，将以双下划线开头的属性重命名的过程，将 `__attribute` 转换为 `_ClassName__attribute`。
- **名称改编的目的**：名称改编的主要目的是防止在使用继承时意外覆盖属性和方法。下面的代码可以让这一点更易理解：

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

## 什么是抽象以及它如何帮助保持复杂系统的有序？

- **抽象**：一种编程概念，其中隐藏对象或系统的复杂实现细节，仅显示必要的特色。在 Python 和其他编程语言中，抽象通过提高可重用性简化复杂系统。
- **抽象的示例**：生活中抽象的一个好例子是汽车让你只需使用方向盘、踏板和换挡杆，而无需了解发动机或刹车的工作原理。
- **Python 如何实现抽象**：Python 通过 `abc` 模块实现抽象。该模块提供了 `ABC` 类（抽象基类）和 `@abstractmethod` 装饰器。抽象基类（ABC）定义了子类必须实现的公共方法和属性。它不能被实例化。
- **抽象方法如何定义**：抽象方法使用 `@abstractmethod` 定义，且必须在子类中重写，即使它有默认实现。抽象的基本语法如下：

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

# --assignment--

复习面向对象编程的主题和概念。
