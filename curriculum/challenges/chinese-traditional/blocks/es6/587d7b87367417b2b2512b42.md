---
id: 587d7b87367417b2b2512b42
title: 變異使用 const 宣告的陣列
challengeType: 1
forumTopicId: 301206
dashedName: mutate-an-array-declared-with-const
---

# --description--

如果你不熟悉 `const`，請參考<a href="/learn/javascript-algorithms-and-data-structures/basic-javascript/declare-a-read-only-variable-with-the-const-keyword" target="_blank" rel="noopener noreferrer nofollow">這個關於 <code>const</code> 關鍵字的挑戰</a>。

`const` 宣告在現代 JavaScript 中有許多使用案例。

有些開發者預設會使用 `const` 指定所有變數，除非他們知道需要重新指定該值。只有在那種情況下，他們才會使用 `let`。

然而，重要的是要了解，使用 `const` 指派給變數的物件（包括陣列和函式）仍然是可變的。使用 `const` 宣告式只會防止變數識別符的重新指派。

```js
const s = [5, 6, 7];
s = [1, 2, 3];
s[2] = 45;
console.log(s);
```

`s = [1, 2, 3]` 會導致錯誤。在註解掉該行之後，`console.log` 會顯示值 `[5, 6, 45]`。

如你所見，你可以變更物件 `[5, 6, 7]` 本身，而變數 `s` 仍會指向已更改的陣列 `[5, 6, 45]`。像所有陣列一樣，`s` 中的陣列元素是可變的，但因為使用了 `const`，你無法使用變數識別符號 `s` 透過指定運算子指向不同的陣列。

# --instructions--

陣列宣告為 `const s = [5, 7, 2]`。使用各種元素指派將陣列改為 `[2, 5, 7]`。

# --hints--

你不應該取代 `const` 關鍵字。

```js
assert(__helpers.removeJSComments(code).match(/const/g));
```

`s` 應該是常數變數（透過使用 `const`）。

```js
assert(__helpers.removeJSComments(code).match(/const\s+s/g));
```

你不應該更改原始的陣列宣告。

```js
assert(__helpers.removeJSComments(code).match(
/const\s+s\s*=\s*\[\s*5\s*,\s*7\s*,\s*2\s*\]\s*;?/g
));
```

`s` 應該相等於 `[2, 5, 7]`。

```js
assert.deepEqual(s, [2, 5, 7]);
```

# --seed--

## --seed-contents--

```js
const s = [5, 7, 2];
function editInPlace() {
  // Only change code below this line

  // Using s = [2, 5, 7] would be invalid

  // Only change code above this line
}
editInPlace();
```

# --solutions--

```js
const s = [5, 7, 2];
function editInPlace() {
  s[0] = 2;
  s[1] = 5;
  s[2] = 7;
}
editInPlace();
```
