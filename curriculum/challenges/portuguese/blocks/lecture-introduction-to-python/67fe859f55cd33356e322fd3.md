---
id: 67fe859f55cd33356e322fd3
title: Como as Funções Funcionam em Python?
challengeType: 19
dashedName: how-do-functions-work-in-python
---

# --description--

Funções são trechos reutilizáveis de código que são executados quando você as chama. Muitas linguagens de programação vêm com funções embutidas que facilitam o início.  Python is no exception, and we've already covered some built-in functions like `print()` in previous lessons.

Outra função interna útil é `input()`, que permite solicitar uma entrada do usuário:

```python
name = input('What is your name?') # User types "Kolade" and presses Enter  
print('Hello', name) # Output: Hello Kolade
```

Por outro lado, `int()` converte um número, booleano e uma string numérica em um inteiro:

```python
print(int(3.14)) # 3
print(int('42')) # 42
print(int(True)) # 1
print(int(False)) # 0 
```

Você também pode escrever suas próprias funções customizadas. Para fazer isso, você usa a palavra-chave `def`, seguida do nome que deseja dar à sua função, um par de parênteses e dois pontos. Então, em uma nova linha, você escreve o código que sua função deve executar. O código que a função executa também é chamado de corpo da função.

Aqui está um exemplo de uma função personalizada chamada `hello` que imprime a string `Hello World` no terminal:

```python
def hello():
    print('Hello World')
```

Para executar a função, você precisa chamá-la pelo nome seguido de um par de parênteses:

```python
hello() # Hello World
```

Note a indentação antes de `print('Hello World')`. O nível de indentação define um "bloco de código" em Python, que é um grupo de instruções que pertencem juntas.

Enquanto outras linguagens de programação usam caracteres como chaves para definir blocos de código e usam apenas indentação para legibilidade, em Python, os blocos de código são determinados pela indentação.

Embora você possa usar dois ou quatro espaços para determinar cada nível de indentação, o guia de estilo do Python recomenda usar quatro espaços.

Blocos também são encontrados em loops e condicionais, que você aprenderá nas próximas lições.

Aqui está outra função simples que imprime a soma de dois números no terminal:

```python
def calculate_sum(a, b):
    print(a + b)
```

Você pode ver que nossa função, `calculate_sum`, tem `a` e `b` em seus parênteses, separados por uma vírgula. Esses são chamados de parâmetros. Pense nos parâmetros como variáveis substitutas que funcionam como "espaços" para os valores que você passa para as funções quando as chama.

Para usar os parâmetros, você precisa passar "arguments". Argumentos são os valores que você passa para uma função quando a chama.

Aqui está como chamar a função `calculate_sum` para somar os números `3` e `1`:

```python
calculate_sum(3, 1) # 4
```

Se você chamar a função sem o número correto de argumentos, você receberá um `TypeError`:

```python
calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'
```

Funções também usam uma palavra-chave especial `return` para sair da função e retornar um valor. Se você não usar explicitamente `return`, o Python retornará `None` por padrão.

Aqui está um exemplo:

```python
def calculate_sum(a, b):
    print(a + b)

my_sum = calculate_sum(3, 1) # 4
print(my_sum) # None
```

Você pode ver que a função `calculate_sum` imprime a soma de `a` e `b`, mas não retorna nada explicitamente. Então, quando atribuímos seu resultado a `my_sum`, o valor é na verdade `None`. Para corrigir isso, você pode usar a palavra-chave `return` para enviar de volta o resultado:

```python
def calculate_sum(a, b):
    return a + b

my_sum = calculate_sum(3, 1)
print(my_sum) # 4
```

Agora, `calculate_sum` retorna a soma de `a` e `b`, que é armazenada em `my_sum`.

Decorators são um tipo especial de função em Python. Eles são como invólucros para outras funções, então eles recebem outra função como argumento. Com decorators, você pode adicionar funcionalidades extras a uma função sem modificar seu código original. Aqui está um exemplo de como usar um decorator:

```python
def say_hello():
   name = input('What is your name? ')
   return 'Hello ' + name

def uppercase_decorator(func):
   def wrapper():
       original_func = func()
       modified_func = original_func.upper()
       return modified_func
   return wrapper

say_hello_res = uppercase_decorator(say_hello)

print(say_hello_res())
```

Neste código:

- Estamos recebendo uma entrada do usuário e armazenando-a na variável `name`.
    
- A função `say_hello` retorna `Hello` e o `name`.
    
- O decorator, `uppercase_decorator` recebe uma função, a chama, depois transforma seu valor de retorno em maiúsculas e retorna a função original.
    
- A função `uppercase_decorator` é então chamada com a função original `say_hello` e salva em `say_hello_res`.
    
- `say_hello_res` é então chamado e impresso em uma linha.
    

É assim que os decorators são tipicamente usados.

# --questions--

## --text--

Qual é o valor de retorno padrão de uma função em Python?

## --answers--

`0`

### --feedback--

Se uma função não tem uma declaração `return`, ela automaticamente retorna esse valor.

---

`None`

---

""

### --feedback--

Se uma função não tem uma declaração `return`, ela automaticamente retorna esse valor.

---

`False`

### --feedback--

Se uma função não tem uma declaração `return`, ela automaticamente retorna esse valor.

## --video-solution--

2

## --text--

Qual é o termo para uma variável placeholder em uma função?

## --answers--

Parâmetro

---

Argumento

### --feedback--

É definido na declaração da função, não quando ela é chamada.

---

Valor de retorno

### --feedback--

É definido na declaração da função, não quando ela é chamada.

---

Decorador

### --feedback--

É definido na declaração da função, não quando ela é chamada.

## --video-solution--

1

## --text--

Qual é o propósito dos decorators em Python?

## --answers--

Eles modificam diretamente o código original de uma função para adicionar funcionalidade extra.

### --feedback--

Decorators agem como invólucros ao redor de funções.

---

Eles convertem uma função em uma classe para melhor organização.

### --feedback--

Decorators agem como invólucros ao redor de funções.

---

Eles permitem que funções sejam executadas apenas uma vez quando definidas.

### --feedback--

Decorators agem como invólucros ao redor de funções.

---

Eles envolvem outra função para estender seu comportamento sem modificar o código original.

## --video-solution--

4
