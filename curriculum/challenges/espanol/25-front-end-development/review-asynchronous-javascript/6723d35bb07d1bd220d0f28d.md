---
id: 6723d35bb07d1bd220d0f28d
title: Revisión de JavaScript Asíncrono
challengeType: 24
dashedName: review-asynchronous-javascript
---

# --description--

- **JavaScript Síncrono** se ejecuta secuencialmente y espera a que la operación anterior termine antes de pasar a la siguiente.
- **JavaScript Asíncrono** permite que varias operaciones se ejecuten en segundo plano sin bloquear el hilo principal.
- **Hilo** es una secuencia de instrucciones que pueden ejecutarse independientemente del flujo principal del programa.
- **Funciones de devolución de llamada** son funciones que se pasan como argumentos a otras funciones y se ejecutan después de que la operación se complete o como resultado de un evento.

## El motor de JavaScript y el tiempo de ejecución de JavaScript

- El **motor de JavaScript** es un programa que ejecuta código JavaScript en un navegador web. Funciona como un convertidor que toma tu código, lo convierte en instrucciones que la computadora puede entender y actuar en consecuencia.
- V8 es un ejemplo de un motor de JavaScript desarrollado por Google.
- El **tiempo de ejecución de JavaScript** es el entorno en el que se ejecuta el código JavaScript. Incluye el motor de JavaScript que procesa y ejecuta el código, y características adicionales como un navegador web o Node.js.

## La API Fetch

- La API Fetch permite a las aplicaciones web realizar requests de red, típicamente para recuperar o enviar datos al servidor. Proporciona un método `fetch()` que puedes usar para realizar estas requests.
- Puedes recuperar texto, imágenes, audio, JSON y otros tipos de datos usando la API Fetch.

## Métodos HTTP para la API Fetch

La API Fetch soporta varios métodos HTTP para interactuar con el servidor. Los métodos más comunes son:

- **GET**: Se utiliza para recuperar datos del servidor. Por defecto, la API Fetch utiliza el método `GET` para recuperar datos.

```js
fetch('https://api.example.com/data')
```

Para utilizar los datos obtenidos, es necesario convertirlos al formato JSON usando el método `.json()`:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

En este código, la respuesta que proviene de la API Fetch es una promesa y el manejador `.then` está convirtiendo la respuesta a un formato JSON.

- **POST**: Se utiliza para enviar datos al servidor. El método `POST` se utiliza para crear nuevos recursos en el servidor.

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

En este ejemplo, estamos enviando una request `POST` para crear un nuevo usuario. Hemos especificado el método como `POST`, establecido los encabezados apropiados y hemos incluido un cuerpo con los datos que queremos enviar. El cuerpo necesita ser una cadena, por lo que usamos `JSON.stringify()` para convertir nuestro objeto a una cadena JSON.

- **PUT**: Se utiliza para actualizar datos en el servidor. El método `PUT` se usa para actualizar recursos existentes en el servidor.

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

En este ejemplo, estamos actualizando el ID `45` que se especifica al final del URL. Hemos usado el método `PUT` en el código y también hemos especificado los datos como el cuerpo que se usará para actualizar los datos identificados.

- **DELETE**: Se usa para eliminar datos en el servidor. El método `DELETE` se utiliza para eliminar recursos en el servidor.

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

En este ejemplo, estamos enviando una request `DELETE` para eliminar un usuario con el ID `45`.

## Promesa y encadenamiento de promesas

- Las **promesas** son objetos que representan la finalización o el fallo eventual de una operación asincrónica y su valor resultante. El valor de la promesa es conocido solo cuando la operación `async` se completa.
- Aquí tienes un ejemplo para crear una promesa simple:

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- El método `.then()` se utiliza en una promesa para especificar qué debería suceder cuando la promesa se cumple, mientras que `.catch()` se usa para manejar cualquier error que ocurra.
- Aquí hay un ejemplo del uso de `.then()` y `.catch()` con una promesa:

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

En el ejemplo anterior, el método `.then()` se usa para imprimir los datos recibidos de la promesa, mientras que el método `.catch()` se usa para imprimir cualquier error que ocurra.

- **Encadenamiento de promesas**: Una de las características poderosas de las promesas es que podemos encadenar múltiples operaciones asincrónicas juntas. Cada `.then()` puede devolver una nueva promesa, lo que te permite realizar una secuencia de operaciones asincrónicas una tras otra.
- Aquí tienes un ejemplo de encadenamiento de promesas:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

En el ejemplo anterior, primero obtenemos datos de una URL, luego obtenemos datos de otra URL en base a la primera respuesta, y finalmente imprimimos los segundos datos recibidos.

El método `catch` manejaría cualquier error que ocurra durante el proceso. Esto significa que no necesitas agregar manejo de errores a cada paso, lo que puede simplificar en gran medida tu código.

## Uso de `async/await` para manejar promesas

Async/await facilita la escritura y lectura de código asincrónico, el cual se basa en promesas.

- **async**: La palabra clave `async` se usa para definir una función asincrónica. Una función `async` devuelve una promesa, la cual se resuelve con el valor devuelto por la función `async`.
- **await**: La palabra clave `await` se utiliza dentro de una función `async` para pausar la ejecución de la función hasta que la promesa se resuelva. Solo puede usarse dentro de una función `async`.
- Aquí tienes un ejemplo de uso de `async/await`:

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

En el ejemplo anterior, la función `delayedGreeting` es una función `async` que se pausa durante 2 segundos antes de imprimir el mensaje de saludo. La palabra clave `await` se usa para pausar la ejecución de la función hasta que la `Promise` se resuelva.

- Una de las mayores ventajas de `async/await` es el manejo de errores a través de bloques `try/catch`. Aquí tienes un ejemplo:

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

En el ejemplo anterior, el bloque `try` contiene el código que podría generar un error, y el bloque `catch` maneja el error si ocurre. Esto hace que el manejo de errores sea más simple y legible.

## El atributo `async`

- El atributo `async` le dice al navegador que descargue el archivo de script de manera asíncrona mientras continúa analizando el documento HTML.
- Una vez que el script se descarga, el análisis HTML se pausa, el script se ejecuta y luego se reanuda el análisis HTML.
- Deberías usar `async` para scripts independientes donde el orden de ejecución no importe.

## El atributo `defer`

- El atributo `defer` también descarga el script de forma asíncrona, pero difiere la ejecución del script hasta que el documento HTML haya sido completamente analizado.
- Los scripts diferidos mantienen el orden de ejecución como aparecen en el documento HTML.

- Es importante observar que tanto los atributos `async` como `defer` se ignoran para scripts internos y solo funcionan para archivos de script externos.

- Cuando ambos atributos, `async` y `defer`, están presentes, el atributo `async` tiene precedencia.

## API de Geolocalización

- La API de Geolocalización proporciona una manera para que los sitios web soliciten la ubicación del usuario.

- El ejemplo de abajo demuestra el uso del método `getCurrentPosition()` de la API, el cual se utiliza para obtener la ubicación actual del usuario.

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

En este código, estamos llamando a `getCurrentPosition` y pasándole una función que se llamará cuando se obtenga exitosamente la posición.

El objeto `position` contiene una variedad de información, pero aquí hemos seleccionado solo `latitud` y `longitud`.

Si hay un problema al obtener la `posición`, entonces el error se registrará en la consola.

- Es importante respetar la privacidad del usuario y solicitar su ubicación solo cuando sea necesario.

# --assignment--

Revisa los temas y conceptos de JavaScript Asíncrono.
