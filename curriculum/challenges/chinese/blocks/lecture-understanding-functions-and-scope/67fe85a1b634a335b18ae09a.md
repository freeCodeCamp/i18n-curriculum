---
id: 67fe85a1b634a335b18ae09a
title: Python 中的作用域是什么及其如何工作？
challengeType: 19
dashedName: what-is-scope-in-python-and-how-does-it-work
---

# --description--

在 Python 中，作用域决定了你可以访问变量的点。它控制变量的生命期以及变量在代码不同部分的解析方式。

为了正确确定作用域，Python 遵循 **LEGB** 规则，该规则代表以下内容：

- **局部作用域 (L)**：在函数或类中定义的变量。
    
- **封闭作用域 (E)**：定义在封闭或嵌套函数中的变量。
    
- **全局作用域 (G)：** 在模块或文件顶层定义的变量。
    
- **内置作用域 (B)**：Python 中为预定义函数、模块、关键字和对象保留的名称。

Python 使用 LEGB 规则来解析你程序中变量的作用域。我们将深入探讨这些规则中的每一条，以便你更好地理解这个进程。

**局部作用域** 意味着在函数或类内部声明的变量只能在该函数或类内部访问。

这是一个示例：

```python
def my_func():
    my_var = 10
    print(my_var)
```

在这种分支中，`my_func` 函数有它自己的作用域，外部无法访问该作用域。调用 `my_func` 会输出 `10`，但在函数外打印 `my_var` 会导致 `NameError`：

```python
def my_func():
    my_var = 10 # Locally scoped to my_func
    print(my_var)

my_func() # 10

print(my_var) # NameError: name 'my_var' is not defined
```

**封闭作用域** 意味着嵌套在另一个函数内部的函数可以访问它所嵌套的函数的变量。

例如：

```python
def outer_func():
    msg = 'Hello there!'

    def inner_func():
        print(msg)

    inner_func()

outer_func() # Hello there!
```

在此示例中，内部函数 `inner_func` 可以自由访问在外部函数 `outer_func` 中定义的 `msg` 变量。然而，请注意外部函数无法访问在任何嵌套函数中定义的变量：

```python
def outer_func():
    msg = 'Hello there!'
    print(res)

    def inner_func():
        res = 'How are you?'
        print(msg)

    inner_func()

outer_func() # NameError: name 'res' is not defined
```

这是因为 `res` 是局部作用域于 `inner_func` 的。另外，注意 `outer_func` 试图在调用 `inner_func` 之前打印 `res`。

一种方案是在包含的作用域中，即 `outer_func` 内，将 `res` 初始化为空字串。然后在 `inner_func` 中，使用 `nonlocal` 关键字将 `res` 设为非局部变量：

```python
def outer_func():
    msg = 'Hello there!'
    res = ""  # Declare res in the enclosing scope

    def inner_func():
        nonlocal res  # Allow modification of an enclosing variable
        res = 'How are you?'
        print(msg)  # Accessing msg from outer_func()

    inner_func()
    print(res)  # Now res is accessible and modified

outer_func()

# Output:
# Hello there!
# How are you?
```

**全局作用域** 指的是声明在任何函数或类之外的变量，这些变量可以在程序的任何地方访问。这里，`my_var` 可以在任何地方访问，即使是在它未定义的函数内部：

```python
my_var = 100

def show_var():
    print(my_var)

show_var() # 100
print(my_var) # 100
```

如果你想让在函数内部定义的局部作用域变量可以全局访问，你可以使用 `global` 关键字：

```python
my_var_1 = 7

def show_vars():
    global my_var_2
    my_var_2 = 10
    print(my_var_1)
    print(my_var_2)

show_vars() # 7 10

# my_var_2 is now a global variable and can be accessed anywhere in the program
print(my_var_2) # 10
```

你也可以使用 `global` 关键字来修改全局的变量：

```python
my_var = 10  # A global variable

def change_var():
    global my_var  # Allows modification of a global variable
    my_var = 20

change_var()

print(my_var)  # my_var is now modified globally to 20
```

最后，**内置作用域**指的是 Python 的所有内置函数、模块和关键字，并且在你的程序中的任何地方都可用：

```python
print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False
```

# --questions--

## --text--

Python 遵循什么规则来确定变量的作用域？

## --answers--

栈：静态、临时、活动、常量、关键字

### --feedback--

它由四个级别组成，从最具体到最通用。

---

树：临时，保留，封闭，外部

### --feedback--

它由四个级别组成，从最具体到最通用。

---

LEGB：局部的、封闭的、全局的、内置

---

作用域：脚本、常量、外部、Python、嵌入式

### --feedback--

它由四个级别组成，从最具体到最通用。

## --video-solution--

3

## --text--

`nonlocal` 关键字有什么作用？

## --answers--

使变量变为全局的。

### --feedback--

它有助于修改外部函数中的变量。

---

创建一个新的局部变量。

### --feedback--

它有助于修改外部函数中的变量。

---

防止变量重新赋值。

### --feedback--

它有助于修改外部函数中的变量。

---

允许修改封闭函数中的变量

## --video-solution--

4

## --text--

在 Python 中，你可以使用哪个关键字来修改一个全局的变量？

## --answers--

`global`

---

`local`

### --feedback--

它允许在函数外部更改变量。

---

`static`

### --feedback--

它允许在函数外部更改变量。

---

`nonlocal`

### --feedback--

它允许在函数外部更改变量。

## --video-solution--

1
