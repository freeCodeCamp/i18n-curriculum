---
id: 594810f028c0303b75339ad5
title: Y 組合子
challengeType: 1
forumTopicId: 302345
dashedName: y-combinator
---

# --description--

在嚴格的 <a href="https://www.freecodecamp.org/news/the-principles-of-functional-programming/" target="_blank" rel="noopener noreferrer nofollow">函式式程式設計</a> 和 lambda 演算中，函式（lambda 表達式）沒有狀態，且只允許取用封閉函式的引數。這排除了通常遞迴函式的定義，其中函式與變數的狀態相關，且該變數的狀態會用在函式主體中。

Y 組合子本身是一個無狀態的函式，當它套用到另一個無狀態的函式時，會傳回該函式的遞迴版本。Y 組合子是這類函式中最簡單的，稱為不動點組合子。

# --instructions--

定義無狀態的 Y 組合子函式，並使用它來計算階乘。`factorial(N)` 函式已經提供給你。 

# --hints--

Y 應該傳回一個函式（程式）。

```js
assert.equal(typeof Y((f) => (n) => n), 'function');
```

factorial(1) 應該傳回 1。

```js
assert.equal(factorial(1), 1);
```

factorial(2) 應該傳回 2。

```js
assert.equal(factorial(2), 2);
```

factorial(3) 應該傳回 6。

```js
assert.equal(factorial(3), 6);
```

factorial(4) 應該傳回 24。

```js
assert.equal(factorial(4), 24);
```

factorial(10) 應該傳回 3628800。

```js
assert.equal(factorial(10), 3628800);
```

# --seed--

## --after-user-code--

```js
var factorial = Y(f => n => (n > 1 ? n * f(n - 1) : 1));
```

## --seed-contents--

```js
function Y(f) {
  return function() {

  };
}

var factorial = Y(function(f) {
  return function (n) {
    return n > 1 ? n * f(n - 1) : 1;
  };
});
```

# --solutions--

```js
var Y = f => (x => x(x))(y => f(x => y(y)(x)));
```
