---
id: 6874b7d3b286c538b39d0c25
title: 什么是特殊方法及其用途？
challengeType: 19
dashedName: what-are-special-methods-and-what-are-they-used-for
---

# --description--

Python 中的特殊方法，也称为“魔术方法”或“dunder 方法”，是以双下划线（`__`）开头和结尾的特殊 Python 方法。“dunder”一词本身来源于双下划线（**d** 代表 double，**under** 代表 underscores）。

你可能已经在不知不觉中使用了特殊方法。每当你写 `3 + 4` 这样的表达式时，Python 会在后台悄悄地运行 `3.__add__(4)`。这就是特殊方法的作用。所以虽然你*可以*直接调用特殊方法，但你很少这样做。像 `3 + 4` 这样的写法比你自己调用 `3.__add__(4)` 更清晰、更易读。

除了 `__add__`，`__init__()` 是你最常见和使用的另一个特殊方法，因为它是一个类初始化方法。还有其他如 `__len__()` 和 `__str__()`。

将特殊方法视为编程者与 Python 语言解释器之间活动的导演。

请记住，你不需要直接调用特殊方法。相反，当发生某些操作时，Python 会自动调用它们。这些操作包括：

- **算术操作，如加法、减法、乘法、除法和其他**。此外，会调用 `__add__()`，减法调用 `__sub__()`，乘法调用 `__mul__()`，除法调用 `__truediv__()`。
    
- **字符串操作，如串接、重复、格式化和转换为文本**。`__add__()` 用于串接，`__mul__()` 用于重复，`__format__()` 用于格式化，`__str__()` 和 `__repr__()` 用于文本转换，等等。
    
- **比较操作，如相等性、小于、大于和其他**。`__eq__()` 用于相等性查看，`__lt__()` 用于小于，`__gt__()` 用于大于，依此类推。
    
- **迭代操作，例如使对象可迭代和遍历项**。调用 `__iter__()` 来返回迭代器，调用 `__next__()` 来获取下一项。
    

通常，Python 数据类型如字串和数字已经知道如何添加内容、进行串接、比较相等性、用于循环以及其他操作。

但是当你创建你自己的类时，Python 不会自动知道如何处理事情。

这就是特殊方法的用武之地——它们让你自定义 Python 的内置行为。

假设你想获取使用下面类创建的书籍对象中的页数，或者比较它们并获取对象的可读字串。以下是在没有特殊方法时会发生的情况：

```python
class Book:
   def __init__(self, title, pages):
       self.title = title
       self.pages = pages

book1 = Book("Built Wealth Like a Boss", 420)
book2 = Book("Be Your Own Start", 420)

print(len(book1)) # TypeError: object of type 'Book' has no len()
print(str(book1)) # <__main__.Book object at 0x102ed2900>
print(book1 == book2) # False even though they have the same number of pages
```

在示例中：

- `len(book1)` 失败，因为 Python 不知道如何在没有 `__len__()` 的情况下获取你的书对象的长度
    
- `str(book1)` 打印了类似 `<__main__.Book object at 0x102ed2900>` 的内容，因为当你不使用 `__str__()` 时，这是默认的表现形式
    
- `book1 == book2` 的结果是 `False`，因为 Python 只是查看两个对象是否在内存中相同，而不是按内容比较。
    

下面是你如何定义自己的 `__len__()`、`__str__()` 和 `__eq__()` 特殊方法，以便更轻松地操作由 `Book` 类创建的对象：

```python
class Book:
   def __init__(self, title, pages):
       self.title = title
       self.pages = pages

   def __len__(self):
       return self.pages

   def __str__(self):
       return f"'{self.title}' has {self.pages} pages"

   def __eq__(self, other):
       return self.pages == other.pages
  
book1 = Book("Built Wealth Like a Boss", 420)
book2 = Book("Be Your Own Start", 420)

print(len(book1)) # 420
print(len(book2)) # 420
print(str(book1)) # 'Built Wealth Like a Boss' has 420 pages
print(str(book2)) # 'Be Your Own Start' has 420 pages
print(book1 == book2) # True
```

另一个例子是购物车，你执行以下操作：

- 将项添加到购物车
    
- 从购物车中移除项
    
- 获取购物车中项的数量
    
- 查看购物车中的项
    
- 查看特定项是否在购物车中
    
- 返回或显示购物车中指定索引的项
    

虽然你可能有一个将项添加到购物车和从购物车中移除某些项的方法，但你可以为所有其他功能性创建特殊的方法：

- `__len__()` 用于获取购物车中项的长度
    
- 使用 `__iter__()` 循环遍历购物车中的项，以便你查看它们
    
- `__contains__()` 用于查看特定项是否在购物车中
    
- `__getitem__()` 用于返回或显示购物车中特定索引处的项
    

这是一个包含这些用户定义方法和特殊方法的 `Cart` 类示例：

```python
class Cart:
   def __init__(self):
       self.items = []

   def add(self, item):
       self.items.append(item)

   def remove(self, item):
       if item in self.items:
           self.items.remove(item)
       else:
           print(f'{item} is not in cart')

   def list_items(self):
       return self.items

   def __len__(self):
       return len(self.items)

   def __getitem__(self, index):
       return self.items[index]

   def __contains__(self, item):
       return item in self.items

   def __iter__(self):
       return iter(self.items)
```

下面是你如何使用它们的方法：

```python
cart = Cart()
cart.add('Laptop')
cart.add('Wireless mouse')
cart.add('Ergo keyboard')
cart.add('Monitor')

for item in cart:
   print(item, end=' ') # Laptop Wireless mouse Ergo keyboard Monitor

print(len(cart)) # 4
print(cart[3]) # Monitor

print('Monitor' in cart) # True
print('banana' in cart) # False

cart.remove('Ergo keyboard')

print(cart.list_items()) # ['Laptop', 'Wireless mouse', 'Monitor']

cart.remove('banana') # banana is not in cart
```

这就是你在实际中使用 Python 特殊方法的几种方式。

# --questions--

## --text--

在加法操作期间调用的特殊方法是哪一个？

## --answers--

`__plus__()`

### --feedback--

注意使用 `+` 操作符时触发了什么。

---

`__sum__()`

### --feedback--

注意使用 `+` 操作符时触发了什么。

---

`__add__()`

---

`__concat__()`

### --feedback--

注意使用 `+` 操作符时触发了什么。

## --video-solution--

3

## --text--

单词 "dunder" 是如何派生的？

## --answers--

从动态底层操作

### --feedback--

思考“dunder”这个词与 dunder 方法的写法之间的关系。

---

从缩写“双下划线” (`__`)

---

来自 Python 昵称的创造者

### --feedback--

思考“dunder”这个词与 dunder 方法的写法之间的关系。

---

从引用中“data under”指隐藏的方法

### --feedback--

思考“dunder”这个词与 dunder 方法的写法之间的关系。

## --video-solution--

2

## --text--

当你使用大于号（`>`）比较操作符时，会调用哪个特殊方法？

## --answers--

`__more__()`

### --feedback--

它代表“大于”，由 `>` 操作符触发。

---

`__compare__()`

### --feedback--

它代表“大于”，由 `>` 操作符触发。

---

`__greater__()`

### --feedback--

它代表“大于”，由 `>` 操作符触发。

---

`__gt__()`

## --video-solution--

4
