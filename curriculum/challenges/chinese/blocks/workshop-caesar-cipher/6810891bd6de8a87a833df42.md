---
id: 6810891bd6de8a87a833df42
title: 步骤 10
challengeType: 20
dashedName: step-10
---

# --description--

正如你从输出中看到的，消息已经被加密。下一步将是使你的代码可重用，以防你想加密不同的消息。

为此，你需要创建一个函数。提醒一下，下面是如何创建一个名为 `spam` 的函数，该函数在终端打印 `Spam!`：

```py
def spam():
    print('Spam!')
```

创建一个名为 `caesar` 的函数。将你所有现有的代码放入函数体内。注意保持函数体内所有行的缩排级别一致。

# --hints--

你应该有一个名为 `caesar` 的函数。

```js
({ test: () => assert(runPython(`_Node(_code).has_function("caesar")`)) })
```

你应该将到目前为止编写的所有代码移动到 `caesar` 函数体内。确保函数体内所有行保持相同的缩排级别……

```js
({ test: () => assert(runPython(`_Node(_code).find_function("caesar").find_body().is_equivalent("alphabet = 'abcdefghijklmnopqrstuvwxyz'\\nshift = 5\\nshifted_alphabet = alphabet[shift:] + alphabet[:shift]\\ntranslation_table = str.maketrans(alphabet, shifted_alphabet)\\ntext = 'hello world'\\nencrypted_text = text.translate(translation_table)\\nprint(encrypted_text)")`)) })
```

# --seed--

## --seed-contents--

```py
--fcc-editable-region--

alphabet = 'abcdefghijklmnopqrstuvwxyz'
shift = 5
shifted_alphabet = alphabet[shift:] + alphabet[:shift]
translation_table = str.maketrans(alphabet, shifted_alphabet)
text = 'hello world'
encrypted_text = text.translate(translation_table)
print(encrypted_text)
--fcc-editable-region--
```
