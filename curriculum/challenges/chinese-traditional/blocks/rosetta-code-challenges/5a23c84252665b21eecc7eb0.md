---
id: 5a23c84252665b21eecc7eb0
title: I 在 C 之後除外，皆為 E
challengeType: 1
forumTopicId: 302288
dashedName: i-before-e-except-after-c
---

# --description--

**<a href="http://www.rosettacode.org/wiki/I_before_E_except_after_C" target="_blank" rel="noopener noreferrer nofollow">「I 在 E 之前，除非在 C 之後」</a>** 是英語拼字的一般規則。如果不確定一個字是用雙字母組合 `ei` 還是 `ie` 拼寫，這個押韻法則建議正確的順序是 `ie`，除非前一個字母是 `c`，在這種情況下可能是 `ei`。

使用所提供的字、單字，檢查該語句的兩個子語句是否各自合理：

<ol>
  <li>
    <i>"I before E when not preceded by C".</i>
  </li>
  <li>
    <i>"E before I when preceded by C".</i>
  </li>
</ol>

如果兩個子片語皆合理，則原始片語可視為合理。

# --instructions--

撰寫一個函式（程式），接受一個字，並檢查該字是否符合此規則。若該字符合規則，函式（程式）應傳回 true，否則傳回 false。

# --hints--

`IBeforeExceptC` 應該是一個函式（程式）。

```js
assert(typeof IBeforeExceptC == 'function');
```

`IBeforeExceptC("receive")` 應該傳回一個布林值。

```js
assert(typeof IBeforeExceptC('receive') == 'boolean');
```

`IBeforeExceptC("receive")` 應該傳回 `true`。

```js
assert.equal(IBeforeExceptC('receive'), true);
```

`IBeforeExceptC("science")` 應該傳回 `false`。

```js
assert.equal(IBeforeExceptC('science'), false);
```

`IBeforeExceptC("imperceivable")` 應該傳回 `true`。

```js
assert.equal(IBeforeExceptC('imperceivable'), true);
```

`IBeforeExceptC("inconceivable")` 應該傳回 `true`。

```js
assert.equal(IBeforeExceptC('inconceivable'), true);
```

`IBeforeExceptC("insufficient")` 應該傳回 `false`。

```js
assert.equal(IBeforeExceptC('insufficient'), false);
```

`IBeforeExceptC("omniscient")` 應該傳回 `false`。

```js
assert.equal(IBeforeExceptC('omniscient'), false);
```

# --seed--

## --seed-contents--

```js
function IBeforeExceptC(word) {

}
```

# --solutions--

```js
function IBeforeExceptC(word)
{
    if(word.indexOf("c")==-1 && word.indexOf("ie")!=-1)
        return true;
    else if(word.indexOf("cei")!=-1)
        return true;
    return false;
}
```
