---
id: 67f413a2abe9894c52e15c6e
title: 動態規劃測驗
challengeType: 8
dashedName: quiz-dynamic-programming
---

# --description--

要通過測驗，你必須正確回答以下 10 題中的至少 9 題。

# --quizzes--

## --quiz--

### --question--

#### --text--

動態規劃成為有效解決方案方法時，問題中必須具備哪兩個基本屬性？

#### --distractors--

快速執行時間和最小記憶體使用量

---

遞迴能力和反覆的迴圈

---

序列處理和平行計算

#### --answer--

重疊子問題和最佳子結構

### --question--

#### --text--

動態規劃中，備忘錄法與表格法的主要差異是什麼？

#### --distractors--

備忘錄使用雜湊表，而表格法使用陣列，使其更高效。

---

備忘錄法比表格法更快，但使用更多記憶體和 CPU 週期。

---

備忘錄化只能解決比表格法更簡單的問題。

#### --answer--

備忘錄法是使用遞迴的自頂向下方法，而表格法是使用迭代的自底向上方法。

### --question--

#### --text--

為什麼對動態規劃問題的天真遞迴解法通常具有指數時間複雜度？

#### --distractors--

因為它們使用指數級的記憶體來儲存變數。

---

因為它們需要以指數時間排序資料。

---

因為它們必須檢查輸入的所有可能排列組合。

#### --answer--

因為每次遞迴呼叫會分支多次，導致相同的子問題被重複計算。

### --question--

#### --text--

在動態規劃的背景關係中，最佳子結構是什麼意思？

#### --distractors--

該演算法必須使用可用的最高效資料結構。

---

該解法必須同時將時間與空間複雜度降到最低。

---

問題必須有唯一且單一的最佳解決方案。

#### --answer--

最佳解決方案可以由其子問題的最佳解決方案構建而成。

### --question--

#### --text--

當實作記憶化時，當一個函式以已經計算過的引數被呼叫時會發生什麼？

#### --distractors--

該函式（程式）重新計算結果以確保準確性。

---

該函式（程式）將舊結果和新結果取平均以獲得更好的精確度。

---

因為不允許重複計算，所以發出錯誤。

#### --answer--

快取的結果會立即傳回，無需重新計算。

### --question--

#### --text--

使用頁籤而非備忘錄的主要優勢是什麼？

#### --distractors--

表格法總是比備忘錄法需要更少的記憶體。

---

縮排可以解決更廣泛的類別問題。

---

製表總是較容易實作且理解。

#### --answer--

製表法避免了遞迴的額外開銷，並提供可預測的順序執行。

### --question--

#### --text--

在自底向上的動態規劃解法中，為什麼要先初始化基底案例？

#### --distractors--

為 `data structure` 高效配置 `memory`。

---

為了防止演算法中的無窮迴圈。

---

為了改善演算法的時間複雜度。

#### --answer--

提供所有較大子問題建立的基礎值。

### --question--

#### --text--

動態程式設計如何改變具有重疊子問題的問題的時間複雜度？

#### --distractors--

透過高效地除以問題，從多項式轉為對數。

---

透過優化迴圈結構，將二次方降低為線性。

---

從線性到常數，透過使用雜湊表。

#### --answer--

透過儲存並重複使用子問題的解法，將指數時間轉換為多項式時間。

### --question--

#### --text--

動態程式設計通常會做出什麼取捨以達成更好的時間複雜度？

#### --distractors--

它犧牲了程式碼可讀性以換取更快的執行速度。

---

它需要更複雜且較難維護的演算法。

---

它限制了可解決問題的大小。

#### --answer--

它使用額外空間來儲存中間結果。

### --question--

#### --text--

在什麼情況下，動態規劃不會是適當的演算法方法？

#### --distractors--

當問題需要尋找最佳解決方案時。

---

當問題可以被拆解成較小的子問題時。

---

當必須將空間複雜度降到最低時。

#### --answer--

當子問題彼此獨立且不重疊時。
