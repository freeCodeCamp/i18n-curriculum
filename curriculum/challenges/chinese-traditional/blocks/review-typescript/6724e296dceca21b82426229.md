---
id: 6724e296dceca21b82426229
title: Typescript 審查
challengeType: 31
dashedName: review-typescript
---

# --description--

## 什麼是 TypeScript

- **JavaScript**：JavaScript 是一種動態型別語言。這表示變數可以在執行時接收任何值。動態型別語言的挑戰在於缺乏型別安全性，可能會引入錯誤。

例如，即使你的 JavaScript 函式（程式）期望一個陣列，你仍然可以用一個數字來呼叫它：

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

上述範例的 `console` 輸出將會是 `undefined`。

- **TypeScript**：TypeScript 擴充了 JavaScript 語言，加入靜態型別，幫助你在執行程式碼之前捕捉因型別不匹配而產生的錯誤。

例如，你可以為 `array` 參數定義一個型別，如下所示：

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

這個型別定義告訴 TypeScript，`array` 參數必須是字串的陣列。然後，當你呼叫 `getRandomValue` 並傳入一個數字時，你會得到一個稱為編譯器錯誤的錯誤。

- **編譯器**：你首先需要將 TypeScript 程式碼編譯成一般的 JavaScript。當你執行編譯器時，TypeScript 會評估你的程式碼，並在任何型別不匹配的問題上發出錯誤。

## TypeScript 中的資料型別

- **TypeScript 中的原始資料型別**：對於原始資料型別 `string`、`null`、`undefined`、`number`、`boolean` 和 `bigint`，TypeScript 提供相應的型別關鍵字。

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **陣列**：你可以用兩種不同的語法定義特定型別的陣列。

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **物件**：你可以定義物件的精確結構。

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

如果你想要一個具有任意鍵，但所有值必須是字串的物件，有兩種定義方式：

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **TypeScript 中的其他有用型別**：
  - **`any`**：`any` 顯示一個值可以有任何型別。它告訴編譯器停止關注該變數的型別。
  - **`unknown`**：`unknown` 告訴 TypeScript 你*確實*在意該值的型別，但你實際上不知道它是什麼。`unknown` 通常比 `any` 更受推薦。
  - **`void`**：這是一種特殊的型別，你通常只會在定義函式時使用。沒有返回值的函式使用 `void` 作為返回型別。
  - **`never`**：它表述一種永遠不會存在的型別。

- **`type` 關鍵字**：這個關鍵字類似於 `const`，但不是宣告變數，而是宣告一個型別。

它對於宣告訂製型別非常有用，例如聯集（數學）型別或只包含特定值的型別：

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interface`**：介面就像型別的類別。它們可以實作或擴充其他介面，特別是物件型別，且通常會被優先使用，除非你需要 `type` 宣告所提供的特定功能。

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **定義返回類型**：你也可以定義函式的*返回類型*。

以下範例將返回值定義為字串。如果你嘗試返回其他任何東西，TypeScript 將會產生編譯器錯誤。

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## 泛型

- **定義泛型**：你可以定義一個泛型並在你的函式中取用它。它可以被視為你提供給函式的一個特殊參數，用來控制函式型別定義的行為。

這裡是一個為函式定義泛型型別的範例：

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

`<T>` 語法告訴 TypeScript 你正在為函式定義一個泛型型別 `T`。`T` 是泛型型別的常用名稱，但你可以使用任何名稱。

然後，你告訴 TypeScript `array` 參數是符合泛型型別的值的陣列，且傳回值是相同型別的單一元素。

- **在函式呼叫中指定型別引數**：你可以在函式名稱和其參數之間使用尖括號傳遞型別引數。

這裡是一個將型別引數傳遞給函式呼叫的範例：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

這告訴 TypeScript 你預期找到的元素將會是輸入元素。

## 型別縮小

- **以真值進行縮小**：在以下範例中，你嘗試存取 `email` 的 `value` 屬性時會得到編譯器錯誤，因為 `email` *可能* 是 `null`。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

你可以使用條件述語來確認 `email` 是 *truthy*，然後再存取該屬性：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

真值檢查也可以反向運作：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

發出錯誤會結束此程式碼的邏輯執行，這表示當你到達 `console.log()` 呼叫時，TypeScript 知道 `email` *不可能* 是 `null`。

- **選用串鏈**：選用串鏈 `?.` 也是一種型別縮小，前提是如果 `email` 值為 `null`，則不會發生該屬性的存取。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **`typeof` 運算子**：你可以使用條件判斷來檢查變數的型別，方法是使用 `typeof` 運算子。

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **`instanceof` 關鍵字**：如果物件來自某個類別，你可以使用 `instanceof` 關鍵字來縮小型別。

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **類型轉換**：當 TypeScript 無法自動判斷一個值的型別，例如下面範例中 `request.json()` 方法的結果，你會遇到編譯器錯誤。解決此問題的一種方法是進行類型轉換，但這樣會削弱 TypeScript 偵測潛在錯誤的能力。

```typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **型別守衛**：你可以撰寫型別守衛，而不是進行型別轉換：

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

`user is User` 語法指出你的函式傳回布林值，當為 true 時表示 `user` 值符合 `User` 介面。

## `tsconfig` 檔案

- **`tsconfig.json`**：TypeScript 的編譯器設定存放在你的專案根目錄中的 `tsconfig.json` 檔案內。

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

以下是上述範例中使用的編譯器選項的說明：

- **`compilerOptions`**：`compilerOptions` 屬性是你控制 TypeScript 編譯器行為的地方。
- **`rootDir` 和 `outDir`**：`rootDir` 和 `outDir` 告訴 TypeScript 哪個目錄包含你的原始碼檔案，以及哪個目錄應該包含轉譯後的 JavaScript 程式碼。
- **`lib`**：`lib` 屬性決定編譯器使用哪些型別定義，並允許你包含對特定 ES 版本、DOM 等的支援。
- **`module` 和 `moduleResolution`**：`module` 和 `moduleResolution` 協同運作，以管理你的軟體包如何使用模組－無論是 CommonJS 還是 ECMAScript。
- **`esModuleInterop`**：`esModuleInterop` 允許 CommonJS 和 ES 模組之間更順暢的互通，方法是自動為匯入建立命名空間物件。
- **`skipLibCheck`**：`skipLibCheck` 選項會跳過驗證未被你的程式碼中匯入取用的 `.d.ts` 檔案。
- **`strict`**：`strict` 旗標會啟用多項檢查，例如確保正確處理可為 null 的型別，並在 TypeScript 回退到 `any` 時發出警告。
- **`exclude`**：頂層的 `exclude` 屬性告訴編譯器在編譯期間忽略這些 TypeScript 檔案。

# --assignment--

檢視 Typescript 主題和概念。
