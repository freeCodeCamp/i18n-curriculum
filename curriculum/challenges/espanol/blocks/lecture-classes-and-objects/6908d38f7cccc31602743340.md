---
id: 6908d38f7cccc31602743340
title: ¿Cómo manejar atributos de objetos dinámicamente?
challengeType: 19
dashedName: how-to-handle-object-attributes-dynamically
---

# --description--

En una lección anterior, aprendiste que los atributos son las variables que pertenecen a un objeto. Eso significa que contienen datos que describen el estado o comportamiento del objeto.

Por ejemplo, un coche normalmente tendría una marca y un modelo. La marca y el modelo podrían ser atributos para una clase `Car`:

```python
class Car: 
    def __init__(self, brand, model): 
        self.brand = brand 
        self.model = model 

my_car = Car('Lamborghini', 'Gallardo') 
print(my_car.brand) # Lamborghini 
print(my_car.model) # Gallardo 
```

Pero a veces, puede que no sepas qué atributos necesitas hasta que tu programa esté en ejecución. Imagina que estás escribiendo un script que recibe nombres de atributos de un usuario o de un archivo de configuración. Esos no son atributos que puedas codificar de forma fija con anticipación.

Ahí es donde entra el manejo dinámico de atributos. De esta manera, puedes acceder, modificar, verificar o incluso eliminar atributos usando sus nombres como variables, y no como nombres fijos en tu código. Esto le da a tu programa la flexibilidad para responder a diferentes datos o entradas del usuario en tiempo real.

Python te ofrece cuatro funciones integradas muy útiles para trabajar dinámicamente con atributos de objetos. Son `getattr()`, `setattr()`, `hasattr()` y `delattr()`.

Te permiten acceder, crear, verificar y eliminar atributos usando nombres de variables. Veamos cada uno en acción. 

`getattr()` hace posible leer un atributo de un objeto cuando no conoces su nombre hasta el tiempo de ejecución. Si el atributo no existe, genera un `AttributeError`, a menos que proporciones un valor predeterminado.

Para usarlo, pasa el objeto, el nombre del atributo y un valor predeterminado opcional: 

```python
getattr(object, attribute_name, default_value) 
```

Aquí tienes un ejemplo:

```python
class Person: 
    def __init__(self, name, age): 
        self.name = name 
        self.age = age 

person = Person('John Doe', 30) 
 
print(getattr(person, 'name')) # John Doe 
print(getattr(person, 'age')) # 30 
print(getattr(person, 'city', 'Milano')) # Milano
```

En el ejemplo anterior, `Milano` es un valor predeterminado porque `city` no existe en la clase `Person`. 

Como dijimos antes, el verdadero poder de `getattr()` es evidente cuando el nombre del atributo proviene de una variable, como de la entrada del usuario o de algún archivo.

En ese caso, no puedes usar la sintaxis regular `object.attribute_name` porque el nombre del atributo no es fijo.

```python
class Person: 
    def __init__(self, name, age): 
        self.name = name 
        self.age = age 

person = Person('John Doe', 30)

attr_name = input('Enter the attribute you want to see: ')
print(getattr(person, attr_name, 'Attribute not found'))
```

En este caso, si el usuario escribe `name`, verá `John Doe`, y si escribe `age`, verá `30`. Y si escribe algo que no existe en la clase como `email`, verá `Attribute not found`.

Aquí es exactamente donde brilla el manejo dinámico de atributos. Permite que tu código responda a entradas y datos que no ha visto antes.

Además, puede que quieras revisar todos los atributos que tiene un objeto, no solo los que ya conoces. La función incorporada `dir()` te permite hacer eso. Devuelve una lista con todos los nombres de atributos del objeto. Aquí te mostramos cómo usarla:

```python
class Person: 
    def __init__(self, name, age): 
        self.name = name 
        self.age = age 

person = Person('John Doe', 30)

# Loop through all attributes of the person object with dir() function
for attr in dir(person):
    # Ignore dunder methods like __init__ or __str__ and regular methods
    if not attr.startswith('__') and not callable(getattr(person, attr)): 
        value = getattr(person, attr)
        print(f'{attr}: {value}')

# Output
# age: 30
# name: John Doe
```

La función `setattr()` te permite crear un nuevo atributo o actualizar uno existente de forma dinámica. La sintaxis es la siguiente: 

```python
setattr(object, attribute_name, value) 
```

Aquí tienes un ejemplo que establece atributos de configuración basados en datos de algún archivo de configuración o variable de entorno: 

```python
class Configuration:
    pass

# Data loaded at runtime (like from a config or env file)
settings_data = {
    'server_url': 'https://api.example.com',
    'timeout_sec': 30,
    'max_retries': 5
}

config_obj = Configuration()

# Dynamically set attributes using dictionary keys and values
for attr_name, attr_value in settings_data.items():
    setattr(config_obj, attr_name, attr_value)

print(config_obj.server_url) # https://api.example.com
print(config_obj.timeout_sec) # 30
```

También existe `hasattr()`. Antes de hacer algo con un atributo o eliminarlo, es buena práctica verificar si existe. Eso es lo que permite hacer `hasattr()`. Comprueba si un atributo existe y devuelve `True` o `False` según el resultado. 

Aquí está la sintaxis básica:

```python
hasattr(object, attribute_name)  
```

Y aquí tienes un ejemplo que verifica dinámicamente la existencia de atributos en una instancia de la clase `Product`:

```python
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price

product_a = Product('T-Shirt', 25)

required_attributes = ['name', 'price', 'inventory_id']

for attr in required_attributes:
    if not hasattr(product_a, attr):
        print(f"ERROR: Product is missing the required attribute: '{attr}'")
    else:
        # Access the attributes dynamically once their existence is confirmed
        print(f'{attr}: {getattr(product_a, attr)}')

# Output:
# name: T-Shirt
# price: 25
# ERROR: Product is missing the required attribute: 'inventory_id'
```

El error ERROR ocurrió porque falta `inventory_id` en la clase `Product` y su instancia.

Por último, `delattr()` te permite eliminar un atributo dinámicamente: 

```python
delattr(object, attribute_name) 
```

Por ejemplo, imagina que un objeto ha sido completamente procesado, luego decides limpiar cualquier atributo sensible o temporal que pueda existir antes de guardar la versión final. Después de eso, puedes usar `dir()` para recorrer los atributos restantes:

```python
class UserSession:
    def __init__(self, user_id, token):
        self.user_id = user_id
        self.auth_token = token # sensitive
        self.temp_counter = 0 # temporary

session = UserSession(101, 'a1b2c3d4e5')

# List of attributes to remove dynamically before "saving" the session
attributes_to_clean = ['auth_token', 'temp_counter']

# Dynamically remove specified attributes
for attr in attributes_to_clean:
    if hasattr(session, attr):
        delattr(session, attr)
        print(f'Removed attribute: {attr}')

print('\nFinal attributes remaining:')

# Loop through the remaining attributes with dir()
for attr in dir(session):
    # Ignore dunder methods like __init__ or __str__ and regular methods
    if not attr.startswith('__') and not callable(getattr(session, attr)):
        print(f' - {attr}: {getattr(session, attr)}')

# Output:
# Removed attribute: auth_token
# Removed attribute: temp_counter

# Final attributes remaining:
#  - user_id: 101
```

¡Y así es como puedes manejar atributos dinámicamente!

# --questions--

## --text--

**¿Qué permite hacer la** `getattr()` **función en Python?**

## --answers--

Lee un atributo de un objeto cuando su nombre es desconocido hasta el tiempo de ejecución.

---

Elimina un atributo de un objeto.

### --feedback--

Piensa en qué función te ayuda a *recuperar* un atributo dinámicamente.

---

Establece un nuevo atributo en un objeto.

### --feedback--

Piensa en qué función te ayuda a *recuperar* un atributo dinámicamente.

---

Verifica si un atributo existe en un objeto.

### --feedback--

Piensa en qué función te ayuda a *recuperar* un atributo dinámicamente.

## --video-solution--

1

## --text--

¿Por qué querrías manejar atributos de objetos dinámicamente en Python?

## --answers--

Para convertir atributos en una lista automáticamente.

### --feedback--

Piensa en responder a la entrada del usuario o a datos externos de forma dinámica.

---

Para hacer que los atributos sean de solo lectura durante el tiempo de ejecución.

### --feedback--

Piensa en responder a la entrada del usuario o a datos externos de forma dinámica.

---

Para reducir la cantidad de atributos de clase creados.

### --feedback--

Piensa en responder a la entrada del usuario o a datos externos de forma dinámica.

---

Para trabajar con atributos cuyos nombres no se conocen hasta el tiempo de ejecución.

## --video-solution--

4

## --text--

¿Cuál es la sintaxis correcta para verificar si un objeto tiene un atributo específico en Python?

## --answers--

`checkattr(object, attribute_name)`

### --feedback--

Piensa en qué nombre de función sugiere literalmente "tiene atributo."

---

`hasattr(object, attribute_name)`

---

`setattr(object, attribute_name)`

### --feedback--

Piensa en qué nombre de función sugiere literalmente "tiene atributo."

---

`getattr(object, attribute_name)`

### --feedback--

Piensa en qué nombre de función sugiere literalmente "tiene atributo."

## --video-solution--

2
