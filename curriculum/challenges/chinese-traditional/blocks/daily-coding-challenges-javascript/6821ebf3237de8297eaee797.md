---
id: 6821ebf3237de8297eaee797
title: "挑戰 21：十六進位產生器"
challengeType: 28
dashedName: challenge-21
---

# --description--

給定一個命名的 CSS 顏色字串，產生一個在該顏色中佔主導地位的隨機十六進位（hex）顏色代碼。

- 該函式（程式）應該將 `"red"`、`"green"` 或 `"blue"` 作為輸入引數來控制代碼。
- 如果輸入不是其中之一，該函式（程式）應該傳回 `"Invalid color"`。
- 該函式（程式）應傳回一個隨機的六字元十六進位色碼，且輸入的顏色值必須大於其他任何顏色值。
- 給定輸入的有效輸出範例：

| Input   | Output   |
|---------|----------|
| `"red"`   | `"FF0000"` |
| `"green"` | `"00FF00"` |
| `"blue"`  | `"0000FF"` |

# --hints--

`generateHex("yellow")` 應該傳回 `"Invalid color"`。

```js
assert.equal(generateHex("yellow"), "Invalid color");
```

`generateHex("red")` 應該傳回一個六字元字串。

```js
assert.lengthOf(generateHex("red"), 6);
```

`generateHex("red")` 應該傳回一個有效的六字元十六進位色碼。

```js
const hex = generateHex("red").toUpperCase();
const isValidHex = /^[0-9A-F]{6}$/.test(hex);
assert.isTrue(isValidHex);
```

`generateHex("red")` 應該傳回一個有效的十六進位顏色，其紅色值高於其他顏色。

```js
const hex = generateHex("red").toUpperCase();
const isValidHex = /^[0-9A-F]{6}$/.test(hex);
assert.isTrue(isValidHex);

const r = parseInt(hex.slice(0, 2), 16);
const g = parseInt(hex.slice(2, 4), 16);
const b = parseInt(hex.slice(4, 6), 16);

assert.isAbove(r, g);
assert.isAbove(r, b);
```

呼叫 `generateHex("red")` 兩次應該會傳回兩個不同的以紅色為主的十六進位色彩值。

```js
const hex1 = generateHex("red").toUpperCase();
const isValidHex1 = /^[0-9A-F]{6}$/.test(hex1)
assert.isTrue(isValidHex1);

const r1 = parseInt(hex1.slice(0, 2), 16);
const g1 = parseInt(hex1.slice(2, 4), 16);
const b1 = parseInt(hex1.slice(4, 6), 16);

assert.isAbove(r1, g1);
assert.isAbove(r1, b1);

const hex2 = generateHex("red").toUpperCase();
const isValidHex2 = /^[0-9A-F]{6}$/.test(hex2);
assert.isTrue(isValidHex2);

const r2 = parseInt(hex2.slice(0, 2), 16);
const g2 = parseInt(hex2.slice(2, 4), 16);
const b2 = parseInt(hex2.slice(4, 6), 16);

assert.isAbove(r2, g2);
assert.isAbove(r2, b2);
assert.notEqual(hex1, hex2);
```

呼叫 `generateHex("green")` 兩次應該會傳回兩個不同的以綠色為主的十六進位色彩值。

```js
const hex1 = generateHex("green").toUpperCase();
const isValidHex1 = /^[0-9A-F]{6}$/.test(hex1)
assert.isTrue(isValidHex1);

const r1 = parseInt(hex1.slice(0, 2), 16);
const g1 = parseInt(hex1.slice(2, 4), 16);
const b1 = parseInt(hex1.slice(4, 6), 16);

assert.isAbove(g1, r1);
assert.isAbove(g1, b1);

const hex2 = generateHex("green").toUpperCase();
const isValidHex2 = /^[0-9A-F]{6}$/.test(hex2);
assert.isTrue(isValidHex2);

const r2 = parseInt(hex2.slice(0, 2), 16);
const g2 = parseInt(hex2.slice(2, 4), 16);
const b2 = parseInt(hex2.slice(4, 6), 16);

assert.isAbove(g2, r2);
assert.isAbove(g2, b2);
assert.notEqual(hex1, hex2);
```

呼叫 `generateHex("blue")` 兩次應該會傳回兩個不同的以藍色為主的十六進位色彩值。

```js
const hex1 = generateHex("blue").toUpperCase();
const isValidHex1 = /^[0-9A-F]{6}$/.test(hex1)
assert.isTrue(isValidHex1);

const r1 = parseInt(hex1.slice(0, 2), 16);
const g1 = parseInt(hex1.slice(2, 4), 16);
const b1 = parseInt(hex1.slice(4, 6), 16);

assert.isAbove(b1, r1);
assert.isAbove(b1, g1);

const hex2 = generateHex("blue").toUpperCase();
const isValidHex2 = /^[0-9A-F]{6}$/.test(hex2);
assert.isTrue(isValidHex2);

const r2 = parseInt(hex2.slice(0, 2), 16);
const g2 = parseInt(hex2.slice(2, 4), 16);
const b2 = parseInt(hex2.slice(4, 6), 16);

assert.isAbove(b2, r2);
assert.isAbove(b2, g2);
assert.notEqual(hex1, hex2);
```

# --seed--

## --seed-contents--

```js
function generateHex(color) {

  return color;
}
```

# --solutions--

```js
function generateHex(color) {
  const toHex = n => n.toString(16).padStart(2, "0").toUpperCase();

  const dominant = Math.floor(Math.random() * 86) + 170;
  const weak1 = Math.floor(Math.random() * 170);
  const weak2 = Math.floor(Math.random() * 170);

  let r, g, b;

  switch (color) {
    case "red":
      r = dominant;
      g = weak1;
      b = weak2;
      break;
    case "green":
      r = weak1;
      g = dominant;
      b = weak2;
      break;
    case "blue":
      r = weak1;
      g = weak2;
      b = dominant;
      break;
    default:
      return "Invalid color";
  }

  return `${toHex(r)}${toHex(g)}${toHex(b)}`;
}
```
