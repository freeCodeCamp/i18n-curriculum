---
id: 6732c6e281c14a61c4858361
title: 什么是闭包，它们如何工作？
challengeType: 19
dashedName: what-are-closures-and-how-do-they-work
---

# --interactive--

闭包是 JavaScript 中最强大且常被误解的特色之一。本质上，闭包是一个函数，即使在外部函数已经返回之后，仍然可以访问其外部封闭词法作用域中的变量。这听起来可能很复杂，但它是一个基本概念，使得 JavaScript 中许多高级编程模式成为可能。 

要理解闭包，让我们从一个例子开始：

:::interactive_editor

```js
function outerFunction(x) {
    let y = 10;
    function innerFunction(){
        console.log(x + y);
    }
    return innerFunction;
}

let closure = outerFunction(5);
console.log(closure()); // 15
```

:::

在这个例子中，`outerFunction` 接受一个参数 `x` 并定义一个局部变量 `y`。然后它定义了一个使用 `x` 和 `y` 的 `innerFunction`。最后它返回 `innerFunction`。当我们调用 `outerFunction(5)` 时，它返回 `innerFunction`，我们将其赋值给变量 `closure`。当我们稍后调用 `closure()` 时，它仍然可以访问来自 `outerFunction` 的 `x` 和 `y`，即使 `outerFunction` 已经执行完毕。这就是闭包的本质。

内部函数维护对其外部词法环境的引用，即使外部函数已完成，也能保持对该环境中变量的访问。

闭包对于创建私有变量和函数特别有用。考虑以下示例：

:::interactive_editor

```js
function createCounter() {
    let count = 0;
    return function () {
        count++;
        return count;
    };
}

let counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

:::

在这种分支中，`createCounter` 返回一个函数，该函数递增并返回一个 `count` 变量。`count` 变量不能从 `createCounter` 外部直接访问，但返回的函数（我们的闭包）可以访问它。每次我们调用 `counter()`，它都会递增并返回 `count`。

闭包还可以从它们的外部作用域捕捉多个变量。例如：

:::interactive_editor

```js
function multiply(x) {
    return function (y) {
        return x * y;
    };
}

let double = multiply(2);
console.log(double(5)); // 10
```

:::

这里内部函数捕捉了来自 `multiply` 的 `x` 参数。当我们通过调用 `multiply(2)` 创建 `double` 时，它返回一个函数，该函数总是将其参数乘以 `2`。

关于闭包，有一点很重要，那就是它们捕捉变量是通过引用而不是通过值。这意味着如果被捕捉变量的值发生变化，闭包将看到新的值。例如：

:::interactive_editor

```js
function createIncrementer() {
    let count = 0;
    return function () {
        count++;
        console.log(count);
    };
}

let increment = createIncrementer();
increment(); // 1
increment(); // 2
```

:::

每次我们调用 `increment` 时，它都在使用相同的 `count` 变量，而不是它初始值的拷贝。闭包是 JavaScript 中一个强大的工具。当你继续使用 JavaScript 时，你会发现理解并高效使用闭包可以极大地提升你编写简洁、高效且强大代码的能力。

# --questions--

## --text--

下面代码的输出是什么？

```js
function outer(x) {
    return function(y) {
        return x + y;
    };
}

let add5 = outer(5);
console.log(add5(3));
```

## --answers--

`5`

### --feedback--

考虑外部的内部函数如何捕捉 `x` 参数。

---

`3`

### --feedback--

考虑外部的内部函数如何捕捉 `x` 参数。

---

`8`

---

`undefined`

### --feedback--

考虑外部的内部函数如何捕捉 `x` 参数。

## --video-solution--

3

## --text--

以下 `code` 展示了什么 `concept`？

```js
function createGreeter(greeting) {
    return function(name) {
        console.log(greeting + ", " + name);
    };
}

let sayHello = createGreeter("Hello");
sayHello("Alice");
```

## --answers--

提升。

### --feedback--

考虑返回的函数如何保留对 `greeting` 参数的访问。

---

闭包。

---

递归。

### --feedback--

考虑返回的函数如何保留对 `greeting` 参数的访问。

---

原型继承。

### --feedback--

考虑返回的函数如何保留对 `greeting` 参数的访问。

## --video-solution--

2

## --text--

下面代码的输出是什么？

```js
function counter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}

let increment = counter();
console.log(increment());
console.log(increment());
console.log(increment());
```

## --answers--

```js
1
1
1
```

### --feedback--

考虑内部函数在 `counter` 中如何通过多次调用维护对 `count` 变量的访问。

---

```js
1
2
3
```

---

```js
0
1
2
```

### --feedback--

考虑内部函数在 `counter` 中如何通过多次调用维护对 `count` 变量的访问。

---

```js
undefined
undefined
undefined
```

### --feedback--

考虑内部函数在 `counter` 中如何通过多次调用维护对 `count` 变量的访问。

## --video-solution--

2
