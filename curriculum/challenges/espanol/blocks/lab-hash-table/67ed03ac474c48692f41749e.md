---
id: 67ed03ac474c48692f41749e
title: Construir una Tabla Hash
challengeType: 27
dashedName: build-a-hash-table
saveSubmissionToDB: true
---

# --description--

En este laboratorio, construirás una tabla hash desde cero. Una tabla hash es una estructura de datos que almacena pares clave-valor. Una tabla hash funciona tomando la clave como entrada y luego aplicándole un hash de acuerdo con una función de hash específica. 

Para el propósito de este laboratorio, la función de hash será simple: sumará los valores Unicode de cada carácter en la clave. El valor hash se utilizará entonces como la clave real para almacenar el valor asociado. El mismo valor hash también se utilizaría para recuperar y eliminar el valor asociado con la clave.

**Objetivo:** Cumplir con las historias de usuario a continuación y pasar todas las pruebas para completar el laboratorio.

**Historias de usuario:**

1. Deberías definir una clase llamada `HashTable` con un atributo `collection` inicializado a un diccionario vacío cuando se crea una nueva instancia de `HashTable`. El diccionario `collection` debería almacenar pares clave-valor basados en el valor hash de la clave.

2. La clase `HashTable` debería tener cuatro métodos de instancia: `hash`, `add`, `remove` y `lookup`.

3. El método `hash` debería:

    - Tomar una cadena como parámetro.
    - Devolver un valor hash calculado como la suma de los valores Unicode (ASCII) de cada carácter en la cadena. Puedes usar la función `ord` para este cálculo.

4. El método `add` debería:
    - Aceptar dos argumentos que representen un par clave-valor, y calcular el hash de la clave.
    - Usa el valor hash calculado como clave para almacenar un diccionario que contiene el par clave-valor dentro del diccionario `collection`.
    - Si varias claves producen el mismo valor hash, sus pares clave-valor deben almacenarse en el diccionario anidado existente bajo el mismo valor hash.

5. El método `remove` debería:

    - Tomar una clave como su argumento y calcular su hash.
    - Confirmar si la clave existe en `collection`.
    - Eliminar el par clave-valor correspondiente de la tabla hash.
    - Si la clave no existe en `collection`, no debería lanzar un error o eliminar nada.

6. El método `lookup` debería:

    - Tomar una clave como su argumento.
    - Calcular el hash de la clave y devolver el valor correspondiente almacenado dentro de la tabla hash.
    - Si la clave no existe en `collection`, debería devolver `None`.

# --hints--

Deberías definir una clase `HashTable`.

```js
({ 
    test: () => assert(runPython(`
    _Node(_code).has_class("HashTable")
    `)) 
})
```

Cuando se crea una nueva instancia de la clase `HashTable`, su atributo `collection` debería inicializarse a un diccionario vacío.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.collection == {}
    `) 
})
```

La clase `HashTable` debería tener un método `hash`.

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('hash')`))}})
```

El método `hash` debería tomar una cadena como parámetro.

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.hash)
    len(sig.parameters) == 1
  `))
})
```

El método `hash` debería tomar una cadena como su argumento y devolver la suma de los valores Unicode de cada carácter en la cadena.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("fcc")
        assert hash_result == 300

        # prevent hardcoding
        assert ht.hash("golf") == 424
        assert ht.hash("read") == 412
`) })
```

La clase `HashTable` debería tener un método `add`.

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('add')`))}})
```

El método `add` debería tomar una clave y un valor como parámetros.

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.add)
    len(sig.parameters) == 2
  `))
})
```

La clase `HashTable` debería tener un método `remove`.

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('remove')`))}})
```

El método `remove` debería tomar una clave como parámetro.

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.remove)
    len(sig.parameters) == 1
  `))
})
```

Cuando intentas eliminar una clave que no existe en `collection`, no debería lanzar un error ni eliminar nada.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        ht.add("rose", "flower")
        index = ht.hash("rose")
        original = ht.collection.copy()

        ht.remove("tulip")
        ht.remove("sore")

        assert ht.collection == original
        assert "rose" in ht.collection[index]
        assert "tulip" not in ht.collection.get(index, {})
    `) 
})
```

Si múltiples claves producen el mismo índice, el método `remove` debería eliminar solo el par clave-valor específico y no todo el diccionario en ese índice.

```js
({
  test: () => runPython(`
    ht = HashTable()
    ht.add("rose", "flower")
    ht.add("sore", "pain")  # "rose" and "sore" both hash to the same index

    index = ht.hash("rose")
    ht.remove("rose")

    assert index in ht.collection
    assert "rose" not in ht.collection[index]
    assert "sore" in ht.collection[index]
    assert ht.collection[index]["sore"] == "pain"
  `)
})
```

La clase `HashTable` debería tener un método `lookup`.

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('lookup')`))}})
```

El método `lookup` debería tomar una clave como el parámetro.

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.lookup)
    len(sig.parameters) == 1
  `))
})
```

`HashTable().hash('golf')` debería devolver `424`.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("golf")
        assert hash_result == 424

        # prevent hardcoding
        assert ht.hash("dear") == 412
        assert ht.hash("cat") == 312
    `) 
})
```

`HashTable().add('golf', 'sport')` debería agregar el par clave-valor a la colección en la clave `424`.

```js

({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")
    expected_value = {424: {'golf': 'sport'}}

    assert ht.collection == expected_value
    `) 
})
```

`HashTable().add('dear', 'friend')` y `HashTable().add('read', 'book')` deberían agregar ambos pares clave-valor a la colección en el índice `412` como un diccionario anidado.

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("dear", "friend")
    ht.add("read", "book")

    expected_value = {
        "dear": "friend",
        "read": "book"
    }

    assert ht.collection.get(412) == expected_value
    `) 
})
```

Cuando una clave existe en la tabla hash, el método `remove()` debería eliminar la clave dada y su valor correspondiente de `collection`.

```js
({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")

    expected_value_before_removal = {
        "golf": "sport"
    }

    index = ht.hash("golf")

    assert ht.collection.get(index) == expected_value_before_removal

    ht.remove("golf")

    assert "golf" not in ht.collection.get(index, {})
    `) 
})
```

Cuando el par clave-valor `'golf', 'sport'` existe en la tabla hash, `HashTable().lookup('golf')` debería devolver `sport`.

```js
({ 
    test: () => runPython(`
    ht = HashTable()

    ht.add("golf", "sport")

    expected_value = "sport"
    assert ht.lookup("golf") == expected_value
    `) 
})

```

Cuando el par clave-valor `'golf', 'sport'` no existe en la colección, `HashTable().lookup('golf')` debería devolver `None`.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.lookup("golf") is None
`) })

```

Cuando la clave `'fcc'` existe en la colección, `HashTable().lookup('cfc')` debería devolver `None`.

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        ht.add("fcc", "coding")
        assert ht.lookup("cfc") is None
`) })
```

Cuando añades `('rose', 'flower')` a la tabla hash, su atributo `collection` debería lucir así: `{ 441: { 'rose': 'flower' }}`.

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("rose", "flower")

    expected_value = {
        "rose": "flower"
    }

    assert ht.collection.get(441) == expected_value

    # prevent hardcoding

    ht2 = HashTable()

    ht2.add("kebab", "food")
    expected_value = {
        "kebab": "food"
    }

    assert ht2.collection.get(501) == expected_value
    `)
})
```

Cuando añades una clave que produce el mismo valor hash que una clave existente, como `fcc` y `cfc`, `collection` debería lucir así: `{ 300: { 'fcc': 'coding', 'cfc':  'chemical' }}`.

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("fcc", "coding")
    ht.add("cfc", "chemical")

    expected_value = {
        "fcc": "coding",
        "cfc": "chemical"
    }

    assert ht.collection.get(300) == expected_value

    # prevent hardcoding

    ht2 = HashTable()
    ht2.add("cat", "animal")
    ht2.add("act", "verb")

    expected_value = {
        "cat": "animal",
        "act": "verb"
    }

    assert ht2.collection.get(312) == expected_value
    `)
})
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
class HashTable:
    def __init__(self):
        self.collection = {}

    def hash(self, string):
        hashed = 0
        for char in string:
            hashed += ord(char)  
        return hashed

    def add(self, key, val):
        the_hash = self.hash(key)
        if the_hash not in self.collection:
            self.collection[the_hash] = {}
        self.collection[the_hash][key] = val

    def remove(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            del self.collection[the_hash][key]
            if not self.collection[the_hash]: 
                del self.collection[the_hash]

    def lookup(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            return self.collection[the_hash][key]
        return None
```
