---
id: 5a23c84252665b21eecc8038
title: Subleq
challengeType: 1
forumTopicId: 302328
dashedName: subleq
---

# --description--

Subleq 是一種單指令集電腦（OISC）的範例。

它的名稱來自唯一的指令，該指令是 **SU**btract 並在小於或等於零時 **B**ranch。

你的任務是創建一個模擬此類機器的直譯器。

機器的記憶體由一個帶符號整數的陣列組成。任何合理的字大小都可以，但記憶體必須能夠容納負數和正數。

執行從指向第一個字（位址 0）的指令指標開始。執行流程如下：

<ol>
  <li>Let A, B, and C be the value stored in the three consecutive words in memory starting at the instruction pointer.</li>
  <li>Advance the instruction pointer 3 words to point at the address after the one containing C.</li>
  <li>If A is -1, then a character is read from standard input and its code point stored in the address given by B. C is unused.</li>
  <li>If B is -1, then the number contained in the address given by A is interpreted as a code point and the corresponding character output. C is again unused.</li>
  <li>Otherwise, both A and B are treated as the addresses of memory locations. The number contained in the address given by A is subtracted from the number at the address given by B (and the result stored back in address B). If the result is zero or negative, the value C becomes the new instruction pointer.</li>
  <li>If the instruction pointer becomes negative, execution halts.</li>
</ol>

除了 -1 以外的其他負位址可能會被視為等同於 -1，或依你的需求產生錯誤。

你的解決方案應該接受一個程式在機器上執行，並與輸入給程式本身的資料分開。

這個程式應該是未經處理的 subleq `machine code`——以空白分隔的十進位數字，沒有符號名稱或其他組合語言層級的擴充套件，並從位址 0 開始載入到記憶體中。當輸入這個 `Hello, world!` 程式時，顯示你的解決方案的輸出。（請注意，範例假設使用 ASCII 或其超集，例如任何 Latin-N 字元集或 Unicode。如果你的實作是在非 ASCII 相容的環境中，可以將其翻譯成其他字元集。）

<pre>15 17 -1 17 -1 -1 16 1 -1 16 3 -1 15 15 0 0 -1 72 101 108 108 111 44 32 119 111 114 108 100 33 10 0</pre>

這相當於假設的組譯器語言中的類似內容：

<pre>start:
    zero, message, -1
    message, -1, -1
    neg1, start+1, -1
    neg1, start+3, -1
    zero, zero, start
zero: 0
neg1: -1
message: "Hello, world!\n\0"
</pre>

# --instructions--

撰寫一個函式，該函式以整數陣列作為參數。這表述記憶體元素。該函式應該解讀序列並傳回輸出字串。針對此任務，假設沒有標準輸入。

# --hints--

`Subleq` 應該是一個函式（程式）。

```js
assert(typeof Subleq == 'function');
```

`Subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 0])` 應該傳回一個字串。

```js
assert(
  typeof Subleq([
    15,
    17,
    -1,
    17,
    -1,
    -1,
    16,
    1,
    -1,
    16,
    3,
    -1,
    15,
    15,
    0,
    0,
    -1,
    72,
    101,
    108,
    108,
    111,
    44,
    32,
    119,
    111,
    114,
    108,
    100,
    33,
    0
  ]) == 'string'
);
```

`Subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 0])` 應該傳回 `"Hello, world!"`。

```js
assert.equal(
  Subleq([
    15,
    17,
    -1,
    17,
    -1,
    -1,
    16,
    1,
    -1,
    16,
    3,
    -1,
    15,
    15,
    0,
    0,
    -1,
    72,
    101,
    108,
    108,
    111,
    44,
    32,
    119,
    111,
    114,
    108,
    100,
    33,
    0
  ]),
  'Hello, world!'
);
```

# --seed--

## --seed-contents--

```js
function Subleq(mem) {

}
```

# --solutions--

```js
function Subleq(mem) {
  var out = '';
  var instructionPointer = 0;
  do {
    var a = mem[instructionPointer];
    var b = mem[instructionPointer + 1];
    if (a === -1) {
    } else if (b === -1) {
      out += String.fromCharCode(mem[a]);
    } else {
      mem[b] -= mem[a];
      if (mem[b] < 1) {
        instructionPointer = mem[instructionPointer + 2];
        continue;
      }
    }
    instructionPointer += 3;
  } while (instructionPointer >= 0);

  return out;
}
```
