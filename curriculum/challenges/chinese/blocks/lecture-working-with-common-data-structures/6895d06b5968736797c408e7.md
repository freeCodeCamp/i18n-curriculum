---
id: 6895d06b5968736797c408e7
title: 地图、哈希映射和集合是如何工作的？
challengeType: 19
dashedName: how-do-maps-hash-maps-and-sets-work
---

# --description--

在本课中，我们将讲解 maps、hash maps 和 sets。但在此之前，让我们定义 抽象的数据类型。

抽象数据类型（ADT）是数据类型的一个概念表现，包括可以对数据执行的操作以及该数据的属性。

抽象的数据类型就像蓝图，描述了可以执行的**操作**是什么，而不是**如何**执行。它们将接口与操作的实际实现分离。

**map** 是一种抽象数据类型（ADT），以非常特定且高效的方式管理密钥-值点对的集合及其操作。

在映射中，每个值都与特定的密钥关联。

映射的一个关键特性是每个密钥必须唯一。此唯一性允许直接查找，从而使检索信息的进程更加高效。

只有密钥必须唯一，值可以重复。

映射抽象数据类型还定义了重要的操作，例如插入密钥-值点对、获取与密钥关联的值、更新与密钥关联的值、移除密钥-值点对以及查看映射中是否存在某个密钥。

它实际上并没有指定这些操作应如何执行，只是将它们列为该数据类型可用操作的一部分。

**哈希映射**，也称为哈希表，是映射抽象数据类型的具体实现。

哈希映射使用一种称为“hashing”的技术来高效地执行常见操作。

哈希的本质是使用哈希函数为每个元素生成哈希值。

哈希值是基于键值对的密钥生成的，用于计算底层数组中的索引，数组是保存键值对的实际数据结构。

但是你可能会问自己：如果两个密钥导致相同的索引，会发生什么？

哈希映射通过巧妙的策略解决这些冲突。

一种选项是使用“链式”策略，其中每个数组索引指向一个链表（另一种数据结构），所有具有相同索引的元素都保存在该链表中。

另一种策略是使用“开放寻址”，它涉及根据预定义的查找序列在数组中查找下一个可用的索引。

哈希映射的平均分支时间复杂度为插入、检索和删除键值点对的“常量时间”`O(1)`。

这些操作的最坏分支时间复杂度是线性时间 `O(n)`，当发生大量哈希冲突时会出现这种情况，因此必须多次应用冲突解决策略。

将元素插入哈希映射的空间复杂度在平均分支下是常量 `O(1)`，需要常量量级的内存来保存新建的点对。然而，在最坏分支下，由于底层数组的调整大小操作，空间复杂度可能是线性 `O(n)`。通常，移除一个元素的空间复杂度是常量 `O(1)`。

这会将哈希表变成类似线性数据结构的东西，需要扫描 `n` 个元素才能查找目标密钥。然而，如果哈希映射被正确实现，这种情况相对较少。

Python 的 **dictionaries** 在底层实现为哈希映射。

要创建一个 Python 字典，只需将密钥-值点对写在括弧状的方括弧内，并用逗号分隔。每个密钥应与其对应的值用冒号分开。

```python
my_dictionary = {
  'A': 1,
  'B': 2, 
  'C': 3
}
```

在这段代码中，`'A'` 是密钥，`1` 是值：

```python
'A': 1
```

备选地，你可以使用 `dict()`：

```python
my_dictionary = dict(A=1, B=2, C=3)
```

你可以通过对应的密钥获取该值：

```python
my_dictionary['A']  # 1
```

你也可以更新与密钥关联的值：

```python
my_dictionary['A'] = 4
```

你也可以删除一个密钥-值点对：

```python
del my_dictionary['A']  
```

你也可以查看一个密钥是否在字典中（或不在）：

```python
'C' in my_dictionary
```

你可以调用这些方法来分别获取字典的密钥、值和项。

```python
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

太好了。既然你已经了解了更多关于 maps 和 hash maps 的内容，我们来谈谈 sets。

**集合** 是无序的唯一元素集合。

让我们将这个概念拆解为其关键组件：

* 集合是无序的。集合的元素不会以任何特定顺序保存，因此你不能通过索引访问它们。
    
* 集合只包含唯一的元素。如果你尝试添加相同的值两次，只会保留该值的一个拷贝。
    

它们类似于数学中的集合，并且它们实现相同的集合操作，如交集、并集和差集。

集合的主要优点之一是它们保证元素是唯一的（没有副本）。这就是为什么它们经常用于从列表和其他数据结构中删除副本。

它们也是动态的。它们可以根据当前保存的元素数量进行调整。这使它们非常强大。

添加、移除、获取集合长度以及查看元素是否在集合中的平均分支时间复杂度是“常量时间”`O(1)`，这非常高效。

由于集合是作为哈希表实现的，添加、删除和查看成员的最坏情况时间复杂度是“线性时间”`O(n)`。当发生多次哈希冲突时，哈希表会变成类似线性数据结构的形式，需要扫描 `n` 次才能找到密钥。

在空间复杂度方面，在平均分支中，插入一个元素的复杂度为常量 `O(1)`，新建一个唯一元素需要常量内存。然而，在最坏分支中，可能会对底层数组进行调整大小操作，这可能需要线性空间复杂度 `O(n)`。通用的，移除一个元素的空间复杂度为常量 `O(1)`。

Python 有一个内置的 `set` 数据结构，你可以在你的程序中使用它来处理集合。

在后台，Python 集合是使用哈希表实现的，其中只保存密钥，而不保存任何关联的值。

集合只能保存不可变数据类型的对象，因为它们的哈希值始终保持不变。相比之下，可变对象的哈希值在被修改时会发生变化。这就是它们不能成为集合一部分的原因。如果集合中保存的对象的哈希值发生变化，程序将无法再查找它。

要在 Python 中定义一个集合，只需用括弧状的括起元素，并用逗号分隔它们：

```python
numbers = {1, 2, 3, 4}
```

要创建一个空集合，你可以调用 `set()`：

```python
numbers = set()
```

请注意，如果你使用空的括弧状的括弧，这将自动创建一个 Python 字典，而不是集合，因此你必须调用 `set()` 函数来创建一个空集合。

你可以使用 `.add()` 方法为集合添加元素：

```python
numbers.add(5)
```

你也可以使用 `.remove()` 方法从集合中移除元素：

```python
numbers.remove(5)
```

如果未找到该元素，将抛出 `KeyError`。但如果你不想在这种分支抛出误差，可以改用 `.discard()` 方法。

`.pop()` 方法从集合中返回一个任意元素，而 `.clear()` 方法从集合中移除所有元素。

你可以使用 `in` 操作符测试一个元素是否在集合中：

```python
5 in numbers
```

Python 还支持集合操作，包括并集、差集、对称差集和交集，你可以使用这些方法来执行这些操作：

```python
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

set_a.union(set_b)
set_a.intersection(set_b)
set_a.symmetric_difference(set_b)
set_a.difference(set_b)
```

或者使用它们等效的操作符：

```python
set_a | set_b
set_a & set_b
set_a ^ set_b
set_a - set_b 
```

添加、移除和测试成员的平均分支时间复杂度是“常量时间”`O(1)`。

这些操作的最坏分支时间复杂度是“线性时间”`O(n)`，这是由于哈希映射的最坏分支冲突情况。

你也可以查看一个集合是否是另一个集合的子集或超集：

```python
set_a.issubset(set_b)
set_a.issuperset(set_b)
```

通常，当你需要保存唯一项的集合并频繁查看某项是否存在时，应使用集合。

映射、哈希映射和集合是为高效数据组织和检索设计的强大数据结构。它们每一个都有自己独特的特性和使用场景。作为开发者，你需要为你的项目选择最合适的一个。

# --questions--

## --text--

哈希映射（或映射）存储的数据类型与集合存储的数据类型的根本区别是什么？

## --answers--

哈希映射保存有序集合，而集合保存无序集合。

### --feedback--

考虑每个数据结构主要设计用来保存什么。

---

哈希映射保存唯一的密钥-值点对，而集合保存唯一的单个元素。

---

哈希映射不能保存副本值，而集合可以。

### --feedback--

考虑每个数据结构主要设计用来保存什么。

---

集合用于数值数据，而哈希映射用于文本数据。

### --feedback--

考虑每个数据结构主要设计用来保存什么。

## --video-solution--

2

## --text--

允许哈希映射和集合在插入和查找等操作中实现平均分支 `O(1)`（常量时间）性能的主要机制是什么？

## --answers--

它们保持所有元素有序，从而实现快速二分查找。

### --feedback--

考虑将一个元素转换为索引的特殊函数。

---

它们将元素保存在链表中，允许快速遍历。

### --feedback--

考虑将一个元素转换为索引的特殊函数。

---

他们使用哈希函数计算元素的直接内存位置。

---

它们总是保存非常少量的元素，使所有操作都很快。

### --feedback--

考虑将一个元素转换为索引的特殊函数。

## --video-solution--

3

## --text--

在哈希映射和集合的上下文中，什么是 `hash collision`？

## --answers--

当一个元素在查找后成功找到时。

### --feedback--

考虑哈希函数将不同的输入映射到相同输出时的结果。

---

当一个元素被插入到集合的最前面时。

### --feedback--

考虑哈希函数将不同的输入映射到相同输出时的结果。

---

当哈希映射的内存不足且需要调整大小时。

### --feedback--

考虑哈希函数将不同的输入映射到相同输出时的结果。

---

当两个不同的密钥或元素产生相同的哈希值时。

## --video-solution--

4
