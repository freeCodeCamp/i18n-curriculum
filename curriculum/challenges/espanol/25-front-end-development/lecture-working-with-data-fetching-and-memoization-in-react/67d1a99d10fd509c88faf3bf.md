---
id: 67d1a99d10fd509c88faf3bf
title: '¿Cómo funciona la búsqueda de datos en React?'
challengeType: 11
videoId: _gwWcrZ1WJo
dashedName: how-does-data-fetching-work-in-react
---

# --description--

Mira el video o lee la transcripción y responde las preguntas a continuación.

# --transcript--

¿Cómo funciona la búsqueda de datos en React?

Las aplicaciones de React a menudo dependen de API externas y bases de datos para contenido dinámico. Para acceder a los datos de esas API y bases de datos, necesitas utilizar algunas técnicas de obtención de datos.

Echemos un vistazo a cómo funciona la obtención de datos en React y las diferentes opciones disponibles para ti para obtener datos.

React no tiene una opinión definida sobre cómo debe obtener tus datos, lo que significa que a un nivel básico, puedes usar la API Fetch integrada, que todos los navegadores modernos soportan.

También puedes utilizar Axios y SWR. Axios es una librería de solicitudes HTTP basada en promesas construida sobre el objeto XMLHttpRequest, y SWR es un gancho React para la obtención de datos creado por el equipo de Vercel.

Comencemos con un ejemplo. Primero necesitas importar los ganchos `useState` y `useEffect`:

```js
import { useState, useEffect } from "react";
```

Luego necesitarás crear tres variables de estado llamadas `loading`, `data` y `error`:

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

La variable `loading` realizará un seguimiento de si los datos todavía se están obteniendo. La variable `data` representa los datos en sí mismos, y la variable `error` capturará cualquier error que pueda ocurrir durante el proceso de obtención de datos.

Dado que la obtención de datos es un efecto secundario, es mejor usar la API Fetch dentro de un gancho `useEffect`.

Aquí hay un ejemplo de eso:

```js
useEffect(() => {
  fetch("https://jsonplaceholder.typicode.com/posts")
    .then((res) => res.json())
    .then((data) => {
      setData(data);
      setLoading(false);
    })
    .catch((err) => {
      setError(err);
      setLoading(false);
    });
}, []);
```

Este `useEffect` obtiene los datos con la API Fetch y establece todos los estados. 

Puedes mejorar las cosas utilizando `async`/`await` en lugar de la sintaxis `.then()`. Eso significa que necesitas tener una función separada dentro de `useEffect` porque no puedes anteponer el gancho `useEffect` con la palabra clave `async`:

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");

      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Luego puedes ir y utilizar todos esos estados para renderizar los datos del API.

Aquí está el código completo:

```jsx
import { useState, useEffect } from "react";

const FetchPosts = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/posts");

        if (!res.ok) {
          throw new Error("Network response was not ok");
        }

        const data = await res.json();
        setData(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  if (loading) {
    return <p>Loading...</p>;
  }

  if (error) {
    return <p>{error.message}</p>;
  }

  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
};

export default FetchPosts;
```

En la interfaz de usuario, verás `Loading...` en la pantalla cuando los datos se estén obteniendo, y luego se mostrarán los datos o el error dependiendo de si la obtención de datos fue exitosa.

Recuerda que también hablamos sobre la obtención de datos con Axios y SWR. Veamos un ejemplo usando Axios.

Primero necesitarás instalar Axios desde la línea de comandos de esta manera:

```sh
npm i axios
```

Luego necesitarás importar Axios de esta manera:

```js
import axios from "axios";
```

Luego puedes utilizar las mismas variables de estado de antes y obtener datos de la API usando `axios.get`:

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

Quizás hayas notado que no hay una línea `await res.json()` en este ejemplo. Eso es porque Axios parsea automáticamente JSON, por lo que no hay necesidad de eso.

El último ejemplo que veremos es usar el gancho `useSWR` para obtener datos.

Al igual que con Axios, necesitarás instalar SWR de esta manera:

```sh
npm install swr
```

Luego necesitarás importar el gancho `useSWR` al archivo de esta manera:

```js
import useSWR from "swr";
```

En comparación con los ejemplos anteriores, la sintaxis de SWR es mucho más corta. Lo que necesitas hacer es crear una función de obtención y pasarla al gancho `useSWR` como su segundo parámetro (el punto final es el primer parámetro).

También puedes desestructurar tanto el estado de datos como de error del gancho `useSWR`, por lo que no necesitas el gancho `useState`.

Aquí está la sintaxis:

```js
const fetcher = (url) => fetch(url).then((res) => res.json());
const { data, error } = useSWR(endpoint, fetcher);
```

Ten en cuenta que el nombre "fetcher" aquí es solo una convención, por lo que eres libre de nombrar la variable como desees.

Aquí hay un componente que obtiene tareas del JSON Placeholder API:

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
  const { data, error } = useSWR(
    "https://jsonplaceholder.typicode.com/todos",
    fetcher
  );

  if (!data) {
    return <h2>Loading...</h2>;
  }
  if (error) {
    return <h2>Error: {error.message}</h2>;
  }

  return (
    <>
      <h2>Todos</h2>
      <div>
        {data.map((todo) => (
          <h3 key={todo.id}>{todo.title}</h3>
        ))}
      </div>
    </>
  );
};

export default FetchTodos;
```

Como aprendiste en una lección anterior sobre ganchos personalizados, la obtención de datos es una lógica que puedes extraer en un gancho personalizado. Por lo tanto, si estás obteniendo datos en múltiples componentes y páginas, es mejor crear un gancho `useFetch`.

Aquí hay un gancho `useFetch` que usa SWR para la obtención de datos:

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const useFetch = (url) => {
  const { data, error } = useSWR(url, fetcher);

  return {
    data,
    loading: !data && !error,
    error,
  };
};

export default useFetch;
```

Y aquí está cómo usar el gancho `useFetch` para reescribir el primer ejemplo que obtiene posts del JSON Placeholder API:

```jsx
import useFetch from "./useFetch";

const FetchPosts = () => {
  const { data, loading, error } = useFetch(
    "https://jsonplaceholder.typicode.com/posts"
  );

  if (loading) {
    return <h2>Loading...</h2>;
  }

  if (error) {
    return <h2>{error.message}</h2>;
  }

  return (
    <>
      <h2>Posts</h2>
      <ul>
        {data.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </>
  );
};

export default FetchPosts;
```

# --questions--

## --text--

¿Cuáles son los dos parámetros del gancho `useSWR` en el ejemplo dado?

## --answers--

URL y política de caché.

### --feedback--

El primer parámetro representa la fuente de datos y el segundo maneja la recuperación de datos.

---

Ruta de API y función de obtención.

### --feedback--

El primer parámetro representa la fuente de datos y el segundo maneja la recuperación de datos.

---

Punto final y función de obtención.

---

Clave y objeto de configuración.

### --feedback--

El primer parámetro representa la fuente de datos y el segundo maneja la recuperación de datos.

## --video-solution--

3

## --text--

¿Por qué tienes que manejar la lógica de obtención de datos dentro de un `useEffect`?

## --answers--

Porque la obtención de datos solo debe ejecutarse una vez.

### --feedback--

La obtención de datos afecta cosas fuera del componente y no debería bloquear el renderizado.

---

Porque la obtención de datos no debe formar parte del proceso de renderizado.

---

Porque `useEffect` se ejecuta antes de que el componente se renderice.

### --feedback--

La obtención de datos afecta cosas fuera del componente y no debería bloquear el renderizado.

---

Porque useEffect</ code> se ejecuta sincrónicamente con el ciclo de renderizado.</p>

<h3 spaces-before="0">--feedback--</h3>

<p spaces-before="0">La obtención de datos afecta cosas fuera del componente y no debería bloquear el renderizado.</p>

<h2 spaces-before="0">--video-solution--</h2>

<p spaces-before="0">2</p>

<h2 spaces-before="0">--text--</h2>

<p spaces-before="0">¿En qué se basa Axios?</p>

<h2 spaces-before="0">--answers--</h2>

<p spaces-before="0">La API Fetch.</p>

<h3 spaces-before="0">--feedback--</h3>

<p spaces-before="0">Es una API más antigua utilizada para realizar solicitudes HTTP antes de Fetch.</p>

<hr />

<p spaces-before="0">El objeto XMLHttpRequest.</p>

<hr />

<p spaces-before="0">La API WebSocket.</p>

<h3 spaces-before="0">--feedback--</h3>

<p spaces-before="0">Es una API más antigua utilizada para realizar solicitudes HTTP antes de Fetch.</p>

<hr />

<p spaces-before="0">La API DOM.</p>

<h3 spaces-before="0">--feedback--</h3>

<p spaces-before="0">Es una API más antigua utilizada para realizar solicitudes HTTP antes de Fetch.</p>

<h2 spaces-before="0">--video-solution--</h2>

<p spaces-before="0">2</p>
