---
id: 5cc0bd7a49b71cb96132e54c
title: Construye un Generador de Rango de Números
challengeType: 26
dashedName: build-a-range-of-numbers-generator
---

# --description--

En este laboratorio, construirás una función `rangeOfNumbers` que genera un arreglo de números dentro de un rango especificado.

Ejemplos:

- `rangeOfNumbers(3, 9)` devuelve `[3, 4, 5, 6, 7, 8, 9]`
- `rangeOfNumbers(5, 5)` devuelve `[5]`

Requisitos:

- Usa recursión (la función debe llamarse a sí misma)
- No uses bucles ni métodos de arrays (`for`, `while`, `forEach`, `map`, `filter`, `reduce`)

**Objetivo:** Cumplir con las historias de usuario a continuación y pasar todas las pruebas para completar el laboratorio.

**Historias de usuario:**

1. Debes crear una función llamada `rangeOfNumbers` que tome dos parámetros: `startNum` y `endNum`.
1. La función debe devolver un arreglo de enteros que comience con el número representado por el parámetro `startNum` y termine con el número representado por el parámetro `endNum` (inclusive).
1. El `startNum` siempre será menor o igual que el `endNum`.
1. Tu función debe usar recursión llamándose a sí misma. No debe usar ninguna sintaxis de bucle (`for`, `while` o funciones de orden superior como `forEach`, `map`, `filter` o `reduce`).
1. La función debe manejar el caso base donde `startNum` es igual a `endNum` devolviendo un arreglo que contiene solo ese número.
1. Para el caso recursivo, la función debe llamarse a sí misma con parámetros modificados para construir el arreglo, luego agregar el número actual al resultado.
1. La función no debe depender de variables globales para almacenar en caché o construir el array.

# --hints--

Debes tener una función llamada `rangeOfNumbers`.

```js
assert.isFunction(rangeOfNumbers);
```

La función `rangeOfNumbers` debe tomar dos parámetros.

```js
assert.match(rangeOfNumbers.toString(), /rangeOfNumbers\s*\(\s*\w+\s*,\s*\w+\s*\)/);
```

Tu función debe devolver un arreglo.

```js
assert(Array.isArray(rangeOfNumbers(5, 10)));
```

Tu código no debe utilizar bucles (`for`, `while` o funciones de orden superior como `forEach`, `map`, `filter`, o `reduce`).

```js
assert(
  !__helpers.removeJSComments(code).match(/for|while|forEach|map|filter|reduce/g)
);
```

`rangeOfNumbers` debe utilizar recursión (llamadas a sí mismo) para resolver este desafío.

```js
assert(
  rangeOfNumbers.toString().match(/rangeOfNumbers\s*\(.+\)/)
);
```

`rangeOfNumbers(1, 5)` debe devolver `[1, 2, 3, 4, 5]`.

```js
assert.deepStrictEqual(rangeOfNumbers(1, 5), [1, 2, 3, 4, 5]);
```

`rangeOfNumbers(6, 9)` debe devolver `[6, 7, 8, 9]`.

```js
assert.deepStrictEqual(rangeOfNumbers(6, 9), [6, 7, 8, 9]);
```

`rangeOfNumbers(4, 4)` debe devolver `[4]`.

```js
assert.deepStrictEqual(rangeOfNumbers(4, 4), [4]);
```

`rangeOfNumbers(10, 15)` debería devolver `[10, 11, 12, 13, 14, 15]`.

```js
assert.deepStrictEqual(rangeOfNumbers(10, 15), [10, 11, 12, 13, 14, 15]);
```

`rangeOfNumbers(2, 8)` debería devolver `[2, 3, 4, 5, 6, 7, 8]`.

```js
assert.deepStrictEqual(rangeOfNumbers(2, 8), [2, 3, 4, 5, 6, 7, 8]);
```

No debes emplear variables globales para almacenar el array en caché.

```js
rangeOfNumbers(1, 3);
assert.deepStrictEqual(rangeOfNumbers(6, 9), [6, 7, 8, 9]);
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
function rangeOfNumbers(startNum, endNum) {
  if (endNum - startNum === 0) {
    return [startNum];
  } else {
    const numbers = rangeOfNumbers(startNum, endNum - 1);
    numbers.push(endNum);
    return numbers;
  }
}
```
