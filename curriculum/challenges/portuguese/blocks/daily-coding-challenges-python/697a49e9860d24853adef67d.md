---
id: 697a49e9860d24853adef67d
title: "Desafio 192: Jogos de Inverno 2026 Dia 13: Combinado Nórdico"
challengeType: 29
dashedName: challenge-192
---

# --description--

Dado um array de pontuações de salto para atletas, calcule seus tempos de atraso de largada para a parte de cross-country do Nordic Combined.

O atleta com a maior pontuação no salto começa primeiro (0 segundo de atraso). Todos os outros atletas começam depois com base em quanto sua pontuação no salto está atrás da melhor pontuação.

Para calcular o atraso de cada atleta, subtraia a pontuação do salto do atleta da melhor pontuação geral de salto e multiplique o resultado por 1,5. Arredonde o atraso para cima até o inteiro mais próximo.

# --hints--

`calculate_start_delays([120, 110, 125])` deve retornar `[8, 23, 0]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(calculate_start_delays([120, 110, 125]), [8, 23, 0])`)
}})
```

`calculate_start_delays([118, 125, 122, 120])` deve retornar `[11, 0, 5, 8]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(calculate_start_delays([118, 125, 122, 120]), [11, 0, 5, 8])`)
}})
```

`calculate_start_delays([100, 105, 95, 110, 120, 115, 108])` deve retornar `[30, 23, 38, 15, 0, 8, 18]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(calculate_start_delays([100, 105, 95, 110, 120, 115, 108]), [30, 23, 38, 15, 0, 8, 18])`)
}})
```

`calculate_start_delays([130, 125, 128, 120, 118, 122, 127, 115, 132, 124])` deve retornar `[3, 11, 6, 18, 21, 15, 8, 26, 0, 12]`.

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(calculate_start_delays([130, 125, 128, 120, 118, 122, 127, 115, 132, 124]), [3, 11, 6, 18, 21, 15, 8, 26, 0, 12])`)
}})
```

# --seed--

## --seed-contents--

```py
def calculate_start_delays(jump_scores):

    return jump_scores
```

# --solutions--

```py
import math
def calculate_start_delays(jump_scores):
    best_jump = max(jump_scores)
    return [math.ceil((best_jump - score) * 1.5) for score in jump_scores]
```
