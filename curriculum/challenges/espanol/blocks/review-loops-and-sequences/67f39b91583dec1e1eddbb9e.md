---
id: 67f39b91583dec1e1eddbb9e
title: Revisión de Bucles y Secuencias
challengeType: 31
dashedName: review-loops-and-sequences
---

# --description--

## Listas en Python

- **Introducción**: En Python, el tipo de dato lista es una secuencia ordenada de elementos que pueden ser compuestos de cadenas, números o incluso otras listas. Las listas son mutables y tienen índice basado en cero.

```python
cities = ['Los Angeles', 'London', 'Tokyo']
```

- **Acceder a Elementos de una Lista**: Para acceder a un elemento de la lista `cities`, puede referenciar su número de índice en la secuencia:

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[0] # Los Angeles
```

- **Acceder a Elementos Usando Indexación Negativa**: Para acceder al último elemento de cualquier lista, puede usar `-1` como el número de índice:

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[-1] # Tokyo
```

- La indexación negativa se usa para acceder a elementos comenzando desde el final de la lista en lugar del inicio en el índice `0`.

- **Crear Listas Usando el Constructor `list()`**: Las listas también pueden ser creadas usando el constructor `list()`. El constructor `list()` se usa para convertir un iterable en una lista:

```python
developer = 'Jessica'

print(list(developer)) 
# Result: ['J', 'e', 's', 's', 'i', 'c', 'a']
```

- **Encontrar la Longitud de una Lista**: Puede usar la función `len()` para obtener la longitud de una lista:

```python
numbers = [1, 2, 3, 4, 5]
len(numbers) # 5
```

- **Mutabilidad de Listas**: Las listas son mutables, lo que significa que puede actualizar cualquier elemento en la lista siempre que proporcione un número de índice válido. Para actualizar listas en un índice particular, puede asignar un nuevo valor a ese índice:

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[0] = 'JavaScript'
print(programming_languages) # ['JavaScript', 'Java', 'C++', 'Rust']
```

- **Error de Rango de Índice**: Si proporciona un índice (ya sea positivo o negativo) que está fuera de los límites de la lista, entonces recibirá un `IndexError`:

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[10] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
"""
```

- **Eliminar Elementos de una Lista**: Se pueden eliminar elementos de una lista usando la palabra clave `del`:

```python
developer = ['Jane Doe', 23, 'Python Developer']
del developer[1]
print(developer) # ['Jane Doe', 'Python Developer']
```

- **Verificar si un Elemento Existe en una Lista**: La palabra clave `in` puede usarse para verificar si un elemento existe en una lista:

```py
programming_languages = ['Python', 'Java', 'C++', 'Rust']

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **Listas Anidadas**: Las listas pueden anidarse dentro de otras listas:

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
```

- Para acceder a la lista anidada, necesitará acceder usando el índice `2` ya que las listas están indexadas desde cero.

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2] # ['Python', 'Rust', 'C++']
```

- Para acceder a un lenguaje secundario de esa lista anidada, necesitará acceder usando el índice `1`:

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2][1] # Rust
```

- **Desempaquetar Valores de una Lista:** Desempaquetar valores de una lista es una técnica usada para asignar valores de una lista a nuevas variables. Aquí hay un ejemplo para desempaquetar la lista `developer` en nuevas variables llamadas `name`, `age` y `job` así:

```py
developer = ['Alice', 34, 'Rust Developer']
name, age, job = developer
```

- **Recoger el Resto de Elementos de una Lista**: Para recoger cualquier elemento restante de una lista, puede usar el operador asterisco (`*`) de esta manera:

```py
developer = ['Alice', 34, 'Rust Developer']
name, *rest = developer
```

- Si el número de variables en el lado izquierdo del operador de asignación no coincide con el número total de elementos en la lista, entonces recibirá un `ValueError`.

- **Segmentar Listas**: La segmentación es el concepto de acceder a una porción de una lista usando el operador de segmento `:`. Para segmentar una lista que empieza en el índice `1` y termina en el índice `3`, puede usar la siguiente sintaxis:

```python
desserts = ['Cake', 'Cookies', 'Ice Cream', 'Pie']
desserts[1:3] # ['Cookies', 'Ice Cream']
```

- **Intervalos de Paso**: También es posible especificar un intervalo de paso que determine cuánto incrementar entre los índices. Aquí hay un ejemplo si desea extraer una lista de solo números pares usando la segmentación:

```python
numbers = [1, 2, 3, 4, 5, 6]
numbers[1::2] # [2, 4, 6]
```

## Métodos de Lista

- **append()**: Se usa para agregar un elemento al final de la lista. Aquí tienes un ejemplo de cómo usar el método `append()` para agregar el número `6` a esta lista `numbers`:

```py
numbers = [1, 2, 3, 4, 5]
numbers.append(6)
print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **Añadiendo Listas**: El método `append()` también se puede usar para añadir una lista al final de otra:

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.append(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, [6, 8, 10]]
```

- **extend()**: Usado para añadir múltiples ítems al final de una lista. Aquí hay un ejemplo de añadir los números `6`, `8` y `10` al final de la lista `numbers`:

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.extend(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, 6, 8, 10]
```

- **insert()**: Usado para insertar un ítem en un índice específico en la lista. Aquí hay un ejemplo de cómo usar el método `insert()`:

```py
numbers = [1, 2, 3, 4, 5]
numbers.insert(2, 2.5)

print(numbers) # [1, 2, 2.5, 3, 4, 5]
```

- **remove():** Se usa para eliminar un elemento de la lista. El método `remove()` solo eliminará la primera ocurrencia de un elemento en la lista:

```py
numbers = [1, 2, 3, 4, 5, 5, 5]
numbers.remove(5)

print(numbers) # [1, 2, 3, 4, 5, 5]

```

- **pop()**: Usado para eliminar un ítem específico de la lista y devolverlo:

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop(1) # The number 2 is returned
```

- Si no especifica un elemento para el método `pop`, entonces se elimina el último elemento.

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop() # The number 5 is returned
```

- **clear()**: Usado para eliminar todos los ítems de la lista:

```py
numbers = [1, 2, 3, 4, 5]
numbers.clear()

print(numbers) # []
```

- **sort()**: El método `sort()` se usa para ordenar los elementos en su lugar. Aquí hay un ejemplo de cómo ordenar una lista aleatoria de `numbers` en su lugar:

```py
numbers = [19, 2, 35, 1, 67, 41]
numbers.sort()

print(numbers) # [1, 2, 19, 35, 41, 67]
```

- **sorted()**: Usado para ordenar los elementos en una lista y devolver una nueva lista ordenada en lugar de modificar la lista original.

- **reverse()**: Usado para invertir el orden de los elementos en una lista:

```py
numbers = [6, 5, 4, 3, 2, 1]
numbers.reverse()

print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **index()**: Usado para encontrar el primer índice donde se puede encontrar un elemento en una lista:

```python
programming_languages = ['Rust', 'Java', 'Python', 'C++']
programming_languages.index('Java') # 1
```

- Si el elemento no puede ser encontrado usando el método `index()`, entonces el resultado será un `ValueError`.

## Tuplas en Python

- **Definición**: Una tupla es un tipo de dato de Python usado para crear una secuencia ordenada de valores. Las tuplas pueden contener un conjunto mixto de tipos de datos:

```py
developer = ('Alice', 34, 'Rust Developer')
```

- Las tuplas son inmutables, lo que significa que los elementos en la tupla no pueden ser cambiados una vez creados. Si intenta actualizar uno de los elementos en la tupla, obtendrá un `TypeError`:

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')
programming_languages[0] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object does not support item assignment
"""
```

- **Acceder a Elementos de una Tupla**: Para acceder a un elemento de una tupla, use la notación de corchetes y el número de índice:

```py
developer = ('Alice', 34, 'Rust Developer')
developer[1] # 34
```

- La indexación negativa puede ser usada para acceder a elementos comenzando desde el final de la tupla:

```py
numbers = (1, 2, 3, 4, 5)
numbers[-2] # 4
```

- Si intenta pasar un número de índice que excede o iguala la longitud de la tupla, obtendrá un `IndexError`:

```py
numbers = (1, 2, 3, 4, 5)
numbers[7]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: tuple index out of range
"""
```

- Una tupla también puede ser creada usando el constructor `tuple()`. Dentro del constructor, puede pasar diferentes iterables como cadenas, listas e incluso otras tuplas.

```python
developer = 'Jessica'

print(tuple(developer)) 
# Result: ('J', 'e', 's', 's', 'i', 'c', 'a')
```

- **Verificar Ítems en una Tupla**: Para verificar si hay un ítem en una tupla, puede usar la palabra clave `in` de esta manera:

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **Desempaquetar Tuplas**: Los ítems pueden ser desempacados de una tupla así:

```py
developer = ('Alice', 34, 'Rust Developer')
name, age, job = developer
```

- Si necesita recoger cualquier elemento restante de una tupla, puede usar el operador asterisco (`*`) de esta manera:

```py
developer = ('Alice', 34, 'Rust Developer')
name, *rest = developer
```

- **Segmentar Tuplas**: La segmentación puede usarse para extraer una porción de una tupla. Por ejemplo, los ítems `pie` y `cookies` pueden ser segmentados en una tupla separada:

```py
desserts = ('cake', 'pie', 'cookies', 'ice cream')
desserts[1:3] # ('pie', 'cookies')
```

- **Eliminar Ítems de Tuplas**: Eliminar un ítem de una tupla generará un `TypeError` ya que las tuplas son inmutables:

```py
developer = ('Jane Doe', 23, 'Python Developer')
del developer[1]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object doesn't support item deletion
"""
```

- **¿Cuándo usar una Tupla versus una Lista?**: Si necesita una colección dinámica de elementos donde pueda añadir, eliminar y actualizar elementos, entonces debe usar una lista. Si sabe que está trabajando con una colección fija e inmutable de datos, entonces debe usar una tupla.

## Métodos Comunes de Tuplas

- **`count()`**: Usado para determinar cuántas veces aparece un ítem en una tupla. Por ejemplo, puede verificar cuántas veces aparece el idioma `'Rust'` en la tupla:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('Rust') # 2
```

- Si el ítem especificado en la función `count()` no está presente en absoluto en la tupla, entonces el valor de retorno será `0`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('JavaScript') # 0
```

- Si no pasa argumentos a la función `count()`, entonces Python devolverá un `TypeError`.

- **index()**: Usado para encontrar el índice donde un ítem particular está presente en la tupla. Aquí hay un ejemplo de cómo usar el método `index()` para encontrar el índice del lenguaje `'Java'`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.index('Java') # 1
```

- Si el ítem especificado no puede ser encontrado, entonces Python devolverá un `ValueError`.

- Puede pasar un índice de inicio opcional al método `index()` para especificar dónde empezar a buscar el ítem en la tupla:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
programming_languages.index('Python', 3) # 5
```

- También puede pasar un índice de fin opcional al método `index()` para especificar dónde detener la búsqueda del ítem en la tupla:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python', 'JavaScript', 'Python')
programming_languages.index('Python', 2, 5) # 2
```

- **`sorted()`**: Usado para ordenar los elementos en cualquier iterable y devolver una nueva lista ordenada. Aquí hay un ejemplo de cómo crear una nueva lista de números usando la función `sorted()`:

```py
numbers = (13, 2, 78, 3, 45, 67, 18, 7)
sorted(numbers) # [2, 3, 7, 13, 18, 45, 67, 78]
```

- **Modificando el Comportamiento de Ordenación**: Puede personalizar el comportamiento de ordenación para un iterable usando los argumentos opcionales `reverse` y `key`. Aquí hay un ejemplo de cómo usar el argumento `key` para ordenar elementos en una tupla por longitud:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
sorted(programming_languages, key=len)

# Result
# ['C++', 'Rust', 'Java', 'Rust', 'Python', 'Python']
```

- Puede crear una nueva lista de valores en orden inverso, usando el argumento `reverse` así:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')

print(sorted(programming_languages, reverse=True))

# Result
# ['Rust', 'Rust', 'Python', 'Python', 'Java', 'C++']
```

## Bucles en Python

- **Definición**: Los bucles se usan para repetir un bloque de código un número determinado de veces.

- **Bucle `for`**: Se usa para iterar sobre una secuencia (como una lista, tupla o cadena) y ejecutar un bloque de código para cada elemento en esa secuencia. Aquí tienes un ejemplo de cómo usar un bucle `for` para recorrer una lista e imprimir cada idioma en la consola:

```py
programming_languages = ['Rust', 'Java', 'Python', 'C++']

for language in programming_languages:
    print(language)

"""
Result 

Rust
Java
Python
C++
"""
```

- Aquí hay un ejemplo de cómo usar un bucle `for` para recorrer la cadena `code` y escribir cada carácter:

```py
for char in 'code':
    print(char)

"""
Result 

c
o
d
e
"""
```

- Los bucles `for` pueden estar anidados. Aquí hay un ejemplo de cómo usar un bucle `for` anidado:

```py
categories = ['Fruit', 'Vegetable']
foods = ['Apple', 'Carrot', 'Banana']

for category in categories:
    for food in foods:
        print(category, food)

"""
Result

Fruit Apple
Fruit Carrot
Fruit Banana
Vegetable Apple
Vegetable Carrot
Vegetable Banana
"""

```

- **`while` loop**: Repite un bloque de código hasta que la condición sea `False`. Aquí hay un ejemplo de cómo usar un bucle `while` para un juego de adivinanzas:

```py
secret_number = 3
guess = 0

while guess != secret_number:
    guess = int(input('Guess the number (1-5): '))
    if guess != secret_number:
        print('Wrong! Try again.')

print('You got it!')

"""
Result

Guess the number (1-5): 2
Wrong! Try again.
Guess the number (1-5): 1
Wrong! Try again.
Guess the number (1-5): 3
You got it!
"""

```

- **`break` y `continue` statements**: Usados en bucles para modificar la ejecución de un bucle.

- La declaración `break` se usa para salir del bucle inmediatamente cuando una cierta condición se cumple. Aquí hay un ejemplo de cómo usar la declaración `break` para una lista de `developer_names`:

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        break
    print(developer)
```

- La declaración `continue` se usa para saltar la iteración actual y pasar a la siguiente iteración del bucle. Aquí hay un ejemplo para usar la declaración `continue` en lugar de una declaración `break`:

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        continue
    print(developer)
```

- Tanto los bucles `for` como `while` pueden combinarse con una cláusula `else`, que se ejecuta solo cuando el bucle no fue terminado por un `break`:

```python
words = ['sky', 'apple', 'rhythm', 'fly', 'orange']

for word in words:
    for letter in word:
        if letter.lower() in 'aeiou':
            print(f"'{word}' contains the vowel '{letter}'")
            break
    else:
        print(f"'{word}' has no vowels")
```

## Rangos y su Uso en Bucles

- **La función `range()`**: Usada para generar una secuencia de enteros.

```py
range(start, stop, step)
```

- El argumento obligatorio `stop` es un entero (no inclusivo) que representa el punto final para la secuencia de números que se está generando. Aquí hay un ejemplo de cómo usar la función `range()`:

```py
for num in range(3):
    print(num)
```

- Si no se especifica un argumento `start`, entonces el valor predeterminado será `0`. Por defecto, la secuencia de enteros incrementará en `1`. Puedes usar el argumento opcional `step` para cambiar el valor de incremento predeterminado. Aquí tienes un ejemplo de cómo generar una secuencia de enteros pares desde 2 hasta, pero sin incluir, 11 (es decir, incluye 10)

```py
for num in range(2, 11, 2):
    print(num)
```

- Si no proporciona argumentos a la función `range()`, entonces obtendrá un `TypeError`.

- La función `range()` solo acepta enteros como argumentos y no flotantes. Usar flotantes también resultará en un `TypeError`:

```py
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
```

- Puede usar un entero negativo para el argumento `step` para generar una secuencia de enteros en orden decreciente:

```py
for num in range(40, 0, -10):
    print(num)
```

- La función `range()` también puede usarse para crear una lista de enteros usándola con el constructor `list`. El constructor `list` se usa para convertir un iterable en una lista. Aquí hay un ejemplo de cómo generar una lista de enteros pares entre 2 y 10 inclusive:

```py
numbers = list(range(2, 11, 2))
print(numbers) # [2, 4, 6, 8, 10]
```

## Funciones `enumerate()` y `zip()` en Python

- **`enumerate()`**: usada para iterar sobre una secuencia y llevar un seguimiento del índice para cada ítem en esa secuencia. La función `enumerate()` toma un iterable como argumento y devuelve un objeto `enumerate` que consiste en el índice y valor de cada ítem en el iterable.

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

for index, language in enumerate(languages):
    print(f'Index {index} and language {language}')

# Result
# Index 0 and language Spanish
# Index 1 and language English
# Index 2 and language Russian
# Index 3 and language Chinese

```

- La función `enumerate()` también se puede usar fuera de un bucle `for`:

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

print(list(enumerate(languages)))
# [(0, 'Spanish'), (1, 'English'), (2, 'Russian'), (3, 'Chinese')]
```

- La función `enumerate()` también acepta un argumento opcional `start` que especifica el valor inicial para el conteo. Si este argumento es omitido, entonces el conteo comenzará en `0`.

-  **`zip()`** : Se usa para iterar sobre múltiples iterables en paralelo. Aquí tienes un ejemplo usando la función `zip()` para iterar sobre `developers` y `ids`:

```python
developers = ['Naomi', 'Dario', 'Jessica', 'Tom']
ids = [1, 2, 3, 4]

for name, id in zip(developers, ids):
    print(f'Name: {name}')
    print(f'ID: {id}')


"""
Result

Name: Naomi
ID: 1
Name: Dario
ID: 2
Name: Jessica
ID: 3
Name: Tom
ID: 4
"""

```

## Comprehensiones de Lista en Python

- **Definición**: La comprensión de listas le permite crear una nueva lista en una sola línea combinando el bucle y la condición directamente dentro de corchetes cuadrados. Esto hace que el código sea más corto y, a menudo, más fácil de leer.

```py
even_numbers = [num for num in range(21) if num % 2 == 0]
print(even_numbers)
```

## Métodos Iterables

- **`filter()`**: Usado para filtrar elementos de un iterable basado en una condición. Devuelve un iterador que contiene solo los elementos que satisfacen la condición. Aquí hay un ejemplo de cómo crear una nueva lista de sólo palabras con más de cuatro caracteres:

```py
words = ['tree', 'sky', 'mountain', 'river', 'cloud', 'sun']

def is_long_word(word):
    return len(word) > 4

long_words = list(filter(is_long_word, words))
print(long_words) # ['mountain', 'river', 'cloud']
```

- **`map()`**: Usado para aplicar una función a cada ítem en un iterable y devolver un nuevo iterable con los resultados. Aquí hay un ejemplo de cómo usar la función `map()` para convertir una lista de temperaturas en celsius a fahrenheit:

```py
celsius = [0, 10, 20, 30, 40]

def to_fahrenheit(temp):
    return (temp * 9/5) + 32

fahrenheit = list(map(to_fahrenheit, celsius))
print(fahrenheit) # [32.0, 50.0, 68.0, 86.0, 104.0]
```

- **`sum()`**: Usado para obtener la suma de un iterable como una lista o tupla. Aquí hay un ejemplo de cómo usar la función `sum()`:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers)
print(total) # Result: 50
```

- También puede pasar un argumento opcional `start` que establece el valor inicial para la suma. Aquí hay un ejemplo actualizado usando el argumento `start` como un argumento posicional:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, 10) # positional argument
print(total) # 60
```

- También puede optar por usar el argumento `start` como un argumento de palabra clave en lugar de esto:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, start=10) # keyword argument
print(total) # 60
```

## Funciones Lambda

- **Definición**: Una función lambda en Python es una forma concisa de crear una función sin un nombre (una función anónima).
- Las funciones lambda a menudo se usan como argumento para otra función. Aquí hay un ejemplo de una función lambda:

```py
numbers = [1, 2, 3, 4, 5]

even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]
```

- Las mejores prácticas para usar funciones lambda incluyen no asignarlas a una variable, mantenerlas simples y legibles, y usarlas para funciones cortas y puntuales.

# --assignment--

Revise los temas y conceptos de Bucles y Secuencias.
