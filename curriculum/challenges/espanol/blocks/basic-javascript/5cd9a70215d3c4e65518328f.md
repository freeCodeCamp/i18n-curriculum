---
id: 5cd9a70215d3c4e65518328f
title: Utiliza recursión para crear una cuenta regresiva
challengeType: 1
forumTopicId: 305925
dashedName: use-recursion-to-create-a-countdown
---

# --description--

En un <a href="/learn/javascript-algorithms-and-data-structures/basic-javascript/replace-loops-using-recursion" target="_blank" rel="noopener noreferrer nofollow">desafío anterior</a>, aprendiste cómo usar recursión para reemplazar un ciclo `for`. Ahora, veamos una función más compleja que devuelve un arreglo de enteros consecutivos comenzando desde `1` hasta el número pasado a la función.

Como se mencionó enn el desafío anterior, habrá un <dfn>base case</dfn>. El caso base le indica a la función recursiva cuándo ya no necesita llamarse a sí misma. Es un caso simple donde el valor devuelto es ya conocido. También habrá una <dfn>recursive call</dfn> que ejecuta la función original con argumentos diferentes. Si la función está correctamente escrita, el caso base se alcanzará eventualmente.

Por ejemplo, digamos que quieres escribir una función recursiva que devuelve un array con números desde `1` hasta `n`. Esta función necesitará aceptar un argumento, `n`, que represente el número final. Entonces necesitará llamarse a si misma con valores progresivamente más pequeños de `n` hasta alcanzar `1`. Podrías escribir la función de esta forma:

```javascript
function countup(n) {
  if (n < 1) {
    return [];
  } else {
    const countArray = countup(n - 1);
    countArray.push(n);
    return countArray;
  }
}
console.log(countup(5));
```

Se mostrará el valor `[1, 2, 3, 4, 5]` en la consola.

Al principio, esto parece contra intuitivo ya que el valor de `n`*disminuye*, pero los valores en el arreglo final están *incrementando*. Esto sucede porque la inserción sucede de ultimo, después de que la llamada recursiva ha retornado. En el punto donde `n` es insertado en el arreglo, `countup(n - 1)` ya ha sido evaluada y ha retornado `[1, 2, ..., n - 1]`.

# --instructions--

Hemos definido una función llamada `countdown` con un parámetro (`n`). La función debería usar recursividad para retornar un arreglo conteniendo los `n` enteros hasta `1` basado en el parámetro `n`. Si la función es llamada con un numero menor a 1, la función debería retornar un arreglo vacío. Por ejemplo, llamar esta función con `n = 5` debería retornar el arreglo `[5, 4, 3, 2, 1]`. Tu función debe usar recursividad al llamarse a sí misma y no debe usar ciclos de ningún tipo.

# --hints--

`countdown(-1)` debería retornar un arreglo vacío.

```js
assert.isEmpty(countdown(-1));
```

`countdown(10)` debería retornar `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(10), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
```

`countdown(5)` deberia retornar `[5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

Tu código no debe depender de ningún tipo de ciclos (`for`, `while`) o funciones de orden alto tales como `forEach`, `map`, `filter`, y `reduce`).

```js
assert(
  !__helpers.removeJSComments(code).match(/for|while|forEach|map|filter|reduce/g)
);
```

Debes usar recursión para resolver este problema.

```js
assert(
  countdown.toString().match(/countdown\s*\(.+\)/)
);
```

No debes emplear variables globales para almacenar el array en caché.

```js
countdown(1)
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

# --seed--

## --seed-contents--

```js
// Only change code below this line
function countdown(n){
  return;
}
// Only change code above this line
```

# --solutions--

```js
function countdown(n){
   return n < 1 ? [] : [n].concat(countdown(n - 1));
}
```
