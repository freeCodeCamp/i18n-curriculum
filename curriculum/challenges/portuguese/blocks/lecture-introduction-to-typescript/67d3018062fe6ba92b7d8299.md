---
id: 67d3018062fe6ba92b7d8299
title: Como Funcionam os Diferentes Tipos no TypeScript?
challengeType: 19
dashedName: how-do-the-different-types-work-in-typescript
---

# --description--

Você já viu um na lição anterior: `string[]`, que representa um array de strings. Mas como isso realmente funciona?

Para os tipos de dados primitivos `string`, `null`, `undefined`, `number`, `boolean` e `bigint`, o TypeScript oferece palavras-chave de tipo correspondentes. No nosso exemplo, estamos usando esses tipos para anotar nossas variáveis:

```js
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

Agora, declaramos explicitamente `str` como `string` - o que pode parecer confuso porque já atribuímos a ela um valor string, mas essa anotação garante que não podemos reatribuir um tipo de valor diferente (como um número) a essa variável.

Mas e quanto a arrays e objetos? Bem, você já viu a sintaxe para um array! Você pode definir um array de tipo específico com duas sintaxes diferentes:

```js
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

Fundamentalmente, essas duas sintaxes são as mesmas e a escolha entre as duas geralmente é uma questão de preferência.

Objetos ficam um pouco mais complicados. Você pode definir a estrutura exata de um objeto:

```js
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

Esta sintaxe significa que a propriedade `a` deve sempre ser uma string, a propriedade `b` deve sempre ser um número e você não pode adicionar ou remover propriedades.

Mas talvez você não queira restringir as propriedades? Talvez você queira um objeto com quaisquer chaves, mas os valores precisam ser todos strings. Existem duas maneiras de fazer isso:

```js
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

Como os tipos de array, estes são fundamentalmente semelhantes. Com esses tipos de objeto, você deve definir tanto o tipo das chaves e o tipo dos valores. As chaves devem ser sempre strings, mas você pode definir tipos de string personalizados para restringir ainda mais essas chaves.

Além desses tipos, o TypeScript oferece quatro outros tipos úteis. O primeiro é `any`, que indica que um valor pode ter qualquer tipo. Isso é efetivamente o Konami Code do TypeScript - ele diz ao compilador para parar de se importar com o tipo daquela variável e deixar você fazer o que quiser.

O segundo é `unknown`, que geralmente é preferido em relação a `any`. O tipo `unknown` informa ao TypeScript que você se importa com o tipo do valor, mas na verdade não sabe qual é. Se você então tentar realizar ações específicas de tipo (como um operador de subtração ou o método `slice()` para executar uma operação específica de string), o TypeScript esperará que você restrinja o tipo desse valor primeiro.  You'll learn more about type narrowing in an upcoming lesson.

O terceiro é `void`. Este é um tipo especial que você normalmente usará apenas ao definir funções. É efetivamente o oposto de `any` - representa a ausência de qualquer tipo. Funções que não têm valor de retorno, como `console.log()`, têm um tipo de retorno `void`.

Finalmente, existe o tipo `never`. Isso provavelmente é algo que você não usará com frequência - representa um tipo que nunca existirá. Por exemplo, passar um objeto mock para uma função na sua suíte de testes pode ser um bom uso de `never` para indicar que tal objeto nunca seria realmente passado para a função.

Expandindo esses tipos, você tem acesso à palavra-chave `type`. Esta palavra-chave é como `const`, mas em vez de declarar uma variável você pode declarar um tipo:

```js
type myString = string;
```

Isso pode não parecer muito útil por si só, mas quando combinado com tipos union, torna-se poderoso. Um tipo união permite que você combine dois ou mais tipos em um só. Aqui está um exemplo:

```js
type stringOrNumber = string | number;
```

Nosso tipo `stringOrNumber` corresponde a valores que são uma string e valores que são um número. Você pode então combinar seu tipo com outros tipos, como um array:

```js
const stuff: stringOrNumber[] = ["a", 2, "c", 1000];
```

Você também pode definir tipos mais restritos que incluam apenas valores específicos:

```js
type bot = "camperchan" | "camperbot" | "naomi";
type digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
```

Você poderia então combinar esses tipos para criar restrições mais específicas em um objeto:

```js
const artificialIntelligence: Record<bot, digit> = { camperchan: 5 }
```

Embora, se você precisar de mais controle sobre a estrutura de um objeto, é provável que você recorra ao nosso tipo final: `interface`. Interfaces são efetivamente classes, mas para tipos. Eles podem implementar ou estender outras interfaces, são especificamente tipos de objeto e geralmente são preferidos a menos que você precise de um recurso específico oferecido por uma declaração de tipo.

```js
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

Finalmente, funções também podem receber assinaturas de tipo. Na lição anterior, você viu como definir o tipo de um parâmetro específico:

```js
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Mas você também pode definir o tipo de retorno da função.

```js
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Neste exemplo, informamos ao TypeScript que a função deve retornar uma string. Se tentarmos retornar qualquer outra coisa, o TypeScript fornecerá um erro de compilação para nos avisar.

E isso cobre o básico do sistema de tipos do TypeScript. É bastante complexo e tem muitas partes móveis, mas muitas vezes pode ajudar pensar nisso como um espelhamento dos tipos do JavaScript.

# --questions--

## --text--

Qual dos seguintes NÃO é um tipo de dado primitivo em TypeScript?

## --answers--

`string`

### --feedback--

Tipos de dados primitivos são os tipos de dados mais básicos disponíveis em TypeScript.

---

`number`

### --feedback--

Tipos de dados primitivos são os tipos de dados mais básicos disponíveis em TypeScript.

---

`boolean`

### --feedback--

Tipos de dados primitivos são os tipos de dados mais básicos disponíveis em TypeScript.

---

`array`

## --video-solution--

4

## --text--

Qual é o propósito do tipo `unknown` no TypeScript?

## --answers--

Ele permite que qualquer tipo de valor seja atribuído sem verificação de tipo.

### --feedback--

Ao contrário de `any`, `unknown` requer restrição de tipo antes que operações específicas possam ser realizadas.

---

Indica que você não sabe o tipo e precisa refiná-lo antes do uso.

---

Ele representa a ausência de qualquer tipo.

### --feedback--

Ao contrário de `any`, `unknown` requer restrição de tipo antes que operações específicas possam ser realizadas.

---

Ele representa um tipo que nunca existirá.

### --feedback--

Ao contrário de `any`, `unknown` requer restrição de tipo antes que operações específicas possam ser realizadas.

## --video-solution--

2

## --text--

Qual palavra-chave é usada para declarar um tipo personalizado em TypeScript?

## --answers--

`interface`

### --feedback--

Esta palavra-chave é usada para definir um contrato para formatos de objetos, não para declarar tipos personalizados.

---

`type`

---

`custom`

### --feedback--

Isto não é uma palavra-chave válida em TypeScript.

---

`define`

### --feedback--

Isto não é uma palavra-chave válida em TypeScript.

## --video-solution--

2
