---
id: 6895d06b5968736797c408e7
title: 映射（Maps）、哈希映射（Hash Maps）和集合（Sets）如何運作？
challengeType: 19
dashedName: how-do-maps-hash-maps-and-sets-work
---

# --description--

在本課程中，我們將介紹 maps、hash maps 和 sets。但在此之前，讓我們先定義抽象資料型別。

抽象資料型別（ADT）是一種資料型別的概念性表述，包括可以對資料執行的操作以及該資料的屬性。

抽象的資料型別就像藍圖，描述可以執行的 **操作行為** 是什麼，而不是如何執行。它們將介面與操作行為的實作分離。

**map** 是一種抽象資料型態（ADT），以非常特定且高效的方式管理鍵值對組的群集及其操作。

在映射中，每個值都與特定的鍵相關。

映射的一個主要特性是每個鍵必須是唯一的。這種唯一性允許直接查找，使得擷取資訊的處理程序更加高效。

只有鍵必須唯一，值可以重複。

映射抽象資料型別也定義了重要的操作行為，例如插入鍵值對組、取得與鍵相關的值、更新與鍵相關的值、移除鍵值對組，以及檢查映射中是否存在某個鍵。

它實際上並未指定這些操作應該如何執行，只是將它們列為該資料型別可用的操作部分。

**雜湊映射**，也稱為雜湊表，是映射抽象資料型別的一個具體實作。

雜湊映射使用一種稱為「hashing」的技術來非常高效地執行常見的操作行為。

雜湊基本上是透過使用雜湊函式為每個元素產生雜湊值來運作。

雜湊值是根據鍵值對的鍵產生的，並用於計算底層陣列中的索引，該陣列是存放鍵值對的實際資料結構。

但是你可能會問自己：如果兩個鍵產生相同的索引會發生什麼？

哈希映射透過巧妙的策略解決這些碰撞。

一個選項是使用「串鏈」策略，其中每個陣列索引指向一個鏈結串列（另一種資料結構），該鏈結串列儲存所有具有相同索引的元素。

另一種策略是使用「開放定址法」，它涉及根據預定的搜尋序列在陣列中搜尋下一個可用的索引。

雜湊映射的平均情況時間複雜度為插入、檢索和刪除鍵值對組的「常數時間」`O(1)`。

這些操作的最壞情況時間複雜度是線性時間 `O(n)`，當發生大量雜湊碰撞時，必須多次套用碰撞決議策略。

在平均情況下，將元素插入到雜湊映射的空間複雜度是常數 `O(1)`，需要一個常數量的記憶體來儲存新的配對。然而，在最壞情況下，因為底層陣列的調整大小操作，空間複雜度可能是線性的 `O(n)`。一般來說，移除元素的空間複雜度是常數 `O(1)`。

這會將雜湊表變成類似線性資料結構的東西，需要掃描 `n` 個元素才能找到標的鍵。然而，如果雜湊映射被正確實作，這種情況相對罕見。

Python 的 **字典** 在背後是以雜湊映射實作的。

要創建 Python 字典，你只需要在大括號內寫入鍵值對，並用逗號分隔。每個鍵應該用冒號與其對應的值分隔。

```python
my_dictionary = {
  'A': 1,
  'B': 2, 
  'C': 3
}
```

在這段程式碼中，`'A'` 是鍵，`1` 是值：

```python
'A': 1
```

或者，你可以使用 `dict()`：

```python
my_dictionary = dict(A=1, B=2, C=3)
```

你可以透過其對應的鍵取得該值：

```python
my_dictionary['A']  # 1
```

你也可以更新與鍵相關的值：

```python
my_dictionary['A'] = 4
```

你也可以移除一個鍵值配對：

```python
del my_dictionary['A']  
```

你也可以檢查一個鍵是否在字典中（或不在）：

```python
'C' in my_dictionary
```

你可以呼叫這些方法，分別取得字典的鍵、值和項目。

```python
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

太好了。既然你已經更了解 maps 和 hash maps，現在讓我們來談談 sets。

**集合** 是無序且唯一元素的群集。

讓我們將這個概念拆解成其關鍵組件：

* 集合是無序的。集合的元素不會以任何特定順序儲存，因此你無法透過索引來存取它們。
    
* 集合只包含唯一的元素。如果你嘗試添加相同的值兩次，則只會保留該值的一份複本。
    

它們類似於數學中的集合，並且實作相同的集合操作行為，例如交集、聯集（數學）和差集。

集合的主要優點之一是它們保證元素是唯一的（沒有重複）。這就是為什麼它們經常用來從列表和其他資料結構中移除重複項。

它們也是動態的。它們可以根據目前儲存的元素數量進行調整。這使它們相當強大。

新增、移除、取得集合長度以及檢查元素是否在集合中的平均時間複雜度為「常數時間」`O(1)`，這是非常高效的。

由於集合是以雜湊表實作，新增、移除和檢查成員的最壞情況時間複雜度為「線性時間」`O(n)`。當發生多重雜湊碰撞時，雜湊表會轉變成類似線性資料結構，需要掃描 `n` 次才能找到鍵。

在空間複雜度方面，在平均情況下，插入一個元素會有常數複雜度 `O(1)`，新增一個唯一元素需要常數量的記憶體。然而，在最壞情況下，可能會有底層陣列的調整大小操作，這可能需要線性空間複雜度 `O(n)`。一般來說，移除一個元素會花費常數空間複雜度 `O(1)`。

Python 內建有一個 `set` 資料結構，你可以用它在你的程式中操作集合。

在幕後，Python 集合是使用雜湊表實作的，其中只儲存鍵，沒有任何相關的值。

集合只能儲存不可變的資料型別的物件，因為它們的雜湊值總是保持不變。相反地，可變物件的雜湊值在被變更時會改變。這就是為什麼它們不能成為集合的零件。如果集合中儲存的物件的雜湊值改變，程式將無法再找到它。

要在 Python 中定義集合，只需用大括號將元素包圍並用逗號分隔：

```python
numbers = {1, 2, 3, 4}
```

要創建一個空集合，你可以呼叫 `set()`：

```python
numbers = set()
```

請注意，如果你使用空的大括號，這將自動創建一個 Python 字典，而不是集合，因此你必須呼叫 `set()` 函式來創建一個空集合。

你可以使用 `.add()` 方法為集合添加元素：

```python
numbers.add(5)
```

你也可以使用 `.remove()` 方法從集合中移除元素：

```python
numbers.remove(5)
```

如果找不到該元素，這將會丟出 `KeyError`。但如果你不想在那種情況下丟出錯誤，你可以改用 `.discard()` 方法。

`.pop()` 方法會傳回集合中的任意元素，而 `.clear()` 方法會移除集合中的所有元素。

你可以使用 `in` 運算子測試元素是否在集合中：

```python
5 in numbers
```

Python 也支援集合操作，包括聯集、差集、對稱差集和交集，你可以使用這些方法來執行。

```python
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

set_a.union(set_b)
set_a.intersection(set_b)
set_a.symmetric_difference(set_b)
set_a.difference(set_b)
```

或者使用它們的等價運算子：

```python
set_a | set_b
set_a & set_b
set_a ^ set_b
set_a - set_b 
```

新增、移除和測試成員資格的平均情況時間複雜度為「常數時間」`O(1)`。

這些操作的最壞情況時間複雜度是「線性時間」`O(n)`，因為雜湊映射的最壞情況碰撞場景。

你也可以檢查一個集合是否為另一個集合的子集或超集：

```python
set_a.issubset(set_b)
set_a.issuperset(set_b)
```

一般來說，當你需要儲存一個唯一條款的群集並且經常檢查條款是否存在時，應該使用集合。

映射、雜湊映射和集合是強大的資料結構，專為高效的資料組織和檢索而設計。它們各自具有獨特的特性和使用情境。作為開發者，你需要為你的專案選擇最適合的一種。

# --questions--

## --text--

哈希映射（或映射）所儲存的資料型別與集合相比，根本的差異是什麼？

## --answers--

Hash maps 儲存有序的群集，而 Sets 儲存無序的群集。

### --feedback--

思考每個資料結構主要設計來儲存什麼。

---

Hash maps 儲存唯一的鍵值配對，而 Sets 儲存唯一的個別元素。

---

Hash maps 無法儲存重複值，而 Sets 可以。

### --feedback--

思考每個資料結構主要設計來儲存什麼。

---

集合用於數值資料，而雜湊映射用於文字資料。

### --feedback--

思考每個資料結構主要設計來儲存什麼。

## --video-solution--

2

## --text--

允許雜湊映射和集合在插入和查找等操作中達到平均情況 `O(1)`（常數時間）效率的主要機制是什麼？

## --answers--

它們保持所有元素排序，使快速二分搜尋法成為可能。

### --feedback--

思考將元素轉換成索引的特殊函式（程式）。

---

它們將元素儲存在鏈結串列中，允許快速遍歷。

### --feedback--

思考將元素轉換成索引的特殊函式（程式）。

---

他們使用雜湊函式（hash function）來計算元素的直接記憶體位置。

---

它們總是儲存非常少量的元素，使所有操作行為都很快速。

### --feedback--

思考將元素轉換成索引的特殊函式（程式）。

## --video-solution--

3

## --text--

在 `hash maps` 和 `sets` 的背景關係中，什麼是「hash collision」？

## --answers--

當元素在搜尋後成功找到時。

### --feedback--

思考當雜湊函式將不同輸入映射到相同輸出時的結果。

---

當元素被插入到群集的最前端時。

### --feedback--

思考當雜湊函式將不同輸入映射到相同輸出時的結果。

---

當 `hash map` 用盡記憶體且需要調整大小時。

### --feedback--

思考當雜湊函式將不同輸入映射到相同輸出時的結果。

---

當兩個不同的鍵或元素產生相同的 `hash` 值。

## --video-solution--

4
