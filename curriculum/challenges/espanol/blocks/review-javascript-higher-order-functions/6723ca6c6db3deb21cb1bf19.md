---
id: 6723ca6c6db3deb21cb1bf19
title: Revisión de funciones de orden superior de JavaScript
challengeType: 24
dashedName: review-javascript-higher-order-functions
---

# --description--

## Funciones de devolución de llamada y el método `forEach`

- **Definición**: En JavaScript, una función de devolución de llamada es una función que se pasa como argumento a otra función y se ejecuta después de que la función principal ha terminado su ejecución.
- **Método `forEach()`**: Este método se usa para iterar sobre cada elemento en un arreglo y realizar una operación en cada elemento. La función de devolución de llamada en `forEach` puede aceptar hasta tres argumentos: el elemento actual, el índice del elemento actual y el arreglo sobre el que se llamó `forEach`.

```js
const numbers = [1, 2, 3, 4, 5];

// Result: 2 4 6 8 10
numbers.forEach((number) => {
  console.log(number * 2);
});
```

## Funciones de Orden Superior

- **Definición**: Una función de orden superior toma una o más funciones como argumentos y devuelve una función o un valor como resultado.

```js
function operateOnArray(arr, operation) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(operation(arr[i]));
  }
  return result;
}

function double(x) {
  return x * 2;
}

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = operateOnArray(numbers, double);
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
```

- **Método `map()`**: Este método se utiliza para crear un nuevo arreglo aplicando una función dada a cada elemento del arreglo original. La función de devolución de llamada puede aceptar hasta tres argumentos: el elemento actual, el índice del elemento actual y el arreglo sobre el que se llamó `map`.

```js
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);

console.log(numbers); // [1, 2, 3, 4, 5]
console.log(doubled); // [2, 4, 6, 8, 10]
```

- **Método `filter()`**: Este método se utiliza para crear un nuevo arreglo con elementos que pasan una prueba específica, lo que lo hace útil para extraer elementos selectivamente según criterios. Al igual que el método `map`, la función de devolución de llamada para el método `filter` acepta los mismos tres argumentos: el elemento actual que se está procesando, el índice y el arreglo.

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter((num) => num % 2 === 0);

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

- **Método `reduce()`**: Este método se utiliza para procesar un arreglo y condensarlo en un solo valor. Este valor único puede ser un número, una cadena, un objeto o incluso otro arreglo. El método `reduce()` funciona aplicando una función a cada elemento en el arreglo, en orden, pasando el resultado de cada cálculo al siguiente. Esta función a menudo se llama la función reductora. La función reductora toma dos parámetros principales: un acumulador y el valor actual. El acumulador es donde almacenas el resultado acumulado de tus operaciones, y el valor actual es el elemento del arreglo que se está procesando.

```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0
);

console.log(sum); // 15
```

## Encadenamiento de Métodos

- **Definición**: El encadenamiento de métodos es una técnica de programación que te permite llamar a varios métodos sobre el mismo objeto en una sola línea de código. Esta técnica puede hacer que su código sea más legible y conciso, especialmente cuando se realiza una serie de operaciones en el mismo objeto.

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

## Trabajando con el Método `sort`

- **Definición**: El método `sort` se usa para ordenar los elementos de un arreglo y devolver una referencia al arreglo ordenado. No se hace ninguna copia en este caso porque los elementos se ordenan in situ.

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();

console.log(fruits); // ["Apple", "Banana", "Mango", "Orange"]
```

Si necesitas ordenar números, deberás pasar una función de comparación. El método `sort` convierte los elementos en cadenas y luego compara sus secuencias de valores de unidades de código UTF-16. Las unidades de código UTF-16 son los valores numéricos que representan los caracteres en la cadena. Ejemplos de unidades de código UTF-16 son los números 65, 66 y 67, que representan los caracteres "A", "B" y "C" respectivamente. Entonces, el número 200 aparece antes del número 3 en un arreglo, porque la cadena "200" viene antes de la cadena "3" cuando se comparan sus unidades de código UTF-16.

```js
const numbers = [414, 200, 5, 10, 3];

numbers.sort((a, b) => a - b);

console.log(numbers); // [3, 5, 10, 200, 414]
```

Los parámetros `a` y `b` son los dos elementos que se están comparando. La función de comparación debe devolver un valor negativo si `a` debe venir antes de `b`, un valor positivo si `a` debe venir después de `b`, y cero si `a` y `b` son iguales.

## Trabajando con los Métodos `every` y `some`

- **Método `every()`**: Este método prueba si todos los elementos de un arreglo pasan una prueba implementada por una función proporcionada. El método `every()` devuelve `true` si la función proporcionada devuelve `true` para todos los elementos del arreglo. Si cualquier elemento no pasa la prueba, el método devuelve inmediatamente `false` y deja de verificar los elementos restantes.

```js
const numbers = [2, 4, 6, 8, 10];
const hasAllEvenNumbers = numbers.every((num) => num % 2 === 0);

console.log(hasAllEvenNumbers); // true
```

- **Método `some()`**: Este método verifica si al menos un elemento pasa la prueba. El método `some()` devuelve `true` tan pronto como encuentra un elemento que pasa la prueba. Si ningún elemento pasa la prueba, devuelve `false`.

```js
const numbers = [1, 3, 5, 7, 8, 9];
const hasSomeEvenNumbers = numbers.some((num) => num % 2 === 0);

console.log(hasSomeEvenNumbers); // true
```

# --assignment--

Revise los temas y conceptos de funciones de orden superior de JavaScript.
