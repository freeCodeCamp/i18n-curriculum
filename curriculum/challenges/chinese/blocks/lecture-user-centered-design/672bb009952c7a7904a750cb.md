---
id: 672bb009952c7a7904a750cb
title: 设计无限滚动的最佳实践是什么？
challengeType: 19
dashedName: what-are-best-practices-for-designing-infinite-scrolls
---

# --interactive--

**注意**：某些交互示例可能使用你尚未学习的 CSS 和 JavaScript。不要担心尝试理解所有的代码。示例的目的是向你展示这些设计概念的预览，以便你更好地理解事物的工作原理。要查看预览，你需要启用交互式编辑器。

无限滚动是一种设计模式，当用户向下滚动页面时会装载更多内容。通常，这种模式用于像 Twitter 这样的社交媒体网站。例如，如果你已登录并想查看更多推文，你可以向下滚动，更多推文将被装载。这是无限滚动的一个例子。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="infinite-scroll">
  <div class="post">Post 1</div>
  <div class="post">Post 2</div>
  <div class="post">Post 3</div>
  <div class="post">Post 4</div>
  <div class="post">Post 5</div>
  <div class="post">Post 6</div>
  <div class="post">Post 7</div>
  <div class="post">Post 8</div>
  <div class="post">Post 9</div>
  <div class="post">Post 10</div>
  <!-- More posts will load here as the user scrolls down -->
</div>

<script src="index.js"></script>
```

```css
.infinite-scroll {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.post {
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
```

```js
// Simulate loading more content as the user scrolls
window.addEventListener('scroll', () => {
  if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
    loadMorePosts();
  }
});

function loadMorePosts() {
  const container = document.querySelector('.infinite-scroll');
  for (let i = 0; i < 3; i++) {
    const post = document.createElement('div');
    post.className = 'post';
    post.textContent = `Post ${container.children.length + 1}`;
    container.appendChild(post);
  }
}
```

:::

无限滚动也用作分页的替代方案。分页是一种将内容分成多个页面的设计模式。当需要显示大量内容时，通常会使用分页。分页的一个例子是当你在 Google 上进行查找时，你会看到搜索结果分布在多个页面。使用分页时，你必须点击按钮才能进入下一页。使用无限滚动时，你只需不断向下滚动，更多内容就会装载。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="pagination">
  <div class="post">Post 1</div>
  <div class="post">Post 2</div>
  <div class="post">Post 3</div>
  <!-- More posts will be on the next pages -->
</div>
<div class="pagination-controls">
  <button class="prev" disabled>Previous</button>
  <button class="next">Next</button>
</div>
<script src="index.js"></script>
```

```css
.pagination {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.post {
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.pagination-controls {
  margin-top: 12px;
}

.pagination-controls button {
  padding: 8px 16px;
  margin-right: 8px;
}
```

```js
let currentPage = 1;
const postsPerPage = 3;
const totalPosts = 9; 
const totalPages = Math.ceil(totalPosts / postsPerPage);
const container = document.querySelector('.pagination');
const prevButton = document.querySelector('.prev');
const nextButton = document.querySelector('.next'); 

function renderPosts() {
  container.innerHTML = '';
  const start = (currentPage - 1) * postsPerPage;
  const end = start + postsPerPage;
  for (let i = start; i < end && i < totalPosts; i++) {
    const post = document.createElement('div');
    post.className = 'post';
    post.textContent = `Post ${i + 1}`;
    container.appendChild(post);
  }
  prevButton.disabled = currentPage === 1;
  nextButton.disabled = currentPage === totalPages;
}

prevButton.addEventListener('click', () => {
  if (currentPage > 1) {
    currentPage--;
    renderPosts();
  }
});

nextButton.addEventListener('click', () => {
  if (currentPage < totalPages) {
    currentPage++;
    renderPosts();
  }
});

renderPosts();
```

:::

当你将无限滚动整合到你的设计中时，有一些最佳实践需要牢记。第一个考虑是提供一个 `Load More` 按钮，当用户点击它时装载下一组结果。这是让用户控制何时查看更多内容的好方法。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="infinite-scroll">
  <div class="post">Post 1</div>
  <div class="post">Post 2</div>
  <div class="post">Post 3</div>
  <!-- More posts will load when the user clicks "Load More" -->
</div>
<button class="load-more">Load More</button>
<script src="index.js"></script>
```

```css
.infinite-scroll {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.post {
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.load-more {
  margin-top: 12px;
  padding: 8px 16px;
}
```

```js
const loadMoreButton = document.querySelector('.load-more');
const container = document.querySelector('.infinite-scroll');   
loadMoreButton.addEventListener('click', () => {
  loadMorePosts();
});

function loadMorePosts() {
  for (let i = 0; i < 3; i++) {
    const post = document.createElement('div');
    post.className = 'post';
    post.textContent = `Post ${container.children.length + 1}`;
    container.appendChild(post);
  }
}
```

:::

另一个考虑是添加一个“Back”按钮。这使用户能够返回到上一页，而无需滚动回顶部。这创造了更好的用户体验，并赋予他们更多浏览控件。

有时你会看到带有“Back to the top”按钮的设计，该按钮将用户带回结果页面的顶部。另一个考虑是提供一个加载指示器。用户应该清楚地知道正在装载更多内容；否则，他们可能会认为页面出现了故障。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="infinite-scroll">
  <div class="post">Post 1</div>
  <div class="post">Post 2</div>
  <div class="post">Post 3</div>
  <div class="post">Post 4</div>
  <div class="post">Post 5</div>
  <div class="post">Post 6</div>
  <div class="post">Post 7</div>
  <div class="post">Post 8</div>
  <div class="post">Post 9</div>
  <div class="post">Post 10</div>
  <!-- More posts will load here as the user scrolls down -->
</div>

<div class="loading-indicator" style="display: none;">Loading...</div>

<button id="back-to-top" class="back-to-top">↑ Back to Top</button>

<script src="index.js"></script>

```

```css
.infinite-scroll {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.post {
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.loading-indicator {
  margin-top: 12px;
  font-weight: bold;
}

.back-to-top {
  position: fixed;
  bottom: 30px;
  right: 30px;
  display: none;
  padding: 10px 15px;
  background-color: #007BFF;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.back-to-top:hover {
  background-color: #0056b3;
}
```

```js
const container = document.querySelector('.infinite-scroll');
const loadingIndicator = document.querySelector('.loading-indicator');
const backToTopBtn = document.getElementById('back-to-top');

window.addEventListener('scroll', () => {
  if (window.scrollY > 400) {
    backToTopBtn.style.display = 'block';
  } else {
    backToTopBtn.style.display = 'none';
  }

  if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
    loadMorePosts();
  }
});

backToTopBtn.addEventListener('click', () => {
  window.scrollTo({ top: 0, behavior: 'smooth' });
});

function loadMorePosts() {
  loadingIndicator.style.display = 'block';
  setTimeout(() => {
    for (let i = 0; i < 3; i++) {
      const post = document.createElement('div');
      post.className = 'post';
      post.textContent = `Post ${container.children.length + 1}`;
      container.appendChild(post);
    }
    loadingIndicator.style.display = 'none';
  }, 1000);
}
``` 

:::

最后的考虑之一是保持页脚对用户的访问。如果页脚包含重要信息，则应始终对用户可访问。

总之，无限滚动是展示你网站内容的绝佳方式。然而，你应当牢记设计无限滚动时的最佳实践，以便提供最佳的用户体验。

# --questions--

## --text--

什么是无限滚动？

## --answers--

一种更改页面上滚动条的设计模式。

### --feedback--

回顾课程开始时介绍该概念的部分。

---

一种改变页面大小的设计模式。

### --feedback--

回顾课程开始时介绍该概念的部分。

---

一种用于更改页面背景颜色的设计模式。

### --feedback--

回顾课程开始时介绍该概念的部分。

---

一种设计模式，在用户向下滚动页面时装载更多内容

## --video-solution--

4

## --text--

在无限滚动中，`"load more"` 按钮的作用是什么？

## --answers--

它重新装载页面。

### --feedback--

名称暗示了它的作用。

---

为了让用户控制他们何时想查看更多内容。

---

它允许用户返回到之前装载的内容。

### --feedback--

名称暗示了它的作用。

---

它限制了可以装载的数据量。

### --feedback--

名称暗示了它的作用。

## --video-solution--

2

## --text--

在使用无限滚动时，为什么保持页脚可访问很重要？

## --answers--

它有助于使页面上的颜色更加突出。

### --feedback--

考虑用户应当访问哪些信息

---

它有助于使页面装载更快。

### --feedback--

考虑用户应当访问哪些信息

---

保持页脚可访问性并不重要。

### --feedback--

考虑用户应当访问哪些信息

---

这样用户可以随时从页脚访问链接和重要信息。

## --video-solution--

4
