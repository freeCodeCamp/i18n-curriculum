---
id: 587d7b8e367417b2b2512b5d
title: 了解使用命令式程式碼的危險性
challengeType: 1
forumTopicId: 301241
dashedName: understand-the-hazards-of-using-imperative-code
---

# --description--

函式式程式設計是一個良好的習慣。它讓你的程式碼易於管理，並且避免你遇到難以察覺的錯誤。但在我們進入主題之前，讓我們先看看命令式程式設計的方法，以凸顯你可能會遇到的問題。

在英文（以及許多其他語言）中，祈使語氣用於發出命令。同樣地，程式設計中的祈使風格是給電腦一組述語來執行任務。

述語經常會改變程式的狀態，例如更新全域變數。一個經典的例子是撰寫 `for` 迴圈，該迴圈提供精確的指示來迭代陣列的索引。

相較之下，函式式程式設計是一種宣告式程式設計的形式。你透過呼叫方法或函式告訴電腦你想完成的工作。

JavaScript 提供許多預定義的方法來控制常見任務，因此你不需要寫出電腦應該如何執行它們。 例如，你可以呼叫 `map` 方法來控制遍歷陣列的細節，而不是使用上面提到的 `for` 迴圈。 這有助於避免語意錯誤，例如在偵錯章節中涵蓋的「離一錯誤」。

考慮這個情境：你正在瀏覽器中瀏覽網頁，並且想要追蹤你已開啟的分頁。讓我們嘗試使用一些簡單的物件導向程式碼來建模這個情況。

一個 Window 物件由多個分頁組成，且你通常會開啟多個 Window。每個 Window 物件中每個開啟網站的標題都儲存在一個陣列中。在瀏覽器中操作（開啟新分頁、合併視窗和關閉分頁）後，你想要列印仍然開啟的分頁。已關閉的分頁會從陣列中移除，而新的分頁（為簡化起見）會被添加到陣列的末端。

程式碼編輯器顯示此功能的實作，包含 `tabOpen()`、`tabClose()` 和 `join()` 的函式。陣列 `tabs` 是儲存開啟頁面名稱的視窗物件的一部分。

# --instructions--

檢查編輯器中的程式碼。它使用了一個在程式中有副作用的方法，導致行為不正確。最終儲存在 `finalTabs.tabs` 的開啟分頁列表應該是 `['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium', 'new tab', 'Netflix', 'YouTube', 'Vine', 'GMail', 'Work mail', 'Docs', 'freeCodeCamp', 'new tab']`，但程式碼產生的列表略有不同。

更改 `Window.prototype.tabClose`，使其移除正確的分頁。

# --hints--

`finalTabs.tabs` 應該是 `['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium', 'new tab', 'Netflix', 'YouTube', 'Vine', 'GMail', 'Work mail', 'Docs', 'freeCodeCamp', 'new tab']`

```js
assert.deepEqual(finalTabs.tabs, [
  'FB',
  'Gitter',
  'Reddit',
  'Twitter',
  'Medium',
  'new tab',
  'Netflix',
  'YouTube',
  'Vine',
  'GMail',
  'Work mail',
  'Docs',
  'freeCodeCamp',
  'new tab'
]);
```

# --seed--

## --seed-contents--

```js
// tabs is an array of titles of each site open within the window
const Window = function(tabs) {
  this.tabs = tabs; // We keep a record of the array inside the object
};

// When you join two windows into one window
Window.prototype.join = function(otherWindow) {
  this.tabs = this.tabs.concat(otherWindow.tabs);
  return this;
};

// When you open a new tab at the end
Window.prototype.tabOpen = function(tab) {
  this.tabs.push('new tab'); // Let's open a new tab for now
  return this;
};

// When you close a tab
Window.prototype.tabClose = function(index) {

  // Only change code below this line

  const tabsBeforeIndex = this.tabs.splice(0, index); // Get the tabs before the tab
  const tabsAfterIndex = this.tabs.splice(index + 1); // Get the tabs after the tab

  this.tabs = tabsBeforeIndex.concat(tabsAfterIndex); // Join them together

  // Only change code above this line

  return this;
 };

// Let's create three browser windows
const workWindow = new Window(['GMail', 'Inbox', 'Work mail', 'Docs', 'freeCodeCamp']); // Your mailbox, drive, and other work sites
const socialWindow = new Window(['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium']); // Social sites
const videoWindow = new Window(['Netflix', 'YouTube', 'Vimeo', 'Vine']); // Entertainment sites

// Now perform the tab opening, closing, and other operations
const finalTabs = socialWindow
  .tabOpen() // Open a new tab for cat memes
  .join(videoWindow.tabClose(2)) // Close third tab in video window, and join
  .join(workWindow.tabClose(1).tabOpen());
console.log(finalTabs.tabs);
```

# --solutions--

```js
const Window = function(tabs) {
  this.tabs = tabs;
};

Window.prototype.join = function(otherWindow) {
  this.tabs = this.tabs.concat(otherWindow.tabs);
  return this;
};

Window.prototype.tabOpen = function(tab) {
  this.tabs.push('new tab');
  return this;
};

Window.prototype.tabClose = function(index) {
  const tabsBeforeIndex = this.tabs.slice(0, index);
  const tabsAfterIndex = this.tabs.slice(index + 1);

  this.tabs = tabsBeforeIndex.concat(tabsAfterIndex);
  return this;
 };

const workWindow = new Window(['GMail', 'Inbox', 'Work mail', 'Docs', 'freeCodeCamp']);
const socialWindow = new Window(['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium']);
const videoWindow = new Window(['Netflix', 'YouTube', 'Vimeo', 'Vine']);

const finalTabs = socialWindow
  .tabOpen()
  .join(videoWindow.tabClose(2))
  .join(workWindow.tabClose(1).tabOpen());
```
