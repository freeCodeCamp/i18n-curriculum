---
id: 67ed03ac474c48692f41749e
title: 构建哈希表
challengeType: 27
dashedName: build-a-hash-table
saveSubmissionToDB: true
---

# --description--

在本实验中，你将从零开始构建一个哈希表。哈希表是一种保存密钥-值点对的数据结构。哈希表的工作原理是将密钥作为输入，然后根据特定的哈希函数对该密钥进行哈希处理。 

为了本实验的目的，哈希函数将非常简单：它会将密钥中每个字符的 Unicode 值相加。然后，哈希值将作为实际的密钥来保存关联的值。相同的哈希值也将用于检索和删除与密钥关联的值。

**目标：**实现以下用户需求并通过所有测试以完成实验。

**用户故事：**

1. 你应该定义一个名为 `HashTable` 的类，该类具有一个 `collection` 属性，在创建 `HashTable` 的新实例时初始化为空字典。`collection` 字典应根据密钥的哈希值保存键值对。

2. `HashTable` 类应有四个实例方法：`hash`、`add`、`remove` 和 `lookup`。

3. `hash` 方法应当：

    - 将字串作为参数。
    - 返回一个哈希值，该值是字串中每个字符的 Unicode（ASCII）值之和计算得出。你可以使用 `ord` 函数进行此计算。

4. `add` 方法应当：
    - 接受两个表现密钥-值点对的参数，并计算密钥的哈希值。
    - 使用计算出的哈希值作为密钥，将包含键值点对的字典保存到 `collection` 字典中。
    - 如果多个密钥产生相同的哈希值，它们的密钥-值点对应存储在该哈希值下现有的嵌套字典中。

5. `remove` 方法应当：

    - 将密钥作为其参数并计算其哈希值。
    - 确认密钥是否存在于集合中。
    - 从哈希表中移除对应的密钥-值点对。
    - 如果密钥不存在于集合中，不应引起误差或删除任何内容。

6. `lookup` 方法应当：

    - 将一个密钥作为它的参数。
    - 计算密钥的哈希值，并返回存储在哈希 `table` 中的对应值。
    - 如果密钥不存在于集合中，它应返回 `None`。

# --hints--

你应该定义一个 `HashTable` 类。

```js
({ 
    test: () => assert(runPython(`
    _Node(_code).has_class("HashTable")
    `)) 
})
```

当 `HashTable` 类的新实例被创建时，其 `collection` 属性应初始化为空字典。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.collection == {}
    `) 
})
```

`HashTable` 类应具有一个 `hash` 方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('hash')`))}})
```

`hash` 方法应接受一个字串作为参数。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.hash)
    len(sig.parameters) == 1
  `))
})
```

`hash` 方法应接受一个字串作为其参数，并返回该字串中每个字符的 Unicode 值之和。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("fcc")
        assert hash_result == 300

        # prevent hardcoding
        assert ht.hash("golf") == 424
        assert ht.hash("read") == 412
`) })
```

`HashTable` 类应有一个 `add` 方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('add')`))}})
```

`add` 方法应接受一个密钥和一个值作为参数。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.add)
    len(sig.parameters) == 2
  `))
})
```

`HashTable` 类应具有一个 `remove` 方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('remove')`))}})
```

`remove` 方法应将密钥作为参数。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.remove)
    len(sig.parameters) == 1
  `))
})
```

当你尝试从集合中移除不存在的密钥时，不应引起误差或移除任何内容。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        ht.add("rose", "flower")
        index = ht.hash("rose")
        original = ht.collection.copy()

        ht.remove("tulip")
        ht.remove("sore")

        assert ht.collection == original
        assert "rose" in ht.collection[index]
        assert "tulip" not in ht.collection.get(index, {})
    `) 
})
```

如果多个密钥哈希到相同的索引，`remove` 方法应仅删除特定的键值点对，而不是删除该索引处的整个字典。

```js
({
  test: () => runPython(`
    ht = HashTable()
    ht.add("rose", "flower")
    ht.add("sore", "pain")  # "rose" and "sore" both hash to the same index

    index = ht.hash("rose")
    ht.remove("rose")

    assert index in ht.collection
    assert "rose" not in ht.collection[index]
    assert "sore" in ht.collection[index]
    assert ht.collection[index]["sore"] == "pain"
  `)
})
```

`HashTable` 类应具有一个 `lookup` 方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('lookup')`))}})
```

`lookup` 方法应将密钥作为参数。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.lookup)
    len(sig.parameters) == 1
  `))
})
```

`HashTable().hash('golf')` 应该返回 `424`。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("golf")
        assert hash_result == 424

        # prevent hardcoding
        assert ht.hash("dear") == 412
        assert ht.hash("cat") == 312
    `) 
})
```

`HashTable().add('golf', 'sport')` 应该将该键值点对添加到键为 `424` 的集合中。

```js

({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")
    expected_value = {424: {'golf': 'sport'}}

    assert ht.collection == expected_value
    `) 
})
```

`HashTable().add('dear', 'friend')` 和 `HashTable().add('read', 'book')` 应该将这两个点对作为嵌套字典添加到索引为 `412` 的集合中。

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("dear", "friend")
    ht.add("read", "book")

    expected_value = {
        "dear": "friend",
        "read": "book"
    }

    assert ht.collection.get(412) == expected_value
    `) 
})
```

当哈希表中存在某个密钥时，`remove()` 方法应从集合中移除该密钥及其对应的值。

```js
({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")

    expected_value_before_removal = {
        "golf": "sport"
    }

    index = ht.hash("golf")

    assert ht.collection.get(index) == expected_value_before_removal

    ht.remove("golf")

    assert "golf" not in ht.collection.get(index, {})
    `) 
})
```

当哈希表中存在 `'golf', 'sport'` 密钥-值点对时，`HashTable().lookup('golf')` 应该返回 `sport`。

```js
({ 
    test: () => runPython(`
    ht = HashTable()

    ht.add("golf", "sport")

    expected_value = "sport"
    assert ht.lookup("golf") == expected_value
    `) 
})

```

当集合中不存在 `'golf', 'sport'` 点对时，`HashTable().lookup('golf')` 应该返回 `None`。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.lookup("golf") is None
`) })

```

当集合中存在 `'fcc'` 密钥时，`HashTable().lookup('cfc')` 应该返回 `None`。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        ht.add("fcc", "coding")
        assert ht.lookup("cfc") is None
`) })
```

当你将 `('rose', 'flower')` 添加到哈希表时，它的 `collection` 属性应如下所示：`{ 441: { 'rose': 'flower' }}`。

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("rose", "flower")

    expected_value = {
        "rose": "flower"
    }

    assert ht.collection.get(441) == expected_value

    # prevent hardcoding

    ht2 = HashTable()

    ht2.add("kebab", "food")
    expected_value = {
        "kebab": "food"
    }

    assert ht2.collection.get(501) == expected_value
    `)
})
```

当你添加一个哈希值与现有密钥相同的密钥时，比如 `fcc` 和 `cfc`，`collection` 应该如下所示：`{ 300: { 'fcc': 'coding', 'cfc':  'chemical' }}`。

```js
({ 
    test: () => runPython(`
 
    ht = HashTable()

    ht.add("fcc", "coding")
    ht.add("cfc", "chemical")

    expected_value = {
        "fcc": "coding",
        "cfc": "chemical"
    }

    assert ht.collection.get(300) == expected_value

    # prevent hardcoding

    ht2 = HashTable()
    ht2.add("cat", "animal")
    ht2.add("act", "verb")

    expected_value = {
        "cat": "animal",
        "act": "verb"
    }

    assert ht2.collection.get(312) == expected_value
    `)
})
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
class HashTable:
    def __init__(self):
        self.collection = {}

    def hash(self, string):
        hashed = 0
        for char in string:
            hashed += ord(char)  
        return hashed

    def add(self, key, val):
        the_hash = self.hash(key)
        if the_hash not in self.collection:
            self.collection[the_hash] = {}
        self.collection[the_hash][key] = val

    def remove(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            del self.collection[the_hash][key]
            if not self.collection[the_hash]: 
                del self.collection[the_hash]

    def lookup(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            return self.collection[the_hash][key]
        return None
```
