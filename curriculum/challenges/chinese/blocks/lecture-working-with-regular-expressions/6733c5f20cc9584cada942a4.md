---
id: 6733c5f20cc9584cada942a4
title: 什么是捕获组和反向引用，它们如何工作？
challengeType: 19
dashedName: what-are-capturing-groups-and-backreferences-and-how-do-they-work
---

# --interactive--

捕捉组允许你“捕捉”匹配字串的一部分，以便你根据需要使用。捕捉组由包含要捕捉的模式的括号定义，且没有像前瞻这样的前导字符。

让我们从我们的 `freeCodeCamp` 正则表达式中捕捉 `code`。为此，我们将在括号中括起 `code` 并将其定义为一个捕捉组：

```js
const regex = /free(code)camp/i;
```

为了确认行为，我们可以针对 `freecodecamp` 字串进行测试：

:::interactive_editor

```js
const regex = /free(code)camp/i;
console.log(regex.test("freecodecamp")); // true
```

:::

但这实际上并没有使用我们的捕捉组。相反，让我们来看一下使用 `match` 的结果：

```js
const regex = /free(code)camp/i;
console.log("freecodecamp".match(regex));
// [
//   'freecodecamp',
//   'code', <--
//   index: 0,
//   input: 'freecodecamp',
//   groups: undefined
// ]
```

这里我们可以看到我们的 `match` 数组有第二个元素，它是被我们的捕捉组捕捉到的字串部分。

注意捕捉组如何匹配精确的模式 `code`，而字符类则匹配来自列表 `c`、`o`、`d` 和 `e` 的单个字符。

但是我们如何实际使用它呢？捕捉组通常在替换字串内容时使用。让我们设置一些代码来实现这一点。我们将把 `freecodecamp` 变成 `paidcodeworld`：

:::interactive_editor

```js
const regex = /free(code)camp/i;
console.log("freecodecamp".replace(regex, "paidcodeworld"));
```

:::

这可以单独工作，但如果我们不知道 `code` 中有多少个 `o` 呢？如果我们需要一个表示一个或多个 `o` 的量词：

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paidcodeworld"));
```

:::

我们得到的结果是 `paidcodeworld`。我们想保留 `o` 的数量，所以需要重用正则表达式捕捉到的内容。

这就是反向引用的用武之地。我们可以直接引用捕捉到的分组，而不是硬编码替换字串中的 `code` 部分。

在一次 `replace` 调用中，你通过使用美元符号（`$`）后跟要使用的捕捉组编号来实现反向引用。在我们的分支中，那将是 `$1`，因为 `code` 被捕捉在第一个捕捉组中：

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world")); // paidcoooooooodeworld
```

:::

我们现在已经成功地在将 `freecodecamp` 转换为 `paidcodeworld` 时保留了未知数量的 `o` 字符。但引用不仅限于替换调用。你实际上可以直接在正则表达式中使用它们。

这将允许你在正则表达式中稍后匹配先前捕捉的模式。

假设我们想匹配 `freecodecamp` 两次，且 `o` 的数量相同，但可以出现在字串的任何位置。

首先，我们需要用我们的通配符字符将它们分开，并允许任意数量的字符匹配该通配符：

```js
const regex = /free(co+de)camp.*free(co+de)camp/i;
```

不过，这个当前的表达式不会确保 `o` 字符的数量相同。为实现这一点，我们需要将第二个捕捉组替换为对第一个的引用。

在正则表达式中，引用用一个斜线后跟捕捉组的编号表示：

:::interactive_editor

```js
const regex = /free(co+de)camp.*free\1camp/i;
console.log(regex.test("freecooooodecamp is great i love freecooooodecamp")); // true
console.log(regex.test("freecooooodecamp is great i love freecodecamp")); // false
```

:::

由此，我们可以看到，具有正确数量 `o` 的字串是匹配的，而具有两个不同数量 `o` 的字串则不匹配。

这种语法很棒，但当你引用多个捕捉组时，很快就会变得混乱。幸运的是，你可以不给组使用数字，而是为你的组命名。

要定义一个命名捕捉组，你需要在组的开头添加一个问号（`?`），后跟用尖括号括起来的名称。让我们将捕捉组命名为 `code`：

```js
const regex = /free(?<code>co+de)camp.*free\1camp/i;
```

现在我们可以更新正则表达式中的反向引用以引用该分组。在 JavaScript 中，命名反向引用以斜线开头，后跟字母 `k`。然后你添加名称，同样用小于号（`<`）和大于号（`>`）括起来。让我们来看一下：

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
```

现在如果我们查看我们的 `test()` 调用，我们可以看到我们仍然通过：

:::interactive_editor

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
console.log(regex.test("freecooooodecamp is freecooooodecamp")); // true
```

:::

要在 `replace()` 调用中使用我们的命名捕捉组，我们需要在字串中插入一个美元符号，后跟用尖括号括起来的名称：

:::interactive_editor

```js
const regex = /free(?<code>co+de)camp/i;
console.log("freecooooodecamp".replace(regex, "paid$<code>camp")); // paidcooooodecamp
```

:::

最后，有时你想创建一组字符，但不需要捕捉的结果。

假设我们想匹配 `freecodecamp` 或 `freecandycamp`。你可以创建两个由 OR 断言分隔的模式：

```js
const regex = /freecodecamp|freecandycamp/i;
```

但对于更大规模的正则表达式，这可能会变得相当冗长。相反，你可以为你需要进行 OR 操作的字符创建一个非捕获组：

```js
const regex = /free(?:code|candy)camp/i;
```

非捕获组不会将 `code|candy` 匹配单独保存到内存中。但它对于创建替代模式而不牺牲可读性或性能是有帮助的。

# --questions--

## --text--

如何在正则表达式中创建命名捕获组？

## --answers--

`(name:pattern)`

### --feedback--

本课描述了用于命名捕捉组的特定语法，涉及尖括弧。

---

`(?<name>pattern)`

---

`(?name:pattern)`

### --feedback--

本课描述了用于命名捕捉组的特定语法，涉及尖括弧。

---

`(name=>pattern)`

### --feedback--

本课描述了用于命名捕捉组的特定语法，涉及尖括弧。

## --video-solution--

2

## --text--

在 `replace()` 方法中，你如何在替换字串中引用第一个捕获组？

## --answers--

`\1`

### --feedback--

本课提到使用特定符号后跟数字来引用替换调用中的捕捉组。

---

`$1`

---

`{1}`

### --feedback--

本课提到使用特定符号后跟数字来引用替换调用中的捕捉组。

---

`[1]`

### --feedback--

本课提到使用特定符号后跟数字来引用替换调用中的捕捉组。

## --video-solution--

2

## --text--

正则表达式中非捕获组的目的是什么？

## --answers--

捕捉一个组但不将其存储在 `memory` 中

### --feedback--

本课描述了与创建替代模式相关的非捕获分组的特定使用分支。

---

创建替代模式而不牺牲可读性或性能

---

为捕获组命名

### --feedback--

本课描述了与创建替代模式相关的非捕获分组的特定使用分支。

---

引用先前捕捉的分组

### --feedback--

本课描述了与创建替代模式相关的非捕获分组的特定使用分支。

## --video-solution--

2
