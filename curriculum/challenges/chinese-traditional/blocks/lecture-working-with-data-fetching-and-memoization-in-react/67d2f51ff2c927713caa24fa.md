---
id: 67d2f51ff2c927713caa24fa
title: useCallback 掛鉤和 React.memo 如何運作？
challengeType: 19
dashedName: how-do-the-usecallback-hook-and-react-memo-work
---

# --description--

在上一課中，你學習了記憶化以及 `useMemo` 掛鉤的運作方式。

在本課程中，你將學習 `useCallback` 掛鉤和 `React.memo` 的運作方式。

在上一課中，我們也提到 `useCallback` 是用來記憶函式的引用。

對於 `React.memo`，它讓你將組件記憶化，以防止當其 prop 未改變時發生不必要的重新呈現。

以下是 `useCallback` 掛鉤的基本語法：

```js
const handleClick = useCallback(() => {
  // code goes here
}, [dependency]);
```

以下是 `React.memo` 的基本語法：

```jsx
const MemoizedComponent = React.memo(({ prop }) => {
  return (
    <>
      {/* Presentation */}
    </>
  )
});
```

讓我們來看一個 `useCallback` 掛鉤的範例：

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount((prevCount) => prevCount + 1);
  };

  useEffect(() => {
    console.log("useEffect runs");
  }, [handleClick]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```

在組件中，因為 `handleClick` 函式（程式）在每次呈現時都會被重新生成，所以效果會在 `handleClick` 變更時執行。

為了解決這個問題，你需要告訴 React 使用 `useCallback` 掛鉤將 `handleClick` 函式（程式）記憶化，使其在多次呈現中被視為相同的東西，這樣它就不會被重新生成：

```jsx
import { useState, useEffect, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  // Memoize the handleClick function with useCallback
  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  useEffect(() => {
    console.log("useEffect runs");
  }, [handleClick]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```

現在 `handleClick` 函式（程式）不會在每次呈現時重新生成。

為了向你展示 `React.memo`（或 `memo`）高階函式與 `useCallback` 掛鉤如何協同運作，這裡有一個帶有 `handleClick` 函式的 `Counter` 組件，該函式需要 `useCallback`，但目前尚未使用它：

```jsx
import { useState, useEffect, useCallback } from "react";
import CounterChild from "./CounterChild";

function Counter() {
  const [count, setCount] = useState(0);
  const [timer, setTimer] = useState(new Date().toLocaleTimeString());

  const handleClick = () => {
    setCount(count + 1);
  };

  useEffect(() => {
    const interval = setInterval(() => {
      setTimer(new Date().toLocaleTimeString());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return (
    <div>
      <h1>Time: {timer}</h1>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
      <CounterChild onClick={handleClick} />
    </div>
  );
}

export default Counter;
```

這個函式（程式）在狀態中也有一個計時器，會每秒更新一次。這使得組件在每次 `timer` 變更時重新呈現，並且 `handleClick` 函式（程式）會在每次呈現時重新生成。

這就是為什麼需要用 `useCallback` 對 `handleClick` 進行記憶化。

這是 `CounterChild` 組件：

```jsx
const CounterChild = ({ onClick }) => {
  console.log("CounterChild component rendered");
  return <button onClick={onClick}>Increment from Child</button>;
};

export default CounterChild;
```

這個 `CounterChild` 組件接受一個 `onClick` 屬性，讓你也能從它那裡遞增計數器。

由於 `CounterChild` 組件是 `Counter` 組件的子組件，因此每當 `Counter` 因計時器變化而重新呈現時，`CounterChild` 也會重新呈現。所以，`CounterChild` 也需要被記憶化。

如果沒有記憶化，因為組件會因計時器每秒更新而重新呈現，`CounterChild` 組件也會被重新呈現。

為防止這種情況，你需要使用 `React.memo` 對 `CounterChild` 組件進行記憶化：

```jsx
import React from "react";

const CounterChild = React.memo(({ onClick }) => {
  console.log("CounterChild component rendered");
  return <button onClick={onClick}>Increment from Child</button>;
});

export default CounterChild;
```

即使使用 `React.memo` 對 `CounterChild` 進行記憶化後，事情仍未達到最佳效能。

這是因為 `handleClick` 函式（程式）在每次呈現時都會被重新生成，所以它也需要用 `useCallback` 進行記憶化，以告訴 React 你需要該函式（程式）在多次呈現中保持不變：

```js
const handleClick = useCallback(() => {
  setCount((prevCount) => prevCount + 1);
}, [count]);
```

現在，只有當 `count` 狀態改變時，組件才會重新呈現。

# --questions--

## --text--

`useCallback` 掛鉤記憶了什麼？

## --answers--

計算值。

### --feedback--

它有助於防止在每次 `render` 時創建新的函式實體。

---

函式引用。

---

組件呈現。

### --feedback--

它有助於防止在每次 `render` 時創建新的函式實體。

---

狀態更新。

### --feedback--

它有助於防止在每次 `render` 時創建新的函式實體。

## --video-solution--

2

## --text--

以下哪一個是 `useCallback` 掛鉤的正確語法？

## --answers--

```js
const handleClick = useCallback(() => { /* code */ });
```

### --feedback--

第二個引數應該是一個依賴項的陣列。

---

```js
const handleClick = useCallback(() => { /* code */ }, dependency);
```

### --feedback--

第二個引數應該是一個依賴項的陣列。

---

```jsx
const handleClick = useCallback(() => { /* code */ }, [dependency]);
```

---

```js
const handleClick = useCallback(() => { dependency }, {});
```

### --feedback--

第二個引數應該是一個依賴項的陣列。

## --video-solution--

3

## --text--

`React.memo` 記憶了什麼？

## --answers--

函式引用。

### --feedback--

當 `props` 保持不變時，它可防止重新呈現。

---

組件狀態。

### --feedback--

當 `props` 保持不變時，它可防止重新呈現。

---

組件根據未改變的 props 進行呈現。

---

DOM 元素。

### --feedback--

當 `props` 保持不變時，它可防止重新呈現。

## --video-solution--

3
