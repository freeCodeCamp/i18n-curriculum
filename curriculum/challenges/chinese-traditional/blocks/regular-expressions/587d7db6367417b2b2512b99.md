---
id: 587d7db6367417b2b2512b99
title: 匹配出現一次或多次的字元
challengeType: 1
forumTopicId: 301350
dashedName: match-characters-that-occur-one-or-more-times
---

# --description--

有時候，你需要匹配連續出現一次或多次的字元（或字元群組）。這表示它至少出現一次，並且可能重複出現。

你可以使用 `+` 字元來檢查是否為該情況。請記住，字元或樣式必須連續出現。也就是說，字元必須一個接著一個重複。

例如，`/a+/g` 會在 `abc` 中找到一個符合項目並傳回 `["a"]`。因為有 `+`，它也會在 `aabc` 中找到一個符合項目並傳回 `["aa"]`。

如果改為檢查字串 `abab`，它會找到兩個符合項並傳回 `["a", "a"]`，因為 `a` 字元並非連續－中間有一個 `b`。最後，由於字串 `bcd` 中沒有 `a`，它不會找到符合項。

# --instructions--

你想要尋找在 `Mississippi` 中字母 `s` 出現一次或多次的匹配。請撰寫一個使用 `+` 符號的正規表達式。

# --hints--

你的正規表達式 `myRegex` 應該使用 `+` 符號來匹配一個或多個 `s` 字元。

```js
assert(/\+/.test(myRegex.source));
```

你的正則表達式 `myRegex` 應該匹配 2 項目。

```js
assert(result.length == 2);
```

`result` 變數應該是一個包含兩個 `ss` 匹配項的陣列。

```js
assert(result[0] == 'ss' && result[1] == 'ss');
```

# --seed--

## --seed-contents--

```js
let difficultSpelling = "Mississippi";
let myRegex = /change/; // Change this line
let result = difficultSpelling.match(myRegex);
```

# --solutions--

```js
let difficultSpelling = "Mississippi";
let myRegex = /s+/g; // Change this line
let result = difficultSpelling.match(myRegex);
```
