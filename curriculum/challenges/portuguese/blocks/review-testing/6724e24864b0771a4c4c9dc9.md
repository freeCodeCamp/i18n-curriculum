---
id: 6724e24864b0771a4c4c9dc9
title: Revisão de Testes
challengeType: 31
dashedName: review-testing
---

# --description--

## Testes Manuais e Automatizados

- **Teste Manual**: No teste manual, um testador irá manualmente passar por cada parte da aplicação e testar diferentes funcionalidades para garantir que funcionem corretamente. Se algum bug for descoberto durante o processo de teste, o testador irá reportar esses bugs para a equipe de software para que possam ser corrigidos.
- **Testes Automatizados**: Em testes automatizados, você pode automatizar seus testes escrevendo um programa separado que verifica se sua aplicação se comporta conforme o esperado.

## Teste Unitário

- **Testes Unitários**: Nos testes unitários, você testa cada função para garantir que tudo está funcionando conforme o esperado. Os testes unitários também podem servir como uma forma de documentação para sua aplicação porque eles são destinados a representar o comportamento esperado do seu código.
- **Princípio da Responsabilidade Única**: O princípio da responsabilidade única recomenda manter cada função pequena e responsável por uma única coisa.
- **Frameworks Comuns de Testes em JavaScript**: Alguns frameworks comuns de teste incluem Jest, Mocha e Vitest. Jest é um framework popular de teste para testes unitários.

Aqui está um exemplo de testes unitários usando Jest.

Primeiro, você pode criar uma função que seja responsável por retornar uma string recém formatada:

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

Em um arquivo separado `getFormattedWord.test.js`, você pode escrever alguns testes para verificar se a função está funcionando conforme o esperado. O arquivo `getFormattedWord.test.js` ficará assim:

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **Função `expect`**: A função `expect` é usada para testar um valor.
- **Matcher**: Matcher é uma função que verifica se o valor se comporta conforme o esperado. No exemplo acima, o matcher é `toBe()`. O Jest possui uma variedade de matchers.

Para usar Jest, você primeiro precisa instalar o pacote `jest` usando `npm i jest`. Você também precisará adicionar um script ao seu arquivo `package.json` assim:

```js
"scripts": {
  "test": "jest"
},
```

Então, você pode executar o comando `npm run test` para rodar seus testes.

## Ciclo de Vida do Desenvolvimento de Software

- **Diferentes Estágios do Ciclo de Vida do Desenvolvimento de Software**:
  - **Fase de Planejamento**: A equipe de desenvolvimento coleta os requisitos para o trabalho proposto dos stakeholders.
  - **Fase de Design**: A equipe de software divide os requisitos e decide as melhores abordagens para as soluções.
  - **Fase de Implementação**: A equipe de software divide os requisitos em tarefas gerenciáveis e as implementa.
  - **Fase de Testes**: Isso envolve testes manuais e automatizados para o novo trabalho. Às vezes, a equipe testa a aplicação durante toda a fase de desenvolvimento para identificar e corrigir quaisquer problemas que surgirem.
  - **Fase de Implantação**: A equipe implanta as novas alterações em um ambiente de build ou de teste.
  - **Estágio de Manutenção**: Isso envolve corrigir quaisquer problemas que surgirem dos clientes na aplicação em produção.

- **Diferentes Modelos do Ciclo de Vida do Desenvolvimento de Software**:
  - **Modelo Waterfall**: O modelo Waterfall é onde cada fase do ciclo de vida precisa ser concluída antes que a próxima fase possa começar.
  - **Modelo Ágil**: O modelo Ágil foca no desenvolvimento iterativo dividindo o trabalho em sprints.

## BDD e TDD

- **TDD**: Desenvolvimento orientado a testes é uma metodologia que enfatiza escrever testes primeiro. Escrever testes antes de desenvolver funcionalidades fornece feedback em tempo real para os desenvolvedores durante o processo de desenvolvimento.
- **BDD**: Desenvolvimento orientado por comportamento é a abordagem de alinhar uma série de testes com os objetivos de negócio. Os cenários de teste em BDD devem ser escritos em uma linguagem que possa ser entendida tanto por pessoas técnicas quanto não técnicas. Um exemplo dessa sintaxe é Gherkin.
- **Frameworks de Teste BDD**: Exemplos de frameworks de teste BDD incluem Cucumber, JBehave e SpecFlow.

## Asserções em Testes Unitários

- **Assertion**: As assertions são usadas para testar se o código está se comportando conforme o esperado.
- **Bibliotecas de Asserção**: Chai é uma biblioteca de asserção comumente usada. Outras bibliotecas comuns de asserção em JavaScript são `should.js` e `expect.js`.

Aqui está um exemplo de uma asserção usando Chai que verifica se o valor retornado da função `addThreeAndFour` é igual ao número 7:

```js
assert.equal(addThreeAndFour(), 7);
```

- **Melhores Práticas**: Independentemente da biblioteca de asserção que você usar, você deve escrever mensagens claras de assert e falha que o ajudarão a entender quais testes estão falhando e por quê.

## Mocking, Faking e Stubbing

- **Mocking**: Mocking é o processo de substituir dados reais por dados falsos que simulam o comportamento de componentes reais. Por exemplo, você pode mockar a resposta da API em testes em vez de fazer chamadas contínuas à API para obter os dados.
- **Stubbing**: Stubs são objetos que retornam respostas pré-definidas ou dados fictícios para um comportamento esperado em uma aplicação. Por exemplo, você pode stubar o comportamento de uma conexão de banco de dados em seus testes sem precisar depender de uma conexão real com o banco de dados.
- **Faking**: Fakes are simplified versions of real components without the complexity or side effects.Por exemplo, você pode simular um banco de dados armazenando os dados na memória em vez de interagir com o banco de dados real.Isso permitirá que você simule operações de banco de dados na memória, o que será muito mais rápido do que lidar com o banco de dados real.

## Teste Funcional

- **Teste Funcional**: O teste funcional verifica se os recursos e funções da aplicação funcionam conforme o esperado. O objetivo do teste funcional é testar o sistema como um todo contra múltiplos cenários.
- **Teste Não Funcional**: O teste não funcional foca em aspectos como desempenho e confiabilidade.
- **Teste de fumaça**: Teste de fumaça é uma verificação preliminar no sistema para problemas básicos ou críticos antes de iniciar testes mais extensos.

## Teste de ponta a ponta

- **Testes de Ponta a Ponta**: Testes de ponta a ponta, ou E2E, testam cenários do mundo real sob a perspectiva do usuário. Testes de ponta a ponta ajudam a garantir que sua aplicação se comporte corretamente e seja previsível para os usuários. No entanto, é demorado configurar, projetar e manter.
- **Frameworks de Teste de Ponta a Ponta**: Playwright é um framework popular de teste de ponta a ponta desenvolvido pela Microsoft. Outros exemplos de ferramentas de teste de ponta a ponta incluem Cypress, Selenium e Puppeteer.

Aqui está um exemplo de testes E2E da base de código do freeCodeCamp usando Playwright. O hook `beforeEach` será executado antes de cada um dos testes. Os testes verificam se o doador possui um link de apoiador na barra de menu, assim como uma borda estilizada especial ao redor do avatar:

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## Teste de Usabilidade

- **Teste de Usabilidade**: Teste de usabilidade é quando você tem usuários reais interagindo com a aplicação para descobrir se há algum problema de design, experiência do usuário ou funcionalidade no app. O teste de usabilidade foca na intuitividade da aplicação pelos usuários.
- **Quatro Tipos Comuns de Testes de Usabilidade**:
  - **Explorative**: Testes de usabilidade exploratórios envolvem os usuários interagindo com os diferentes recursos da aplicação para entender melhor como eles funcionam.
  - **Comparativo**: Teste comparativo é quando você compara a experiência do usuário da sua aplicação com aplicações similares no mercado.
  - **Avaliação**: Testes de avaliação são onde você estuda o quão intuitivo é usar a aplicação.
  - **Validação**: Testes de validação são onde você identifica quaisquer problemas graves que impedirão o usuário de usar a aplicação de forma eficaz.
- **Ferramentas de Teste de Usabilidade**: Exemplos de ferramentas para teste de usabilidade incluem Loop11, Maze, Userbrain, UserTesting e UXTweak.

## Teste de Compatibilidade

- **Teste de Compatibilidade**: O objetivo do teste de compatibilidade é garantir que sua aplicação funcione em diferentes ambientes computacionais.
- **Diferentes Tipos de Testes de Compatibilidade**:
  - **Compatibilidade Retroativa**: Compatibilidade retroativa refere-se a quando o software é compatível com versões anteriores.
  - **Compatibilidade com versões futuras**: Compatibilidade com versões futuras refere-se a quando o software e os sistemas funcionarão com versões futuras.
  - **Compatibilidade de Hardware**: Compatibilidade de hardware é a capacidade do software de funcionar corretamente em diferentes configurações de hardware.
  - **Compatibilidade de Sistemas Operacionais**: A compatibilidade de sistemas operacionais é a capacidade do software de funcionar em diferentes sistemas operacionais, como macOS, Windows e distribuições Linux como Ubuntu e Fedora.
  - **Compatibilidade de Rede**: Compatibilidade de rede significa que o software pode funcionar em diferentes condições de rede, como diferentes velocidades de rede, protocolos, configurações de segurança, etc.
  - **Compatibilidade entre Navegadores**: Compatibilidade entre navegadores significa que a aplicação web pode funcionar de forma consistente em diferentes navegadores, como Google Chrome, Safari, Firefox etc.
  - **Compatibilidade Móvel**: É importante garantir que suas aplicações de software funcionem em uma variedade de dispositivos Android e iOS, incluindo telefones e tablets.

## Teste de Desempenho

- **Teste de Desempenho**: No teste de desempenho, você testa a velocidade, a capacidade de resposta, a escalabilidade e a estabilidade de uma aplicação sob diferentes cargas de trabalho. O objetivo é resolver qualquer tipo de gargalo de desempenho.
- **Diferentes Tipos de Testes de Desempenho**:
  - **Teste de Carga**: O teste de carga determina como um sistema se comporta durante períodos de carga normal e máxima.
  - **Teste de Estresse**: Teste de estresse é quando você testa sua aplicação em cargas extremas e verifica quão bem seu sistema responde à carga maior.
  - **Soak Testing (Endurance Testing)**: Soak testing ou endurance testing é um tipo de teste de carga onde você testa o sistema com uma carga maior por um período prolongado.
  - **Teste de Pico**: Teste de pico é quando você aumenta e diminui dramaticamente as cargas e analisa as reações do sistema às mudanças.
  - **Teste de Ponto de Interrupção (Teste de Capacidade)**: O teste de ponto de interrupção ou teste de capacidade é quando você aumenta lentamente a carga ao longo do tempo até o ponto em que o sistema começa a falhar ou degradar.

## Teste de Segurança

- **Testes de Segurança**: Testes de segurança ajudam a identificar vulnerabilidades e pontos fracos.
- **Princípios de Segurança**:
  - **Confidencialidade**: Isso protege contra o vazamento de informações sensíveis para outros destinatários que não sejam o destinatário pretendido.
  - **Integridade**: Isso envolve impedir que usuários mal-intencionados modifiquem informações do usuário.
  - **Autenticação**: Isso envolve verificar a identidade do usuário para garantir que ele tenha permissão para usar aquele sistema.
  - **Autorização**: Este é o processo de determinar quais ações os usuários autenticados têm permissão para executar ou quais partes do sistema eles podem acessar.
  - **Disponibilidade**: Isso garante que informações e serviços estejam disponíveis para usuários autorizados quando eles precisarem.
  - **Não Repúdio**: Isso garante que tanto o remetente quanto o destinatário tenham prova da entrega e verificação da identidade do remetente. Protege contra o remetente negar ter enviado a informação.
- **Ameaças Comuns à Segurança**:
  - **Cross-Site Scripting (XSS)**: Ataques de XSS acontecem quando um invasor injeta scripts maliciosos em uma página web e então os executa no contexto do navegador da vítima.
  - **SQL Injection**: SQL injection permite que usuários mal-intencionados injetem código malicioso em um banco de dados.
  - **Ataque de Negação de Serviço (DoS)**: Ataque DoS ocorre quando usuários maliciosos inundam um site com um alto número de requisições ou tráfego, fazendo com que o servidor fique lento e possivelmente trave, tornando o site indisponível para os usuários. 
- **Categorias de Ferramentas de Teste de Segurança**:
  - **Teste Estático de Segurança de Aplicações**: Essas ferramentas avaliam o código-fonte de uma aplicação para identificar vulnerabilidades de segurança.
  - **Teste Dinâmico de Segurança de Aplicações**: Essas ferramentas interagem com o frontend da aplicação para descobrir possíveis vulnerabilidades de segurança. As ferramentas DAST não têm acesso ao código-fonte.
- **Penetration Testing (pentest)**: Penetration testing é um tipo de teste de segurança que envolve a criação de ataques cibernéticos simulados na aplicação para identificar quaisquer vulnerabilidades no sistema.

## Teste A/B

- **Teste A/B**: O teste A/B envolve comparar duas versões de uma página ou aplicação e estudar qual versão tem melhor desempenho. Também é conhecido como teste bucket ou split. O teste A/B permite que você tome decisões mais baseadas em dados e melhore continuamente a experiência do usuário.
- **Ferramentas para Testes A/B**: Exemplos de ferramentas para usar em testes A/B incluem GrowthBook e LaunchDarkly.

## Teste Alpha e Beta

Uma vez que o desenvolvimento inicial e os testes de software estejam completos, é importante que a aplicação seja testada por testadores e usuários reais.É aqui que entram os testes alpha e beta.

- **Teste Alfa**: O teste alfa é realizado por um grupo seleto de testadores que percorrem a aplicação para garantir que não haja bugs antes de ser lançada no mercado. O teste alfa faz parte do teste de aceitação e utiliza técnicas de teste de caixa branca e preta.
- **Teste Beta**: O teste beta é quando a aplicação é disponibilizada para usuários reais. Os usuários podem interagir com a aplicação e fornecer feedback. O teste beta também é uma forma de teste de aceitação do usuário.
- **Teste de Aceitação**: O teste de aceitação garante que a aplicação de software atenda aos requisitos de negócio e às necessidades dos usuários antes de seu lançamento.
- **Teste de Caixa Preta**: O teste de caixa preta foca apenas no comportamento esperado da aplicação.
- **Teste de Caixa Branca**: O teste de caixa branca envolve o testador conhecer os componentes internos e realizar testes neles.

## Teste de Regressão

- **Regressão**: Regressão refere-se a situações em que novas alterações quebram involuntariamente funcionalidades existentes.
- **Teste de Regressão**: O teste de regressão ajuda a identificar problemas de regressão. No teste de regressão, você executa novamente os testes funcionais em partes da sua aplicação para garantir que tudo ainda funcione conforme o esperado.
- **Ferramentas para Testes de Regressão**: Ferramentas que você pode usar para realizar testes de regressão incluem Puppeteer, Playwright, Selenium e Cypress.
- **Técnicas para Testes de Regressão**: 
  - **Teste de Regressão Unitário**: É quando você tem uma lista de itens que precisam ser testados toda vez que mudanças ou correções importantes são implementadas no app.
  - **Teste de Regressão Parcial**: Isso envolve abordagens direcionadas para garantir que novas alterações não tenham quebrado aspectos específicos da aplicação.
  - **Teste de Regressão Completo**: Isso executa testes contra todas as funcionalidades na base de código. Esta é a opção mais demorada e detalhada.
- **Retesting**: Retesting é usado para verificar problemas conhecidos e garantir que eles foram resolvidos. Em contraste, regression testing busca por problemas desconhecidos que possam ter ocorrido por meio de mudanças recentes na codebase.

# --assignment--

Revise os tópicos e conceitos de Testing.
