---
id: 68829162a7f96d73c8505d3d
title: O que são conflitos de merge e como você pode resolvê-los?
challengeType: 19
dashedName: what-are-merge-conflicts-and-how-can-you-resolve-them
---

# --description--

Se você já esteve perto de desenvolvedores experientes, seja em uma comunidade online ou pessoalmente, provavelmente já ouviu falar dos "temidos conflitos de merge". Mas o que exatamente eles são?

Bem, quando você está usando uma estratégia de branching adequada como discutimos nas lições anteriores, você pode estar trabalhando em duas funcionalidades diferentes em dois branches diferentes ao mesmo tempo. Ou talvez você esteja trabalhando em algo e um colega esteja trabalhando em outro branch. De qualquer forma, você tem duas mudanças independentes acontecendo. Mas às vezes, ambos os branches vão editar o mesmo arquivo. E se o outro branch for mesclado no `main` primeiro, as mudanças do seu branch agora estão desatualizadas.

Na maioria das vezes, isso pode ser corrigido mesclando `main` de volta para sua branch de feature. Mas quando as alterações da outra branch entram em conflito com sua branch, o Git não consegue determinar quais alterações você deseja manter durante uma mesclagem. Isso é chamado de "merge conflict".

Mas como você pode corrigir isso? Bem, para conflitos menores e mais simples, o GitHub fornecerá uma interface web para corrigir. Um botão "Resolve conflicts" aparecerá na parte inferior de um PR se houver conflitos. Se você clicar nele, verá o arquivo com conflitos que inclui seu código e o código conflitante. O Git adicionará "merge conflict markers" ao redor do seu código e do código conflitante para ajudar a identificar o problema. Parece algo assim:

```sh
1 <<<<<<< feat/conflict
2 Here's some code from my first PR :)
3 =======
4 Here's some code that was merged to main that conflicts with the code on my PR
5 >>>>>>> main
```

O marcador de abertura é o `<<<<<<< feat/conflict` e indica o início das alterações que nossa branch atual está fazendo. Depois vemos o `Here's some code from my first PR :)`. Em seguida vem o marcador `=======`, que indica o fim das nossas alterações e o início das alterações da branch `main`. Podemos ver que as alterações feitas em `main` são a linha `Here's some code that was merged to main that conflicts with the code on my PR`. E depois disso vem o marcador de fechamento `>>>>>> main` para mostrar o fim dos conflitos.

Mas como corrigimos isso? Bem, você precisa decidir quais alterações deseja manter como parte dos conflitos de merge. Se quiser manter ambas as alterações, pode remover apenas os marcadores de conflito e deixar as alterações inalteradas. Alternativamente, se quiser manter as alterações de apenas um branch, você deve excluir os marcadores de conflito e as alterações do outro branch (aquelas que você não deseja manter). E finalmente, se não gostar de nenhuma das alterações, pode remover tudo desde o marcador de abertura até o marcador de fechamento (inclusive).

Vamos remover as alterações da branch `main`, mas manter as nossas. Aqui está o que temos agora:

```sh
1 Here's some code from my first PR :)
```

Clique no botão "Mark as resolved", que informa ao GitHub que você está satisfeito com sua resolução. Se houvesse arquivos adicionais, o GitHub mudaria para o próximo. Mas como este é nosso único arquivo com conflito, você verá um botão "Commit merge" aparecer. Clique nesse botão e o GitHub criará um merge commit para você. Você será levado de volta ao pull request, onde verá seu novo merge commit e os conflitos resolvidos. E está tudo pronto!

Mas e se você não puder editar os conflitos diretamente no GitHub, porque eles são muito complexos?

Bem, se seu branch tiver poucos commits ou apenas alguns commits modificarem aquele arquivo, você poderá conseguir mesclar `main` no seu branch:

```sh
git checkout feat/conflict
git fetch origin
git merge origin/main
```

À medida que o Git processa esse merge, você terá conflitos para resolver manualmente. O Git notificará quais arquivos precisam ser corrigidos. Quando abrimos os arquivos com conflitos no nosso editor, vemos os mesmos marcadores de conflito, com algumas adições úteis na interface graças ao VSCode. Vá em frente e corrija os conflitos no arquivo da mesma forma. Mas desta vez, precisaremos criar o commit manualmente. É o mesmo que criar qualquer outro commit:

```sh
git add .
git commit -m "chore: resolve conflicts"
```

Após executar esses comandos, podemos ver que o Git aceitou nossa resolução.

Às vezes, quando você tem muitos commits ou conflitos, um rebase pode ser útil. Em vez de mesclar as alterações, um rebase pega todos os commits no seu branch e os reaplica para que venham depois das alterações mais recentes em `main`. Em termos do Git, isso efetivamente "reseta" a base do seu branch para o commit mais recente em `main`.

Para experimentar isso, precisamos de uma nova branch:

```sh
git checkout main
git pull
git checkout -b feat/rebase
```

Vamos em frente e gerar vários commits para nossa branch, para que possamos praticar rebasing:

```sh
echo "change one" > README.md
git add .
git commit -m "change one"
echo "change two" > README.md
git add .
git commit -m "change two"
echo "change three" > README.md
git add .
git commit -m "change three"
```

Agora, vamos fazer outra alteração em `main` para criar um conflito:

```sh
git checkout main
echo "change four" > README.md
git add .
git commit -m "change four"
```

E confira nossa branch rebase:

```sh
git checkout feat/rebase
```

Em seguida, execute `git rebase -i main`. Isso irá rebasear nossa branch para o estado atual da branch `main`. A flag `-i` informa ao Git para realizar um rebase em modo interativo. Você verá seus commits com a palavra `pick` ao lado deles. `pick` informa ao Git para usar o commit como está para o rebase. Salve e feche o arquivo, e receberemos uma mensagem de erro informando que há conflitos.

Nosso commit `change one` conflita com o commit `change four` e precisamos resolver isso. Abra o arquivo no seu editor e você verá a mesma interface que tivemos com os conflitos anteriormente. Vamos manter as alterações do `change one`. Depois, você precisará executar `git add .` para adicionar as alterações e `git rebase --continue` para informar ao Git que estamos prontos para continuar o rebase. Como resolvemos o conflito no primeiro commit, o Git pode lidar automaticamente com o rebase dos commits restantes.

Agora, só como uma última limpeza, vamos juntar nossos três commits de alteração em um único commit para um histórico mais limpo. Execute `git rebase -i main` novamente para abrir o editor. Então, deixe o primeiro comando como `pick` mas mude os dois seguintes para `squash`. Você pode encontrar o mesmo conflito novamente. Se isso acontecer, resolva da mesma forma que fez antes. Depois de resolver e continuar o rebase (ou imediatamente, se não houve conflito), você verá um novo editor de mensagem de commit aparecer. Essa mensagem será seu novo commit, contendo as alterações dos três commits que juntamos. Vamos nomear este como `change three complete`. Salve e feche o editor, e o Git finalizará o rebase.

Se verificarmos seu histórico de commits agora, podemos ver que agora temos nosso único commit `change three complete`, e ele está corretamente baseado no commit `change four`. Isso significa que você completou com sucesso um rebase com commits squashados! E agora você tem as ferramentas que precisa para se tornar um campeão em conflitos de merge!

# --questions--

## --text--

Quais são os marcadores de conflito de merge que o Git adiciona para ajudar a identificar mudanças conflitantes?

## --answers--

`<<< current branch`, `=== separator`, `>>> other branch`

### --feedback--

Pense na sintaxe específica que o Git usa para marcar o início, meio e fim dos conflitos.

---

`[[ current branch`, `|| separator`, `]] other branch`

### --feedback--

Pense na sintaxe específica que o Git usa para marcar o início, meio e fim dos conflitos.

---

`<<<<<<< current branch`, `======= separator`, `>>>>>>> other branch`

---

`--- current branch`, `+++ separator`, `--- other branch`

### --feedback--

Pense na sintaxe específica que o Git usa para marcar o início, meio e fim dos conflitos.

## --video-solution--

3

## --text--

Após resolver manualmente um conflito de merge no seu repositório local, quais comandos você precisa executar para completar o merge?

## --answers--

`git push origin main` e `git rebase -i origin/main`

### --feedback--

Após resolver os conflitos, você precisa preparar e commitar as alterações resolvidas assim como qualquer outro commit.

---

`git add` e `git commit`

---

`git merge --abort` e `git commit`

### --feedback--

Após resolver os conflitos, você precisa preparar e commitar as alterações resolvidas assim como qualquer outro commit.

---

`git reset --hard` e `git push -f`

### --feedback--

Após resolver os conflitos, você precisa preparar e commitar as alterações resolvidas assim como qualquer outro commit.

## --video-solution--

2

## --text--

Qual é a principal diferença entre merging e rebasing ao lidar com conflitos de branch?

## --answers--

A mesclagem cria um novo commit, enquanto o rebase reescreve o histórico para colocar seus commits após os commits da outra branch.

---

Rebase é mais rápido do que merge.

### --feedback--

Considere como cada operação afeta o histórico de commits.

---

A fusão só pode ser feita no GitHub, o rebase deve ser feito localmente.

### --feedback--

Considere como cada operação afeta o histórico de commits.

---

Não há diferença, é a mesma operação.

### --feedback--

Considere como cada operação afeta o histórico de commits.

## --video-solution--

1
