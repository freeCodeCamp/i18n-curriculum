---
id: 6553a572f7a65718f1e42e18
title: 步骤 49
challengeType: 20
dashedName: step-49
---

# --description--

函数本质上是可重复使用的代码块。 你已经遇到了一些内置的函数，如 `print()`, `find()` 和 `len()`。 但你也可以定义如下的自定义功能：

```py
def function_name():
    <code>
```

函数声明以 `def` 关键字开始，然后是函数名称——一个有效的变量名称——和一对括号。 声明以冒号结束。

在 `shift` 变量之后，声明一个名为 `caesar` 的函数，并缩进以下所有行以为新函数提供主体。

# --hints--

你应该使用 `def` 关键词来声明一个新的函数。

```js
assert.match(code, /^def\s+/m)
```

你应该在 `def` 关键字之后将 `caesar` 作为函数名称。 记得在 `def` 之后添加一个空格。

```js
assert.match(code, /^def\s+caesar/m)
```

你应该在函数名称后添加一对括号。 不要忘记最后的冒号。

```js
assert.match(code, /^def\s+caesar\s*\(\s*\)\s*:/m)
```

你应该在 `shift = 3` 之后缩进所有行，以便它们成为你的新函数结构。

```js
({ test: () => {
    const commentless_code = __helpers.python.removeComments(code);
    const {def} = __helpers.python.getDef(commentless_code, "caesar");    
    const replacement = def.replace(/print\s*\(\s*("|')plain\stext:\1\s*,\s*text\s*\)\s*print\s*\(\s*("|')encrypted\stext:\2\s*,\s*encrypted_text\s*\)/, "return encrypted_text")
    const py_code = `
text = "Hello Zaira"
shift = 3
${replacement}
caesar()
`
    const out = runPython(py_code, {});
    assert.equal(out, "khoor cdlud");
  }
})
```

# --seed--

## --seed-contents--

```py
--fcc-editable-region--
text = 'Hello Zaira'
shift = 3

alphabet = 'abcdefghijklmnopqrstuvwxyz'
encrypted_text = ''

for char in text.lower():
    if char == ' ':
        encrypted_text += char
    else:
        index = alphabet.find(char)
        new_index = (index + shift) % len(alphabet)
        encrypted_text += alphabet[new_index]
print('plain text:', text)
print('encrypted text:', encrypted_text)
--fcc-editable-region--
```
