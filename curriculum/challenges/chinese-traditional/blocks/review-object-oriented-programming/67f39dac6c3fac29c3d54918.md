---
id: 67f39dac6c3fac29c3d54918
title: 物件導向的程式設計複習
challengeType: 31
dashedName: review-object-oriented-programming
---

# --description--

## 什麼是物件導向程式設計？

- **物件導向程式設計**：一種程式設計風格，開發者將程式碼中的所有事物視為真實世界的物件。它通常被稱為 OOP。幫助你有效組織和管理程式碼的四大關鍵原則是 **封裝**、**繼承**、**多型** 和 **抽象體**。
- **類別**：用於創建物件的藍圖。每個由類別創建的物件都有定義資料的屬性和決定物件行為的方法。

## 什麼是封裝？

- **封裝**：將物件的屬性和方法封裝成一個單一單元。它讓你能夠將物件的內部狀態隱藏在一組簡單的公開方法和屬性背後，這些方法和屬性就像門一樣。在這些門的背後是私有的屬性和方法，控制資料如何變更以及誰可以看到它。
- **封裝範例**：如果你想追蹤錢包餘額，你會允許存款和提款，但你不會想讓任何人竄改錢包餘額本身：

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

- **單底線與雙底線前置式屬性之間的差異**：為屬性和方法前置單底線表示它們是供內部使用的。這是一種慣例，並不會強制禁止從外部存取屬性。為屬性和方法前置雙底線則有效防止它們被從類別外部存取。

## 什麼是取值函式和設值函式？

- **取值函式和設值函式**：讓你控制類別屬性如何被存取和修改的方法。你使用取值函式來取得值，使用設值函式來設定值。
- **屬性**：它們連接取值函式和設值函式，並允許存取資料。當你取得、設定或刪除值時，它們會在幕後執行額外邏輯。
- **為什麼使用屬性而非方法**：屬性用於取代方法，以提升可讀性和程式碼整潔度。它們讓你像存取一般屬性一樣，使用點記法存取值，而不需要小括弧。
- **創建取值函式**：要創建取值函式，你使用 `@property` 裝飾器。這裡有一個取得圓半徑的取值函式：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

- **創建設值函式**：為了創建將設定半徑的設值函式，你必須定義另一個同名的方法，並在其上方使用 `@<property_name>.setter`：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

- **Python 如何控制取值函式和設值函式**：一旦你定義了取值函式和設值函式，Python 在你以這種方式使用一般屬性語法時，會自動在背後呼叫它們：

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

 當設定值時，你不應該指定給屬性名稱本身，因為那會導致 `RecursionError`。請使用一個獨立的內部名稱，通常帶有底線，來儲存該值。

- **Deleter**：在使用設值函式和取值函式設定及取得值之後，你可以使用 `deleter` 控制它如何被刪除。當你對屬性使用 `del` 述語時，deleter 會執行訂製邏輯。要創建 deleter，你需要使用 `@<property_name>.deleter` 裝飾器。

```py
  # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

## 什麼是繼承以及它如何促進程式碼重複使用？

- **繼承**：子類別使用父類別的屬性和方法的處理程序。繼承促進程式碼重複使用，提供清晰的階層結構，並且在不重寫所有內容的情況下自訂行為。要實作繼承，子類別需接收父類別的名稱：

```py
class Parent:
    # Parent attributes and methods

class Child(Parent):
    # Child inherits, extends, and/or overrides where necessary
```

- **單一繼承和多重繼承**：當子類別從單一父類別繼承屬性和方法時，如上所示，該處理程序稱為**單一繼承**。當子類別從多個父類別繼承屬性和方法時，則稱為**多重繼承**。以下是其語法：

```py
class Parent:
    # Attributes and methods for Parent

class Child:
    # Attributes and methods for Child

class GrandChild(Parent, Child):
    # GrandChild inherits from both Parent and Child
    # GrandChild can combine or override behavior from each
```

- **`super()` 函式**：一個讓你在子類別中改寫父類別方法的函式。

## 什麼是多型以及它如何促進程式碼重複使用？

- **多型**：物件導向程式設計的原則，讓不同的類別使用相同的行為名稱，但每個類別在被呼叫時會以不同方式實作。以下是它的語法：

```py
class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # Works for A, B, or C
```

- **基於繼承的多型**：父類別設定一個方法，而每個子類別都會將它調整為自己的用途。

## 什麼是 Name Mangling 以及它如何運作？

- **名稱改寫**：Python 內部將以雙底線為前置式的屬性重新命名的處理程序，方法是加上一個底線和類別名稱作為前置式，將 `__attribute` 變成 `_ClassName__attribute`。
- **名稱改編的目的**：名稱改編的主要目的是在你使用繼承時防止意外的屬性和方法覆寫。以下是一段讓這點更容易理解的程式碼：

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

## 什麼是抽象性以及它如何幫助保持複雜系統的組織性？

- **抽象性**：一種程式設計概念，其中物件或系統的複雜實作細節被隱藏，僅顯示必要的特性。在 Python 和其他程式語言中，抽象性透過提高可重複使用性來簡化複雜系統。
- **抽象性的範例**：生活中抽象性的好範例是汽車讓你只使用方向盤、踏板和排檔桿，而不需要知道引擎或煞車如何運作。
- **Python 如何實作抽象性**：Python 透過 `abc` 模組實作抽象性。該模組提供 `ABC` 類別（抽象的基礎類別）和 `@abstractmethod` 裝飾器。抽象的基礎類別（ABC）定義子類別必須實作的共用方法和屬性。它無法被具現化。
- **抽象方法的定義方式**：抽象方法是以 `@abstractmethod` 定義，且即使有預設實作，也必須在子類別中覆寫。抽象性的基本語法如下：

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

# --assignment--

複習物件導向的程式設計主題和概念。
