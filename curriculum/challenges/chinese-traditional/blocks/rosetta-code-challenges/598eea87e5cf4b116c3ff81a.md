---
id: 598eea87e5cf4b116c3ff81a
title: 梅森數的因數
challengeType: 1
forumTopicId: 302264
dashedName: factors-of-a-mersenne-number
---

# --description--

梅森數是形如 <code>2<sup>P</sup>-1</code> 的數字。

如果 `P` 是質數，則 Mersenne 數可能是 Mersenne 質數。（如果 `P` 不是質數，則 Mersenne 數也不是質數。）

在尋找梅森質數時，透過在開始可能冗長的 <a href="https://rosettacode.org/wiki/Lucas-Lehmer test" target="_blank" rel="noopener noreferrer nofollow">Lucas-Lehmer test</a> 之前找到一個小因數來消除指數是有利的。

有非常高效的演算法用於判斷一個數字是否整除 <code>2<sup>P</sup>-1</code>（或等價地，判斷 <code>2<sup>P</sup> mod (the number) = 1</code>）。

某些語言已經內建此指數與取模運算（稱為 modPow 或類似名稱）的實作。

以下是如何自己實作這個 modPow：

例如，讓我們計算 <code>2<sup>23</sup> mod 47</code>。

將指數 23 轉換成二進位，你會得到 10111。從 <code><tt>square</tt> = 1</code> 開始，反覆平方它。

移除指數的最高位元，如果是 1，則將 `square` 乘以指數的底數（2），然後計算 <code><tt>square</tt> 取模 47</code>。

將上一步的取模結果用作下一步中 `square` 的初始值：

<pre>Remove   Optional
square        top bit  multiply by 2  mod 47
------------  -------  -------------  ------
1*1 = 1       1  0111  1*2 = 2           2
2*2 = 4       0   111     no             4
4*4 = 16      1    11  16*2 = 32        32
32*32 = 1024  1     1  1024*2 = 2048    27
27*27 = 729   1        729*2 = 1458      1
</pre>

由於 <code>2<sup>23</sup> mod 47 = 1</code>，47 是 <code>2<sup>P</sup>-1</code> 的因數。

（要看到這一點，請從兩邊都減去 1：<code>2<sup>23</sup>-1 = 0 mod 47</code>。）

既然我們已經證明 47 是一個因數，<code>2<sup>23</sup>-1</code> 就不是質數。

Mersenne 數的進一步性質使我們能夠更精細地優化處理程序。

任何 <code>2<sup>P</sup>-1</code> 的因數 `q` 必須是 `2kP+1` 的形式，其中 `k` 是正整數或零。此外，`q` 必須是 `1` 或 `7 mod 8`。

最後，任何潛在因數 `q` 必須是<a href="https://rosettacode.org/wiki/Primality_by_trial_division" target="_blank" rel="noopener noreferrer nofollow">質數</a>。

如同其他試除法演算法，當 `2kP+1 > sqrt(N)` 時，演算法會停止。這些主要測試僅適用於 `P` 為質數的梅森數。例如，<code>M<sub>4</sub>=15</code> 使用這些技術不會產生因數，但可分解為 3 和 5，兩者皆不符合 `2kP+1`。

# --instructions--

使用上述方法尋找 <code>2<sup>p</sup>-1</code> 的因數。

# --hints--

`check_mersenne` 應該是一個函式（程式）。

```js
assert(typeof check_mersenne === 'function');
```

`check_mersenne(3)` 應該傳回一個字串。

```js
assert(typeof check_mersenne(3) == 'string');
```

`check_mersenne(3)` 應該傳回字串 `M3 = 2^3-1 is prime`。

```js
assert.equal(check_mersenne(3), 'M3 = 2^3-1 is prime');
```

`check_mersenne(23)` 應該傳回字串 `M23 = 2^23-1 is composite with factor 47`。

```js
assert.equal(check_mersenne(23), 'M23 = 2^23-1 is composite with factor 47');
```

`check_mersenne(929)` 應該傳回字串 `M929 = 2^929-1 is composite with factor 13007`。

```js
assert.equal(
  check_mersenne(929),
  'M929 = 2^929-1 is composite with factor 13007'
);
```

# --seed--

## --seed-contents--

```js
function check_mersenne(p) {

}
```

# --solutions--

```js
function check_mersenne(p){
    function isPrime(value){
      for (let i=2; i < value; i++){
        if (value % i == 0){
          return false;
        }
        if (value % i != 0){
          return true;
         }
      }
    }

    function trial_factor(base, exp, mod){
      let square, bits;
      square = 1;
      bits = exp.toString(2).split('');
      for (let i=0,ln=bits.length; i<ln; i++){
        square = Math.pow(square, 2) * (bits[i] == 1 ? base : 1) % mod;
      }
      return (square == 1);
    }

    function mersenne_factor(p){
      let limit, k, q;
      limit = Math.sqrt(Math.pow(2,p) - 1);
      k = 1;
      while ((2*k*p - 1) < limit){
        q = 2*k*p + 1;
        if (isPrime(q) && (q % 8 == 1 || q % 8 == 7) && trial_factor(2,p,q)){
          return q; // q is a factor of 2**p-1
        }
        k++;
      }
      return null;
    }
  let f, result;
  result="M"+p+" = 2^"+p+"-1 is ";
  f = mersenne_factor(p);
  result+=f == null ? "prime" : "composite with factor "+f;
  return result;
}
```
