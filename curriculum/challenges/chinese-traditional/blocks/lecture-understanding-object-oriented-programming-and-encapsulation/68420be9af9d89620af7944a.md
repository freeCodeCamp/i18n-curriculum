---
id: 68420be9af9d89620af7944a
title: 什麼是物件導向程式設計，以及封裝如何運作？
challengeType: 19
dashedName: what-is-object-oriented-programming-and-how-does-encapsulation-work
---

# --description--

物件導向程式設計，也稱為 OOP，是一種程式設計風格，開發者將程式碼中的所有事物視為現實世界的物件。

類別就像是用來生成物件的藍圖。每一個由類別生成的物件都有定義資料的屬性和定義物件行為的函式。

在之前的課程中，你學會了如何創建類別。這裡是語法的提醒：

```py
class ClassName:
   def __init__(self, parameters):
       attribute = value

   def method_name(self):
       # method logic
```

這是一個類別範例，使用 `__init__` 特殊方法，在每次使用該類別創建物件時初始化品牌和顏色屬性：

```py
class Car:
   def __init__(self, brand, color):
       self.brand = brand
       self.color = color

# create two objects from the Car class
car1 = Car('Toyota', 'red')
car2 = Car('Lambo', 'green')

print('Car 1 Brand:', car1.brand) # Car 1 Brand: Toyota
print('Car 1 Color:', car1.color) # Car 1 Color: red

print('Car 2 Brand:', car2.brand) # Car 2 Brand: Lambo
print('Car 2 Color:', car2.color) # Car 2 Color: green
```

物件導向程式設計有四個關鍵原則，幫助你有效地組織和管理程式碼。它們是封裝、繼承、多型和抽象性。

本課程的其餘部分將專注於封裝的運作方式。

封裝是將物件的屬性和方法封裝成單一單元，即類別。

透過封裝，你可以將物件的內部狀態隱藏在一組簡單的公開方法和屬性背後，這些方法和屬性就像門一樣。在這些門的背後，是控制資料如何變更以及誰可以看到它的私有屬性和方法。

假設你想追蹤錢包餘額。你想允許人們從錢包存入或提取金錢，但沒有人應該能夠直接竄改餘額。

在這種情況下，你可以將 `deposit()` 和 `withdraw()` 設為公開方法，並將餘額隱藏在 `_balance` 屬性下：

```py
class Wallet:
   def __init__(self, balance):
       self._balance = balance # For internal use by convention

   def deposit(self, amount):
       if amount > 0:
           self._balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self._balance:
           self._balance -= amount # Remove from the balance safely
```

依慣例，為屬性和方法加上單一底線前置式表示它們是供內部使用的。沒有人應該從類別外部直接存取它們，因為這違反了封裝的原則，可能會導致錯誤。

雖然單一底線前置式只是慣例，但使用雙底線前置式來標示屬性和方法，能有效防止它們被類別外部存取，使這些屬性和方法成為私有。

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

要取得 `__balance` 的當前值，你可以定義一個 get_balance 方法。 例如：

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount
  
   def get_balance(self):
       return self.__balance


acct_one = Wallet(100)
acct_one.deposit(50)
print(acct_one.get_balance()) # 150

acct_two = Wallet(450)
acct_two.withdraw(28)
print(acct_two.get_balance()) # 422

acct_two.deposit(150)
print(acct_two.get_balance()) # 572
```

你也可以定義一個私有的 `__validate` 方法來檢查每筆存款或提款金額是否為正數：

```py
class Wallet:
   def __init__(self):
       self.__balance = 0

   def __validate(self, amount):
       if amount < 0:
           raise ValueError('Amount must be positive')

   def deposit(self, amount):
       self.__validate(amount)
       self.__balance += amount

   def withdraw(self, amount):
       self.__validate(amount)
       if amount > self.__balance:
           raise ValueError('Insufficient funds')
       self.__balance -= amount

   def get_balance(self):
       return self.__balance

acct_one = Wallet()
acct_one.deposit(3)
print(acct_one.get_balance()) # 3

acct_one.deposit(50)
print(acct_one.get_balance()) # 53

acct_one.deposit(-4)  # ValueError: Amount must be positive
acct_one.withdraw(-8) # ValueError: Amount must be positive
acct_one.withdraw(58) # ValueError: Insufficient funds
```

如你所見，`__validate` 方法是私有的，並在 `deposit()` 和 `withdraw()` 公開方法背後執行，以確保金額始終有效。

在即將到來的課程中，你將學習更多關於以雙底線作為前置式的屬性如何運作。

總結來說，封裝會將內部資料鎖定在明確的公開方法背後。這就是你如何保護你的類別不被竄改，並將驗證集中在一個地方。你可以自由更新或擴充你的程式碼，因為你知道外部程式碼只會接觸你所公開的介面。

# --questions--

## --text--

物件導向程式設計（OOP）的四個關鍵原則是什麼？

## --answers--

封裝、繼承、多型、抽象性

---

變數、函式（程式）、迴圈、條件判斷

### --feedback--

注意定義物件導向程式設計中資料和行為如何組織的原則。

---

類別、物件、方法、屬性

### --feedback--

注意定義物件導向程式設計中資料和行為如何組織的原則。

---

公開、私有、受保護、靜態

### --feedback--

注意定義物件導向程式設計中資料和行為如何組織的原則。

## --video-solution--

1

## --text--

為什麼直接存取以單一底線為前置式的屬性／方法是不良的做法？

## --answers--

因為如果你嘗試，Python 會引發語法錯誤。

### --feedback--

思考封裝如何存在以保護物件的內部狀態。

---

因為它違反了封裝，允許不受控制的資料存取。

---

因為私有屬性的存取速度比公有屬性慢。

### --feedback--

思考封裝如何存在以保護物件的內部狀態。

---

因為它們只能從子類別中存取。

### --feedback--

因為它們只能從子類別中存取。

## --video-solution--

2

## --text--

表示私有屬性或方法的方式是什麼？

## --answers--

以單一底線作為前置式

### --feedback--

注意用來作為私有屬性或方法名稱前置式的符號。

---

使用前置和後置雙底線

### --feedback--

注意用來作為私有屬性或方法名稱前置式的符號。

---

以雙底線作為前置式

---

使用 private 關鍵字

### --feedback--

注意用來作為私有屬性或方法名稱前置式的符號。

## --video-solution--

3

