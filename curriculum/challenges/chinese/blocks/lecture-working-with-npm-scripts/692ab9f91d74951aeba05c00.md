---
id: 692ab9f91d74951aeba05c00
title: 什么是 npm 脚本？
challengeType: 19
dashedName: what-are-npm-scripts
---

# --description--

现在你将学习关于 npm 脚本。

在我们深入之前，让我们回顾一些重要的概念：

* **npm** 是一个命令行工具，你可以用它来安装和管理 JavaScript 包。
    
* **包** 是一个将相关代码按逻辑结构分组的目录。
    
* **脚本** 是用脚本编程语言编写的一系列指令或命令。
    

**npm 脚本** 是你可以在你的应用的 `package.json` 文件中定义的自定义命令。

它们有助于自动化你将在项目的开发、测试和部署阶段反复使用的任务和工作流。

例如，npm 脚本的一个使用分支是自定义 `npm start` 来启动你的整个开发环境。你无需每次启动开发环境时手动逐条编写所有命令，只需运行 `npm start`，整个进程就会被执行。

你还可以使用 npm 脚本来自动化整个代码库的 linting 和运行测试套件，以及其他用例。

它们非常强大，所以让我们查看它们的基础知识。

## 如何创建 `package.json` 文件

要能够创建并运行自定义 npm 脚本，你需要一个 `package.json` 文件。

`package.json` 文件对于 Node.js 项目至关重要。该文件包含项目的元数据、依赖项和脚本。

提醒你，要创建 `package.json` 文件，必须在你的项目根目录中运行 `npm init` 命令。然后你可以手动输入包名、版本、描述和其他详细信息，或者将这些字段留空以使用默认值。

完成此进程后，你将在你的项目根目录中拥有一个 `package.json` 文件。

如果你保留了所有默认值，当你在代码编辑器中打开 `package.json` 时，你应该会看到这些密钥-值点对：

```json
{
  "name": "<project_name>",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": ""
}
```

注意这里的密钥-值点对：

```json
"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1"
}
```

这里是你将在 `scripts` 密钥下指定你的 npm 脚本的地方。

你将默认看到一个脚本，即测试脚本：

```json
"test": "echo \"Error: no test specified\" && exit 1"
```

这是在 `package.json` 中定义的 npm 脚本示例。

以下是定义 npm 脚本的基本语法：

```json
"<script_name>": "<commands>"
```

冒号左侧是脚本名称。常见的有 `run`、`start`、`test`、`build`、`dev` 和 `lint`。这些名称作为其右侧底层命令的“快捷”。

在冒号右侧，我们找到基础的命令本身。

例如：

```json
"scripts": {
  "start": "node app.js"
}
```

要运行脚本，请在命令行中输入：

```bash
npm run <script_name>
```

这就是你如何运行在 `package.json` 中定义的任何自定义脚本。

有时你可以使用这个简写版本而不带单词 `run` 来执行脚本：

```bash
npm <script_name>
```

但这仅适用于名为 `start`、`test`、`stop` 和 `restart` 的特定 npm 脚本。

回到我们的例子，如果我们在 `package.json` 中有这个：

```json
"scripts": {
  "start": "node app.js"
}
```

要运行 npm 脚本，你需要在命令行中输入 `npm run start`。当你这样做时，实际执行的底层命令是 `node app.js`。

由于这个 npm 脚本有一个简写版本，你也可以使用 `npm start`，结果将是相同的。

在这个分支中，你只是用另一个简单的命令 `npm start` 替换了 `node app.js`。但想象一下，如果你有一系列需要顺序或并行执行的复杂命令，而你只需使用 `npm start` 来运行它们所有。这将为你节省大量时间，对吧？这就是 npm 脚本真正强大的地方。

以下是一些最常用的 npm 脚本的快速概述：

* `npm run`：用于运行自定义 npm 脚本。
    
* `npm start`：用于启动主应用或开发服务器。
    
* `npm lint`：用于运行代码风格检查器，以查看你的代码是否符合代码风格标准和最佳实践。
    
* `npm test`：用于运行项目的测试套件。
    
还有许多用于不同目的的其他 npm 脚本，但这些是你最常见的一些。

此外，一个常见的约定是使用冒号将相关的脚本分组到同一个命名空间下。例如，`start:server` 和 `start:ui`。

## 如何循序运行命令

如果你需要在一个序列中运行多个命令，你有两个选项。你可以使用逻辑 AND 操作符（`&&`）或者分号（`;`）。让我们查看它们的区别。

逻辑 AND 操作符仅在第一个命令成功运行时才运行下一个命令。

例如：

```json
"scripts": {
  "build": "webpack --mode production",
  "start": "npm run build && node server.js"
}
```

注意 `start` 命令中有一个逻辑 AND 操作符：

```json
"start": "npm run build && node server.js"
```

这里，`npm start` 会先尝试运行 `npm run build`，只有当该脚本成功运行时，才会执行 `node server.js`。

这是一个非常常见的方法，因为它确保了可靠性，并防止在前一个命令失败时浪费时间和资源去执行后续可能失败或抛出误差的命令。

备选地，你可以使用分号操作符来循序运行命令，无论前一个命令是否成功。

在我们的示例中，这个简单的更改将对命令的运行方式产生重要影响：

```json
"scripts": {
  "build": "webpack --mode production",
  "start": "npm run build; node server.js"
}
```

再次关注 `start` 命令：

```json
"start": "npm run build; node server.js"
```

现在，由于我们使用分号而不是 `&&` 操作符，`node server.js` 命令将始终在 `npm run build` 之后运行，即使 `node server.js` 没有成功。

```json
"start": "npm run build; node server.js"
```

## 如何并发运行命令

如果你需要并发（并行）运行命令，可以使用 `&` 操作符。

```json
"scripts": {
  "start:server": "node server/index.js",
  "start:client": "npm run build:watch",
  "dev": "npm run start:server & npm run start:client"
}
```

但是，你应该知道这个选项会在后台运行这些进程。

这意味着，如果你在同一个终端会话中运行它们，你可能会看到它们的合并输出，这可能难以理解。

运行命令并发的其他选项包括像 `concurrently` 和 `npm-run-all` 这样的工具。

## 如何向 npm 脚本传递参数

如果你需要将参数直接传递给在 npm 脚本中执行的命令，可以通过在命令中写两个连字符（`--`）后跟参数来指定它们。

`--` 告诉 npm，后面的所有内容都是 npm 脚本将执行的底层命令的参数。

这是通用的语法：

```bash
npm run <script_name> -- <argument_1> <argument_2> <argument_3>
```

例如，假设你定义了这个 `npm start` 脚本：

```json
{
  "name": "project-example",
  "scripts": {
    "start": "node app.js"
  }
}
```

如果你使用 `npm start`，你如何指定想要运行服务器的端口？

假设我们想将端口直接作为命令行参数传递。你可以这样写：

```bash
npm start -- 8000
```

在你的代码中，你可以使用索引访问 `process.argv` 数组中的这些参数：

```bash
process.argv[0] # The path to the node executable.
process.argv[1] # The script file being executed.
process.argv[2] # The first argument (8000).
```

因此，你可以在任何需要的地方使用 `process.argv[2]` 来访问和使用端口号。这就是命令行参数与 npm 脚本结合的强大之处。

正如你所见，npm 脚本是简化开发工作流程的关键工具。它们帮助你将复杂且可重用的命令序列自动化并转换为你日常工作中可以使用的简单且一致的快捷方式。

# --questions--

## --text--

在 Node.js `project` 中，`npm` 脚本在哪里定义？

## --answers--

在 `.npmignore` 文件中。

### --feedback--

考虑作为 Node.js 项目及其可执行命令的中央清单的文件。

---

在 `package.json` 的 `"dependencies"` 对象内。

### --feedback--

考虑作为 Node.js 项目及其可执行命令的中央清单的文件。

---

在 `package.json` 的 `"scripts"` 对象内。

---

在单独的 `npm-config.json` 文件中。

### --feedback--

考虑作为 Node.js 项目及其可执行命令的中央清单的文件。

## --video-solution--

3

## --text--

你如何执行名为 `build` 的 npm 脚本？

## --answers--

`build npm`

### --feedback--

考虑告诉 npm 你想执行 `"scripts"` 部分中定义的自定义命令的命令前缀。

---

`npm run build`

---

`node build`

### --feedback--

考虑告诉 npm 你想执行 `"scripts"` 部分中定义的自定义命令的命令前缀。

---

`run build`

### --feedback--

考虑告诉 npm 你想执行 `"scripts"` 部分中定义的自定义命令的命令前缀。

## --video-solution--

2

## --text--

在运行像 `npm run start -- 5` 这样的 npm 脚本时，双连字符 (`--`) 的作用是什么？

## --answers--

它表示脚本应以静默模式运行。

### --feedback--

考虑一个复杂的命令工具（如 Jest 或 Webpack）在通过 npm 快捷方式运行时如何接收其特定标记。

---

它告诉 npm 将剩余的参数传递给底层的脚本命令。

---

这意味着脚本必须以提升的管理员权限执行。

### --feedback--

考虑一个复杂的命令工具（如 Jest 或 Webpack）在通过 npm 快捷方式运行时如何接收其特定标记。

---

它表示该脚本应与其他已定义的脚本并行运行。

### --feedback--

考虑一个复杂的命令工具（如 Jest 或 Webpack）在通过 npm 快捷方式运行时如何接收其特定标记。

## --video-solution--

2
