---
id: 68e2c945cc1d8e778152be31
title: Construir uma Interface de Player
challengeType: 27
dashedName: build-a-player-interface
---

# --description--

**Objetivo:** Cumprir as user stories abaixo e fazer todos os testes passarem para completar o laboratório.

**Histórias de Usuário:**

1. Você deve definir uma classe abstrata chamada `Player` que herda da classe `abc.ABC`.
1. A classe `Player` deve ter um método `__init__` que define:

   - O atributo `moves` para uma lista vazia.
   - O atributo `position` para `(0, 0)`.
   - O atributo `path` para uma lista contendo a posição inicial.

1. A classe `Player` deve ter um método chamado `make_move` que:

   - Usa `random.choice` para obter um movimento aleatório do atributo `moves` (definido na classe concreta).
   - Adiciona os valores do movimento selecionado à posição atual e atualiza o atributo `position`.
   - Anexa a nova tupla `position` ao atributo `path`.
   - Retorna a nova `position`.

1. A classe `Player` deve ter um método abstrato chamado `level_up` para ser implementado em classes concretas.
1. Você deve definir uma classe `Pawn` que herda da classe `Player`.
1. A classe `Pawn` deve usar `super()` para chamar o método `__init__` do pai e então definir o atributo `moves` como uma lista de tuplas que representam as coordenadas `x, y`.
1. Cada tupla de coordenadas deve representar um movimento de `1` unidade nas seguintes direções: para cima, para baixo, para a esquerda e para a direita.
1. A classe `Pawn` deve implementar um método concreto `level_up` adicionando mais movimentos ao atributo `moves`. Os movimentos adicionados devem representar os quatro movimentos diagonais (por exemplo, `1` unidade para baixo mais `1` unidade para a esquerda).

**Nota:** Os módulos da biblioteca padrão devem ser importados sem usar aliases. Testes relacionados à classe `Player` falharão até que a classe `Pawn` se torne instanciável.

# --hints--

Você deve ter uma classe chamada `Player`.

```js
({ test: () => runPython(`assert _Node(_code).has_class("Player")`) })
```

A classe `Player` deve herdar da classe `ABC` do módulo `abc`.

```js
({ test: () => runPython(`
from abc import ABC
import ast
cls = _Node(_code).find_class("Player")
assert cls.inherits_from("ABC") or cls.inherits_from("abc.ABC")
`) })
```

A classe `Player` deve ter um método `__init__`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("__init__")`) })
```

O método `__init__` do `Player` deve ter um único parâmetro `self`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("__init__").has_args("self")`) })
```

O método `__init__` do `Player` deve definir `self.moves` como uma lista vazia.

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.moves = []") or init.has_stmt("self.moves = list()")
`) })
```

O método `__init__` do `Player` deve definir `self.position` como `(0, 0)`.

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.position = (0, 0)")
`) })
```

O método `Player`'s `__init__` deve definir `self.path` como uma lista contendo a posição inicial.

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.path = [self.position]")
`) })
```

A classe `Player` deve ter um método `make_move`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("make_move")`) })
```

O método `make_move` do `Player` deve ter um único parâmetro `self`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("make_move").has_args("self")`) })
```

O método `make_move` do `Player` deve usar `random.choice` para obter um movimento aleatório do atributo `moves`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").block_has_call("choice", "make_move")`) })
```

O método `make_move` do `Player` deve atualizar o atributo `position` adicionando a ele as coordenadas do movimento selecionado aleatoriamente.

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "Unable to instantiate Pawn"

  p.make_move()
  assert p.position == (1, 2)
  p.make_move()
  assert p.position == (2, 4)

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "missing import"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

O método `make_move` do `Player` deve adicionar a nova tupla `position` ao atributo `path`.

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "Unable to instantiate Pawn"

  p.make_move()
  assert p.path == [(0, 0), (1, 2)]
  p.make_move()
  assert p.path == [(0, 0), (1, 2), (2, 4)]

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "missing import"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

O método `make_move` do `Player` deve retornar o atributo `position` atualizado.

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "Unable to instantiate Pawn"

  assert p.make_move() == (1, 2)

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "missing import"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

A classe `Player` deve ter um método `level_up`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("level_up")`) })
```

O método `level_up` do `Player` deve ter um único parâmetro `self`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("level_up").has_args("self")`) })
```

O método `level_up` do `Player` deve ser um método abstrato.

```js
({ test: () => runPython(`
target = _Node(_code).find_class("Player").find_function("level_up")
assert target.has_decorators("abstractmethod") or target.has_decorators("abc.abstractmethod")
`) })
```

A classe `Player` deve ser uma classe abstrata.

```js
({ test: () => runPython(`
try:
  Player()
except TypeError as e:
  assert str(e) == "Can't instantiate abstract class Player with abstract method level_up"
else:
  assert False, "Player class should not be instantiable"
`) })
```

Você deve ter uma classe chamada `Pawn`.

```js
({ test: () => runPython(`assert _Node(_code).has_class("Pawn")`) })
```

A classe `Pawn` deve herdar da classe `Player`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").inherits_from("Player")`) })
```

A classe `Pawn` deve ter um método `__init__`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").has_function("__init__")`) })
```

O método `__init__` do `Pawn` deve ter um único parâmetro `self`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").find_function("__init__").has_args("self")`) })
```

O método `__init__` do `Pawn` deve chamar o `__init__` do pai usando a função `super`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").find_function("__init__").has_stmt("super().__init__()")`) })
```

O método `Pawn`'s `__init__` deve definir o atributo `moves` como uma lista de tuplas que representam coordenadas `x, y`, onde cada tupla de coordenadas representa um movimento de `1` unidade nas seguintes direções: para cima, para baixo, para a esquerda e para a direita.

```js
({ test: () => runPython(`
p = Pawn()
moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]
assert isinstance(p.moves, list)
assert len(p.moves) == 4
assert all(move in p.moves for move in moves)
`) })
```

A classe `Pawn` deve ter um método `level_up`.

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").has_function("level_up")`) })
```

O método `level_up` do `Pawn` deve adicionar o movimento diagonal de quatro de `1` unidade ao atributo `moves`.

```js
({ test: () => runPython(`
p = Pawn()
moves = [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
p.level_up()
assert isinstance(p.moves, list)
assert len(p.moves) == 8
assert all(move in p.moves for move in moves)
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
from abc import ABC, abstractmethod
from random import choice


class Player(ABC):
    def __init__(self):
        self.moves = []
        self.position = (0, 0)
        self.path = [self.position]

    def make_move(self):
        x, y = self.position
        move = choice(self.moves)
        new_x = move[0] + x
        new_y = move[1] + y
        self.position = (new_x, new_y)
        self.path.append(self.position)
        return self.position

    @abstractmethod
    def level_up(self):
        pass


class Pawn(Player):
    def __init__(self):
        super().__init__()
        self.moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]

    def level_up(self):
        self.moves.extend([(1, 1), (1, -1), (-1, 1), (-1, -1)])
```
