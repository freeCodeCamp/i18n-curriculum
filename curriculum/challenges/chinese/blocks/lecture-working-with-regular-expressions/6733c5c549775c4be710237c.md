---
id: 6733c5c549775c4be710237c
title: 如何在字串中匹配并替换所有出现的内容？
challengeType: 19
dashedName: how-can-you-match-and-replace-all-occurrences-in-a-string
---

# --description--

让我们学习如何匹配或替换字串中模式的所有出现。

你之前已经学习过 `replace()` 和 `match()` 方法，以及全局的 `g` 修饰符。现在你可以结合这些知识来处理字串中的所有模式。让我们回顾一下最初的匹配代码：

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match);
```

以及我们得到的匹配对象：

```js
// [
//   'freeCodeCamp',
//   index: 0,
//   input: 'freeCodeCamp',
//   groups: undefined
// ]
```

但是如果我们有一个包含多个 `freecodecamp` 出现的字串需要匹配呢？让我们看看 `match()` 在这种情况下的表现。我们也会加入之前的 `replace()` 示例，以便比较：

```js
const regex = /freecodecamp/;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

结果如下：

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
// freeCodeCamp is the best we love freecodecamp
```

糟糕！`match()` 只返回了第一个匹配，`replace()` 也只替换了第一个匹配。这是因为默认情况下，`match()` 和 `replace()` 只针对第一个模式出现进行操作。

幸运的是，你可以通过在你的正则表达式上使用全局的修饰符来避免这个问题。让我们为我们的添加它：

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

并确认结果：

```js
// [ 'freecodecamp', 'freecodecamp' ]
// freeCodeCamp is the best we love freeCodeCamp
```

成功了！我们的替换调用替换了所有小写的 `freecodecamp` 字串，而我们的 `match()` 方法匹配了它们两个。

有趣的是，当你在 `match()` 中使用全局修饰符时，你会失去匹配数组中关于捕捉组和字串索引的额外信息。

值得庆幸的是，2019 年的 ECMAScript 更新为我们带来了两个新方法：`matchAll()` 和 `replaceAll()`。像它们的单数对应方法一样，这些方法接受一个字串或正则表达式，而 `replaceAll()` 还接受第二个参数作为替换用的字串。 

但与之前的方法不同，如果你给 `replaceAll()` 和 `matchAll()` 传入没有全局修饰符的正则表达式，它们会抛出误差。让我们更新代码以使用这些新方法：

```js
const pattern = "freecodecamp";
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(pattern);
const replaced = str.replaceAll(pattern, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

我们的结果：

```js
// {}
// freeCodeCamp is the best we love freeCodeCamp
```

好消息！我们的 `replaceAll()` 完全按照预期工作——它将所有小写的 `freecodecamp` 替换为正确的驼峰式大小写版本。

但是那个空对象是什么？`matchAll()` 返回一种称为 `Iterator` 的特殊类型对象，freeCodeCamp 控制台无法处理它。

如果我们查看浏览器控制台，`Iterator` 有一个 `next()` 方法，我们可以调用它来获取下一个值：

```js
// RegExpStringIterator {  }
//  <prototype>: RegExp String Iterator {
//    next: ƒ next(),
//    Symbol(Symbol.toStringTag): "RegExp String Iterator"
//    <prototype>: Object { ... }
//  }
```

让我们继续调用 `matched.next()`，并记录结果日志：

```js
// {
//   "done": false,
//   "value": [
//     0: "freecodecamp"
//     groups: undefined
//     index: 0
//     input: "freecodecamp is the best we love freecodecamp"
//   ]
// }
```

这就是我们的匹配数组！`next()` 给我们一个包含两个值的对象：`done`，当迭代器中还有更多元素时为 `false`，以及 `value`，它是我们刚刚迭代过的值。所以，如果我们再调用一次：

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
const replaced = str.replaceAll(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
console.log(matched.next());
console.log(matched.next());
```

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
```

等等，为什么它显示 `done` 仍然是 `false`？数组中应该只有两个匹配，对吧？我们再调用第三次看看结果：

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": true,
//   "value": undefined
// }
```

`done` 最终是 `true`，但为什么该值是 `undefined`？事实证明，`matchAll()` 迭代器是惰性的。它不会一次找到你所有的匹配项。只有当你通过调用 `next()` 告诉它时，它才会找到一个匹配项。

只要找到匹配，它就不是 `done`。一旦找不到匹配并返回 `undefined`，它就是 `done`。这看起来可能不方便，但当你的正则表达式计算量很大时，这非常有用。

如果你的示例较少，像我们的那样，你可以跳过该特色，通过将其转换为数组一次性提取所有匹配。这是通过调用 `Array.from()` 并将你的迭代器作为参数传递来实现的。

让我们更新我们的代码以使用它——既然我们知道 `replaceAll` 调用有效，就先清理一下它们：

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
console.log(Array.from(matched));
```

我们最终得到了我们的匹配数组：

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
//
// [
//   'freecodecamp',
//   index: 33,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
```

这些强大的方法可以帮助你操作和提取字串中的数据，而无需牺牲性能或可读性。

# --questions--

## --text--

应为正则表达式添加什么修饰符以匹配字串中模式的所有出现？

## --answers--

`/i`

### --feedback--

课程提到了一个用于全局的匹配的特定修饰符。

---

`/m`

### --feedback--

课程提到了一个用于全局的匹配的特定修饰符。

---

`/g`

---

`/a`

### --feedback--

课程提到了一个用于全局的匹配的特定修饰符。

## --video-solution--

3

## --text--

当与全局的正则表达式一起使用时，`match()` 和 `matchAll()` 方法的主要区别是什么？

## --answers--

`match()` 返回一个数组，而 `matchAll()` 返回一个迭代器。

---

`matchAll()` 比 `match()` 更快。

### --feedback--

本课描述了由 `matchAll()` 返回的一种特殊类型的对象。

---

`match()` 只能查找第一个出现的内容，而 `matchAll()` 会查找所有出现的内容。

### --feedback--

本课描述了由 `matchAll()` 返回的一种特殊类型的对象。

---

没有区别，它们可以互换使用

### --feedback--

本课描述了由 `matchAll()` 返回的一种特殊类型的对象。

## --video-solution--

1

## --text--

你如何将 `matchAll()` 的结果转换为包含所有匹配项的数组？

## --answers--

通过使用 `for...of` 循环

### --feedback--

本课演示了将 `Iterator` 转换为数组的特定方法。

---

通过对结果调用 `toArray()` 方法。

### --feedback--

本课演示了将 `Iterator` 转换为数组的特定方法。

---

通过将结果作为参数使用 `Array.from()`。

---

通过将结果展开到数组字面中。

### --feedback--

本课演示了将 `Iterator` 转换为数组的特定方法。

## --video-solution--

3
