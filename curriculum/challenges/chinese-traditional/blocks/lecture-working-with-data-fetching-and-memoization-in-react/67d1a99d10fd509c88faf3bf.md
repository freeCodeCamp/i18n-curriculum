---
id: 67d1a99d10fd509c88faf3bf
title: React 中的資料擷取如何運作？
challengeType: 19
dashedName: how-does-data-fetching-work-in-react
---

# --description--

React 應用程式經常依賴外部 API 和資料庫來取得動態內容。要存取那些 API 和資料庫中的資料，你需要使用一些資料擷取技術。

讓我們來看看在 React 中資料擷取的運作方式以及你可用來擷取資料的不同選項。

React 對於你如何取得你的資料沒有特定看法，這表示在基本層次上，你可以使用所有現代瀏覽器都支援的內建 Fetch API。

你也可以使用 Axios 和 SWR。Axios 是基於 Promise 的 HTTP 請求函式庫，建立於 `XMLHttpRequest` 物件之上，而 SWR 是由 Vercel 團隊創建的用於資料擷取的 React 掛鉤。

讓我們從一個範例開始。你首先需要匯入 `useState` 和 `useEffect` 掛鉤：

```js
import { useState, useEffect } from "react";
```

然後你將需要創建三個狀態變數，分別稱為 `loading`、`data` 和 `error`：

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

`loading` 變數將追蹤資料是否仍在被擷取。`data` 變數表述資料本身，而 `error` 變數將捕捉在資料擷取過程中可能發生的任何錯誤。

由於資料擷取是副作用，最好在 `useEffect` 掛鉤內使用 Fetch API。

這裡有一個範例：

```js
useEffect(() => {
  fetch("https://jsonplaceholder.typicode.com/posts")
    .then((res) => res.json())
    .then((data) => {
      setData(data);
      setLoading(false);
    })
    .catch((err) => {
      setError(err);
      setLoading(false);
    });
}, []);
```

這個 `useEffect` 使用 Fetch API 取得資料並設定所有狀態。 

你可以透過使用 `async`/`await` 取代 `.then()` 語法來讓事情變得更好。這表示你必須在 `useEffect` 裡面有一個獨立的函式，因為你不能在 `useEffect` 前置 `async` 關鍵字：

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
       
      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

你接著就可以使用所有那些狀態來呈現來自 API 的資料。

以下是完整的程式碼：

```jsx
import { useState, useEffect } from "react";

const FetchPosts = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/posts");
       
        if (!res.ok) {
          throw new Error("Network response was not ok");
        }

        const data = await res.json();
        setData(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  if (loading) {
    return <p>Loading...</p>;
  }

  if (error) {
    return <p>{error.message}</p>;
  }

  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
};

export default FetchPosts;
```

在使用者介面中，當資料正在被擷取時，你會在螢幕上看到 `Loading...`，然後會根據資料擷取是否成功顯示資料或錯誤。

記得我們也談過使用 Axios 和 SWR 進行資料擷取。讓我們來看看一個使用 Axios 的範例。

你首先需要從命令列安裝 Axios，如下所示：

```sh
npm i axios
```

然後你將需要像這樣匯入 Axios：

```js
import axios from "axios";
```

然後你可以使用先前相同的狀態變數，並使用 `axios.get` 從 API 取得資料：

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

你可能已經注意到這個範例中沒有 `await res.json()` 這一行。那是因為 Axios 會自動解析 JSON，所以不需要那行程式碼。

最後一個範例是使用 `useSWR` 掛鉤來擷取資料。

就像使用 Axios 一樣，你需要這樣安裝 SWR：

```sh
npm install swr
```

然後你將需要像這樣將 `useSWR` 掛鉤匯入到檔案中：

```js
import useSWR from "swr";
```

與之前的範例相比，SWR 的語法簡短許多。你需要做的是創建一個 fetcher 函式（程式），並將它作為第二個參數傳入 `useSWR` 掛鉤（端點是第一個參數）。

你也可以從 `useSWR` 掛鉤中解構資料和錯誤狀態，因此你不需要 `useState` 掛鉤。

這是語法：

```js
const fetcher = (url) => fetch(url).then((res) => res.json());
const { data, error } = useSWR(endpoint, fetcher);
```

請注意，這裡的「fetcher」名稱只是慣例，因此你可以自由命名該變數。

這是一個從 JSON Placeholder API 取得待辦事項的組件：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
  const { data, error } = useSWR(
    "https://jsonplaceholder.typicode.com/todos",
    fetcher
  );

  if (!data) {
    return <h2>Loading...</h2>;
  }
  if (error) {
    return <h2>Error: {error.message}</h2>;
  }

  return (
    <>
      <h2>Todos</h2>
      <div>
        {data.map((todo) => (
          <h3 key={todo.id}>{todo.title}</h3>
        ))}
      </div>
    </>
  );
};

export default FetchTodos;
```

正如你在先前關於訂製掛鉤的課程中學到的，資料擷取是一種你可以抽取到訂製掛鉤中的邏輯。因此，如果你在多個組件和頁面中擷取資料，最好創建一個 `useFetch` 掛鉤。

這是一個使用 SWR 進行資料擷取的 `useFetch` 掛鉤：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const useFetch = (url) => {
  const { data, error } = useSWR(url, fetcher);

  return {
    data,
    loading: !data && !error,
    error,
  };
};

export default useFetch;
```

以下是如何使用 `useFetch` 掛鉤來重寫第一個從 JSON Placeholder API 抓取貼文的範例：

```jsx
import useFetch from "./useFetch";

const FetchPosts = () => {
  const { data, loading, error } = useFetch(
    "https://jsonplaceholder.typicode.com/posts"
  );

  if (loading) {
    return <h2>Loading...</h2>;
  }

  if (error) {
    return <h2>{error.message}</h2>;
  }

  return (
    <>
      <h2>Posts</h2>
      <ul>
        {data.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </>
  );
};

export default FetchPosts;
```

# --questions--

## --text--

在給定範例中，`useSWR` 掛鉤的兩個參數是什麼？

## --answers--

URL 和快取政策。

### --feedback--

第一個參數表述資料原始碼，第二個參數控制代碼資料擷取。

---

API 路由和 fetcher 函式（程式）。

### --feedback--

第一個參數表述資料原始碼，第二個參數控制代碼資料擷取。

---

端點和擷取函式（程式）。

---

金鑰和設定物件。

### --feedback--

第一個參數表述資料原始碼，第二個參數控制代碼資料擷取。

## --video-solution--

3

## --text--

為什麼你必須在 `useEffect` 裡控制代碼資料擷取邏輯？

## --answers--

因為資料擷取應該只執行一次。

### --feedback--

擷取資料會影響組件外的事物，且不應阻塞呈現。

---

因為資料擷取不應該是呈現行程的一部分。

---

因為 `useEffect` 在組件呈現之前執行。

### --feedback--

擷取資料會影響組件外的事物，且不應阻塞呈現。

---

因為 `useEffect` 與呈現週期同步執行。

### --feedback--

擷取資料會影響組件外的事物，且不應阻塞呈現。

## --video-solution--

2

## --text--

Axios 是建立在什麼基礎上的？

## --answers--

Fetch API。

### --feedback--

這是較舊的 API，用於在 Fetch 之前進行 HTTP 請求。

---

XMLHttpRequest 物件。

---

WebSocket API。

### --feedback--

這是較舊的 API，用於在 Fetch 之前進行 HTTP 請求。

---

DOM API。

### --feedback--

這是較舊的 API，用於在 Fetch 之前進行 HTTP 請求。

## --video-solution--

2
