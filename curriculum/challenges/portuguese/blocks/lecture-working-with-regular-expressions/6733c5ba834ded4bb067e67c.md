---
id: 6733c5ba834ded4bb067e67c
title: Quais S√£o Alguns Modificadores Comuns de Express√£o Regular Usados para Pesquisa?
challengeType: 19
dashedName: what-are-some-common-regular-expression-modifiers-used-for-searching
---

# --interactive--

Modificadores, frequentemente chamados de "flags", modificam o comportamento de uma express√£o regular. Vamos relembrar nosso exemplo de uma li√ß√£o anterior:

:::interactive_editor

```js
const regex = /freeCodeCamp/;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // true
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // false
console.log(regex.test("FREECODECAMP")); // false
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

:::

Se voc√™ lembrar, as strings `freeCodeCamp` totalmente em min√∫sculas e totalmente em mai√∫sculas n√£o corresponderam ao padr√£o. Isso ocorre porque, por padr√£o, express√µes regulares s√£o sens√≠veis a mai√∫sculas e min√∫sculas.

Mas e se pud√©ssemos dizer √† express√£o regular para ser case-insensitive? Bem, existe um modificador para isso. A flag `i` faz com que uma regex ignore mai√∫sculas e min√∫sculas. Como podemos us√°-lo? As flags v√£o depois da barra final em uma express√£o regular:

```js
const regex = /freeCodeCamp/i;
```

Observe a mudan√ßa na express√£o regular na primeira linha. Agora podemos verificar como isso muda as coisas:

:::interactive_editor

```js
const regex = /freeCodeCamp/i;

console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // true
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

:::

Porque nossa express√£o regular agora √© case-insensitive, as strings totalmente em min√∫sculas e totalmente em mai√∫sculas "passaram" no teste. Isso tamb√©m pode funcionar para uma string com uma mistura aleat√≥ria de letras mai√∫sculas e min√∫sculas:

:::interactive_editor

```js
const regex = /freeCodeCamp/i;

console.log(regex.test("dO yOu LoVe fReEcOdEcAmP?")); // true
```

:::

Existem v√°rios outros flags que voc√™ pode usar. A flag `g`, ou modificador global, permite que sua express√£o regular corresponda a um padr√£o mais de uma vez. 

Vamos ver como isso afeta nosso c√≥digo. Voc√™ vai notar que mantivemos a flag `i` ‚Äì uma express√£o regular pode usar m√∫ltiplas flags (quantas forem necess√°rias) para alcan√ßar o comportamento desejado:

```js
const regex = /freeCodeCamp/gi;
```

Espere um segundo... o que √© isso? Parece que o modificador global est√° fazendo com que algumas de nossas strings que deveriam passar falhem em vez disso:

:::interactive_editor

```js
const regex = /freeCodeCamp/gi;

console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // false
console.log(regex.test("FREECODECAMP")); // true
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

:::

Why? Bem, o modificador global torna sua express√£o regular com estado. Isso significa que ele mant√©m o controle de onde j√° correspondeu a um padr√£o anteriormente. Ent√£o, quando ele encontra a primeira string `freeCodeCamp`, ele lembra que encontrou uma correspond√™ncia come√ßando no √≠ndice `0`.

Testamos ent√£o contra `freeCodeCamp is great`, mas n√£o come√ßa no √≠ndice `0`. A express√£o regular "sabe" que encontrou uma correspond√™ncia no √≠ndice `0` j√°, ent√£o mesmo que esta seja uma string diferente, ela come√ßa a partir do √≠ndice final da correspond√™ncia. 

`freeCodeCamp` tem `12` caracteres, ent√£o uma correspond√™ncia em `0` termina no √≠ndice `11`. A correspond√™ncia ser√° retomada no √≠ndice `12`. E como `is great` n√£o corresponde a `freeCodeCamp`, ele retorna `false`.

Ent√£o, porque n√£o encontra uma correspond√™ncia, ele "perde" seu estado e inicia a correspond√™ncia seguinte de volta em `0`.

Se invertermos nossos logs para que uma string com a correspond√™ncia em `0` seja seguida imediatamente por uma string que tenha uma correspond√™ncia depois do √≠ndice `11`:

:::interactive_editor

```js
const regex = /freeCodeCamp/gi;

console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("I loooooooove freeCodeCamp")); // true
```

:::

Quando uma express√£o regular √© global, ela recebe uma nova propriedade chamada `lastIndex`. Pegando nosso c√≥digo anterior, vamos ver como essa propriedade funciona:

:::interactive_editor

```js
const regex = /freeCodeCamp/gi;

console.log(regex.lastIndex); // 0
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.lastIndex); // 12
console.log(regex.test("freeCodeCamp is great")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.lastIndex); // 19
console.log(regex.test("freecodecamp")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("FREECODECAMP")); // true
console.log(regex.lastIndex); // 12
console.log(regex.test("free")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("code")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("camp")); // false
```

:::

Olhando para este exemplo, voc√™ pode ver como o estado da express√£o regular muda a cada chamada de teste usando o `lastIndex` para rastrear suas correspond√™ncias anteriores.

A flag global √© √≥tima quando voc√™ precisa obter m√∫ltiplas correspond√™ncias de uma √∫nica string. Mas se voc√™ estiver testando m√∫ltiplas strings com a mesma express√£o regular √© melhor deixar a flag `g` desligada.

Antes de aprender sobre a pr√≥xima flag, voc√™ precisa aprender sobre √¢ncoras. A √¢ncora caret (`^`), no in√≠cio da express√£o regular, indica "corresponder ao in√≠cio da string":

```js
const start = /^freecodecamp/i;
```

O s√≠mbolo de cifr√£o (`$`), no final da express√£o regular, indica "corresponder ao fim da string":

```js
const end = /freecodecamp$/i;
```

Reserve um momento para comparar as sa√≠das √† direita:

:::interactive_editor

```js
const start = /^freecodecamp/i;
const end = /freecodecamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
console.log(start.test("freecodecamp is great")); // true
console.log(end.test("freecodecamp is great")); // false
console.log(start.test("i love freecodecamp")); // false
console.log(end.test("i love freecodecamp")); // true
console.log(start.test("have met freecodecamp's founder")); // false
console.log(end.test("have met freecodecamp's founder")); // false
```

:::

Veja como a √¢ncora de in√≠cio corresponde apenas ao come√ßo da string e a √¢ncora de fim corresponde apenas ao final da string? Mas e quanto a correspond√™ncia em v√°rias linhas?  Let's take a look at that:

:::interactive_editor

```js
const start = /^freecodecamp/i;
const end = /freecodecamp$/i;
const string = `I really love
freecodecamp
it's my favorite`;
console.log(start.test(string)); // false
console.log(end.test(string)); // false
```

:::

Mesmo que `freecodecamp` esteja l√° em sua pr√≥pria linha, ele falha em ambos os testes. Isso ocorre porque, por padr√£o, os anchors procuram o in√≠cio e o fim de toda a string.

Mas voc√™ pode fazer uma regex lidar com m√∫ltiplas linhas com a flag `m` ou o modificador multi-line. Vamos adicionar isso √†s nossas express√µes regulares para ver o que obtemos:

:::interactive_editor

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const string = `I really love
freecodecamp
it's my favorite`;
console.log(start.test(string)); // true
console.log(end.test(string)); // true
```

:::

Agora ambos correspondem! Porque o `freecodecamp` est√° inteiramente em sua pr√≥pria linha, o √¢ncora de in√≠cio corresponde ao come√ßo dessa linha e o √¢ncora de fim corresponde ao final dessa linha.

Finalmente, voc√™ tem a flag `d`, ou modificador de √≠ndices. Lembre-se de que a flag `i` √© para insensibilidade a mai√∫sculas e min√∫sculas, ent√£o o modificador de √≠ndices precisava de uma flag diferente.

A flag `d` expande as informa√ß√µes que voc√™ obt√©m em um objeto de correspond√™ncia. Vamos adicion√°-lo √† nossa express√£o regular:

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

E o resultado √©:

```js
// [
//   'freecodecamp',
//   index: 8,
//   input: "we love freecodecamp isn't freecodecamp great?",
//   groups: undefined,
//   indices: [
//     0: [8, 20],
//     groups: undefined
//   ]
// ]
```

Nosso objeto match recebe uma nova propriedade `indices`! Esta propriedade √© um array de dois n√∫meros, o primeiro sendo o √≠ndice na string original onde a correspond√™ncia come√ßa e o segundo sendo o √≠ndice ap√≥s a correspond√™ncia terminar. Este array tamb√©m possui uma propriedade extra `groups`, que √© tamb√©m para grupos de captura nomeados.

Existem algumas outras flags que voc√™ deve saber que est√£o dispon√≠veis para voc√™, mas s√£o menos comuns em c√≥digos t√≠picos.

O primeiro √© o modificador unicode, ou a flag `u`. Isso expande a funcionalidade de uma express√£o regular para permitir que ela corresponda a caracteres unicode especiais.

Voc√™ aprender√° mais sobre classes de caracteres em uma li√ß√£o futura, mas a flag `u` d√° acesso a classes especiais como `Extended_Pictographic` para corresponder √† maioria dos emojis:

:::interactive_editor

```js
const regex = /üçé/u;

const str = "I have an apple üçé";
console.log(regex.test(str)); // true
```

:::

Tamb√©m existe uma flag `v`, que expande ainda mais a funcionalidade da correspond√™ncia unicode.

O segundo √© o modificador sticky, ou a flag `y`. O modificador sticky se comporta de forma muito semelhante ao modificador global, mas com algumas exce√ß√µes.

A maior diferen√ßa √© que uma express√£o regular global come√ßar√° a partir de `lastIndex` e buscar√° em todo o restante da string por outra correspond√™ncia, mas uma express√£o regular sticky retornar√° `null` e resetar√° o `lastIndex` para `0` se n√£o houver uma correspond√™ncia imediatamente no `lastIndex` anterior.

E o √∫ltimo √© o modificador de linha √∫nica, ou a flag `s`. Lembre-se de que o modificador multiline permite que os √¢ncoras de in√≠cio e fim correspondam ao in√≠cio e ao fim de uma linha, em vez de toda a string. 

O modificador de linha √∫nica permite que um caractere curinga, representado por um ponto (`.`) em regex, corresponda a quebras de linha ‚Äì tratando efetivamente a string como uma √∫nica linha de texto.

Existem v√°rios desses modificadores, mas as flags `i` e `g` s√£o as que voc√™ usar√° com mais frequ√™ncia e s√£o as mais importantes para lembrar.

# --questions--

## --text--

Qual seria a sa√≠da do seguinte c√≥digo?

```js
const regex = /freecodecamp/i;
console.log(regex.test("I love FREECODECAMP!"));
console.log(regex.test("freeCodoCamp"));
console.log(regex.test("We went freeCodeCamping."));
```

## --answers--

```js
true
true
true
```

### --feedback--

A flag `i` torna a regex case-insensitive, ent√£o `freeCodeCamp` corresponde independentemente de mai√∫sculas ou min√∫sculas, desde que as letras sejam as mesmas.

---

```js
true
false
true
```

---

```js
true
true
false
```

### --feedback--

A flag `i` torna a regex case-insensitive, ent√£o `freeCodeCamp` corresponde independentemente de mai√∫sculas ou min√∫sculas, desde que as letras sejam as mesmas.

---

```js
false
false
false
```

### --feedback--

A flag `i` torna a regex case-insensitive, ent√£o `freeCodeCamp` corresponde independentemente de mai√∫sculas ou min√∫sculas, desde que as letras sejam as mesmas.

## --video-solution--

2

## --text--

Quando voc√™ N√ÉO gostaria de usar a flag global (`g`) em uma express√£o regular?

## --answers--

Quando voc√™ quer corresponder a um padr√£o v√°rias vezes dentro de uma √∫nica string.

### --feedback--

A flag `g` √© com estado, o que significa que ela rastreia a √∫ltima correspond√™ncia, o que pode causar problemas ao testar v√°rias strings.

---

Quando voc√™ quiser que a correspond√™ncia comece do zero a cada novo teste.

### --feedback--

A flag `g` √© com estado, o que significa que ela rastreia a √∫ltima correspond√™ncia, o que pode causar problemas ao testar v√°rias strings.

---

Quando voc√™ quiser tornar o regex case-insensitive.

### --feedback--

A flag `g` √© com estado, o que significa que ela rastreia a √∫ltima correspond√™ncia, o que pode causar problemas ao testar v√°rias strings.

---

Quando voc√™ est√° testando m√∫ltiplas strings e n√£o precisa rastrear o estado da correspond√™ncia.

## --video-solution--

4

## --text--

O que o modificador multi-linha (`m`) faz em uma express√£o regular?

## --answers--

Ele permite que os anchors (`^` e `$`) correspondam ao in√≠cio e ao fim de cada linha, n√£o apenas √† string inteira.

---

Ele torna a express√£o regular case-insensitive.

### --feedback--

O modificador `m` permite correspond√™ncia no in√≠cio e no fim das linhas em strings multilinha.

---

Ele permite que a express√£o regular corresponda a quebras de linha.

### --feedback--

O modificador `m` permite correspond√™ncia no in√≠cio e no fim das linhas em strings multilinha.

---

Ele faz com que a express√£o regular corresponda globalmente.

### --feedback--

O modificador `m` permite correspond√™ncia no in√≠cio e no fim das linhas em strings multilinha.

## --video-solution--

1
