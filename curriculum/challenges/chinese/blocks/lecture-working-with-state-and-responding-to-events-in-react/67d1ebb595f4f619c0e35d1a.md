---
id: 67d1ebb595f4f619c0e35d1a
title: 如何更新状态中的对象？
challengeType: 19
dashedName: how-do-you-update-objects-in-state
---

# --description--

如果你习惯于直接更改对象属性值，那么在 React 中更新状态中的对象可能会很棘手。

React 将状态视为不可变的，这意味着你不应直接修改它。

让我们看看如果你尝试直接更改 React 状态中的对象会发生什么，然后深入了解正确的做法。

假设你的组件状态中有一个对象表示用户的评测，你希望用户更新他们的年龄： 

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({
    name: "John Doe",
    age: 31,
    city: "LA",
  });

  // Change user age directly
  const handleAgeChange = (e) => {
    user.age = e.target.value;
    console.log(user);
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" value={user.age} onChange={handleAgeChange} />
    </div>
  );
}

export default Profile;
```

这段代码无法工作，因为你直接修改了 `user.age` 属性。

尽管 `console.log(user)` 会在控制台显示新的年龄，但 React 不会重新渲染组件以在用户界面中显示它，因为你没有使用设置函数 `setUser`。

要直接更新状态中的对象，你需要使用 setter 函数来创建一个带有更新值的新对象。例如：

```js
const handleAgeChange = (e) => {
  setUser({
    age: e.target.value,
  });
};
```

这样可以。但如果你现在查看页面，用户的年龄会被更新，但姓名和城市的值会丢失。

这是因为你传递给 setter 函数的新建对象只包含了 `age` 的密钥/值点对。

为防止这种情况发生，你可以先拷贝现有对象，然后只更新你想更新的属性，在本例中为 `age`。

为此，你可以将一个称为更新函数的特殊函数传递给你的设置函数 `setUser`。更新函数将待处理状态作为一个参数，这里称为 `prevUser`，并且应该返回下一个状态：

```js
const handleAgeChange = (e) => {
  setUser((prevUser) => {
    const updatedUser = { ...prevUser, age: e.target.value };
    console.log('Previous State:', prevUser);
    console.log('Updated State:', updatedUser);
    return updatedUser;
  });
};
```

如你所见，我们通过使用展开语法拷贝待处理的用户对象 `...prevUser`，创建了一个名为 `updatedUser` 的新用户对象。然后，我们根据表单输入更新年龄，并在函数底部返回 `updatedUser` 作为下一个状态。

现在你的项目按预期工作，年龄输入的更新不会影响用户的姓名或城市名称。你还可以在控制台中看到之前和更新后的状态。

这是更新状态中对象的理想方式，尤其是在你没有更新所有属性时。

要更新剩余的 `name` 和 `city` 属性，你可以将它们写成单独的设置函数并连接到各自的输入：

```js
const handleNameChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    name: e.target.value,
  }));
};

const handleCityChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    city: e.target.value,
  }));
};
```

或者你可以将它们合并成一个单一的 setter 函数，如下所示：

```js
const handleChange = (e) => {
  const { name, value } = e.target;
  setUser((prevUser) => ({
    ...prevUser,
    [name]: value,
  }));
};
```

要使其工作，每个输入字段必须有一个 `name` 属性。

这是完整的代码：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

# --questions--

## --text--

React 如何处理组件中的 state？

## --answers--

作为可变的，允许直接修改。

### --feedback--

思考 React 确保状态变化可预测性的方法。

---

作为不可变的，意味着它不应被直接修改。

---

作为一个在所有组件中可访问的全局变量。

### --feedback--

思考 React 确保状态变化可预测性的方法。

---

作为一个在每次 `Render` 时重置的临时变量。

### --feedback--

思考 React 确保状态变化可预测性的方法。

## --video-solution--

2

## --text--

你应该如何更新存储在 React 状态中的对象？

## --answers--

使用 setter 函数创建新建对象。

---

直接在状态中修改对象。

### --feedback--

React 将状态视为不可变的，因此避免直接修改。

---

使用 `Object.assign()`，但不调用 setter。

### --feedback--

React 将状态视为不可变的，因此避免直接修改。

---

使用 `push()` 方法为对象添加属性。

### --feedback--

React 将状态视为不可变的，因此避免直接修改。

## --video-solution--

1

## --text--

这段 `code` 中的 setter `function` 是什么？

```js
const [user, setUser] = useState({
   name: 'John Doe',
   age: 31,
   city: 'LA',
 });
```

## --answers--

`user`

### --feedback--

设置函数更新 `state` 变量。

---

`useState`

### --feedback--

设置函数更新 `state` 变量。

---

`age`

### --feedback--

设置函数更新 `state` 变量。

---

`setUser`

## --video-solution--

4
