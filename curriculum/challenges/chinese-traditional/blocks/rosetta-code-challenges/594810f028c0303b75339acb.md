---
id: 594810f028c0303b75339acb
title: 100 扇門
challengeType: 1
forumTopicId: 302217
dashedName: 100-doors
---

# --description--

有 100 扇門排成一列，起初全部關閉。你會對這些門進行 100 次巡視。第一次巡視時，拜訪每一扇門並「切換」該門（如果門是關閉的，就打開它；如果門是打開的，就關閉它）。第二次巡視時，只拜訪每第 2 扇門（例如，第 2、4、6 扇門……）並切換它。第三次巡視時，拜訪每第 3 扇門（例如，第 3、6、9 扇門……），依此類推，直到只拜訪第 100 扇門。

# --instructions--

實作一個函式以判斷最後一次通過後門的狀態。傳回最終結果為一個陣列，且只有在門是開啟狀態時，才將門號包含在陣列中。

# --hints--

`getFinalOpenedDoors` 應該是一個函式（程式）。

```js
assert(typeof getFinalOpenedDoors === 'function');
```

`getFinalOpenedDoors` 應該傳回一個陣列。

```js
assert(Array.isArray(getFinalOpenedDoors(100)));
```

`getFinalOpenedDoors` 應該產生正確的結果。

```js
assert.deepEqual(getFinalOpenedDoors(100), solution);
```

# --seed--

## --after-user-code--

```js
const solution = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100];
```

## --seed-contents--

```js
function getFinalOpenedDoors(numDoors) {

}
```

# --solutions--

```js
function getFinalOpenedDoors(numDoors) {
  // this is the final pattern (always squares).
  // thus, the most efficient solution simply returns an array of squares up to numDoors).
  const finalState = [];
  let i = 1;
  while (Math.pow(i, 2) <= numDoors) {
    finalState.push(Math.pow(i, 2));
    i++;
  }
  return finalState;
}
```
