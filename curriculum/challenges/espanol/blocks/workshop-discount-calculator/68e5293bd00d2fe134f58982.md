---
id: 68e5293bd00d2fe134f58982
title: Paso 9
challengeType: 20
dashedName: step-9
---

# --description--

Como se discutió en la lección anterior, los métodos abstractos son métodos que deben ser implementados por cualquier clase que herede de la clase base abstracta. Sirven como un contrato, asegurando que todas las estrategias de descuento tendrán ciertos métodos requeridos.

Dentro de tu clase `DiscountStrategy`, define un método llamado `is_applicable`. Usa el decorador `@abstractmethod` encima de la definición del método. El método debe tener los siguientes parámetros: `self`, `product` y `user_tier`. Usa la instrucción `pass` en el cuerpo del método.

Agrega indicaciones de tipo para que la firma del método sea clara: `product` debe ser de tipo `Product`, `user_tier` debe ser de tipo `str`.


# --hints--

Tu clase `DiscountStrategy` debe tener un método llamado `is_applicable`.

```js
({
  test: () => runPython(`assert _Node(_code).find_class("DiscountStrategy").has_function("is_applicable")`)
})
```

Tu método `is_applicable` debe tener el decorador `@abstractmethod`.

```js
({
  test: () => runPython(`assert _Node(_code).find_class("DiscountStrategy").find_function("is_applicable").has_decorators("abstractmethod")`)
})
```

Tu método `is_applicable` debe tener los parámetros `self`, `product: Product` y `user_tier: str`.

```js
({
  test: () => runPython(`assert _Node(_code).find_class("DiscountStrategy").find_function("is_applicable").has_args("self,product:Product,user_tier:str")`)
})
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod

class Product:
    def __init__(self, name: str, price: float) -> None:
        self.name = name
        self.price = price

    def __str__(self) -> str:
        return f'{self.name} - ${self.price}'

--fcc-editable-region--
class DiscountStrategy(ABC):
    pass
--fcc-editable-region--
product = Product('Wireless Mouse', 50.0)
print(product)
```
