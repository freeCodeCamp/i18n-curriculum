---
id: 6733b02d1e556005a544c5e3
title: ¿Qué es la recursión, y cómo funciona?
challengeType: 19
dashedName: what-is-recursion-and-how-does-it-work
---

# --interactive--

La recursión es una característica complicada que permite llamar a una función repetidamente hasta que se alcanza un caso base. A diferencia de un bucle tradicional, la recursión permite manejar algo con una profundidad desconocida, como objetos/arrays profundamente anidados, o un árbol de archivos. Pero también pueden usarse para tareas más básicas, como contar hacia atrás desde un número dado.

Construyamos una función para hacer exactamente eso. Llamaremos a nuestra función `recursiveCountdown`, y necesita aceptar un número. Haremos que imprima este número en la consola:

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  console.log(number);
};

recursiveCountdown(5);
```

:::

Ahora, si llamamos a esto y pasamos el número 5, veremos el número impreso en nuestro terminal. Pero no sucede nada más – y el número 5 no es ciertamente una cuenta regresiva.

Antes de que empecemos a construir la parte recursiva de nuestra función, necesitamos establecer primero nuestro caso base. Si no tienes un caso base establecido, tu código se ejecutará hasta que exceda tu asignación de memoria y se bloquee.

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  if (number < 1) {
    return;
  }
  console.log(number);
};

recursiveCountdown(5);
```

:::

Para nuestro caso base, queremos que la cuenta regresiva se detenga si el número es menor que 1. Cuando alcanzamos ese caso base, podemos retornar para salir de la ejecución de la función.

Ahora que hemos preparado de manera segura un caso base, podemos configurar la recursión. El punto clave que hace que una función sea recursiva es que se llama a sí misma en su ejecución. En este caso, queremos llamar a la función después de imprimir el número. Pero para contar hacia atrás, nuestro nuevo número debe ser uno menos:

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  if (number < 1) {
    return;
  }
  console.log(number);
  recursiveCountdown(number - 1);
};

recursiveCountdown(5); 
```

:::

Esto registraría los números 5, 4, 3, 2 y 1 en la consola.

¡Conseguimos nuestros cinco números! Pero ¿y si quisiéramos contar hacia arriba en su lugar? En lugar de escribir una nueva función, podemos intercambiar el orden de nuestro registro y nuestra llamada recursiva:

:::interactive_editor

```js
const recursiveCountdown = (number) => {
    if (number < 1) {
        return;
    }
    recursiveCountdown(number - 1);
    console.log(number);
  };

recursiveCountdown(5);
```

:::

Esto registraría los números 1, 2, 3, 4 y 5 en la consola.

¿Pero por qué funciona eso? Bueno, para entender esto necesitas comprender la pila de llamadas. La pila de llamadas es cómo JavaScript rastrea y resuelve llamadas a funciones. La pila funciona como una cola de último en entrar, primero en salir de cierta manera. Para entender esto mejor, agreguemos algunos registros a nuestra función:

:::interactive_editor

```js
const recursiveCountdown = (number) => {
  console.log(`Function execution started for number: ${number}`);
  if (number < 1) {
    console.log(`Base case reached, begin resolving stack`);
    return;
  }
  console.log(`Calling recursiveCountdown with number: ${number - 1}`);
  recursiveCountdown(number - 1);
  console.log(`Function execution completed for number: ${number}`);
};

recursiveCountdown(5);
```

:::

Hemos añadido cuatro declaraciones clave aquí. El primer registro se ejecuta cuando una llamada a función comienza a ejecutarse. El tercer registro se ejecuta justo antes de que se llame a la función recursiva. Y el cuarto registro se ejecuta cuando ha terminado la ejecución de la función. El resultado es:

```md
Function execution started for number: 5
Calling recursiveCountdown with number: 4
Function execution started for number: 4
Calling recursiveCountdown with number: 3
Function execution started for number: 3
Calling recursiveCountdown with number: 2
Function execution started for number: 2
Calling recursiveCountdown with number: 1
Function execution started for number: 1
Calling recursiveCountdown with number: 0
Function execution started for number: 0
Base case reached, begin resolving stack
Function execution completed for number: 1
Function execution completed for number: 2
Function execution completed for number: 3
Function execution completed for number: 4
Function execution completed for number: 5
```

¿Cómo sucede esto? Bueno, aquí es donde entra en juego la pila de llamadas. Cuando llamamos a `recursiveCountdown(5)`, esa llamada a función se añade a la pila de llamadas. 

Cuando esa llamada a función llega al punto donde necesita llamar a `recursiveCountdown(4)`, debe detenerse y esperar por ese resultado. Mientras tanto, nuestro `recursiveCountdown(4)` se añade a la pila de llamadas, encima de `recursiveCountdown(5)`.

Cuando esa llamada a función llega al punto donde necesita llamar a `recursiveCountdown(3)`, debe detenerse y esperar por ese resultado. Mientras tanto, nuestro `recursiveCountdown(3)` se añade a la pila de llamadas, encima de `recursiveCountdown(4)`.

Cuando esa llamada a función llega al punto donde necesita llamar a `recursiveCountdown(2)`, debe detenerse y esperar por ese resultado. Mientras tanto, nuestro `recursiveCountdown(2)` se añade a la pila de llamadas, encima de `recursiveCountdown(3)`.

Cuando esa llamada a función llega al punto donde necesita llamar a `recursiveCountdown(1)`, debe detenerse y esperar por ese resultado. Mientras tanto, nuestro `recursiveCountdown(1)` se añade a la pila de llamadas, encima de `recursiveCountdown(2)`.

Y finalmente, cuando esa llamada a función llega al punto donde necesita llamar a `recursiveCountdown(0)`, debe detenerse y esperar por ese resultado. Mientras tanto, nuestro `recursiveCountdown(0)` se añade a la pila de llamadas, encima de `recursiveCountdown(1)`.

Pero `recursiveCountdown(0)` no llama a otra función – alcanza nuestro caso base, donde retorna temprano. Debido a que ha terminado la ejecución de esa función, la llamada a función puede considerarse "resuelta". Cuando la llamada se resuelve, se elimina de la pila.

Ahora nuestro `recursiveCountdown(1)` ya no está esperando esa llamada – está en la cima de la pila y puede retomar la ejecución.

`recursiveCountdown(1)` se resuelve, se elimina de la pila, y permite que `recursiveCountdown(2)` retome la ejecución.

`recursiveCountdown(2)` se resuelve, se elimina de la pila, y permite que `recursiveCountdown(3)` retome la ejecución.

`recursiveCountdown(3)` se resuelve, se elimina de la pila, y permite que `recursiveCountdown(4)` retome la ejecución.

`recursiveCountdown(4)` se resuelve, se elimina de la pila, y permite que `recursiveCountdown(5)` retome la ejecución.

Y `recursiveCountdown(5)` se resuelve y se elimina de la pila. Nuestra pila de llamadas ahora está vacía, ¡la recursión está completa!

Esta es una visión general básica de cómo funciona la recursión en JavaScript. Es un concepto complicado, y deberías practicar con algo de código y declaraciones de registro hasta que te sientas cómodo con el comportamiento de la pila de llamadas.

Como dato curioso, hablamos de cómo la falta de un caso base puede causar que tu código se bloquee cuando se queda sin memoria. Esto se debe a que la recursión sigue acumulando más y más llamadas a funciones en la pila de llamadas hasta que la pila desborda. Al igual que el nombre de la popular comunidad de programación.

# --questions--

## --text--

¿Cuál es el propósito principal de un caso base en una función recursiva?

## --answers--

Para iniciar las llamadas recursivas.

### --feedback--

La lección menciona qué sucede si no tienes un caso base establecido.

---

Para prevenir la recursión infinita y el desbordamiento de pila.

---

Para mejorar el rendimiento de la función.

### --feedback--

La lección menciona qué sucede si no tienes un caso base establecido.

---

Para manejar condiciones de error.

### --feedback--

La lección menciona qué sucede si no tienes un caso base establecido.

## --video-solution--

2

## --text--

En el contexto de la recursión, ¿para qué se utiliza la pila de llamadas?

## --answers--

Para almacenar variables locales.

### --feedback--

La lección explica cómo la pila de llamadas gestiona las llamadas a funciones durante la recursión.

---

Para rastrear y resolver llamadas a funciones.

---

Para optimizar funciones recursivas.

### --feedback--

La lección explica cómo la pila de llamadas gestiona las llamadas a funciones durante la recursión.

---

Para manejar operaciones asíncronas.

### --feedback--

La lección explica cómo la pila de llamadas gestiona las llamadas a funciones durante la recursión.

## --video-solution--

2

## --text--

¿Qué sucede cuando una llamada recursiva alcanza su caso base?

## --answers--

Inicia un nuevo ciclo recursivo.

### --feedback--

Piensa sobre cómo se comporta la función cuando alcanza la condición que detiene la recursión.

---

Lanza un error.

### --feedback--

Piensa sobre cómo se comporta la función cuando alcanza la condición que detiene la recursión.

---

Devuelve y permite que la llamada anterior retome la ejecución.

---

Continúa llamándose a sí misma indefinidamente.

### --feedback--

Piensa sobre cómo se comporta la función cuando alcanza la condición que detiene la recursión.

## --video-solution--

3
