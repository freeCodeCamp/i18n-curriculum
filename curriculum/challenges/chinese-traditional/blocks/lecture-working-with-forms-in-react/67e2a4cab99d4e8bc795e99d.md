---
id: 67e2a4cab99d4e8bc795e99d
title: 什麼是 useActionState 掛鉤，以及它如何運作？
challengeType: 19
dashedName: what-is-the-useactionstate-hook-and-how-does-it-work
---

# --description--

React 19 帶來了兩個值得注意的新特性，稱為伺服端組件和伺服端動作。 

從該版本開始，伺服端組件成為像 Next.js 這類框架中預設且直接支援的功能。

伺服端動作則是執行於伺服端的函式（程式），允許直接在伺服端處理表單，而無需 API 端點。

伺服端動作看起來像這樣： 

```js
"use server";

async function submitForm(formData) {
  const name = formData.get("name");
  return { message: `Hello, ${name}!` };
}
```

此伺服器動作會從表單中擷取 `name` 欄，並傳回一個問候該名稱的字串。

為了簡化伺服端動作的狀態管理，並且在簡單表單中移除對客戶端 JavaScript 的需求，React 團隊在版本 19 中介紹了 `useActionState` 掛鉤。

讓我們更仔細地看看這個掛鉤，並了解它如何運作。

React 文件將 `useActionState` 掛鉤描述為一個「允許你根據表單操作的結果更新狀態」的掛鉤。

但這並不代表你只能將 `useActionState` 掛鉤用於表單。只要你有相應的動作，也可以用它來管理按鈕點擊和其他事件。

請記住，因為 `useActionState` 是一個掛鉤，你不能在伺服端組件中使用它。

以下是 `useActionState` 掛鉤的基本語法：

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` 是該動作傳回的當前狀態。

- `action` 是觸發伺服端動作的函式（程式）。

- `isPending` 是一個布林值，用來顯示該動作目前是否正在執行。

- `actionFunction` 參數就是伺服器動作本身。

- `initialState` 是表述動作執行前狀態起點的參數。

- `permalink` 是包含表單所修改的唯一頁面 URL 的選用字串。

要使用 `useActionState` 掛鉤，請先確保你已經有一個動作。讓我們使用前一個範例中的動作，並稍作變化：

```js
"use server";

export async function submitForm(_, formData) {
  const name = formData.get("name");

  const hour = new Date().getHours();
  let greeting;

  if (hour < 12) {
    greeting = "Good morning";
  } else if (hour < 18) {
    greeting = "Good afternoon";
  } else {
    greeting = "Good evening";
  }

  return { message: `${greeting}, ${name}` };
}
```

在你的組件中，你需要匯入 `useActionState` 掛鉤，並在組件主體的頂層（在傳回述語之前）呼叫它，就像其他掛鉤一樣。你也應該匯入該 action：

```jsx
"use client";

// Import the useActionState hook
import { useActionState } from "react";

// Import the submitForm action
import { submitForm } from "./actions/submitForm";

const Greeter = () => {

 // Initialize the hook
 const [state, submit, isPending] = useActionState(submitForm, {
   message: "",
 });

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6">
      {/* Rest of component */}
    </div>
  );
};

export default Greeter;
```

以下是帶有一點樣式的完整程式碼範例：

```jsx
"use client";

import { useActionState } from "react";
import { submitForm } from "./actions/submitForm";

const Greeter = () => {
  const [state, submit, isPending] = useActionState(submitForm, {
    message: "",
  });

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6">
      <form
        action={submit}
        className="bg-white p-6 rounded-2xl shadow-md w-full max-w-md"
      >
        <h2 className="text-2xl text-center font-semibold text-gray-700 mb-4">
          Greet Someone
        </h2>

        <input
          type="text"
          name="name"
          placeholder="Enter your name"
          required
          className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-400"
        />

        <button
          type="submit"
          disabled={isPending}
          className="w-full mt-4 p-3 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 disabled:bg-gray-400 transition-all"
        >
          {isPending ? "Greeting..." : "Greet"}
        </button>

        {state.message && (
          <p className="mt-4 text-green-600 text-center font-medium">
            {state.message}
          </p>
        )}
      </form>
    </div>
  );
};

export default Greeter;
```

在瀏覽器中，當動作 `isPending` 時，你會看到你的表單按鈕從 `Greet` 變成 `Greeting...`，而問候語會根據表單提交的時間顯示為 `Good morning, {name}`、`Good afternoon, {name}` 或 `Good evening, {name}`。

還記得我們提到你也可以在表單外使用 `useActionState` 掛鉤嗎？

在此範例中，我們將透過按鈕點擊從 JSONPlaceholder 取得五位使用者：

```js
"use server";

export async function getUsers() {
  const res = await fetch(
    "https://jsonplaceholder.typicode.com/users?_start=0&_limit=5/"
  );
  return await res.json();
}
```

這是已套用樣式的 UI：

```jsx
"use client";

import { useActionState } from "react";
import { getUsers } from "./actions/getUsers";

export default function FetchUsers() {
  const [users, fetchAction, isPending] = useActionState(getUsers, []);

  return (
    <div className="p-6 max-w-lg mx-auto">
      <button
        onClick={fetchAction}
        disabled={isPending}
        className="px-4 py-2 cursor-pointer bg-green-500 text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400 font-bold"
      >
        {isPending ? "Fetching Users..." : "Fetch Users"}
      </button>

      <ul className="mt-4 space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-3 bg-gray-100 rounded-lg">
            <p className="font-semibold">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

在瀏覽器中，你會看到按鈕的文字在被點擊後從未更新為 `Fetching Users...`。

這是因為 React 將資料擷取和呈現視為比 `isPending` 狀態更高的優先權，這會在處理程序中阻擋 `isPending` 並發出錯誤。

要解決此問題，你需要將該動作包裹在 `startTransition` 中：

```jsx
"use client";

// import startTransition from React
import { useActionState, startTransition } from "react";
import { getUsers } from "./actions/getUsers";

export default function FetchUsers() {
  const [users, fetchAction, isPending] = useActionState(getUsers, []);

  return (
    <div className="p-6 max-w-lg mx-auto">
      <button
        {/* wrap fetchAction in startTransition */}
        onClick={() => startTransition(() => fetchAction())}
        disabled={isPending}
        className="px-4 py-2 bg-green-500 font-bold cursor-pointer text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400"
      >
        {isPending ? 'Fetching Users...' : 'Fetch Users'}
      </button>

      <ul className="mt-4 space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-3 bg-gray-100 rounded-lg">
            <p className="font-semibold">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

如果你想知道 `startTransition` 是什麼，它是一個告訴 React 狀態更新屬於低優先權且可以被中斷的函式。這能在處理像伺服端動作這類非同步更新時保持使用者介面的回應性。

這就是如何在表單內外使用 `useActionState` 掛鉤。

# --questions--

## --text--

`useActionState` 掛鉤在 React 中的用途是什麼？

## --answers--

它根據動作的結果管理狀態，包括表單提交、按鈕點擊和其他事件驅動的更新。

---

它只會在表單提交時更新狀態，且不支援按鈕點擊或訂製事件處理常式等其他類型的動作。

### --feedback--

它適用於動作，而不僅僅是表單。

---

它控制多個組件之間的全域狀態管理，使其成為像 Redux 或 Zustand 這類狀態管理函式庫的替代方案。

### --feedback--

它適用於動作，而不僅僅是表單。

---

它完全取代 `useState` 掛鉤，透過內建方式管理區域的和全域的狀態，且不需額外依賴。

### --feedback--

它適用於動作，而不僅僅是表單。

## --video-solution--

1

## --text--

為什麼你無法在伺服端組件內使用 `useActionState` 掛鉤？

## --answers--

因為伺服端組件不支援狀態管理，導致 `useActionState` 不相容。

### --feedback--

掛鉤只在特定型別的組件中運作。

---

因為 `useActionState` 需要資料庫連線，而資料庫連線僅在客戶端組件中可用。

### --feedback--

掛鉤只在特定型別的組件中運作。

---

因為 `useActionState` 是 React 掛鉤，而掛鉤只能在客戶端組件內使用。

---

因為 `useActionState` 依賴於伺端無法使用的瀏覽器 API。

### --feedback--

掛鉤只在特定型別的組件中運作。

## --video-solution--

3

## --text--

哪個版本的 React 介紹了伺端組件和伺端動作？

## --answers--

React 17

### --feedback--

此版本專注於改善伺服端呈現。

---

React 18

### --feedback--

此版本專注於改善伺服端呈現。

---

React 19

---

React 16

### --feedback--

此版本專注於改善伺服端呈現。

## --video-solution--

3
