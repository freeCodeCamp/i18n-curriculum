---
id: 68c128cbd77e4ba9ed671937
title: 什麼是取值函式和設值函式
challengeType: 19
dashedName: what-are-getters-and-setters
---

# --description--

取值函式和設值函式是讓你控制類別屬性如何被存取和修改的方法。使用取值函式你可以取得一個值，使用設值函式你可以設定一個值。

這些動作是透過所謂的屬性完成的。它們是連接取值函式和設值函式的橋樑，並允許存取資料。

屬性表現得像屬性，但在底層行為像方法。你可以將它們視為像方法一樣定義的資料，但運作方式像屬性。這表示你可以用點記法存取屬性，而不是使用小括弧。

屬性的主要功能是在你使用它們取得、設定或刪除值時，幕後執行額外的邏輯。這使得它們成為你想要存取或操作物件內資料時的完美選擇。

那為什麼要用屬性而不是方法呢？主要是關於可讀性和慣例。它們讓你的程式碼更乾淨且更容易閱讀。

當你使用一個方法時，你總是必須用小括弧來呼叫它。但對於一個屬性，你可以像存取一般屬性一樣使用點記法來取用它。即使在幕後執行額外工作，這也讓你的程式碼看起來很簡潔。

例如，你可能想要計算一個值或檢查一個新值是否有效，然後再儲存它。你可以使用類似屬性的方式來做到這點，而不是呼叫一個方法。

要創建一個屬性，你需要定義一個方法，並在它上方放置 `@property` 裝飾器。這告訴 Python 將該方法視為屬性。

這就帶我們進入取值函式。以下是如何使用 `@property` 裝飾器來創建一個取值函式：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

此範例取得圓的半徑和面積。

注意我們在類別內使用 `_radius` 而不是 radius。底線是 Python 常見的慣例，用來表示該屬性是私有的。換句話說，它表示該屬性是供內部使用，不應該從類別外部直接存取。

為了創建半徑的設值函式，例如，你必須定義另一個同名的行為，並在其上方使用 `@<property_name>.setter`：

在 `__init__` 中使用 `self.radius` 可確保在物件產生期間設值函式會被執行，因此會立即捕捉到無效的半徑值。

```py
class Circle:
    def __init__(self, radius):
        self.radius = radius # Calling the setter

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

在這個範例中，半徑設值函式不僅設定圓的半徑，還執行一個驗證，確保半徑不是負數。

一旦你定義了取值函式和設值函式，Python 就會在你使用一般屬性語法時自動在背後呼叫它們：

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

請注意，在設值函式內，當指定新值時，不能使用與屬性相同的名稱。那是因為 `self.radius = value` 會在設值函式內部呼叫該設值函式，導致無限遞迴和 `RecursionError`。所以你必須始終使用帶有底線前置式的形式 `self._radius = value`。

就像你可以透過 getter 控制屬性的存取方式，並透過 setter 控制屬性的修改方式，你也可以透過 deleter 控制屬性的刪除方式。

當你對一個屬性使用 del 述語時，deleter 會執行訂製邏輯。要創建一個 deleter，你需要使用 `@<property_name>.deleter` 裝飾器：

```py
class Circle:
    def __init__(self, radius):
        self.radius = radius

    # Getter
    @property
    def radius(self):
        return self._radius

    # Setter
    @radius.setter
    def radius(self, value):
        if value <= 0:
            raise ValueError("Radius must be positive")
        self._radius = value

    # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

以下是如何使用刪除器的方法：

```py
# Create circle object with a radius
my_circle = Circle(33)
print("Initial radius:", my_circle.radius)  # 33

# Delete the radius
# This calls the deleter
del my_circle.radius # Deleting radius...
print("Radius deleted!") # Radius deleted!

# Try to access radius after deletion
try:
    print(my_circle.radius)
except AttributeError as e:
    print("Error:", e) # Error: 'Circle' object has no attribute '_radius'
```

重點是：

- 取值函式讓你取得一個值，甚至即時計算一個值。
- 設值函式讓你在指定之前透過執行檢查來安全地修改值。
- 屬性是將這些取值函式和設值函式串連起來的方式，讓你在使用點記法的同時仍能撰寫邏輯。
- 刪除器讓你定義刪除屬性時會發生什麼。

# --questions--

## --text--

什麼讓你在取得或設定屬性值時，能在幕後執行邏輯？

## --answers--

匯入外部模組。

### --feedback--

思考允許在讀取和寫入資料時進行驗證或計算的方法。

---

類別繼承。

### --feedback--

思考允許在讀取和寫入資料時進行驗證或計算的方法。

---

屬性

---

直接屬性存取。

### --feedback--

思考允許在讀取和寫入資料時進行驗證或計算的方法。

## --video-solution--

3

## --text--

是什麼將取值函式和設值函式綁定在一起，使你能在維護點記法存取的同時執行邏輯？

## --answers--

屬性

---

裝飾器

### --feedback--

想一想一個讓你能用簡單的點語法將方法當作屬性使用的特性。

---

類別繼承

### --feedback--

想一想一個讓你能用簡單的點語法將方法當作屬性使用的特性。

---

直接方法呼叫

### --feedback--

想一想一個讓你能用簡單的點語法將方法當作屬性使用的特性。

## --video-solution--

1

## --text--

用於為屬性創建取值函式和設值函式的兩個裝飾器是什麼？

## --answers--

`@getter` 和 `@setter`

### --feedback--

思考允許方法呼叫使用簡單點記法而不使用小括弧的裝飾器。

---

`@attr.get` 和 `@attr.set`

### --feedback--

思考允許方法呼叫使用簡單點記法而不使用小括弧的裝飾器。

---

`@compute` 和 `@assign`

### --feedback--

思考允許方法呼叫使用簡單點記法而不使用小括弧的裝飾器。

---

`@property` 和 `@<property_name>.setter`

## --video-solution--

4
