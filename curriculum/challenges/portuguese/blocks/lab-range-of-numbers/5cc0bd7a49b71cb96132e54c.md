---
id: 5cc0bd7a49b71cb96132e54c
title: Construa um Gerador de Intervalo de Números
challengeType: 26
dashedName: build-a-range-of-numbers-generator
---

# --description--

Neste laboratório, você irá construir uma função `rangeOfNumbers` que gera um array de números dentro de um intervalo especificado.

Exemplos:

- `rangeOfNumbers(3, 9)` retorna `[3, 4, 5, 6, 7, 8, 9]`
- `rangeOfNumbers(5, 5)` retorna `[5]`

Requisitos:

- Use recursão (a função deve chamar a si mesma)
- Sem loops ou métodos de array (`for`, `while`, `forEach`, `map`, `filter`, `reduce`)

**Objetivo:** Cumprir as user stories abaixo e fazer todos os testes passarem para completar o laboratório.

**Histórias de Usuário:**

1. Você deve criar uma função chamada `rangeOfNumbers` que recebe dois parâmetros: `startNum` e `endNum`.
1. A função deve retornar um array de inteiros que começa com o número representado pelo parâmetro `startNum` e termina com o número representado pelo parâmetro `endNum` (inclusivo).
1. O `startNum` sempre será menor ou igual ao `endNum`.
1. Sua função deve usar recursão chamando a si mesma. Ela não deve usar nenhuma sintaxe de loop (`for`, `while` ou funções de ordem superior como `forEach`, `map`, `filter` ou `reduce`).
1. A função deve lidar com o caso base onde `startNum` é igual a `endNum` retornando um array contendo apenas esse único número.
1. Para o caso recursivo, a função deve chamar a si mesma com parâmetros modificados para construir o array, e então adicionar o número atual ao resultado.
1. A função não deve depender de variáveis globais para armazenar em cache ou construir o array.

# --hints--

Você deve ter uma função chamada `rangeOfNumbers`.

```js
assert.isFunction(rangeOfNumbers);
```

A função `rangeOfNumbers` deve receber dois parâmetros.

```js
assert.match(rangeOfNumbers.toString(), /rangeOfNumbers\s*\(\s*\w+\s*,\s*\w+\s*\)/);
```

Sua função deve retornar um array.

```js
assert(Array.isArray(rangeOfNumbers(5, 10)));
```

O código não deve depender de nenhum laço (`for` ou `while` ou funções de ordem superior como as funções `forEach`, `map`, `filter` ou `reduce`).

```js
assert(
  !__helpers.removeJSComments(code).match(/for|while|forEach|map|filter|reduce/g)
);
```

`rangeOfNumbers` deve usar recursão (chamar a si) para resolver este desafio.

```js
assert(
  rangeOfNumbers.toString().match(/rangeOfNumbers\s*\(.+\)/)
);
```

`rangeOfNumbers(1, 5)` deve retornar `[1, 2, 3, 4, 5]`.

```js
assert.deepStrictEqual(rangeOfNumbers(1, 5), [1, 2, 3, 4, 5]);
```

`rangeOfNumbers(6, 9)` deve retornar `[6, 7, 8, 9]`.

```js
assert.deepStrictEqual(rangeOfNumbers(6, 9), [6, 7, 8, 9]);
```

`rangeOfNumbers(4, 4)` deve retornar `[4]`.

```js
assert.deepStrictEqual(rangeOfNumbers(4, 4), [4]);
```

`rangeOfNumbers(10, 15)` deve retornar `[10, 11, 12, 13, 14, 15]`.

```js
assert.deepStrictEqual(rangeOfNumbers(10, 15), [10, 11, 12, 13, 14, 15]);
```

`rangeOfNumbers(2, 8)` deve retornar `[2, 3, 4, 5, 6, 7, 8]`.

```js
assert.deepStrictEqual(rangeOfNumbers(2, 8), [2, 3, 4, 5, 6, 7, 8]);
```

As variáveis globais não devem ser usadas para armazenar em cache o array.

```js
rangeOfNumbers(1, 3);
assert.deepStrictEqual(rangeOfNumbers(6, 9), [6, 7, 8, 9]);
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
function rangeOfNumbers(startNum, endNum) {
  if (endNum - startNum === 0) {
    return [startNum];
  } else {
    const numbers = rangeOfNumbers(startNum, endNum - 1);
    numbers.push(endNum);
    return numbers;
  }
}
```
