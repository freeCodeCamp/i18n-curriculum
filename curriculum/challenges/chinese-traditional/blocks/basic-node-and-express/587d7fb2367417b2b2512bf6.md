---
id: 587d7fb2367417b2b2512bf6
title: 從客戶端取得查詢參數輸入
challengeType: 2
forumTopicId: 301512
dashedName: get-query-parameter-input-from-the-client
---

# --description--

另一種從客戶端取得輸入的常見方式是透過在路由路徑後編碼資料，使用查詢字串。查詢字串以問號（？）作為分隔符，並包含欄位=值的組合。每組以和號（＆）分隔。Express 可以解析查詢字串中的資料，並填充物件 `req.query`。某些字元，例如百分比（％），不能出現在 URL 中，必須在傳送前以不同格式編碼。如果你使用 JavaScript 的 API，可以使用特定的方法來編碼／解碼這些字元。

<blockquote>route_path: '/library'<br>actual_request_URL: '/library?userId=546&#x26;bookId=6754' <br>req.query: {userId: '546', bookId: '6754'}</blockquote>

# --instructions--

建置一個 API 端點，掛載於 `GET /name`。回應一個 JSON 文件，採用結構 `{ name: 'firstname lastname'}`。名字和姓氏參數應該編碼在查詢字串中，例如 `?first=firstname&last=lastname`。

**注意：** 在以下練習中，你將從 POST 請求接收資料，路由路徑仍為 `/name`。如果你願意，可以使用方法 `app.route(path).get(handler).post(handler)`。這個語法允許你在相同路由路徑上串鏈不同的動詞處理常式。你可以節省一些輸入，並且讓程式碼更乾淨。

# --hints--

測試 1 ：當使用 `?first=Mick&last=Jagger` 呼叫 `/name` 端點時，你的 API 端點應回應 `{ "name": "Mick Jagger" }`。

```js
  const response = await fetch(code + '/name?first=Mick&last=Jagger');
  if (!response.ok) {
    throw new Error(await response.text());
  }
  const data = await response.json();
  assert.equal(
    data.name,
    'Mick Jagger',
    'Test 1: "GET /name" route does not behave as expected'
  );
```

測試 2 ：當使用 `?first=Keith&last=Richards` 呼叫 `/name` 端點時，你的 API 端點應回應 `{ "name": "Keith Richards" }`。

```js
  const response = await fetch(code + '/name?last=Richards&first=Keith');
  if (!response.ok) {
    throw new Error(await response.text());
  }
  const data = await response.json();
  assert.equal(
    data.name,
    'Keith Richards',
    'Test 2: "GET /name" route does not behave as expected'
  );
```

