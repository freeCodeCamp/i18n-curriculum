---
id: 67fe859f55cd33356e322fd3
title: '¿Cómo funcionan las funciones en Python?'
#change back to 11 when video is updated
challengeType: 19
#videoId: new-id-goes-here-when-ready
dashedName: how-do-functions-work-in-python
---

# --description--

Las funciones son piezas reutilizables de código que se ejecutan cuando las llamas. Muchos lenguajes de programación incluyen funciones integradas que facilitan comenzar. Python no es la excepción, y ya hemos cubierto algunas funciones integradas como `print()` en lecciones anteriores.

Otra función integrada útil es `input()`, que te permite pedir la entrada del usuario:

```python
name = input('What is your name?') # User types "Kolade" and presses Enter  
print('Hello', name) # Output: Hello Kolade
```

Por otro lado, `int()` convierte un número, booleano y una cadena numérica en un entero:

```python
print(int(3.14)) # 3
print(int('42')) # 42
print(int(True)) # 1
print(int(False)) # 0 
```

También puedes escribir tus propias funciones personalizadas. Para hacerlo, usa la palabra clave `def`, seguida del nombre que deseas darle a tu función, un par de paréntesis y dos puntos. Luego, en una nueva línea, escribe el código que tu función debería ejecutar. El código que ejecuta la función también se conoce como el cuerpo de la función.

Aquí está un ejemplo de una función personalizada llamada `hello` que imprime la cadena `Hello World` en el terminal:

```python
def hello():
    print('Hello World')
```

Para ejecutar la función, debes llamarla con su nombre seguido de un par de paréntesis:

```python
hello() # Hello World
```

Observa la indentación antes de `print('Hello World')`. El nivel de indentación define un "bloque de código" en Python, que es un grupo de declaraciones que pertenecen juntas.

Aunque otros lenguajes de programación usan caracteres como llaves para definir bloques de código y solo usan la indentación para la legibilidad, en Python, los bloques de código están determinados por la indentación.

Aunque puedes usar dos o cuatro espacios para determinar cada nivel de indentación, la guía de estilo de Python recomienda usar cuatro espacios.

Los bloques también se encuentran en loops y condicionales, que aprenderás en futuras lecciones.

Aquí hay otra función simple que imprime la suma de dos números en el terminal:

```python
def calculate_sum(a, b):
    print(a + b)
```

Puedes ver que nuestra función, `calculate_sum`, tiene `a` y `b` en sus paréntesis, separados por una coma. Esos se llaman parámetros. Piense en los parámetros como variables de marcador de posición que actúan como "ranuras" para los valores que se pasan a las funciones cuando las llamas.

Para usar los parámetros, tienes que pasar "argumentos". Los argumentos son los valores que pasas a una función cuando la llamas.

Aquí está cómo llamar a la función `calculate_sum` para sumar juntos los números `3` y `1`:

```python
calculate_sum(3, 1) # 4
```

Si llamas a la función sin el número correcto de argumentos, obtendrás un `TypeError`:

```python
calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'
```

Las funciones también usan una palabra clave especial `return` para salir de la función y devolver un valor. Si no usas explícitamente `return`, Python devolverá `None` por defecto.

Aquí tienes un ejemplo:

```python
def calculate_sum(a, b):
    print(a + b)

my_sum = calculate_sum(3, 1) # 4
print(my_sum) # None
```

Puedes ver que la función `calculate_sum` imprime la suma de `a` y `b`, pero no devuelve nada explícitamente. Así que cuando asignamos su resultado a `my_sum`, el valor es en realidad `None`. Para solucionar eso, puedes usar la palabra clave `return` para enviar de vuelta el resultado:

```python
def calculate_sum(a, b):
    return a + b

my_sum = calculate_sum(3, 1)
print(my_sum) # 4
```

Ahora, `calculate_sum` devuelve la suma de `a` y `b`, que se almacena en `my_sum`.

Los decoradores son un tipo especial de función en Python. Son como envoltorios para otras funciones, por lo que toman otra función como argumento. Con los decoradores, puedes agregar funcionalidades adicionales a una función sin modificar su código original. Aquí tienes un ejemplo de cómo usar un decorador:

```python
def say_hello():
   name = input('What is your name? ')
   return 'Hello ' + name

def uppercase_decorator(func):
   def wrapper():
       original_func = func()
       modified_func = original_func.upper()
       return modified_func
   return wrapper

say_hello_res = uppercase_decorator(say_hello)

print(say_hello_res())
```

En este código:

- Estamos obteniendo una entrada del usuario y almacenándola en una variable `nombre`.

- La función `say_hello` devuelve `Hola` y el `nombre`.

- El decorador, `uppercase_decorator` toma una función, la llama, luego convierte su valor devuelto a mayúsculas y devuelve la función original.

- La función `uppercase_decorator` luego se llama con la función original `say_hello` y se guarda en `say_hello_res`.

- `say_hello_res` luego se llama e imprime en una sola línea.


Así es como se usan típicamente los decoradores.

# --questions--

## --text--

¿Cuál es el valor de retorno predeterminado de una función en Python?

## --answers--

`0`

### --feedback--

Si una función no tiene una declaración `return`, devuelve automáticamente este valor.

---

`None`

---

`""` (cadena vacía)

### --feedback--

Si una función no tiene una declaración `return`, devuelve automáticamente este valor.

---

`False`

### --feedback--

If a function has no `return` statement, it automatically returns this value.

## --video-solution--

2

## --text--

¿Cuál es el término para una variable de marcador de posición en una función?

## --answers--

Parámetro

---

Argumento

### --feedback--

Está definido en la declaración de la función, no cuando se llama.

---

Valor de retorno

### --feedback--

It's defined in the function declaration, not when calling it.

---

Decorador

### --feedback--

It's defined in the function declaration, not when calling it.

## --video-solution--

1

## --text--

¿Cuál es el propósito de los decoradores en Python?

## --answers--

Modifican el código original de una función directamente para agregar funcionalidades adicionales.

### --feedback--

Los decoradores actúan como envoltorios alrededor de funciones.

---

Convierten una función en una clase para una mejor organización.

### --feedback--

Decorators act like wrappers around functions.

---

Permiten que las funciones se ejecuten sólo una vez cuando se definen.

### --feedback--

Decorators act like wrappers around functions.

---

Envuelven otra función para ampliar su comportamiento sin modificar el código original.

## --video-solution--

4
