---
id: 5a23c84252665b21eecc7e80
title: 格雷碼
challengeType: 1
forumTopicId: 302276
dashedName: gray-code
---

# --description--

Gray code 是一種二進位編碼形式，其中連續數字之間的轉換僅相差一個位元。

這是一種有用的編碼，用於減少硬體資料風險，適用於快速變化和／或連接到較慢硬體作為輸入的值。

它也有助於依照從左到右或從上到下的順序產生卡諾圖的輸入。

# --instructions--

創建一個函式（程式）來將數字編碼為 Gray code 並從 Gray code 解碼數字。該函式（程式）應該有 2 個參數。

第一個會是布林值。該函式（程式）應該對 true 進行編碼，對 false 進行解碼。第二個參數會是要編碼／解碼的數字。

顯示所有 5 位元二進位數字（包含 0-31，前導 0 不必要）的正常二進位表述、Gray code 表述，以及解碼後的 Gray code 值。

有許多可能的 Gray code。以下編碼的是所謂的「二進位反射 Gray code」。

編碼（MSB 是位元 0，b 是二進位，g 是 Gray 程式碼）：

<pre>if b[i-1] = 1
  g[i] = not b[i]
else
  g[i] = b[i]
</pre>

或者：

<pre>g = b xor (b logically right shifted 1 time)
</pre>

解碼（MSB 是位元 0，b 是二進位，g 是 Gray 程式碼）：

<pre>b[0] = g[0]<br>
for other bits:
b[i] = g[i] xor b[i-1]
</pre>

# --hints--

`gray` 應該是一個函式（程式）。

```js
assert(typeof gray == 'function');
```

`gray(true,177)` 應該傳回一個數字。

```js
assert(typeof gray(true, 177) == 'number');
```

`gray(true,177)` 應該傳回 `233`。

```js
assert.equal(gray(true, 177), 233);
```

`gray(true,425)` 應該傳回 `381`。

```js
assert.equal(gray(true, 425), 381);
```

`gray(true,870)` 應該傳回 `725`。

```js
assert.equal(gray(true, 870), 725);
```

`gray(false,233)` 應該傳回 `177`。

```js
assert.equal(gray(false, 233), 177);
```

`gray(false,381)` 應該傳回 `425`。

```js
assert.equal(gray(false, 381), 425);
```

`gray(false,725)` 應該傳回 `870`。

```js
assert.equal(gray(false, 725), 870);
```

# --seed--

## --seed-contents--

```js
function gray(enc, number) {

}
```

# --solutions--

```js
function gray(enc, number){
  if(enc){
      return number ^ (number >> 1);
  }else{
      let n = number;

      while (number >>= 1) {
          n ^= number;
      }
      return n;
  }
}
```
