---
id: 587d824a367417b2b2512c43
title: 個人函式庫
challengeType: 4
forumTopicId: 301571
dashedName: personal-library
---

# --description--

建置一個功能上類似於此的全端 JavaScript 應用程式：<a href="https://personal-library.freecodecamp.rocks/" target="_blank" rel="noopener noreferrer nofollow">https://personal-library.freecodecamp.rocks/</a>。進行此專案將需要你使用以下其中一種方法撰寫你的程式碼：

-   複製<a href="https://github.com/freeCodeCamp/boilerplate-project-library" target="_blank" rel="noopener noreferrer nofollow">這個 GitHub 倉庫</a>，並在區域完成你的專案。
-   使用你選擇的網站建置工具來完成專案。務必將我們 GitHub 倉庫中的所有檔案納入其中。

# --instructions--

1.  將你的 MongoDB 連接字串添加到 `.env`，不加引號，作為 `DB`  
範例：`DB=mongodb://admin:pass@1234.mlab.com:1234/fccpersonallib`
2.  在你的 `.env` 檔案中將 `NODE_ENV` 設定為 `test`，不加引號
3.  你需要在 `routes/api.js` 中創建所有路由。
4.  你將在 `tests/2_functional-tests.js` 中創建所有功能測試。

# --hints--

你可以提供你自己的專案，而非範例 URL。

```js
  assert(
    !/.*\/personal-library\.freecodecamp\.rocks/.test(code)
  );
```

你可以發送一個 <b>POST</b> 請求到 `/api/books`，並將 `title` 作為表單資料的一部分來添加一本書。傳回的回應將會是一個包含 `title` 和唯一 `_id` 作為鍵的物件。如果請求中未包含 `title`，傳回的回應應該是字串 `missing required field title`。

```js
  try {
    const response1 = await fetch(code + '/api/books', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: 'Faux Book 1' })
    });
    if (!response1.ok) {
      throw Error(await response1.text());
    }
    let data1 = await response1.json();
    assert.isObject(data1);
    assert.property(data1, 'title');
    assert.equal(data1.title, 'Faux Book 1');
    assert.property(data1, '_id');
    const response2 = await fetch(code + '/api/books', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({})
    });
    if (!response2.ok) {
      throw Error(await response2.text());
    }
    let data2 = await response2.text();
    assert.isString(data2);
    assert.equal(data2, 'missing required field title');
  } catch (err) {
    throw new Error(err.responseText || err.message);
  }
```

你可以發送一個 <b>GET</b> 請求到 `/api/books` 並接收一個 JSON 回應，該回應表述所有書籍。JSON 回應將會是一個包含物件的陣列，每個物件（書籍）包含 `title`、`_id` 和 `commentcount` 屬性。

```js
  try {
    let url = code + '/api/books';
    let a = fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: 'Faux Book A' })
    }).then(response => {
      if (!response.ok) throw Error(response.text());
      return response.json();
    });
    let b = fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: 'Faux Book B' })
    }).then(response => {
      if (!response.ok) throw Error(response.text());
      return response.json();
    });
    let c = fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: 'Faux Book C' })
    }).then(response => {
      if (!response.ok) throw Error(response.text());
      return response.json();
    });
    await Promise.all([a, b, c]).then(async () => {
      const response = await fetch(url);
      if (!response.ok) {
        throw Error(await response.text());
      }
      let data = await response.json();
      assert.isArray(data);
      assert.isAtLeast(data.length, 3);
      data.forEach((book) => {
        assert.isObject(book);
        assert.property(book, 'title');
        assert.isString(book.title);
        assert.property(book, '_id');
        assert.property(book, 'commentcount');
        assert.isNumber(book.commentcount);
      });
    });
  } catch (err) {
    throw new Error(err.responseText || err.message);
  }
```

你可以發送一個 <b>GET</b> 請求到 `/api/books/{_id}` 以取得包含屬性 `title`、`_id` 和 `comments` 陣列（若無評論則為空陣列）的單一本書物件。如果找不到書籍，則傳回字串 `no book exists`。

```js
  try {
    let url = code + '/api/books';
    const noBookResponse = await fetch(url + '/5f665eb46e296f6b9b6a504d');
    if (!noBookResponse.ok) {
      throw Error(await noBookResponse.text());
    }
    let noBook = await noBookResponse.text();
    assert.isString(noBook);
    assert.equal(noBook, 'no book exists');
    const createResponse = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: 'Faux Book Alpha' })
    });
    if (!createResponse.ok) {
      throw Error(await createResponse.text());
    }
    let sampleBook = await createResponse.json();
    assert.isObject(sampleBook);
    let bookId = sampleBook._id;
    const queryResponse = await fetch(url + '/' + bookId);
    if (!queryResponse.ok) {
      throw Error(await queryResponse.text());
    }
    let bookQuery = await queryResponse.json();
    assert.isObject(bookQuery);
    assert.property(bookQuery, 'title');
    assert.equal(bookQuery.title, 'Faux Book Alpha');
    assert.property(bookQuery, 'comments');
    assert.isArray(bookQuery.comments);
  } catch (err) {
    throw new Error(err.responseText || err.message);
  }
```

你可以發送包含 `comment` 作為表單主體資料的 <b>POST</b> 請求到 `/api/books/{_id}`，以為書籍添加評論。傳回的回應將是類似先前測試中 <b>GET</b> `/api/books/{_id}` 請求的書籍物件。如果請求中未包含 `comment`，則傳回字串 `missing required field comment`。如果找不到書籍，則傳回字串 `no book exists`。

```js
  try {
    let url = code + '/api/books';
    const createResponse = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: 'Notable Book' })
    });
    if (!createResponse.ok) {
      throw Error(await createResponse.text());
    }
    let commentTarget = await createResponse.json();
    assert.isObject(commentTarget);
    let bookId = commentTarget._id;
    const comment1Response = await fetch(url + '/' + bookId, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ comment: 'This book is fab!' })
    });
    if (!comment1Response.ok) {
      throw Error(await comment1Response.text());
    }
    let bookCom1 = await comment1Response.json();
    const comment2Response = await fetch(url + '/' + bookId, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ comment: 'I did not care for it' })
    });
    if (!comment2Response.ok) {
      throw Error(await comment2Response.text());
    }
    let bookCom2 = await comment2Response.json();
    assert.isObject(bookCom2);
    assert.property(bookCom2, '_id');
    assert.property(bookCom2, 'title');
    assert.property(bookCom2, 'comments');
    assert.lengthOf(bookCom2.comments, 2);
    bookCom2.comments.forEach((comment) => {
      assert.isString(comment);
      assert.oneOf(comment, ['This book is fab!', 'I did not care for it']);
    });
    const commentErrResponse = await fetch(url + '/' + bookId, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({})
    });
    if (!commentErrResponse.ok) {
      throw Error(await commentErrResponse.text());
    }
    let commentErr = await commentErrResponse.text();
    assert.isString(commentErr);
    assert.equal(commentErr, 'missing required field comment');
    const failingCommentResponse = await fetch(url + '/5f665eb46e296f6b9b6a504d', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ comment: 'Never Seen Comment' })
    });
    if (!failingCommentResponse.ok) {
      throw Error(await failingCommentResponse.text());
    }
    let failingComment = await failingCommentResponse.text();
    assert.isString(failingComment);
    assert.equal(failingComment, 'no book exists');
  } catch (err) {
    throw new Error(err.responseText || err.message);
  }
```

你可以發送一個 <b>DELETE</b> 請求到 `/api/books/{_id}`，以從群集中刪除一本書。若成功，回傳的回應將會是字串 `delete successful`。如果找不到書籍，則傳回字串 `no book exists`。

```js
  try {
    let url = code + '/api/books';
    const createResponse = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: 'Deletable Book' })
    });
    if (!createResponse.ok) {
      throw Error(await createResponse.text());
    }
    let deleteTarget = await createResponse.json();
    assert.isObject(deleteTarget);
    let bookId = deleteTarget._id;
    const deleteResponse = await fetch(url + '/' + bookId, { method: 'DELETE' });
    if (!deleteResponse.ok) {
      throw Error(await deleteResponse.text());
    }
    let doDelete = await deleteResponse.text();
    assert.isString(doDelete);
    assert.equal(doDelete, 'delete successful');
    const failingDeleteResponse = await fetch(url + '/5f665eb46e296f6b9b6a504d', { method: 'DELETE' });
    if (!failingDeleteResponse.ok) {
      throw Error(await failingDeleteResponse.text());
    }
    let failingDelete = await failingDeleteResponse.text();
    assert.isString(failingDelete);
    assert.equal(failingDelete, 'no book exists');
  } catch (err) {
    throw new Error(err.responseText || err.message);
  }
```

你可以發送一個 <b>DELETE</b> 請求到 `/api/books` 以刪除資料庫中所有書籍。若成功，傳回的回應將會是字串 `complete delete successful`。

```js
  try {
    const response = await fetch(code + '/api/books', { method: 'DELETE' });
    if (!response.ok) {
      throw Error(await response.text());
    }
    const deleteAll = await response.text();
    assert.isString(deleteAll);
    assert.equal(deleteAll, 'complete delete successful');
  } catch (err) {
    throw new Error(err.responseText || err.message);
  }
```

所有 10 項所需的功能測試皆已完成且通過。

```js
  try {
    const response = await fetch(code + '/_api/get-tests');
    if (!response.ok) {
      throw Error(await response.text());
    }
    const getTests = await response.json();
    assert.isArray(getTests);
    assert.isAtLeast(getTests.length, 10, 'At least 10 tests passed');
    getTests.forEach((test) => {
      assert.equal(test.state, 'passed', 'Test in Passed State');
      assert.isAtLeast(
        test.assertions.length,
        1,
        'At least one assertion per test'
      );
    });
  } catch (err) {
    throw new Error(err.responseText || err.message);
  }
```
