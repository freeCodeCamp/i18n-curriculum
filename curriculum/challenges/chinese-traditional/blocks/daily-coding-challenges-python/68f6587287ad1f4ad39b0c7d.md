---
id: 68f6587287ad1f4ad39b0c7d
title: "挑戰 91：字搜尋"
challengeType: 29
dashedName: challenge-91
---

# --description--

給定一個矩陣（一個陣列的陣列），其中包含單一字母，以及一個要尋找的字，傳回該字在矩陣中的起始和結束索引。

- 給定的矩陣將會填滿所有小寫字母（`a-z`）。
- 要尋找的字、單字將始終在矩陣中恰好出現一次。
- 要尋找的字會永遠沿著以下方向之一的直線排列：
  - 從左到右
  - 從右到左
  - 由上而下
  - 由下而上

例如，給定矩陣：

```md
[
  ["a", "c", "t"],
  ["t", "a", "t"],
  ["c", "t", "c"]
]
```

而字 `"cat"`，傳回：

```md
[[0, 1], [2, 1]]
```

其中 `[0, 1]` 是 `"c"`（字的開始）的索引，而 `[2, 1]` 是 `"t"`（字的結束）的索引。

# --hints--

`find_word([["a", "c", "t"], ["t", "a", "t"], ["c", "t", "c"]], "cat")` 應該傳回 `[[0, 1], [2, 1]]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(find_word([["a", "c", "t"], ["t", "a", "t"], ["c", "t", "c"]], "cat"), [[0, 1], [2, 1]])`)
}})
```

`find_word([["d", "o", "g"], ["o", "g", "d"], ["d", "g", "o"]], "dog")` 應該傳回 `[[0, 0], [0, 2]]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(find_word([["d", "o", "g"], ["o", "g", "d"], ["d", "g", "o"]], "dog"), [[0, 0], [0, 2]])`)
}})
```

`find_word([["h", "i", "s", "h"], ["i", "s", "f", "s"], ["f", "s", "i", "i"], ["s", "h", "i", "f"]], "fish")` 應該傳回 `[[3, 3], [0, 3]]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(find_word([["h", "i", "s", "h"], ["i", "s", "f", "s"], ["f", "s", "i", "i"], ["s", "h", "i", "f"]], "fish"), [[3, 3], [0, 3]])`)
}})
```

`find_word([["f", "x", "o", "x"], ["o", "x", "o", "f"], ["f", "o", "f", "x"], ["f", "x", "x", "o"]], "fox")` 應該傳回 `[[1, 3], [1, 1]]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(find_word([["f", "x", "o", "x"], ["o", "x", "o", "f"], ["f", "o", "f", "x"], ["f", "x", "x", "o"]], "fox"), [[1, 3], [1, 1]])`)
}})
```

# --seed--

## --seed-contents--

```py
def find_word(matrix, word):

    return matrix
```

# --solutions--

```py
def find_word(matrix, word):
    rows = len(matrix)
    cols = len(matrix[0])
    length = len(word)

    directions = [
        (0, 1),
        (0, -1),
        (1, 0),
        (-1, 0)
    ]

    for r in range(rows):
        for c in range(cols):
            for dr, dc in directions:
                match = True
                for i in range(length):
                    nr = r + dr * i
                    nc = c + dc * i
                    if nr < 0 or nr >= rows or nc < 0 or nc >= cols or matrix[nr][nc] != word[i]:
                        match = False
                        break
                if match:
                    return [[r, c], [r + dr * (length - 1), c + dc * (length - 1)]]
```
