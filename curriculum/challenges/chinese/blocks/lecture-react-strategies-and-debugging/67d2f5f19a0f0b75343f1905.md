---
id: 67d2f5f19a0f0b75343f1905
title: 什么是 React 服务器组件，它们如何工作？
challengeType: 19
dashedName: what-are-react-server-components-and-how-do-they-work
---

# --description--

React 服务器组件（RSCs）是一种改变 React 开发者工作方式的新趋势。使用 RSCs，更多工作转移到服务器端，这带来了许多好处。

让我们来看看什么是服务器组件，它们如何工作，以及促使服务器组件引入的原因。

React 服务器端组件是仅在服务器上渲染的 React 组件，服务器只将最终的 HTML 发送给客户。这意味着这些组件可以直接访问服务器端资源，并大幅减少发送到浏览器的 JavaScript 数量。

React 应用传统上使用一种“客户组件”系统，处理典型 React 应用中的所有内容，例如渲染、交互性和副作用。直到最近引入 React 服务器组件之前，“客户组件”这一术语很少被使用。

但是客户组件系统存在一些缺点，例如较大的 JavaScript 包和较慢的初始装载时间。

像 Next.js 和 Gatsby 这样的 React 框架找到了解决方法，将一些进程卸载到服务器以修复这些问题，但它们都没有标准化。如果你使用过任一框架，你可能听说过 `getServerSideProps` 和 `getServerData`。

然后出现了 React Server Components，它允许你将某些组件完全在服务器上运行，这样你就可以在任何代码在用户浏览器中运行之前进行数据获取和计算。

服务器组件最早在 Next.js 中流行起来并且随时可用。其他框架如 Remix 和 Gatsby 正在赶上，还有一个名为 `vite-plugin-react-server` 的 Vite 实验性插件，可以让你构建服务器组件。

那么 `server components` 是如何工作的？

演示 React Server Components 的最佳方式之一是使用数据获取。

在传统的 React 客户端组件中，你让浏览器处理 API 请求。由于数据获取是一个副作用，你在 `useEffect` 钩子中进行该 API 调用。

设置状态变量如 loading、data 和 error 也是一种良好实践，这样你可以指示数据正在装载、在数据准备好时显示数据，或在你的应用中显示误差。

使用 React 服务器组件，你可以将整个组件移动到服务器并在那里获取数据，而无需使用 `useState` 或 `useEffect`：

```jsx
const Users = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  const users = await res.json();

  return (
    <>
      <h1 className="text-4xl text-center mt-6">Users</h1>
      <ul className="text-center mt-3">
        {users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </>
  );
};

export default Users;
```

因为 `React Server Components` 只在服务器上运行，你可以直接从 API 获取数据并只渲染一次。此外，由于数据获取发生在更接近源头的服务器上，你的应用可能表现更好，尤其是对于网络连接较慢的人。

一个主要的陷阱是所有 `server` 组件的代码都保留在 `server` 上，不会被发送到浏览器。这意味着你不能在它们中使用 React hooks，并且它们无法访问 Web API 或浏览器 `event` 监听器。那么你如何为它们添加交互性呢？

在 Next.js 应用路由中，所有组件默认都是服务器组件。如果你想添加交互性，需要使用 `"use client"` 指令将组件标记为客户组件。

假设你想将前面的示例制作成一个客户组件。以下是你可以这样做的方法：

```jsx
"use client";

import { useState, useEffect } from "react";

const Users2 = () => {
  const [status, setStatus] = useState({
    users: [],
    loading: true,
    error: null,
  });

  async function fetchUsers() {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/users");
      const data = await res.json();
      setStatus((prevStatus) => ({
        ...prevStatus,
        users: data,
        loading: false,
      }));
    } catch (err) {
      setStatus((prevStatus) => ({
        ...prevStatus,
        error: err.message,
        loading: false,
      }));
    }
  }

  useEffect(() => {
    fetchUsers();
  }, []);

  if (status.loading) {
    return <p>Loading Users...</p>;
  }
  if (status.error) {
    return <p>Error getting users: {status.error}</p>;
  }

  return (
    <>
      <h1 className="text-4xl text-center mt-6">Users</h1>
      <ul className="text-center mt-3">
        {status.users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </>
  );
};

export default Users2;
```

如果你想添加像点击事件这样的交互性，组件也必须被标记为客户组件：

```jsx
"use client";

import { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <>
      <h1>Counter</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <h2>{count}</h2>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
    </>
  );
};

export default Counter;
```

如果你不为组件添加 `use client` 指令，你会收到一条消息提示的误差，内容是 "You're importing a server component that needs `useState`。这个 React 钩子只在客户端组件中有效。要修复，请用 `"use client"` 指令标记该文件（或其父级）。"

React Server Components 随附的主要好处是数据获取变得更简单，代码更易于读取，且客户复杂度降低。

# --questions--

## --text--

React Server 组件运行在哪里？

## --answers--

仅限浏览器中。

### --feedback--

考虑到 RSC 不在浏览器中执行，并用于预渲染数据。

---

在客户和服务器上。

### --feedback--

考虑到 RSC 不在浏览器中执行，并用于预渲染数据。

---

完全在服务器上。

---

在 Web Worker 中。

### --feedback--

考虑到 RSC 不在浏览器中执行，并用于预渲染数据。

## --video-solution--

3

## --text--

为什么 React 服务器组件无法访问 React hooks 和 Web APIs？

## --answers--

它们在浏览器装载之前被渲染。

### --feedback--

这些组件从不在浏览器中执行，因此它们不能使用客户端特色。

---

它们只在服务器上运行，不会被发送到浏览器。

---

它们受限于 React 的渲染周期。

### --feedback--

这些组件从不在浏览器中执行，因此它们不能使用客户端特色。

---

它们仅用于样式目的。

### --feedback--

这些组件从不在浏览器中执行，因此它们不能使用客户端特色。

## --video-solution--

2

## --text--

在使用 app router 时，如何为 Next.js 中的组件添加交互性？

## --answers--

将组件包裹在 `<ClientProvider>` 标签中。

### --feedback--

Next.js 假设所有组件都是服务器组件，除非显式声明另有说明。

---

使用 Next.js 中的 `withClient()` 函数。

### --feedback--

Next.js 假设所有组件都是服务器组件，除非显式声明另有说明。

---

在 `next.config.js` 中启用客户端渲染。

### --feedback--

Next.js 假设所有组件都是服务器组件，除非显式声明另有说明。

---

使用 `"use client"` 指令将组件标记为客户组件。

## --video-solution--

4
