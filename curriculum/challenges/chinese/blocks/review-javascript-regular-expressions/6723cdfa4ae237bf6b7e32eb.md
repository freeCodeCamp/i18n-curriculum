---
id: 6723cdfa4ae237bf6b7e32eb
title: JavaScript 正则表达式复习
challengeType: 31
dashedName: review-javascript-regular-expressions
---

# --interactive--

## 正则表达式和常用方法

- **定义**：正则表达式，或称 Regex，用于创建一个“模式”，你可以用它来查看字串、提取文本等。

```js
const regex = /freeCodeCamp/;
```

- **`test()` 方法**：此方法接受一个字串，该字串用于测试是否与正则表达式匹配。如果字串匹配正则表达式，此方法将返回一个布尔值。

:::interactive_editor

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test); // false
```

:::

- **`match()` 方法**：此方法接受一个正则表达式，尽管你也可以传入一个字串，该字串将被构造为正则表达式。`match` 方法返回该字串的匹配数组。

:::interactive_editor

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match); // ["freeCodeCamp"]
```

:::

- **`replace()` 方法**：此方法接受两个参数：用于匹配的正则表达式（或字串），以及用于替换匹配项的字串（或对每个匹配项运行的函数）。

:::interactive_editor

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced); // "freeCodeCamp is rly kewl"
```

:::

- **`replaceAll` 方法**：此方法用于将指定模式的所有出现替换为新字串。如果你传入没有全局修饰符的正则表达式，此方法将抛出误差。

:::interactive_editor

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

:::

- **`matchAll` 方法**：此方法用于检索字串中给定正则表达式的所有匹配项，包括捕获组，并将它们作为迭代器返回。迭代器是一个允许你遍历（或“迭代”）集合中项的对象。

:::interactive_editor

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

:::

## 正则表达式修饰符

- **定义**：修饰符，通常称为“标记”，修改正则表达式的行为。
- **`i` 标记**：此标记使正则表达式忽略分支。

:::interactive_editor

```js
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
```

:::

- **`g` 标记**：此标记，或全局修饰符，允许你的正则表达式多次匹配一个模式。

:::interactive_editor

```js
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
```

:::

- **锚点定义**：位于正则表达式开头的 `^` 锚点表示“匹配字串的开始”。位于正则表达式结尾的 `$` 锚点表示“匹配字串的结束”。

:::interactive_editor

```js
const start = /^freeCodeCamp/i;
const end = /freeCodeCamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
```

:::

- **`m` 标记**：锚点查找整个字串的开始和结束。但你可以使用 `m` 标记，或多行修饰符，使正则表达式处理器支持多行。

:::interactive_editor

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const str = `I love 
freecodecamp
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true
```

:::

- **`d` 标记**：此标记扩展你在匹配对象中获得的信息。

:::interactive_editor

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

:::

- **`u` 标记**：这扩展了正则表达式的功能性，使其能够匹配特殊的 unicode 字符。`u` 标记使你能够访问像 `Extended_Pictographic` 这样的特殊类，以匹配大多数表情符号。还有一个 `v` 标记，它进一步扩展了 unicode 匹配的功能性。
- **`y` 标记**：粘性修饰符的行为与全局修饰符非常相似，但有一些例外。最大区别是，全局正则表达式会从 lastIndex 开始并查找字串剩余部分的另一个匹配项，但如果粘性正则表达式在上一个 lastIndex 处没有立即匹配，则会返回 null 并将 lastIndex 重置为 0。
- **`s` 标记**：单行修饰符允许通配符字符，在正则表达式中由 `.` 表现，匹配换行符——有效地将字串视为单行文本。

## 字符类

- **通配符 `.`**：字符类是一种特殊的语法，你可以用来匹配字符的集合或子集。你应该学习的第一个字符类是通配符类。通配符由句点表示，匹配除换行符以外的任意单个字符。要允许通配符类匹配换行符，请记住你需要使用 `s` 标记。

```js
const regex = /a./;
```

- **`\d`**：这将匹配字串中所有的数字（`0-9`）。

```js
const regex = /\d/;
```

- **`\w`**：用于匹配字串中的任何单词字符（`a-z0-9_`）。单词字符定义为任何字母（从 a 到 z）、数字（从 0 到 9）或下划线字符。

```js
const regex = /\w/;
```

- **`\s`**：空白字符类 `\s`，由一个反斜线后跟一个 `s` 表现。该字符类将匹配任何空白，包括换行符、空格、制表符和特殊的 unicode 空白字符。
- **取反特殊字符类**：要取反这些字符类之一，不要在斜线后使用小写字母，而是使用对应的大写字母。以下示例不匹配数字字符。相反，它匹配任何不是数字字符的单个字符。

```js
const regex = /\D/;
```

- **自定义字符类**：你可以通过将你希望匹配的字符放在一组方括弧内来创建自定义字符类。

```js
const regex = /[abcdf]/;
```

## 前瞻断言和后顾断言

- **定义**：前瞻和后顾断言允许你根据周围模式的存在或缺失来匹配特定的模式。
- **正向前瞻断言**：当一个模式后面跟着另一个模式时，该断言将匹配该模式。要构造正向前瞻，你需要从你想匹配的模式开始。然后，使用括号包裹你想用作条件的模式。在开括号后，使用 `?=` 来定义该模式为正向前瞻。

```js
const regex = /free(?=code)/i;
```

- **负向前瞻断言**：这是一种用于正则表达式中的条件，用来查看某个模式在字串前方未出现。

```js
const regex = /free(?!code)/i;
```

- **正向后行断言**：此断言仅在前述的另一个特定模式存在时匹配一个模式，但不将前述的模式包含在匹配中。

```js
const regex = /(?<=free)code/i;
```

- **负向后行断言**：该断言确保某个模式前面不跟随另一个特定的模式。只有在指定的模式前面没有紧跟给定的序列时才匹配，且匹配结果不包含前述的序列。

```js
const regex = /(?<!free)code/i;
```

## 正则表达式量词

- **定义**：正则表达式中的量词指定模式（或模式的一部分）应出现的次数。它们帮助控制匹配中字符或组的出现次数。以下示例用于匹配前一个字符恰好出现 4 次。

```js
const regex = /^\d{4}$/;
```

- **`*`** ：匹配前述元素的 0 次或多次出现。
- **`+`**：匹配前述的元素 1 次或多次出现。
- **`?`**：匹配前述元素的 0 次或 1 次出现。
- **`{n}`**：精确匹配前述元素的 n 次出现。
- **`{n,}`**：匹配前述元素出现 n 次或更多次。
- **`{n,m}`**：匹配前述元素出现的 n 到 m 次。

## 捕获组和反向引用

- **捕捉组**：捕捉组允许你“捕捉”匹配字串的一部分，以便你根据需要使用。捕捉组由包含要捕捉的模式的括号定义，且前面没有像前瞻这样的字符。

```js
const regex = /free(code)camp/i;
```

- **非捕获组**：非捕获组类似于捕获组，但不会保存匹配的字串部分以供后续使用。非捕获组由 `(?:...)` 定义。

```js
const regex = /free(?:code)camp/i;
```

- **引用**：正则表达式中的引用指的是一种重用同一表达式中先前匹配的模式部分的方法。它允许你通过编号引用一个被捕捉的分组（括号中的模式部分）。例如，`$1` 指的是第一个被捕捉的分组。

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

:::

- 你可以在正则表达式内部使用反向引用，通过斜线和捕捉组编号来匹配之前捕捉的相同文本。例如：

:::interactive_editor

```js
const regex = /(hello) \1/i;
console.log(regex.test("hello hello"));  // true
console.log(regex.test("hello world"));  // false
```

:::

# --assignment--

查看 JavaScript 正则表达式 主题和 概念。
