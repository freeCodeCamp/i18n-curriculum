---
id: 68420c314cdf5c6863ca8330
title: 什麼是演算法以及 Big O 符號如何運作？
challengeType: 19
dashedName: what-is-an-algorithm-and-how-does-big-o-notation-work
---

# --description--

每個在你的裝置上執行的電腦程式都有一組特定的指令，這些指令會以特定的順序執行以完成任務。

任務可能是排序一組數字、修改影像、追蹤庫存，甚至是執行你最喜歡的遊戲。

這就是演算法發揮作用的地方。**演算法**是一組明確無誤的指令，用於解決問題或執行任務。

你可以將演算法想像成「食譜」。當你烹飪時，食譜會列出你需要的所有食材，並提供逐步說明教你如何準備一道菜。

等價地，你可以將演算法視為告訴電腦應該做什麼以及如何做的「食譜」。

演算法有兩個主要特性：

* 它們不能無限期地繼續。它們必須在有限的步驟內完成。
    
* 每個步驟必須精確且明確。
    

它們可能有零個、一個或多個輸入，並產生一個或多個輸出。

演算法的步驟與任何程式語言無關。

但要實際讓它們在電腦上執行，你需要用程式語言實作它們，例如 Python 或 JavaScript。

如果演算法是正確的，任何有效輸入的輸出都應該符合預期輸出。

除了正確之外，演算法也應該是高效的。

演算法效率可以用它們執行所需的時間以及完成任務所需的記憶體空間來衡量。

了解演算法的效率非常重要，因為它讓你了解當輸入大小增加時，演算法的效能表現如何。

例如，排序 15 個整數與排序 1 百萬個整數不同。

隨著處理程序的規模和複雜度增加，如果演算法不夠高效來控制代碼，你可能會得到一個非常緩慢的電腦程式，甚至可能導致整個系統當機。

這就是為什麼開發和選擇最高效的演算法非常重要。

這就是 Big O 符號變得非常重要的地方。

Big O 符號描述演算法在輸入大小增加時的最壞情況效率、性能或成長率。

演算法的成長率是指當輸入大小增加時，它所需資源的增加速度。

Big O 符號專注於最壞情況的效率，因為即使在最壞情況下，不論輸入為何，了解演算法能有多高效是非常重要的。

回到我們的排序範例，排序 1 百萬個整數直覺上應該比排序 15 個整數花費更多時間和資源。

但是還能多多少？

這真的取決於你選擇用來排序它們的演算法。

Big O 符號不會給你一個精確的數字來描述演算法的效率，但它會根據演算法執行的操作數量，讓你了解當輸入大小增加時效能的擴展情況。

在 Big O 符號中，我們通常用字母 `n` 來表示輸入大小。例如，如果輸入是一個列表，`n` 就表示該列表中的元素數量。

在根據操作數量找出演算法的時間複雜度時，不會考慮常數因子和低階項。因為隨著 `n` 的大小增加，這些較小項在執行的總操作數中的影響會越來越小。

主導演算法整體行為的項將會是帶有輸入大小 `n` 的最高階項。

例如，如果一個演算法執行 `7n + 20` 個操作行為才能完成，當 `n` 增加時，常數 `20` 對最終結果的影響會越來越小。`7n` 這個項目將會逐漸主導，並且這將決定演算法的整體行為和效率。

另一個範例是一個需要 `20n² + 15n + 7` 操作行為才能完成的演算法。隨著 `n` 增大，`20n²` 這個項目會傾向於主導，因此這個演算法會有二次時間複雜度，因為主導項目具有 `n²`。

二次方時間複雜度是你在演算法世界中可以找到的多種不同時間複雜度之一。

讓我們來了解一些最常見的。

**`O(1)`** 被稱為「常數時間複雜度」。當一個演算法具有常數時間複雜度時，無論輸入大小為何，執行所需的時間都相同。

例如，檢查一個數字是偶數還是奇數，無論該數字本身為何，都會花費相同的時間。

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

**`O(log n)`** 被稱為「對數時間複雜度」。這表示隨著輸入大小的增加，演算法所需的時間緩慢增加。這在問題大小反覆以固定比例縮小的問題中很常見。

例如，一個流行的搜尋演算法稱為 Binary Search，其最壞情況時間複雜度為 `O(log n)`。這是因為它在每次比較中消除剩餘元素的一半，使整體更高效。

**`O(n)`** 被稱為「線性時間複雜度」。具有此時間複雜度的演算法執行時間會隨輸入大小成比例增加。

例如，一個 `for` 迴圈迭代列表中所有元素，當列表元素數量增加時，將執行更多的迭代。如果列表大小加倍，操作次數也會大約加倍。

```python
for grade in grades:  # grades is a list.
    print(grade)
```

**`O(n log n)`** 被稱為「對數線性時間複雜度」。這是高效排序演算法（例如合併排序和快速排序）的常見時間複雜度。

**`O(n²)`** 被稱為「二次時間複雜度」。這些演算法的執行時間會隨輸入大小呈二次方增加，通常對於實際問題來說並不高效。

巢狀迴圈是二次時間複雜度的常見範例。內部迴圈會對外部迴圈的每一個 `n` 次迭代執行 `n` 次迭代，導致總共 `n` 平方次迭代。

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

其他時間複雜度包括「指數時間複雜度」，表示為 `O(2^n)`，以及「階乘時間複雜度」，表示為 `O(n!)`。兩者在現實世界情境中皆為低效。

在這個圖表中，你可以比較表述最常見時間複雜度的數學函數的成長。將 x 軸（水平）視為輸入大小，將 y 軸（垂直）視為演算法的執行時間。

你可以看到二次時間複雜度（`O(n²)`）（黃色）比其他複雜度增長得快得多，而常數時間複雜度（`O(1)`）（紅色）即使輸入變大也保持不變。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-is-an-algorithm-and-how-does-big-o-notation-work-1.png" alt="graph comparing time complexity">

很好。到目前為止，你已經了解了 Big O 符號在時間需求方面的應用，但這個符號也可以應用於空間需求的背景關係。

在這個背景關係中，它描述了隨著輸入大小增加，演算法所需的記憶體空間如何成長。

具有「常數空間複雜度」`O(1)` 的演算法，即使輸入變大，也總是需要固定量的記憶體空間。

一個範例會是一個只在記憶體中創建並儲存少數變數的演算法。

相反地，具有「線性空間複雜度」`O(n)` 的演算法所需的空間會隨著輸入大小成比例增加。

這個例子是一個演算法，該演算法創建並儲存一個長度為 `n` 的列表的副本。

最後，具有「二次空間複雜度」`O(n²)` 的演算法的空間需求會隨著輸入大小呈二次方增加。

這個範例是建立一個二維矩陣，其維度由輸入大小決定，並儲存所有可能的配對。

演算法是電腦程式的建造區塊，而 Big O 符號是一個強大的框架，用於分析它們的效率，根據在最壞情況下隨著輸入大小增長，其時間和空間需求的擴展方式。了解它們的效率對於開發在現實情況中高效運作的軟體非常重要。

# --questions--

## --text--

以下哪一項最能描述演算法？

## --answers--

用來撰寫程式碼的特定程式設計語言。

### --feedback--

當你嘗試完成特定任務時，請思考你所遵循的內容。

---

一組逐步指示，用於解決問題或執行任務。

---

一種電腦硬體組件的型別。

### --feedback--

當你嘗試完成特定任務時，請思考你所遵循的內容。

---

一個用於開發和遊玩遊戲的軟體應用程式。

### --feedback--

當你嘗試完成特定任務時，請思考你所遵循的內容。

## --video-solution--

2

## --text--

在演算法的背景關係中，Big O 符號的主要目的是什麼？

## --answers--

測量演算法在特定電腦上以秒為單位的精確執行時間。

### --feedback--

思考 Big O 符號如何幫助你了解演算法在處理大量資料時的效率。

---

計算演算法中程式碼的總行數。

### --feedback--

思考 Big O 符號如何幫助你了解演算法在處理大量資料時的效率。

---

描述當輸入大小增加時，演算法的資源使用量如何成長。

---

要判斷演算法的最佳效率。

### --feedback--

思考 Big O 符號如何幫助你了解演算法在處理大量資料時的效率。

## --video-solution--

3

## --text--

如果一個演算法的時間複雜度是 `O(n)`，這代表它的效率是什麼？

## --answers--

演算法的執行時間會隨輸入大小成比例增加。

---

演算法的執行時間無論輸入大小都保持不變。

### --feedback--

思考「線性」在直接關係或圖表上的直線意義。

---

演算法的執行時間會隨著輸入大小呈指數成長。

### --feedback--

思考「線性」在直接關係或圖表上的直線意義。

---

隨著輸入大小變大，演算法的執行時間減少。

### --feedback--

思考「線性」在直接關係或圖表上的直線意義。

## --video-solution--

1

