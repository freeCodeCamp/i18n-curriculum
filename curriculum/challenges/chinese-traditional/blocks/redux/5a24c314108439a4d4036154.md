---
id: 5a24c314108439a4d4036154
title: 組合多個 Reducers
challengeType: 6
forumTopicId: 301436
dashedName: combine-multiple-reducers
---

# --description--

當你的應用程式狀態開始變得更複雜時，可能會想將狀態拆分成多個部分。但請記住 Redux 的第一原則：所有應用程式狀態都保存在 store 中的單一狀態物件中。因此，Redux 提供了 reducer 複合作為複雜狀態模型的解決方案。你定義多個 reducer 來控制代碼應用程式狀態的不同部分，然後將這些 reducer 組合成一個根 reducer。接著，根 reducer 會被傳入 Redux 的 `createStore()` 方法。

為了讓我們能夠將多個 reducers 組合在一起，Redux 提供了 `combineReducers()` 方法。此方法接受一個物件作為引數，在該物件中你定義屬性，將鍵與特定的 reducer 函式相關聯。你給鍵的名稱將被 Redux 用作相關狀態片段的名稱。

通常，當應用程式狀態的各個部分彼此不同或獨特時，為每個部分創建一個 reducer 是一個良好的做法。<dfn>例如</dfn>，在具有使用者驗證的筆記應用程式中，一個 reducer 可以控制驗證，而另一個 reducer 則控制使用者提交的文字和筆記。對於這樣的應用程式，我們可能會這樣撰寫 `combineReducers()` 方法：

```js
const rootReducer = Redux.combineReducers({
  auth: authenticationReducer,
  notes: notesReducer
});
```

現在，鍵 `notes` 將包含所有與我們的筆記相關的狀態，並由我們的 `notesReducer` 控制代碼。這就是多個 reducer 如何組合以管理更複雜的應用程式狀態。在此範例中，Redux 儲存庫中持有的狀態將是一個包含 `auth` 和 `notes` 屬性的單一物件。

# --instructions--

程式碼編輯器中提供了 `counterReducer()` 和 `authReducer()` 函式，以及一個 Redux store。使用 `Redux.combineReducers()` 方法完成撰寫 `rootReducer()` 函式。將 `counterReducer` 指定到名為 `count` 的鍵，並將 `authReducer` 指定到名為 `auth` 的鍵。

# --hints--

`counterReducer` 應該遞增和遞減 `state`。

```js
assert(
  (function () {
    const initialState = store.getState().count;
    store.dispatch({ type: INCREMENT });
    store.dispatch({ type: INCREMENT });
    const firstState = store.getState().count;
    store.dispatch({ type: DECREMENT });
    const secondState = store.getState().count;
    return firstState === initialState + 2 && secondState === firstState - 1;
  })()
);
```

`authReducer` 應該在 `true` 和 `false` 之間切換 `authenticated` 的 `state`。

```js
assert(
  (function () {
    store.dispatch({ type: LOGIN });
    const loggedIn = store.getState().auth.authenticated;
    store.dispatch({ type: LOGOUT });
    const loggedOut = store.getState().auth.authenticated;
    return loggedIn === true && loggedOut === false;
  })()
);
```

儲存 `state` 應該有兩個鍵：`count`，其保存一個數字，以及 `auth`，其保存一個物件。`auth` 物件應該有一個 `authenticated` 屬性，其保存一個布林值。

```js
assert(
  (function () {
    const state = store.getState();
    return (
      typeof state.auth === 'object' &&
      typeof state.auth.authenticated === 'boolean' &&
      typeof state.count === 'number'
    );
  })()
);
```

`rootReducer` 應該是一個將 `counterReducer` 和 `authReducer` 組合起來的函式（程式）。

```js
assert(
    (function () {
      const noWhiteSpace = __helpers.removeWhiteSpace(code);
      return (
        typeof rootReducer === 'function' &&
        noWhiteSpace.includes('Redux.combineReducers')
      );
    })()
  );
```

# --seed--

## --seed-contents--

```js
const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';

const counterReducer = (state = 0, action) => {
  switch(action.type) {
    case INCREMENT:
      return state + 1;
    case DECREMENT:
      return state - 1;
    default:
      return state;
  }
};

const LOGIN = 'LOGIN';
const LOGOUT = 'LOGOUT';

const authReducer = (state = {authenticated: false}, action) => {
  switch(action.type) {
    case LOGIN:
      return {
        authenticated: true
      }
    case LOGOUT:
      return {
        authenticated: false
      }
    default:
      return state;
  }
};

const rootReducer = // Define the root reducer here

const store = Redux.createStore(rootReducer);
```

# --solutions--

```js
const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';

const counterReducer = (state = 0, action) => {
  switch(action.type) {
    case INCREMENT:
      return state + 1;
    case DECREMENT:
      return state - 1;
    default:
      return state;
  }
};

const LOGIN = 'LOGIN';
const LOGOUT = 'LOGOUT';

const authReducer = (state = {authenticated: false}, action) => {
  switch(action.type) {
    case LOGIN:
      return {
        authenticated: true
      }
    case LOGOUT:
      return {
        authenticated: false
      }
    default:
      return state;
  }
};

const rootReducer = Redux.combineReducers({
  count: counterReducer,
  auth: authReducer
});

const store = Redux.createStore(rootReducer);
```
