---
id: 697dc755c709772fad37de9f
title: ¿Qué son los árboles y los tries y cómo funcionan?
challengeType: 19
dashedName: what-are-trees-and-tries-and-how-do-they-work
---

# --description--

Los árboles son muy importantes en el mundo de la informática.

Un **árbol** es un tipo específico de grafo.

Para que un grafo sea clasificado como un árbol, debe:

* No tiene bucles ni ciclos (caminos donde los nodos de inicio y fin son los mismos).
    
* Estar conectado (cada nodo puede ser alcanzado desde cualquier otro nodo).
    

Los árboles son estructuras de datos no lineales que organizan nodos en una jerarquía, donde los nodos pueden tener hijos, hermanos y nodos padre.

El nodo raíz es la parte más alta de un árbol. Es el único nodo en el árbol que no tiene un nodo padre. Este es el nodo donde comenzarás a recorrer toda la estructura de datos, usualmente con algoritmos como breadth-first search (BFS) o depth-first search (DFS).

Este es un ejemplo gráfico de un árbol:

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-trees-and-tries-and-how-do-they-work-1.png" alt="A tree diagram showing a hierarchical structure with node A at the root, nodes B and C as children of A, and nodes D and E as children of C. Node B is a leaf node.">

Dado que los nodos están organizados en una jerarquía, tienen relaciones entre ellos.

Un **nodo padre** es un nodo que está conectado inmediatamente a otros nodos debajo de él. En el diagrama, el nodo A es el nodo padre de los nodos B y C.

Un **nodo hijo** es un nodo que está conectado inmediatamente a un nodo encima de él. En el diagrama, el nodo D y E son los nodos hijos del nodo C.

Los nodos D y E también se clasifican como **hojas**. Una hoja es un nodo que no tiene nodos hijos. Puedes considerarlos como el final de las "ramas" del árbol.

Los nodos del árbol también tienen propiedades importantes:

* **Profundidad**: la longitud del camino desde la raíz hasta ese nodo. Por ejemplo, en el diagrama, el nodo D tiene profundidad 2 porque si comienzas en la raíz, tienes que pasar por dos aristas para llegar a él.
    
* **Altura**: la longitud del camino desde ese nodo hasta una hoja. Por ejemplo, el nodo C tiene una altura de 1 porque está un nivel por encima de los nodos hoja.
    
* **Grado:** el número de nodos hijos que tiene cada nodo. En el diagrama, el nodo B tiene grado 0 porque es un nodo hoja, por lo que no tiene nodos hijos. El nodo C tiene grado 2 porque tiene dos nodos hijos.
    

Los árboles también tienen una **altura**. La altura de un árbol es la altura de su nodo raíz.

Hay muchos tipos diferentes de árboles, incluyendo Binary Trees, Binary Search Trees, AVL trees, Red-Black Trees y B-Trees.

## Árboles Binarios y Árboles Binarios de Búsqueda

Estos son dos de los tipos de árboles más comúnmente usados.

Un **árbol binario** es un tipo de árbol en el que cada nodo puede tener como máximo dos nodos hijos, un nodo hijo izquierdo y un nodo hijo derecho. ¡Sí, esto significa que el ejemplo que has visto hasta ahora es un árbol binario!

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-trees-and-tries-and-how-do-they-work-1.png" alt="The same binary tree example highlighting that it's a binary tree, with each node having at most two children.">

Un **árbol binario de búsqueda** es una versión más específica de un árbol binario, con una propiedad de ordenamiento muy particular.

Para entenderlo, primero necesitas entender los subárboles. Un **subárbol** es una sección de un árbol que es un árbol en sí mismo.

En nuestro ejemplo de árbol, los nodos C, D y E forman un árbol por sí mismos, por lo que se consideran un subárbol.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-trees-and-tries-and-how-do-they-work-3.png" alt="A diagram highlighting a subtree within the main tree, showing nodes C, D, and E forming their own tree structure.">

La propiedad de ordenamiento de los árboles binarios de búsqueda (BST) establece que para cada nodo, todos los valores en su subárbol izquierdo son menores que el valor del nodo, y todos los valores en su subárbol derecho son mayores que el valor del nodo.

Los subárboles izquierdo y derecho también deben ser árboles binarios de búsqueda.

Este ordenamiento hace que las operaciones de búsqueda, inserción y eliminación sean muy eficientes si el árbol está balanceado.

Un árbol balanceado es un árbol en el que las alturas de los subárboles izquierdo y derecho de cualquier nodo son muy similares para asegurar que las operaciones se mantengan eficientes.

## Tries

Ahora que sabes más sobre árboles y árboles binarios de búsqueda, vamos a sumergirnos en tries.

**Tries** son estructuras de datos en forma de árbol usadas para almacenar un conjunto de cadenas.

Los tries también se conocen como **árboles de prefijos** porque son muy eficientes para operaciones que requieren encontrar cadenas basadas en sus prefijos.

Cada nodo en el trie representa un solo carácter de una cadena.

El nodo raíz no representa ningún carácter en particular, así que puedes pensar en él como que representa una cadena vacía.

A medida que recorres el trie desde la raíz hacia abajo, el camino a un nodo define un prefijo específico. Para encontrar una palabra, sigues ese prefijo hasta llegar al nodo con la palabra que estás buscando.

Los nodos que representan palabras completas se les asignan marcadores de fin de palabra.

Este es un ejemplo de un trie con las palabras "top", "tea" y "ten".

Observa cómo las palabras "tea" y "ten" comparten el mismo prefijo "te", por lo que la estructura de datos sigue el mismo camino hasta el último carácter, que está marcado como un carácter de fin de palabra. En este diagrama, esto se representa con un borde rojo alrededor del nodo:

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-trees-and-tries-and-how-do-they-work-4.png" alt="A trie data structure showing the words 'top', 'tea', and 'ten'. The root node branches to 't', which then branches to 'o' (leading to 'top') and 'e' (leading to 'tea' and 'ten'). End-of-word nodes are marked with red borders.">

La complejidad temporal en el peor caso para la operación de búsqueda es O(L), donde L es la longitud de la cadena que estás buscando.

La inserción también es eficiente. Esta operación solo requiere crear nuevos nodos para los caracteres que aún no existen en el trie.

La gran ventaja de esta estructura de datos es que cuando múltiples cadenas comparten el mismo prefijo, sus rutas se superponen, por lo que el prefijo en sí solo se almacena una vez.

Esta eficiencia hace que los tries sean perfectos para implementar funciones como autocompletar y correctores ortográficos.

Sin embargo, los tries no son eficientes para todos los conjuntos de cadenas. Pueden ser ineficientes si el conjunto de cadenas tiene muchos caracteres únicos. Esto requeriría almacenar muchos caracteres únicos como nodos individuales. Estos nodos tendrían que ser recorridos para encontrar las palabras, lo cual no sería óptimo.

Ahora que estás familiarizado con los diferentes tipos de árboles y para qué se usan, puedes comenzar a usarlos en escenarios del mundo real. Saber cómo elegir el correcto es una habilidad valiosa cuando necesitas enfrentar desafíos en tu trabajo diario.

# --questions--

## --text--

¿Cuál de las siguientes afirmaciones sobre un Binary Search Tree (BST) es siempre verdadera?

## --answers--

Todos los valores en el subárbol izquierdo de un nodo son menores que el valor del nodo.

---

Cada nodo puede tener hasta tres hijos.

### --feedback--

Piensa en la regla específica que gobierna cómo se organizan los números en un Binary Search Tree (BST) para permitir una búsqueda eficiente.

---

El árbol está garantizado que estará perfectamente balanceado después de cada inserción.

### --feedback--

Piensa en la regla específica que gobierna cómo se organizan los números en un Binary Search Tree (BST) para permitir una búsqueda eficiente.

---

Es una estructura especializada en forma de árbol optimizada para almacenar cadenas.

### --feedback--

Piensa en la regla específica que gobierna cómo se organizan los números en un Binary Search Tree (BST) para permitir una búsqueda eficiente.

## --video-solution--

1

## --text--

¿Para cuál de las siguientes tareas es un trie, o árbol de prefijos, más efectivo?

## --answers--

Encontrar el valor más pequeño en un conjunto de datos grande.

### --feedback--

Piensa en la ventaja principal de una estructura trie y cómo se construye basada en caracteres.

---

Gestionando un sistema de archivos jerárquico en una computadora.

### --feedback--

Piensa en la ventaja principal de una estructura trie y cómo se construye basada en caracteres.

---

Implementando una función de autocompletado.

---

Almacenar una lista desordenada de números únicos.

### --feedback--

Piensa en la ventaja principal de una estructura trie y cómo se construye basada en caracteres.

## --video-solution--

3

## --text--

¿Cuál es la diferencia fundamental entre un árbol general y un Binary Tree?

## --answers--

Un Árbol Binario solo puede almacenar números, mientras que un árbol general puede almacenar cualquier tipo de dato.

### --feedback--

Piensa en la cantidad de conexiones que cada nodo en un Árbol Binario puede tener, en comparación con árboles generales.

---

Un Árbol Binario tiene un nodo raíz, pero un árbol general no.

### --feedback--

Piensa en la cantidad de conexiones que cada nodo en un Árbol Binario puede tener, en comparación con árboles generales.

---

Un Árbol Binario no tiene relaciones de padre-hijo, a diferencia de un árbol general.

### --feedback--

Piensa en la cantidad de conexiones que cada nodo en un Árbol Binario puede tener, en comparación con árboles generales.

---

Un Árbol Binario restringe cada nodo a un máximo de dos hijos, mientras que un árbol general no.

## --video-solution--

4
