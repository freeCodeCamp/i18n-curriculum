---
id: 680b3ef395479b0e449ecb6e
title: 實作 Selection Sort 演算法
challengeType: 27
dashedName: implement-selection-sort-algorithm
---

# --description--

選擇排序是大多數計算機科學課程中教授的另一種熱門排序演算法。

這個演算法的運作方式是反覆尋找列表中未排序部分的最小元素，並將其與第一個未排序元素交換。它從選取整個列表中的最小值開始，並將其與第一個元素交換。接著移動到第二個位置，尋找剩餘未排序元素中的最小值，並將其與第二個元素交換。這個過程持續進行，每次移動一個元素，直到整個列表排序完成。

選擇排序在最佳、平均和最壞情況下皆導致二次時間複雜度。空間複雜度將是常數 `O(1)`，因為排序是在原地完成，且無論列表大小如何，都只使用固定量的記憶體。

**目標：** 完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 你應該定義一個名為 `selection_sort` 的函式（程式）。
1. 你的 `selection_sort` 函式應該有一個參數，用來表述項目列表。
1. 你的 `selection_sort` 函式應該接受一個列表，並就地將項目從最小排序到最大。
1. 你的 `selection_sort` 函式應該就地修改輸入的列表，並在排序完成後傳回它。
1. 你的 `selection_sort` 函式應該遵循選擇排序演算法，將列表中未排序部分的最小元素與第一個未排序元素交換。
1. 你的 `selection_sort` 函式不應該在最小元素已經在正確位置時執行不必要的交換。
1. 你的 `selection_sort` 函式不應該使用內建的 `sort()` 方法或 `sorted()` 函式。

# --hints--

你應該有一個名為 `selection_sort` 的函式（程式）。

```js
({test: () => {
    runPython(`
assert _Node(_code).has_function('selection_sort')
    `)
}})
```

你的 `selection_sort` 函式應該有一個參數。

```js
(
    {test: () => {
        runPython(`
            import inspect
            sig = inspect.signature(selection_sort)
            assert len(sig.parameters) == 1
        `)
    }}
)
```

你不應該在你的程式碼中匯入任何模組或使用內建排序方法。

```js
(
    {
        test: () => runPython(`
            assert len(_Node(_code).find_imports()) == 0
            assert not _Node(_code).block_has_call("sort")
            assert not _Node(_code).block_has_call("sorted")
        `)
    }
)
```

你的 `selection_sort` 應該傳回與輸入列表相同的列表。

```js
(
    {
        test: () => runPython(`
            input_list = [32, 0, 88, 1, 203]
            assert selection_sort(input_list) is input_list
        `)
    }
)
```

你的 `selection_sort` 應該就地修改輸入列表。你不應該使用任何添加或移除列表項目的方法。

```js
(
    {
        test: () => runPython(`
            from collections import UserList

            class CustomList(UserList):
                def __init__(self, *args, **kwargs):
                    self._record = []
                    super().__init__(*args, **kwargs)

                def __setitem__(self, key, value):
                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')
                    super().__setitem__(key, value)

                def append(self, *args, **kwargs):
                    self._record.append(f'Appending to list: {args}, {kwargs}')
                    super().append(*args, **kwargs)

                def insert(self, *args, **kwargs):
                    self._record.append(f'Inserting to list: {args}, {kwargs}')
                    super().insert(*args, **kwargs)

                def pop(self, *args, **kwargs):
                    self._record.append(f'Popping from list: {args}, {kwargs}')
                    super().pop(*args, **kwargs)

                def remove(self, *args, **kwargs):
                    self._record.append(f'Removing from list: {args}, {kwargs}')
                    super().remove(*args, **kwargs)


            list_to_sort = CustomList([32, 0, 88, 1, 203])

            selection_sort(list_to_sort)
            assert all(
                'Setting item' in record
                for record in list_to_sort._record
            )
        `)
    }
)
```

你的 `selection_sort` 函式應該遵循選擇排序演算法，將列表中未排序零件的最小值與第一個未排序元素交換。當最小值已經在正確位置時，避免不必要的交換。

```js
(
    {
        test: () => runPython(`
            from collections import UserList

            class CustomList(UserList):
                def __init__(self, *args, **kwargs):
                    self._record = []
                    super().__init__(*args, **kwargs)

                def __setitem__(self, key, value):
                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')
                    super().__setitem__(key, value)


            list_to_sort = CustomList([33, 1, 89, 2, 67, 245])

            swap_pairs = [
                ((0, 1, 33), (1, 33, 1)),
                ((1, 2, 33), (3, 33, 2)),
                ((2, 33, 89), (3, 89, 33)),
                ((3, 67, 89), (4, 89, 67)),
            ]

            selection_sort(list_to_sort)
            record = list_to_sort._record

            actual_pairs = [
                (record[offset * 2], record[offset * 2 + 1])
                for offset, _ in enumerate(record[::2])
            ]
            assert len(swap_pairs) == len(actual_pairs)

            for expected_pair, actual_pair in zip(swap_pairs, actual_pairs):
                assert (
                    set(f'Setting item {key} to {value}. Previous value: {old}' for key, value, old in expected_pair)
                    == set(actual_pair)
                )
        `)
    }
)
```

`selection_sort([33, 1, 89, 2, 67, 245])` 應該傳回 `[1, 2, 33, 67, 89, 245]`。

```js
(
    {
        test: () => runPython(`
            assert selection_sort([33, 1, 89, 2, 67, 245]) == [1, 2, 33, 67, 89, 245]
            
        `)
    }
)
```

`selection_sort([5, 16, 99, 12, 567, 23, 15, 72, 3])` 應該傳回 `[3, 5, 12, 15, 16, 23, 72, 99, 567]`。

```js
(
    {
        test: () => runPython(`
            assert selection_sort([5, 16, 99, 12, 567, 23, 15, 72, 3]) == [3, 5, 12, 15, 16, 23, 72, 99, 567]
            
        `)
    }
)
```

`selection_sort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92])` 應該傳回 `[1, 1, 2, 2, 4, 8, 32, 43, 43, 55, 63, 92, 123, 123, 234, 345, 5643]`。

```js
(
    {
        test: () => runPython(`
            assert selection_sort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]) == [1, 1, 2, 2, 4, 8, 32, 43, 43, 55, 63, 92, 123, 123, 234, 345, 5643]
            
        `)
    }
)
```

你的 `selection_sort` 函式應該能正確排序任何數字列表。

```js
(
    {
        test: () => runPython(`
            assert selection_sort([42, 17, 93, 8, 61, 29]) == [8, 17, 29, 42, 61, 93]
            assert selection_sort([11, 4, 78, 23, 55, 198, 65, 90, 2]) == [2, 4, 11, 23, 55, 65, 78, 90, 198]
            assert selection_sort([9, 27, 3, 7, 101, 66, 34, 52, 87, 42, 12, 29]) == [3, 7, 9, 12, 27, 29, 34, 42, 52, 66, 87, 101]
            assert selection_sort([5, 14, 33, 77, 2, 18, 92, 1, 100, 45, 73, 64, 28, 56]) == [1, 2, 5, 14, 18, 28, 33, 45, 56, 64, 73, 77, 92, 100]
            
        `)
    }
)     
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def selection_sort(nums):
    for i, _ in enumerate(nums):
        min_index = i

        for j in range(i + 1, len(nums)):
            if nums[j] < nums[min_index]:
                min_index = j

        if min_index != i:
            nums[i], nums[min_index] = nums[min_index], nums[i]

    return nums

```
