---
id: 67338e93b75977a344cf6d40
title: 事件冒泡和事件委托是如何工作的？
challengeType: 19
dashedName: how-do-event-bubbling-and-event-delegation-work
---

# --description--

事件冒泡，或传播，指的是当事件被触发时，事件如何“冒泡”到父对象。例如，考虑以下代码：

```html
<p>
  <span>Click me~!</span>
</p>
```

这里的 `p` 元素将被视为 `span` 元素的父元素。 

当你点击 `span` 元素时，正如指示的那样，`span` 元素成为 `click` 事件的目标。该事件，然而，也会冒泡到父元素——`p` 元素可以根据需要接收并处理该事件。

但是这实际上意味着什么？你可以为 `p` 元素添加一个事件监听器：

```js
const p = document.querySelector("p");
p.addEventListener("click", (event) => {
  console.log(event.target);
});
```

然后，当你点击 `span` 元素时，你会看到文本 `Click me~!` 被记录到控制台。

事件传播到父级 `p` 元素，该元素在事件监听器中构造它以显示事件的目标。 

注意目标仍然是 `span` 元素。这是因为 `span` 元素接收了初始点击。

为了确认事情的运行方式，让我们展开我们的代码：

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {
  console.log("P listener: ");
  console.log(event.target);
});
span.addEventListener("click", (event) => {
  console.log("Span listener: ");
  console.log(event.target);
});
```

为了让你了解事件如何冒泡，点击 `span` 元素后你将在控制台看到以下内容：

```html
"Span listener: "
<span>Click me~!</span>
"P listener: "
<span>Click me~!</span>
```

现在让我们看看当你使用 `stopPropagation()` 阻止事件传播时会发生什么。我们将在 `span` 的事件监听器中调用它：

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {
  console.log("P listener: ");
  console.log(event.target);
});
span.addEventListener("click", (event) => {
  console.log("Span listener: ");
  console.log(event.target);
  event.stopPropagation();
});
```

然后再次点击我们的 `span`：

```html
"Span listener: "
<span>Click me~!</span>
```
 
这一次，我们没有看到我们的 `p` 监听器触发。该事件从未在 `p` 元素上触发，因为我们告诉它在处理子 `span` 元素时停止传播。

事件委托可以被视为相反的过程。它是将一个捕捉到的事件，委托给另一个元素的进程。 

回到我们的代码，让我们更新它，使点击 `span` 元素时变为红色：

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {});
span.addEventListener("click", (event) => {
  event.target.style.color = "red";
});
```

但是如果你有二十个 `span` 元素呢？或者你使用 JavaScript 运行中创建更多的 `span` 元素？

你不必为每个 `span` 元素都附加一个事件监听器，实际上你可以在 `p` 元素上使用监听器来处理所有这些元素。换句话说，你可以将 `span` 点击的处理委托给父级的 `p` 元素。

我们的代码现在可能看起来像这样：

```js
const p = document.querySelector("p");
p.addEventListener("click", (event) => {
  event.target.style.color = "red";
});
```

注意我们现在完全没有任何监听器附加到 `span` 元素上。你已经正确地将事件处理委托给了 `p` 元素。但它能正常工作吗？

让我们生成几个额外的 `span` 元素，看看：

```html
<p>
  <span>Click me~!</span>
  <span>Click me~!</span>
  <span>Click me~!</span>
  <span>Click me~!</span>
</p>
```

现在，每次点击 `span`，该元素的文本将变为红色。 

就这样，通过一个事件监听器，我们已经正确地允许了 `click` 事件从 `span` 元素冒泡到父级 `p`，并将该 `click` 事件的逻辑委托给了 `p` 元素。

事件传播和委托可能是一个复杂的话题，尤其是当你涉及像表格这样高度嵌套的元素时。鼓励你进一步探索并尝试我们这里编写的一些代码。


# --questions--

## --text--

JavaScript 中的事件冒泡是什么？

## --answers--

新建事件的过程。

### --feedback--

考虑课程如何描述事件传播的“方向”。

---

事件从子元素传播到父元素的方式。

---

一种防止事件默认行为的方法。

### --feedback--

考虑课程如何描述事件传播的“方向”。

---

将多个事件监听器附加到单个元素的过程。

### --feedback--

考虑课程如何描述事件传播的“方向”。

## --video-solution--

2

## --text--

`stopPropagation()` 方法的目的是什么？

## --answers--

防止事件的默认行为。

### --feedback--

本课演示了该方法对事件冒泡的效果。

---

从一个元素中移除所有事件监听器。

### --feedback--

本课演示了该方法对事件冒泡的效果。

---

阻止事件向父元素冒泡。

---

将事件处理委托给子元素。

### --feedback--

本课演示了该方法对事件冒泡的效果。

## --video-solution--

3

## --text--

使用事件委托的主要优势是什么？

## --answers--

它允许事件向父元素冒泡。

### --feedback--

考虑包含多个 `span` 元素的示例以及事件处理如何被简化。

---

它阻止事件的默认行为。

### --feedback--

考虑包含多个 `span` 元素的示例以及事件处理如何被简化。

---

它减少了多个元素所需的事件监听器数量。

---

它会自动停止事件传播。

### --feedback--

考虑包含多个 `span` 元素的示例以及事件处理如何被简化。

## --video-solution--

3
