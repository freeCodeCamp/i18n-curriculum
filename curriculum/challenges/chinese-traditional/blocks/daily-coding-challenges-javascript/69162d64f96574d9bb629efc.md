---
id: 69162d64f96574d9bb629efc
title: "挑戰 111：球的軌跡"
challengeType: 28
dashedName: challenge-111
---

# --description--

今天的挑戰靈感來自於於 1972 年 11 月 29 日發行的遊戲 Pong。

給定一個矩陣（陣列的陣列），其中包含球的位置（`2`）和球的先前位置（`1`），傳回球下一個位置的矩陣索引。

- 球總是沿直線移動。
- 移動方向由球從 `1` 移動到 `2` 的方式決定。
- 矩陣的邊緣被視為牆壁。如果球撞到：
  - 當碰到頂部或底部牆壁時，它會透過反轉其垂直方向來反彈。
  - 當碰到左邊或右邊牆壁時，它會透過反轉其水平方向來反彈。
  - 在角落，它會透過反轉兩個方向來反彈。

# --hints--

`getNextLocation([[0,0,0,0], [0,0,0,0], [0,1,2,0], [0,0,0,0]])` 應該傳回 `[2, 3]`。

```js
assert.deepEqual(getNextLocation([[0,0,0,0], [0,0,0,0], [0,1,2,0], [0,0,0,0]]), [2, 3]);
```

`getNextLocation([[0,0,0,0], [0,0,1,0], [0,2,0,0], [0,0,0,0]])` 應該傳回 `[3, 0]`。

```js
assert.deepEqual(getNextLocation([[0,0,0,0], [0,0,1,0], [0,2,0,0], [0,0,0,0]]), [3, 0]);
```

`getNextLocation([[0,2,0,0], [1,0,0,0], [0,0,0,0], [0,0,0,0]])` 應該傳回 `[1, 2]`。

```js
assert.deepEqual(getNextLocation([[0,2,0,0], [1,0,0,0], [0,0,0,0], [0,0,0,0]]), [1, 2]);
```

`getNextLocation([[0,0,0,0], [0,0,0,0], [2,0,0,0], [0,1,0,0]])` 應該傳回 `[1, 1]`。

```js
assert.deepEqual(getNextLocation([[0,0,0,0], [0,0,0,0], [2,0,0,0], [0,1,0,0]]), [1, 1]);
```

`getNextLocation([[0,0,0,0], [0,0,0,0], [0,0,1,0], [0,0,0,2]])` 應該傳回 `[2, 2]`。

```js
assert.deepEqual(getNextLocation([[0,0,0,0], [0,0,0,0], [0,0,1,0], [0,0,0,2]]), [2, 2]);
```

# --seed--

## --seed-contents--

```js
function getNextLocation(matrix) {

  return matrix;
}
```

# --solutions--

```js
function getNextLocation(matrix) {
  let prev = null;
  let curr = null;

  for (let row = 0; row < matrix.length; row++) {
    for (let col = 0; col < matrix[0].length; col++) {
      if (matrix[row][col] === 1) prev = [row, col];
      if (matrix[row][col] === 2) curr = [row, col];
    }
  }

  const [prevRow, prevCol] = prev;
  const [currRow, currCol] = curr;

  let dirX = currCol - prevCol;
  let dirY = currRow - prevRow;

  let nextRow = currRow + dirY;
  let nextCol = currCol + dirX;

  const maxRow = matrix.length - 1;
  const maxCol = matrix[0].length - 1;


  if (nextCol < 0 || nextCol > maxCol) dirX *= -1;
  if (nextRow < 0 || nextRow > maxRow) dirY *= -1;

  nextRow = currRow + dirY;
  nextCol = currCol + dirX;

  return [nextRow, nextCol];
}
```
