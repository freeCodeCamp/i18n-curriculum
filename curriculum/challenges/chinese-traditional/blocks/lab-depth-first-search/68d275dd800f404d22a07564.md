---
id: 68d275dd800f404d22a07564
title: 實作深度優先搜尋演算法
challengeType: 27
dashedName: lab-depth-first-search
---

# --description--

在本實驗中，你將實作一種稱為 <dfn>深度優先搜尋</dfn> 的圖形遍歷演算法。

當 <dfn>breadth-first search</dfn> 從原始節點開始以遞增的邊長進行搜尋時，<dfn>depth-first search</dfn> 則會先沿著一條邊路徑盡可能深入。

一旦到達路徑的一端，搜尋將回溯到最後一個具有未造訪邊路的節點並繼續搜尋。

與廣度優先搜尋不同，每次拜訪節點時，不會拜訪它所有的鄰居。相反地，它會先拜訪其中一個鄰居，並沿著該路徑繼續前進，直到該路徑上沒有更多節點可拜訪。

要實作這個演算法，你會想使用堆疊（一個陣列，其中最後加入的元素是第一個被移除的，遵循 <dfn>Last-In-First-Out</dfn> 原則）。堆疊在深度優先搜尋演算法中很有幫助，因為當你將鄰居加入堆疊時，你會想先造訪最近加入的鄰居，並將它們從堆疊中移除。

這個演算法的一個簡單輸出是從給定節點可達的節點列表。因此，你也會想要追蹤你造訪過的節點。

**目標**：完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 你應該有一個名為 `dfs` 的函式（程式）。
1. `dfs` 函式應該接受兩個引數：
   - 一個無向的鄰接矩陣。
   - 節點標籤，是介於 `0` 和 `n - 1` 之間的節點數值，其中 `n` 是圖中節點的總數。
1. `dfs` 函式（程式）應該實作深度優先搜尋演算法，以輸出從傳入節點可達的所有節點列表。

# --hints--

你應該有一個名為 `dfs` 的函式（程式），它接受兩個引數。

```js
({ test: () => runPython(`
  import inspect
  assert inspect.isfunction(dfs)
  sig = inspect.signature(dfs)
  assert len(sig.parameters) == 2
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1)` 應該傳回一個包含 `1`、`2`、`3` 和 `0` 的列表。

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1)
  assert isinstance(result, list)
  assert len(result) == 4
  assert set(result) == {1, 2, 3, 0}
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3)` 應該傳回一個包含 `1`、`2`、`3` 和 `0` 的列表。

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3)
  assert isinstance(result, list)
  assert len(result) == 4
  assert set(result) == {3, 2, 1, 0}
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], 3)` 應該傳回 `[3]`。

```js
({ test: () => runPython(`
  assert dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], 3) == [3]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 3)` 應該傳回一個包含 `3` 和 `2` 的列表。

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 3)
  assert result == [3, 2] or result == [2, 3]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 0)` 應該傳回一個包含 `0` 和 `1` 的列表。

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 0)
  assert result == [0, 1] or result == [1, 0]
`) })
```

`dfs` 函式應該傳回正確的結果。

```js
({ test: () => runPython(`
  import random

  def solve(g, s):
      v, q = set(), [s]
      while q:
          u = q.pop()
          if u not in v:
              v.add(u)
              q.extend([i for i, x in enumerate(g[u]) if x == 1 and i not in v])
      return v

  random.seed(0)

  for _ in range(10):
      n = 6
      mat = [[0]*n for _ in range(n)]
      for i in range(n):
          for j in range(i+1, n):
              if random.random() > 0.5:
                  mat[i][j] = mat[j][i] = 1

      start = random.randint(0, n-1)
      assert set(dfs(mat, start)) == solve(mat, start), "Random graph check failed"
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def dfs(graph, root):
    stack = []
    temp_v = None
    visited = []
    temp_v_neighbors = []
    stack.append(root)
    while stack:
        temp_v = stack.pop()
        if temp_v not in visited:
            visited.append(temp_v)
            temp_v_neighbors = graph[temp_v]
            for n, is_neighbor in enumerate(temp_v_neighbors):
                if is_neighbor == 1:
                    stack.append(n)
    return visited
```
