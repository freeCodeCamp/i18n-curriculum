---
id: 6732b29b8b7d4f15b94d12ca
title: 什麼是陣列的淺層複製，以及有哪些方法可以創建這些複製？
challengeType: 19
dashedName: what-is-a-shallow-copy-of-an-array-and-what-are-some-ways-to-create-these-copies
---

# --interactive--

陣列的淺層複製是一個新的陣列，具有與原始陣列相同的條款。如果陣列只包含像數字或字串這樣的原始值，新的陣列將完全獨立。但如果陣列內包含其他陣列，原始陣列和複製陣列都會引用相同的內部陣列。這表示如果你更改共享內部陣列中的某些內容，你會在兩個陣列中看到該更改。

淺層複製在你需要修改頂層結構時很有幫助，例如為你的陣列添加、移除或重新排序元素，而不修改原始陣列或內部陣列。

有幾種為陣列建立淺層複本的方法，我們將探討一些最常見的：`concat()`、`slice()` 和展開運算子。

讓我們從 `concat()` 方法開始。這個方法透過合併兩個或多個陣列來創建一個新的陣列。當只使用單一陣列時，它會有效地創建一個淺層複本。以下是一個範例：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = [].concat(originalArray);

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

:::

在這個範例中，我們使用 `concat()` 方法將一個空陣列串接到 `originalArray`。這將創建一個新的陣列，該陣列是 `originalArray` 的淺層複本。 

`copyArray` 包含與 `originalArray` 相同的元素，但它是不同的陣列物件，這就是為什麼嚴格相等性檢查（`===`）會傳回 `false`。

另一種創建淺層複本的方法是使用 `slice()` 方法。當不帶引數呼叫時，`slice()` 會傳回整個陣列的淺層複本。以下是它的運作方式：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = originalArray.slice();

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

:::

在這種情況下，`originalArray.slice()` 會創建一個新的陣列，該陣列是 `originalArray` 的淺層複製。再次強調，`copyArray` 包含相同的元素，但它是不同的陣列物件。

展開運算子（`...`），在 ES6 中被介紹，提供另一種簡潔的方式來創建陣列的淺層複製。以下是一個範例：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = [...originalArray];

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

:::

展開運算子（`...`）將 `originalArray` 的元素展開到一個新的陣列中，有效地創建淺層複製。重要的是要注意，所有這些方法都會創建新的陣列物件，這表示你可以修改複製品而不會影響原始陣列。例如：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = [...originalArray];

copyArray.push(4);
console.log(originalArray); // [1, 2, 3]
console.log(copyArray);     // [1, 2, 3, 4]
```

:::

在此範例中，為 `copyArray` 添加元素不會影響 `originalArray`。

總結來說，可以使用像是 `concat()`、`slice()` 或展開運算子這些方法輕鬆地創建陣列的淺層複製。這些方法對於創建可以獨立於原始陣列操作的新陣列非常有用。

# --questions--

## --text--

以下 `code` 的輸出結果會是什麼？

```js
const arr1 = [1, 2, 3];
const arr2 = arr1.slice();
arr2.push(4);
console.log(arr1, arr2);
```

## --answers--

`[1, 2, 3] [1, 2, 3, 4]`

---

`[1, 2, 3, 4] [1, 2, 3, 4]`

### --feedback--

`slice()` 方法會創建陣列的淺層複本。

---

`[1, 2, 3] [1, 2, 3]`

### --feedback--

`slice()` 方法會創建陣列的淺層複本。

---

這將會丟出錯誤。

### --feedback--

`slice()` 方法會創建陣列的淺層複本。

## --video-solution--

1

## --text--

以下 `code` 的輸出結果會是什麼？

```js
const fruits = ["apple", "banana", "orange"];
const fruitsCopy = [...fruits];
console.log(fruitsCopy.length);
```

## --answers--

`0`

### --feedback--

展開運算子（`...`）會創建整個陣列的淺層複本。

---

`2`

### --feedback--

展開運算子（`...`）會創建整個陣列的淺層複本。

---

`3`

---

`undefined`

### --feedback--

展開運算子（`...`）會創建整個陣列的淺層複本。

## --video-solution--

3

## --text--

以下 `code` 的輸出結果會是什麼？

```js
const arr1 = [1, 2, 3];
const arr2 = [].concat(arr1);
console.log(arr1 === arr2);
```

## --answers--

`true`

### --feedback--

`concat()` 方法會創建一個新的陣列，即使它是與空陣列串接。

---

`false`

---

`undefined`

### --feedback--

`concat()` 方法會創建一個新的陣列，即使它是與空陣列串接。

---

這將會丟出錯誤。

### --feedback--

`concat()` 方法會創建一個新的陣列，即使它是與空陣列串接。

## --video-solution--

2
