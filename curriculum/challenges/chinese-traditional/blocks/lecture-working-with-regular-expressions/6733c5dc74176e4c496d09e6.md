---
id: 6733c5dc74176e4c496d09e6
title: 什麼是 Lookahead 和 Lookbehind 斷言，它們如何運作？
challengeType: 19
dashedName: what-are-lookaheads-and-lookbehind-assertions-and-how-do-they-work
---

# --interactive--

前瞻和後顧斷言允許你根據周圍樣式的存在或缺失來匹配特定樣式。這些斷言有四種變體。

首先是正向先行斷言。當一個樣式後面跟著另一個樣式時，該斷言將會匹配該樣式。

要構造正向先行斷言，你需要從你想要匹配的樣式開始。然後，使用小括弧將你想用作條件的樣式包起來。在開啟小括弧後，使用 `?=` 將該樣式定義為正向先行斷言。

此樣式只會在 `free` 後面接著 `code` 時符合該字。

```js
const regex = /free(?=code)/i;
```

讓我們測試我們的樣式行為：

:::interactive_editor

```js
const regex = /free(?=code)/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

:::

注意只有 `free` 緊接著 `code` 的字串通過測試。

但是如果你想要匹配 `free` 出現時後面**不**接著 `code` 呢？你可以將你的正向前瞻改成負向前瞻來反轉行為。為此，將你的 `?=` 改成 `?!`：

```js
const regex = /free(?!code)/i;
```

讓我們用相同的字串來測試這個。

:::interactive_editor

```js
const regex = /free(?!code)/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

:::

如預期，結果是反轉的。唯一失敗的字串是第一個字串，其中 `free` 緊接著 `code`。

Lookbehind 斷言的功能與 lookahead 斷言類似，不同之處在於它們不是根據後方的樣式有條件地匹配，而是根據前方的樣式有條件地匹配。讓我們來看看正向 lookbehind。

正向後顧使用 `?<=` 表示，而非 `?=`。讓我們讓正規表達式在 `code` 前面有 `free` 時符合匹配：

```js
const regex = /(?<=free)code/i;
```

就像我們的正向先行斷言一樣，我們的正向後行斷言會匹配第一個字串，因為 `code` 緊接在 `free` 之前：

:::interactive_editor

```js
const regex = /(?<=free)code/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

:::

要匹配未被 `free` 所前置的 `code`，我們可以使用負向回顧。負向回顧是透過將 `?<=` 替換為 `?<!` 來定義的：

```js
const regex = /(?<!free)code/i;
```

這將符合任何未被 `free` 緊接著前置的 `code` 出現情況：

:::interactive_editor

```js
const regex = /(?<!free)code/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

:::

請記住，`Regex.prototype.test` 只會確認字串是否符合正規表達式。讓我們使用帶有 `String.prototype.match` 的負向後顧斷言，來看看斷言如何影響結果：

```js
const regex = /(?<!free)code/i;
console.log("freeCodeCamp".match(regex)); // null
console.log("free code camp".match(regex)); // ['code', index: 5, input: 'free code camp', groups: undefined]
console.log(
  "I need someone for free to write code for me".match(regex)
); // ['code', index: 33, input: 'I need someone for free to write code for me', groups: undefined]
```

注意，即使我們的正規表達式使用了向後查找來檢查 `free` 的存在，它也不會匹配 `free`。匹配中唯一包含的文字是 `code`。

前瞻和後顧在有條件地匹配文字時非常有用，且不會影響你的匹配所傳回的值。

# --questions--

## --text--

正規表達式中正向先行斷言的語法是什麼？

## --answers--

`(?=pattern)`

---

`(?<=pattern)`

### --feedback--

本課程說明如何使用特定的 `syntax` 來構造正向前瞻。

---

`(?!pattern)`

### --feedback--

本課程說明如何使用特定的 `syntax` 來構造正向前瞻。

---

`(?<!pattern)`

### --feedback--

本課程說明如何使用特定的 `syntax` 來構造正向前瞻。

## --video-solution--

1

## --text--

你會使用哪種斷言來匹配只有在後面**不**跟特定樣式時的字、單字？

## --answers--

正向前瞻。

### --feedback--

思考哪個斷言會「反轉」正向先行斷言的行為。

---

負向前瞻。

---

正向後顧。

### --feedback--

思考哪個斷言會「反轉」正向先行斷言的行為。

---

負向後顧。

### --feedback--

思考哪個斷言會「反轉」正向先行斷言的行為。

## --video-solution--

2

## --text--

當使用帶有 `String.prototype.match` 的向後查找斷言時，字串的哪一部分實際上包含在匹配結果中？

## --answers--

整個字串。

### --feedback--

本課程透過使用負向回顧的範例來示範此點。

---

在後顧斷言中的樣式。

### --feedback--

本課程透過使用負向回顧的範例來示範此點。

---

在反向先行斷言之後的樣式。

---

前瞻樣式和其後的樣式。

### --feedback--

本課程透過使用負向回顧的範例來示範此點。

## --video-solution--

3
