---
id: 67d1a99d10fd509c88faf3bf
title: React 中的数据获取是如何工作的？
challengeType: 19
dashedName: how-does-data-fetching-work-in-react
---

# --description--

React 应用程序通常依赖外部 API 和数据库来获取动态内容。要访问这些 API 和数据库中的数据，你需要使用一些数据获取技术。

让我们来看一下在 React 中数据获取是如何工作的，以及你可用的不同数据获取选项。

React 对你如何获取你的数据没有固定看法，这意味着在基本层面上，你可以使用所有现代浏览器都支持的内置 Fetch API。

你也可以使用 Axios 和 SWR。Axios 是基于 Promise 的超文本传输协议请求库，构建于 `XMLHttpRequest` 对象之上，SWR 是由 Vercel 团队创建的用于数据获取的 React 钩子。

让我们从一个例子开始。你首先需要导入 `useState` 和 `useEffect` 钩子：

```js
import { useState, useEffect } from "react";
```

然后你需要创建三个状态变量，分别叫做 `loading`、`data` 和 `error`：

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

`loading` 变量将跟踪数据是否仍在获取中。`data` 变量表现数据本身，`error` 变量将捕捉在数据获取进程中可能发生的任何误差。

由于获取数据是一个副作用，最好在 `useEffect` 钩子内使用 Fetch API。

这是一个示例：

```js
useEffect(() => {
  fetch("https://jsonplaceholder.typicode.com/posts")
    .then((res) => res.json())
    .then((data) => {
      setData(data);
      setLoading(false);
    })
    .catch((err) => {
      setError(err);
      setLoading(false);
    });
}, []);
```

这个 `useEffect` 使用 Fetch API 获取数据并设置所有状态。 

你可以通过使用 `async`/`await` 替代 `.then()` 语法来使事情变得更好。这意味着你必须在 `useEffect` 内部有一个单独的函数，因为你不能在 `useEffect` 前加上 `async` 关键字：

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
       
      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

然后你可以使用所有这些状态来渲染来自 API 的数据。

这是完整的代码：

```jsx
import { useState, useEffect } from "react";

const FetchPosts = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/posts");
       
        if (!res.ok) {
          throw new Error("Network response was not ok");
        }

        const data = await res.json();
        setData(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  if (loading) {
    return <p>Loading...</p>;
  }

  if (error) {
    return <p>{error.message}</p>;
  }

  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
};

export default FetchPosts;
```

在 UI 中，当数据正在被获取时，你会在屏幕上看到 `Loading...`，然后根据数据获取是否成功显示数据或误差。

记得我们也讨论过使用 Axios 和 SWR 进行数据获取。让我们来看一个使用 Axios 的示例。

你首先需要从命令行这样安装 Axios：

```sh
npm i axios
```

然后你需要像这样导入 Axios：

```js
import axios from "axios";
```

然后你可以使用之前相同的状态变量，并使用 `axios.get` 从 API 获取数据：

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

你可能已经注意到这个示例中没有 `await res.json()` 这一行。那是因为 Axios 会自动解析 JSON，所以不需要那一步。

我们将要看的最后一个例子是使用 `useSWR` 钩子来获取数据。

就像使用 Axios 一样，你需要这样安装 SWR：

```sh
npm install swr
```

然后你需要像这样将 `useSWR` 钩子导入到该文件中：

```js
import useSWR from "swr";
```

与之前的示例相比，SWR 语法要简短得多。你需要做的是创建一个 fetcher 函数，并将其作为第二个参数传递给 `useSWR` 钩子（端点是第一个参数）。

你还可以从 `useSWR` 钩子中解构出数据和误差状态，因此你不需要 `useState` 钩子。

语法如下：

```js
const fetcher = (url) => fetch(url).then((res) => res.json());
const { data, error } = useSWR(endpoint, fetcher);
```

请注意，这里 `"fetcher"` 名称只是一个约定，因此你可以自由地将变量命名为任何你想要的名称。

这是一个从 JSON Placeholder API 获取待办事项的组件：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
  const { data, error } = useSWR(
    "https://jsonplaceholder.typicode.com/todos",
    fetcher
  );

  if (!data) {
    return <h2>Loading...</h2>;
  }
  if (error) {
    return <h2>Error: {error.message}</h2>;
  }

  return (
    <>
      <h2>Todos</h2>
      <div>
        {data.map((todo) => (
          <h3 key={todo.id}>{todo.title}</h3>
        ))}
      </div>
    </>
  );
};

export default FetchTodos;
```

正如你在之前关于自定义钩子的课程中学到的，数据获取是一种可以提取到自定义钩子中的逻辑。因此，如果你在多个组件和页面中获取数据，最好创建一个 `useFetch` 钩子。

这是一个使用 SWR 进行数据获取的 `useFetch` 钩子：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const useFetch = (url) => {
  const { data, error } = useSWR(url, fetcher);

  return {
    data,
    loading: !data && !error,
    error,
  };
};

export default useFetch;
```

下面是如何使用 `useFetch` 钩子重写第一个从 JSON 占位符 API 获取帖子示例：

```jsx
import useFetch from "./useFetch";

const FetchPosts = () => {
  const { data, loading, error } = useFetch(
    "https://jsonplaceholder.typicode.com/posts"
  );

  if (loading) {
    return <h2>Loading...</h2>;
  }

  if (error) {
    return <h2>{error.message}</h2>;
  }

  return (
    <>
      <h2>Posts</h2>
      <ul>
        {data.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </>
  );
};

export default FetchPosts;
```

# --questions--

## --text--

给定示例中 `useSWR` 钩子的两个参数是什么？

## --answers--

URL 和缓存策略。

### --feedback--

第一个参数表现数据源，第二个参数处理数据检索。

---

API 路由和 fetcher 函数。

### --feedback--

第一个参数表现数据源，第二个参数处理数据检索。

---

端点和获取函数。

---

密钥和配置对象。

### --feedback--

第一个参数表现数据源，第二个参数处理数据检索。

## --video-solution--

3

## --text--

为什么你必须在 `useEffect` 内处理数据获取逻辑？

## --answers--

因为数据获取应该只运行一次。

### --feedback--

获取数据会影响组件外部的内容，不应阻塞渲染。

---

因为数据获取不应成为渲染进程的一部分。

---

因为 `useEffect` 在组件渲染之前执行。

### --feedback--

获取数据会影响组件外部的内容，不应阻塞渲染。

---

因为 `useEffect` 与渲染周期同步运行。

### --feedback--

获取数据会影响组件外部的内容，不应阻塞渲染。

## --video-solution--

2

## --text--

Axios 是基于什么构建的？

## --answers--

Fetch API。

### --feedback--

它是一个较旧的 API，用于在 Fetch 之前发起超文本传输协议请求。

---

XMLHttpRequest 对象。

---

WebSocket API。

### --feedback--

它是一个较旧的 API，用于在 Fetch 之前发起超文本传输协议请求。

---

DOM API。

### --feedback--

它是一个较旧的 API，用于在 Fetch 之前发起超文本传输协议请求。

## --video-solution--

2
