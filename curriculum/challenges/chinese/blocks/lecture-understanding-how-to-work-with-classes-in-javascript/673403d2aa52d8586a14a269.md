---
id: 673403d2aa52d8586a14a269
title: 什么是类继承，它是如何工作的？
challengeType: 19
dashedName: what-is-class-inheritance-and-how-does-it-work
---

# --interactive--

在编程中，继承允许你定义从其他类继承属性和方法的类。

例如，`Car` 是一种 `Vehicle` 类型，所以你可以定义一个具有所有车辆类型通用的最通用属性和方法的 `Vehicle` 类，然后定义一个继承 `Vehicle` 类属性和方法的 `Car` 类。

这种 "is a" 关系是继承的特征。在此示例中，`Car` 是 `Vehicle` 的更特化形式。

有两个主要的概念你应该了解以开始使用继承：父类和子类。

父类是作为其他类蓝图的类。它定义了被其他类继承的属性和方法。

子类是继承另一个类的属性和方法的类。子类还可以通过添加新属性和方法来扩展其父类的功能性。

在我们之前的例子中，`Vehicle` 是 `Car` 类的父类，而 `Car` 类是 `Vehicle` 的子类。

一个父类可以有多个子类。

在 JavaScript 中，我们使用 `extends` 关键字来实现继承。该关键字表示一个类是另一个类的子类。

在此示例中，我们仅有类定义的第一行，你可以看到 `Car` 类继承自 `Vehicle` 类，因此 `Car` 继承了 `Vehicle`。

```js
class Vehicle {
  // Implementation of Vehicle...
}

class Car extends Vehicle {
  // Implementation of Car...
}
```

假设 `Vehicle` 类有两个属性：`brand` 和 `year`。你可以在更新后的代码中看到这一点。

`Car` 有一个名为 `honk` 的方法。然而，请注意 `Car` 类没有自己的构造函数。让我们看看它是否继承了属性。

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

要定义一个 `Car` 的实例，你需要传入两个参数：`brand` 和 `year`。在这个分支中，品牌是 `freeCodeCamp Motors`，年份是 `2019`。

```js
let myCar = new Car("freeCodeCamp Motors", 2019);
```

如果你尝试使用点符号访问这些属性并调用该方法：

```js
console.log(myCar.brand);
console.log(myCar.year);
myCar.honk();
```

这是完整的示例：

:::interactive_editor

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}

let myCar = new Car("freeCodeCamp Motors", 2019);
console.log(myCar.brand);
console.log(myCar.year);
myCar.honk();
```

:::

确实，输出是正确的，所以这些属性和方法是在 `Car` 实例中定义的，而你只是通过从 `Vehicle` 类继承这些属性，节省了大量代码重复。

在这个例子中，子类没有任何额外的属性。这就是为什么该类没有构造函数，只有一个方法。

如果你确实需要添加额外的属性，你需要定义一个构造函数。

让我们来看一个例子。


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

这次，我们将为 `Car` 子类添加一个 `numDoors` 属性。

你可以看到现在这个类在更新后的代码中有一个构造函数。在构造函数内，有一个对 `super()` 的调用，传递了参数 `brand` 和 `year`。

`super()` 调用基类的构造函数，所以通过使用 `super(brand, year)`，你实际上是在子类中定义基类的属性。这是你可以使用的另一种术语——基类是父类，子类是子类。

然后，`this.numDoors = numDoors` 这一行定义了一个属于 `Car` 类的专属新属性，即车门数量（`numDoors`）。

这是一种扩展 `Vehicle` 类的方法，为你的 `Car` 实例添加一个专属的属性。

这就是可扩展性的一个例子，它是继承的基本优势之一。

现在，如果你创建一个 `Car` 类的实例，你会看到它有三个属性：`brand`、`year` 和 `numDoors`。你还需要在创建实例时传入必要的参数。

```js
let myCar = new Car("freeCodeCamp Motors", 2019, 4);
```

如果你用 `console.log()` 打印这些属性的值：

```js
console.log(myCar.brand);
console.log(myCar.year);
console.log(myCar.numDoors);
```

这是完整的示例：

:::interactive_editor

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}

let myCar = new Car("freeCodeCamp Motors", 2019, 4);
console.log(myCar.brand);
console.log(myCar.year);
console.log(myCar.numDoors);
```

:::

继承的主要优点是代码重用、模块性、可扩展性和改进的代码结构。

通过实现层次结构，你可以在子类中重用你已经为父类编写的代码，避免重复。

继承还通过将层次结构中的复杂系统分解为更简单的组件来促进模块性。

此外，能够扩展父类的功能性使得更容易适应不断变化的需求，并在开发进程后期添加新建特色。

最后，层级结构可以使你的代码更易于理解和维护。

这些是继承的基础。通过理解继承的工作原理，你可以设计结构良好、易于维护且可扩展的面向对象程序。

# --questions--

## --text--

面向对象编程中继承的主要目的是什么？

## --answers--

创建新建对象。

### --feedback--

思考继承如何帮助代码的可重用性和组织。

---

为一个 `class` 定义 `method`。

### --feedback--

思考继承如何帮助代码的可重用性和组织。

---

为了重用代码并创建类之间的层次关系。

---

将数据封装在对象中。

### --feedback--

思考继承如何帮助代码的可重用性和组织。

## --video-solution--

3

## --text--

JavaScript 中用于继承父类的关键字是什么？

## --answers--

`inherit`

### --feedback--

考虑建立继承关系的关键字。

---

`extends`

---

`super`

### --feedback--

考虑建立继承关系的关键字。

---

`prototype`

### --feedback--

考虑建立继承关系的关键字。

## --video-solution--

2

## --text--

`parent class` 和 `child class` 有什么区别？

## --answers--

父类是子类的特化版本。

### --feedback--

考虑类之间的层级关系。

---

子类是父类的特化版本。

---

父类和子类之间没有区别。

### --feedback--

考虑类之间的层级关系。

---

父类总是比子类大。

### --feedback--

考虑类之间的层级关系。

## --video-solution--

2
