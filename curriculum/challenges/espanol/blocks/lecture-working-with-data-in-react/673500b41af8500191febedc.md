---
id: 673500b41af8500191febedc
title: ¿Cómo se renderizan las listas en React?
challengeType: 19
dashedName: how-do-you-render-lists-in-react
---

# --description--

Renderizar listas es una tarea fundamental en las aplicaciones web de React, y se usa para mostrar datos a los usuarios. En React, se utiliza el método `map` para transformar un array de datos en un array de elementos JSX que pueden ser renderizados en la interfaz de usuario.

Aquí hay un ejemplo de un componente llamado `FruitList` que muestra una lista de frutas:

```jsx
function FruitList() {
  const fruits = ['Apple', 'Banana', 'Cherry', 'Date'];
  return (
    <ul>
      {fruits.map(fruit => <li>{fruit}</li>)}
    </ul>
  );
}
```

En este ejemplo, la función `map` itera sobre cada elemento del array `fruits`. Para cada fruta, crea un nuevo elemento `li` que contiene el nombre de la fruta. El nuevo array de elementos `li` se muestra entonces dentro de las etiquetas padre `ul`.

Sin embargo, al renderizar listas en React, es importante no olvidar la prop `key` para cada elemento de la lista. La clave siempre debe ser única y ayuda a React a identificar qué elementos han cambiado, se han agregado o se han eliminado, lo cual es esencial para rendereizar y actualizar la lista de manera eficiente.

Si olvidas la key, React mostrará una advertencia en la consola, pero no generará un error fatal. La aplicación aún podría renderizar y funcionar, pero podrías encontrar errores sutiles, especialmente cuando la lista cambia. Estos errores pueden ser difíciles de depurar porque la interfaz de usuario podría parecer correcta inicialmente.

Un error común es usar el índice del array como la clave, así:

```jsx
{fruits.map((fruit, index) => <li key={index}>{fruit}</li>)}
```

Aunque esto silencia la advertencia, generalmente se considera una mala práctica. Usar el índice como clave puede causar problemas cuando la lista se reordena, se ordena o se filtra. React usa la clave para rastrear elementos. Si el orden de la lista cambia, React podría reutilizar incorrectamente el estado del componente o no actualizar el DOM de manera eficiente porque las claves (índices) permanecen iguales incluso si el contenido en ese índice ha cambiado.

La mejor práctica es usar un identificador estable y único para cada elemento. Esto suele ser un ID de tu base de datos, como un UUID o un database ID.

Si tus datos no tienen un ID único, puedes generar uno cuando se crean los datos (por ejemplo, usando `crypto.randomUUID()` o una biblioteca como `uuid`), o usar una combinación de campos que estén garantizados como únicos. Sin embargo, debes evitar generar claves sobre la marcha durante el renderizado (por ejemplo, `key={Math.random()}`), ya que esto hará que React recree los elementos del DOM en cada renderizado y restablezca su estado.

Modifiquemos nuestro ejemplo para incluir claves:

```jsx
function FruitList() {
  const fruits = ["Apple", "Banana", "Cherry", "Date"];
  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={`${fruit}-${index}`}>{fruit}</li>
      ))}
    </ul>
  );
}
```

En este ejemplo refactorizado, estamos creando una clave única para cada elemento de la lista concatenando el nombre de la fruta con su índice. Esto asegura que cada elemento de la lista tenga una clave distinta, lo cual ayuda a React a gestionar y actualizar la lista eficientemente cuando los elementos se agregan, eliminan o reorganizan.

React también te permite renderizar estructuras más complejas. Por ejemplo, podrías tener un array de objetos que representan usuarios, cada uno con múltiples propiedades que deseas mostrar:

```jsx
function UserList() {
  const users = [
    { id: "user-001-employee", name: "Alice", email: "alice@example.com" },
    { id: "user-002-employee", name: "Bob", email: "bob@example.com" },
    { id: "user-003-employee", name: "John", email: "john@example.com" },
  ];
  return (
    <div>
      {users.map((user) => (
        <div key={user.id}>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      ))}
    </div>
  );
}
```

En este ejemplo, estamos creando una estructura JSX más compleja para cada usuario, mostrando tanto su nombre como su dirección de correo electrónico. Estamos utilizando el `id` del usuario como la `key`, lo cual es una buena práctica.

En conclusión, renderizar listas en React implica convertir arrays de datos en elementos JSX, típicamente usando la función `map`.

# --questions--

## --text--

¿Cuál es el propósito principal de usar la prop `key` al renderizar listas en React?

## --answers--

Para estilizar los elementos de la lista.

### --feedback--

Piensa en lo que dijimos sobre la optimización del renderizado de React.

---

Para ayudar a React a identificar eficientemente los cambios en la lista.

---

Para ordenar los elementos de la lista.

### --feedback--

Piensa en lo que dijimos sobre la optimización del renderizado de React.

---

Para filtrar los elementos de la lista.

### --feedback--

Piensa en lo que dijimos sobre la optimización del renderizado de React.

## --video-solution--

2

## --text--

¿Qué método de JavaScript se usa típicamente para transformar un array de datos en un array de elementos JSX en React?

## --answers--

`forEach()`

### --feedback--

Recuerda el método que consistentemente usamos en nuestros ejemplos para crear elementos JSX a partir de elementos de array.

---

`reduce()`

### --feedback--

Recuerda el método que consistentemente usamos en nuestros ejemplos para crear elementos JSX a partir de elementos de array.

---

`map()`

---

`filter()`

### --feedback--

Recuerda el método que consistentemente usamos en nuestros ejemplos para crear elementos JSX a partir de elementos de array.

## --video-solution--

3

## --text--

Al renderizar una lista de elementos que tienen IDs únicos, ¿cuál es considerado la mejor práctica para la prop `key`?

## --answers--

Usar el índice del elemento en el array.

### --feedback--

Recuerda lo que dijimos sobre usar identificadores únicos y estables para claves.

---

Usar un número aleatorio.

### --feedback--

Recuerda lo que dijimos sobre usar identificadores únicos y estables para claves.

---

Usar el ID único del elemento.

---

Usar el nombre o título del elemento.

### --feedback--

Recuerda lo que dijimos sobre usar identificadores únicos y estables para claves.

## --video-solution--

3
