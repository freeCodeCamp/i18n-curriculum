---
id: 68420c314cdf5c6863ca8330
title: 什么是算法以及 `Big O Notation` 如何工作？
challengeType: 19
dashedName: what-is-an-algorithm-and-how-does-big-o-notation-work
---

# --description--

每个在你的设备上 `Run` 的计算机 `Program` 都有一组特定的指令，这些指令按特定顺序执行以完成一个 `Task`。

任务可以是对一组数字进行排序、修改一个图像、跟踪库存，甚至运行你最喜欢的电子游戏。

这就是算法发挥作用的地方。**算法**是一组明确无误的指令，用于解决问题或执行任务。

你可以将算法看作“配方”。当你做饭时，配方会列出你需要的所有食材，并提供逐步的制作步骤说明。

等效地，你可以将算法看作告诉计算机确切应该做什么以及如何做的“配方”。

算法有两个关键特性：

* 它们不能无限期地继续。它们必须在有限的步骤内完成。
    
* 每一步都必须精确且明确。
    

它们可能有零个、一个或多个 `input`，并生成一个或多个输出。

算法的步骤独立于任何编程语言。

但是，要让它们实际在计算机上运行，你需要用编程语言实现它们，比如 Python 或 JavaScript。

如果一个算法是正确的，任何有效 `input` 的输出都应该与预期输出 `Match`。

算法除了要正确，还应当高效。

算法效率可以通过它们完成任务所需的运行时间和占用的内存空间来衡量。

了解一个算法的效率非常重要，因为它能让你了解随着输入规模的增长算法的执行表现。

例如，排序 15 个整数与排序 100 万个整数不同。

随着进程的规模和复杂度增长，如果算法不足够高效来处理它，你可能最终得到一个非常缓慢的计算机程序，甚至可能导致整个系统崩溃。

这就是为什么开发和选择尽可能高效的算法非常重要。

这就是 Big O 符号变得非常重要的地方。

大 O 符号描述了算法在输入大小增加时的最坏分支性能或增长率。

算法的增长率是指随着输入规模的增长，其所需资源的增加情况。

大 O 记法关注最坏分支的性能，因为这个分支对于理解算法即使在最坏情况下也能多么高效非常重要，无论输入如何。

回到我们的排序示例，排序 1 000 000 个整数直观上应该比排序 15 个整数花费更多时间和资源。

但是多少更多？

这实际上取决于你选择用来排序它们的算法。

大 O 记号不会给你一个确切的数字来描述算法的效率，但它会根据算法执行的操作数量，给你一个关于随着输入规模增长算法如何扩展的概念。

在大 O 表示法中，我们通常用字母 `n` 表示输入大小。例如，如果输入是一个列表，`n` 表示该列表中的元素数量。

在基于操作次数查找算法时间复杂度时，不考虑常量因子和低阶项。因为随着 `n` 的大小增长，这些较小项在执行的总操作次数中的影响会变得越来越小。

主导算法整体行为的项将是含有 `n`（输入大小）的最高阶项。

例如，如果一个算法执行 `7n + 20` 个操作才能完成，随着 `n` 的增长，常量 `20` 对最终结果的影响将越来越小。术语 `7n` 将趋于主导，这将定义算法的整体行为和效率。

另一个例子是一个需要完成 `20n² + 15n + 7` 次操作的算法。随着 `n` 的增长，`20n²` 这一项将趋于主导，因此该算法具有二次时间复杂度，因为主导项包含 `n²`。

二次时间复杂度是算法世界中你可以查找的多种不同时间复杂度类型之一。

让我们了解一些最常见的。

**`O(1)`** 被称为“常量时间复杂度”。当一个算法具有常量时间复杂度时，无论输入大小如何，运行所需时间都是相同的。

例如，检查一个数字是偶数还是奇数总是花费相同的时间，无论数字本身是多少。

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

**`O(log n)`** 被称为“对数时间复杂度”。这意味着随着输入大小的增长，算法所需的时间增长缓慢。这在问题规模被反复按常量比例缩小的问题中很常见。

例如，一种流行的查找算法叫做二分查找，其最坏情况时间复杂度为 `O(log n)`。这是因为它在每次比较中都会消除剩余元素的一半，从而使整体更高效。

**`O(n)`** 被称为“线性时间复杂度”。具有此时间复杂度的算法的运行时间与输入大小成正比增加。

例如，`for` 循环迭代列表中所有元素时，随着列表元素数量的增加，将执行更多的迭代。如果列表大小翻倍，操作次数也将大致翻倍。

```python
for grade in grades:  # grades is a list.
    print(grade)
```

**`O(n log n)`** 被称为“对数线性时间复杂度”。这是高效排序算法（如归并排序和快速排序）常见的时间复杂度。

**`O(n²)`** 被称为“二次时间复杂度”。这些算法的运行时间相对于输入大小呈二次增长，通常对于现实问题来说不是高效的。

嵌套循环是二次时间复杂度的常见例子。内层循环将为外层循环的每一个 `n` 次迭代执行 `n` 次迭代，导致 `n` 的平方次迭代。

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

其他时间复杂度包括“指数时间复杂度”，表示为 `O(2^n)`，以及“阶乘时间复杂度”，表示为 `O(n!)`。两者在实际场景中都不高效。

在这个 `Graph` 中，你可以比较表现最常见时间复杂度的数学函数的增长。将 x 轴（水平）视为输入大小，y 轴（垂直）视为算法的运行时间。

你可以看到，二次时间复杂度（`O(n²)`）（黄色）增长速度远快于其他复杂度，而常数时间复杂度（`O(1)`）（红色）保持不变，即使输入变大。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-is-an-algorithm-and-how-does-big-o-notation-work-1.png" alt="graph comparing time complexity">

太好了。到目前为止，你已经了解了关于时间需求的 Big O 符号，但该符号也可以应用于空间需求的上下文。

在这个上下文中，它描述了算法所需的内存空间如何随着输入大小的增长而增长。

具有 `"Constant Space Complexity"` `O(1)` 的算法始终需要恒定数量的内存空间，即使输入变得更大。

一个例子是一个只在内存中创建并保存少量变量的算法。

相比之下，具有“线性空间复杂度”`O(n)`的算法所需的空间会随着输入大小的增长成比例增加。

这的一个例子是一个创建并保存长度为 `n` 的列表拷贝的算法。

最后，具有“二次空间复杂度”`O(n²)`的算法的空间需求会随着输入大小的增长呈二次增长。

这的一个例子是创建一个二维矩阵，其中维度由输入大小决定，存储所有可能的点对。

算法是计算机程序的创建块，而 Big O 符号是一个强大的框架，用于分析它们的效率，基于它们在最坏分支情况下的时间和空间需求如何随着输入大小的增长而扩展。理解它们的效率对于开发在现实场景中高效运行的软件非常重要。

# --questions--

## --text--

以下哪项最能描述一个算法？

## --answers--

用于编写代码的特定编程语言。

### --feedback--

当你尝试完成特定任务时，考虑你遵循的内容。

---

一组逐步说明，旨在解决问题或执行任务。

---

一种计算机硬件组件的类型。

### --feedback--

当你尝试完成特定任务时，考虑你遵循的内容。

---

用于开发和运行游戏的 `software application`。

### --feedback--

当你尝试完成特定任务时，考虑你遵循的内容。

## --video-solution--

2

## --text--

在算法的上下文中，Big O 符号的主要目的是什麽？

## --answers--

测量算法在特定计算机上运行所用的准确时间（以秒为单位）。

### --feedback--

考虑当算法处理的数据量变得非常大时，Big O 符号如何帮助你理解算法的性能。

---

计算算法中代码的总行数。

### --feedback--

考虑当算法处理的数据量变得非常大时，Big O 符号如何帮助你理解算法的性能。

---

描述算法的资源使用如何随着输入大小的增加而增长。

---

要确定算法的最佳分支性能。

### --feedback--

考虑当算法处理的数据量变得非常大时，Big O 符号如何帮助你理解算法的性能。

## --video-solution--

3

## --text--

如果一个算法的时间复杂度是 `O(n)`，这对它的性能意味着什么？

## --answers--

算法的运行时间与输入大小成正比增加。

---

算法的运行时间无论 `input` 大小如何都保持常量。

### --feedback--

考虑“linear”在直接关系或图上的直线方面的含义。

---

算法的运行时间随着输入大小呈指数增长。

### --feedback--

考虑“linear”在直接关系或图上的直线方面的含义。

---

随着输入大小变大，算法的运行时间减少。

### --feedback--

考虑“linear”在直接关系或图上的直线方面的含义。

## --video-solution--

1

