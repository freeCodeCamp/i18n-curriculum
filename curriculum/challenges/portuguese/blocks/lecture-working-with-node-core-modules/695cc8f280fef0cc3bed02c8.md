---
id: 695cc8f280fef0cc3bed02c8
title: O que é o módulo Crypto e como ele funciona?
challengeType: 19
dashedName: what-is-the-crypto-module-and-how-does-it-work
---

# --description--

Crypto é outro módulo principal que está incorporado no Node.js. Ele inclui ferramentas para coisas como hashing, criptografia, descriptografia e criação de assinaturas digitais, todas usadas para proteger informações sensíveis e manter seu app seguro.

Dito isso, `crypto` oferece blocos de construção de baixo nível, não segurança plug-and-play. Escrever seu próprio código de criptografia ou autenticação pode ser inseguro se você não tomar cuidado. Na maioria dos casos, é melhor usar bibliotecas bem testadas como `bcrypt` para hash de senhas ou `jsonwebtoken` (JWT) para gerenciar logins e tokens.

Dito isso, ainda é útil entender como alguns dos métodos no módulo crypto funcionam.

Para usar esses métodos, você precisa importar o módulo `crypto`:

```js
const crypto = require("crypto");
```

Alguns dos métodos são usados para fins de transformação de dados, como os de hashing e criptografia de dados, e outros são para gerenciamento de chaves e segurança, como os de geração de valores aleatórios e criação de segredos.

Vamos primeiro analisar os métodos para hashing e criptografia de dados.

O método `createHash()` cria um objeto hash utilizando algoritmos como `sha256`, `sha512` e `md5`. É uma operação unidirecional, então você não pode revertê-la.

`createHash()` é útil para hash de senhas e fingerprinting de arquivos. Para usá-lo, você passa seu algoritmo, usa o método `update()` para fornecer os dados e finalmente usa `digest()` com uma codificação para obter o valor do hash:

```js
const crypto = require("crypto");

const hashedPassword = crypto
  .createHash("sha256")
  .update("myStrongPassword")
  .digest("hex");

console.log("createHash result:", hashedPassword);
// createHash result: f92c9cfa0ead1bcec05ca75888a4074ba994ad237e5e2a8c7cc6a620378c061d
```

`createHmac()` faz quase a mesma coisa que `createHash()`, mas leva as coisas para o próximo nível ao aceitar uma chave secreta, para que somente alguém com essa chave possa verificar o hash. É ideal para autenticação e verificação da integridade dos dados:

```js
const crypto = require("crypto");

const hashedMessage = crypto
  .createHmac("sha256", "secretkey")
  .update("important-secret-message")
  .digest("hex");

console.log("createHmac result:", hashedMessage);
// createHmac result: da48d6f026b6036286b1fb872c63264130d5cc4271f3a213bb6ddca5a023e77e
```

Os métodos `createCipheriv()` e `createDecipheriv()` criptografam e descriptografam dados. Ambos recebem um algoritmo, uma chave e um `iv`, que é um bloco de dados aleatórios ou únicos usado no início do processo de criptografia:

```js
createCipheriv(algorithm, key, iv);
createDecipheriv(algorithm, key, iv);
```

Para descriptografar os dados, a chave deve ser a mesma, caso contrário, a descriptografia falhará e você receberá um erro ou um texto ilegível em vez da mensagem original.

Aqui estão os dois em ação:

```js
const crypto = require("crypto");

// A key must match the algorithm length. Here AES-256 is 32 bytes
const key = Buffer.from("12345678901234567890123456789012");

// A fixed IV, 16 bytes for AES
const iv = Buffer.from("1234567890123456");

const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);

let encrypted = cipher.update("Hello campers!", "utf8", "hex");
encrypted += cipher.final("hex");

console.log("Encrypted data:", encrypted);
// Encrypted data: 4ee93aa398ab44e3540e4a67ca96bc8c

// Decrypt the "Hello campers!" message
const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
let decrypted = decipher.update(encrypted, "hex", "utf8");
decrypted += decipher.final("utf8");

console.log("Decrypted data:", decrypted);
// Decrypted data: Hello campers!
```

Outro método criptográfico para transformação de dados é `sign()` e `verify()`. 

`sign()` cria uma assinatura digital a partir de alguns dados usando uma chave privada. Essa assinatura prova que os dados vieram do titular da chave privada e não foram alterados.

`verify()` então verifica essa assinatura e falha se os dados ou a assinatura não corresponderem.

Agora, vamos analisar os métodos de criptografia para gerar valores aleatórios e criar segredos.

`randomBytes()` recebe um `size` e gera tokens criptograficamente seguros. Isso o torna bom para gerar UUIDs (identificadores universalmente únicos). Além disso, é uma boa substituição para `Math.random()`, que não é seguro para tokens e chaves.

```js
console.log("Random Bytes:", crypto.randomBytes(16));
// Random Bytes: <Buffer 01 88 aa 1e 2c 38 48 39 26 e1 6b a9 d8 c5 ed 49>
```

A saída é um buffer por padrão. Como você aprendeu na lição sobre o módulo Buffer, você pode converter esse Buffer em uma string com o método `toString()`:

```js
console.log("Random Bytes:", crypto.randomBytes(16).toString("hex"));
// Random Bytes: a6154ef5a296fa176ad0f332bd94d712
```

O argumento `'hex'` em `toString('hex')` aqui indica ao Node para codificar os dados binários do Buffer como uma string hexadecimal.

O método `randomInt()` recebe valores `min` e `max` e gera um número inteiro aleatório seguro entre eles. É útil para OTPs e seleção aleatória.

```js
console.log("Random Int:", crypto.randomInt(0, 100)); // 89
```

Novamente, a melhoria em relação a `Math.random()` e `Math.floor()` é que o método usa aleatoriedade criptograficamente segura por trás dos panos, então os atacantes não podem prever o número aleatório resultante.

Outro método é `createSecretKey()`. Ele recebe um buffer e gera um byte bruto encapsulado em um `KeyObject`:

```js
const crypto = require("crypto");

const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret); // SecretKeyObject [KeyObject] { [Symbol(kKeyType)]: 'secret' }
```

Você pode então usar o método `export` para enviar esse `KeyObject`:

```js
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export());
// <Buffer 53 06 a1 c7 75 69 8b 38 8b a4 b2 f7 1b bc b8
// ae e2 d1 bf 67 af 1a 6a 0a 6e a0 29 62 bb 52 52 32>
```

E finalmente, use `toString()` no buffer para ver a representação em string dele:

```js
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export().toString('hex'));
// 32dfe5917668580160986f1623bf8152913329c71163be9c3404a110cd78efd6
```

Além destes, existem:

- `createPublicKey()` e `createPrivateKey()` que permitem trabalhar com chaves geradas em outro lugar
- `createDiffieHellman()` para duas partes gerarem um segredo compartilhado sem enviar o segredo diretamente
- `Certificate()` para trabalhar com o usado em HTTPS, para que você possa analisar, exportar e verificar o conteúdo do certificado

# --questions--

## --text--

Qual destas é a maneira correta de importar o módulo crypto do Node.js?

## --answers--

`const crypto = require('crypto')`

---

`const crypto = import('crypto')`

### --feedback--

Concentre-se na sintaxe que o Node.js usa para requerer módulos internos.

---

`import crypto from 'nodes:crypto'`

### --feedback--

Foque na sintaxe que o Node.js usa para requerer módulos internos.

---

`crypto = requireModule('crypto')`

### --feedback--

Foque na sintaxe que o Node.js usa para requerer módulos internos.

## --video-solution--

1

## --text--

Qual dessas afirmações sobre `sign()` e `verify()` está correta?

## --answers--

`sign()` usa uma chave pública para criar uma assinatura e `verify()` a verifica com uma chave privada.

### --feedback--

Lembre-se de que assinaturas digitais funcionam com pares de chaves privadas e públicas.

---

Tanto `sign()` quanto `verify()` requerem apenas uma chave privada.

### --feedback--

Lembre-se de que assinaturas digitais funcionam com pares de chaves privadas e públicas.

---

`sign()` cria uma assinatura digital com uma chave privada e `verify()` a verifica com a chave pública correspondente.

---

`verify()` pode verificar assinaturas sem precisar de nenhuma chave.

### --feedback--

Lembre-se de que assinaturas digitais funcionam com pares de chaves privadas e públicas.

## --video-solution--

3

## --text--

Qual método no módulo crypto cria um objeto de hash unidirecional usando algoritmos como `sha256`, `sha512` ou `md5`?

## --answers--

`createCipheriv()`

### --feedback--

Este método é frequentemente usado para hashing de senhas e fingerprinting de arquivos.

---

`createDiffieHellman()`

### --feedback--

Este método é frequentemente usado para hashing de senhas e fingerprinting de arquivos.

---

`createSign()`

### --feedback--

Este método é frequentemente usado para hashing de senhas e fingerprinting de arquivos.

---

`createHash()`

## --video-solution--

4
