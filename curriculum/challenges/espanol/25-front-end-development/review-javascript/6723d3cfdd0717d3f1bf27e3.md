---
id: 6723d3cfdd0717d3f1bf27e3
title: Revisión de JavaScript
challengeType: 24
dashedName: review-javascript
---

# --description--

Revise los conceptos a continuación para prepararse para el próximo examen de preparación.


## Trabajando con HTML, CSS y JavaScript

Mientras que HTML y CSS proporcionan la estructura del sitio web, JavaScript aporta interactividad al permitir funcionalidades complejas, como manejar la entrada del usuario, animar elementos e incluso construir aplicaciones web completas.

## Tipos de datos en JavaScript

Los tipos de datos ayudan al programa a entender el tipo de datos con los que está trabajando, ya sea un número, un texto o algo más.

- **Número**: Un número representa tanto valores enteros como de punto flotante. Los ejemplos de enteros incluyen 7, 19 y 90.
- **Punto flotante**: Un número de punto flotante es un número con punto decimal. Los ejemplos incluyen 3.14, 0.5 y 0.0001.
- **Cadena**: Una cadena es una secuencia de caracteres o texto, encerrado entre comillas. `"Me gusta programar"` y `'JavaScript es divertido'` son ejemplos de cadenas.
- **Booleano**: Un booleano representa uno de dos posibles valores: `true` o `false`. Puedes usar un booleano para representar una condición, como `isLoggedIn = true`.
- **Undefined y Null**: Un valor undefined es una variable que ha sido declarada pero no ha sido asignada un valor. Un valor null es un valor vacío o una variable a la que se le ha asignado intencionadamente el valor `null`.
- **Objeto**: Un objeto es una colección de pares clave-valor. La clave es el nombre de la propiedad y el valor es el valor de la propiedad.

Aquí, el objeto `pet` tiene tres propiedades o claves: `name`, `age` y `type`. Los valores son `Fluffy`, `3` y `perro`, respectivamente.

```js
let pet = {
  name: 'Fluffy',
  age: 3,
  type: 'dog'
};
```

- **Símbolo**: El tipo de dato Symbol es un valor único e inmutable que puede usarse como un identificador para propiedades de objetos.

En el ejemplo a continuación, se crean dos símbolos con la misma descripción, pero no son iguales.

```js
const crypticKey1= Symbol('saltNpepper');
const crypticKey2= Symbol('saltNpepper');
console.log(crypticKey1 === crypticKey2); // false
```

- **BigInt**: Cuando el número es demasiado grande para el tipo de dato `Number`, se puede usar el tipo de dato BigInt para representar enteros de longitud arbitraria.

Al agregar una `n` al final del número, se puede crear un BigInt.

```js
const veryBigNumber = 1234567890123456789012345678901234567890n;
```

## Variables en JavaScript

- Las variables pueden ser declaradas usando la palabra clave `let`.

```js
let cityName;
```

- Para asignar un valor a una variable, se puede usar el operador de asignación `=`.

```js
cityName = 'New York';
```

- Las variables declaradas usando `let` pueden ser reasignadas a un nuevo valor.

```js
cityName = 'Los Angeles';
console.log(cityName); // Los Angeles
```

- Además de `let`, se puede usar `const` para declarar una variable. Sin embargo, una variable `const` no puede ser reasignada a un nuevo valor.

```js
const cityName = 'New York';
cityName = 'Los Angeles'; // TypeError: Assignment to constant variable.
```

- Las variables declaradas usando `const` se usan para declarar constantes, que no se permiten cambiar a lo largo del código, como `PI` o `MAX_SIZE`.

## Convenciones para la denominación de variables

- Los nombres de las variables deben ser descriptivos y significativos.
- Los nombres de variables deben estar en camelCase como `cityName`, `isLoggedIn` y `veryBigNumber`.
- Los nombres de las variables no deben comenzar con un número. Deben comenzar con una letra, `_` o `$`.
- Los nombres de las variables no deben contener espacios ni caracteres especiales, excepto por `_` y `$`.
- Los nombres de las variables no deben ser palabras reservadas.
- Los nombres de las variables distinguen entre mayúsculas y minúsculas. `age` y `Age` son variables diferentes.

## Cadenas e inmutabilidad de cadenas en JavaScript

- Las cadenas son secuencias de caracteres encerradas entre comillas. Se pueden crear usando comillas simples y comillas dobles.

```js
let correctWay = 'This is a string';
let alsoCorrect = "This is also a string";
```

- Las cadenas son inmutables en JavaScript. Esto significa que una vez creada una cadena, no se pueden cambiar los caracteres de la cadena. Sin embargo, aún se pueden reasignar cadenas a un nuevo valor.

```js
let firstName = 'John';
firstName = 'Jane'; // Reassigning the string to a new value
```

## Concatenación de Cadenas en JavaScript

- La concatenación es el proceso de unir múltiples cadenas o combinar cadenas con variables que contienen texto. El operador `+` es uno de los métodos más simples y más frecuentemente usados para concatenar cadenas.

```js
let studentName = 'Asad';
let studentAge = 25;
let studentInfo = studentName + ' is ' + studentAge + ' years old.';
console.log(studentInfo); // Asad is 25 years old.
```

- Si necesitas agregar o adjuntar a una cadena existente, entonces puedes usar el operador `+=`. Esto es útil cuando quieres construir sobre una cadena añadiendo más texto a lo largo del tiempo.

```js
let message = 'Welcome to programming, ';
message += 'Asad!';
console.log(message); // Welcome to programming, Asad!
```

- Otra forma de concatenar cadenas es usar el método `concat()`. Este método une dos o más cadenas.

```js
let firstName = 'John';
let lastName = 'Doe';
let fullName = firstName.concat(' ', lastName);
console.log(fullName); // John Doe
```

## Registro de Mensajes con `console.log()`

- El método `console.log()` se usa para registrar mensajes en la consola. Es una herramienta útil para depurar y probar tu código.

```js
console.log('Hello, World!');
// Output: Hello, World!
```

## Punto y Coma en JavaScript

- Los puntos y comas se usan principalmente para marcar el final de una sentencia. Esto ayuda al motor de JavaScript a entender la separación de instrucciones individuales, lo cual es crucial para una ejecución correcta.

```js
let message = 'Hello, World!'; // first statement ends here
let number = 42; // second statement starts here
```

- Los puntos y comas ayudan a prevenir ambigüedades en la ejecución del código y aseguran que las sentencias se terminen correctamente.

## Comentarios en JavaScript

- Cualquier línea de código que está comentada es ignorada por el motor de JavaScript. Los comentarios se usan para explicar el código, hacer notas o desactivar temporalmente el código.
- Los comentarios de una sola línea se crean usando `//`.

```js
// This is a single-line comment and will be ignored by the JavaScript engine
```

- Los comentarios de varias líneas se crean usando `/*` para iniciar el comentario y `*/` para finalizar el comentario.

```js
/*
This is a multi-line comment.
It can span multiple lines.
*/
```

## JavaScript como un Lenguaje de Tipado Dinámico

- JavaScript es un lenguaje de tipado dinámico, lo que significa que no necesitas especificar el tipo de dato de una variable cuando la declaras. El motor de JavaScript determina automáticamente el tipo de dato basado en el valor asignado a la variable.

```js
let error = 404; // JavaScript treats error as a number
error = "Not Found"; // JavaScript now treats error as a string
```

- Otros lenguajes, como Java, que no son de tipado dinámico resultarían en un error:

```js
int error = 404; // value must always be an integer
error = "Not Found"; // This would cause an error in Java
```

## Uso del Operador `typeof`

- El operador `typeof` se usa para verificar el tipo de dato de una variable. Devuelve una cadena que indica el tipo de la variable.

```js
let age = 25;
console.log(typeof age); // number

let isLoggedIn = true;
console.log(typeof isLoggedIn); // boolean
```

- Sin embargo, hay una peculiaridad bien conocida en JavaScript cuando se trata de null. El operador `typeof` devuelve `object` para valores nulos.

```js
let user = null;
console.log(typeof user); // object
```

## Fundamentos de las Cadenas

- **Definición**: Una cadena es una secuencia de caracteres envueltos en comillas simples, dobles o comillas invertidas. Las cadenas son tipos de datos primitivos y son inmutables. La inmutabilidad significa que una vez creada una cadena, no se puede cambiar.
- **Accediendo a Caracteres de una Cadena**: Para acceder a un carácter de una cadena, puedes usar la notación de corchetes y pasar el número de índice. Un índice es la posición de un carácter dentro de una cadena y comienza desde cero.

```js
const developer = "Jessica";
developer[0] // J
```

- **`\n` (Carácter de Nueva Línea)**: Pueds crear una nueva línea en una cadena usando el carácter de nueva línea `\n`.

```js
const poem = "Roses are red,\nViolets are blue,\nJavaScript is fun,\nAnd so are you.";
console.log(poem);
```

- **Escapando Cadenas**: Puedes escapar caracteres en una cadena colocando barras inclinadas (`\`) antes de las comillas.

```js
const statement = "She said, \"Hello!\"";
console.log(statement); // She said, "Hello!"
```

## Literales de Plantilla y Interpolación de Cadenas

- **Definición**: Los literales de plantilla se definen con acentos graves (`). Permiten una manipulación de cadenas más fácil, incluyendo la inserción directamente de variables dentro de una cadena, característica conocida como interpolación de cadenas.

```js
const name = "Jessica";
const greeting = `Hello, ${name}!`; // "Hello, Jessica!"
```

## ASCII, el Método `charCodeAt()` y el Método `fromCharCode()`

- **ASCII**: ASCII, abreviatura de American Standard Code for Information Interchange, es un estándar de codificación de caracteres usado en computadoras para representar texto. Asigna un valor numérico a cada carácter, que es universalmente reconocido por las máquinas.
- **El Método `charCodeAt()`**: Este método se llama sobre una cadena y devuelve el código ASCII del carácter en el índice especificado.

```js
const letter = "A";
console.log(letter.charCodeAt(0));  // 65
```

- **El Método `fromCharCode()`**: Este método convierte un código ASCII en su carácter correspondiente.

```js
const char = String.fromCharCode(65);
console.log(char);  // A
```

## Otros Métodos Comunes de Cadenas

- **El método `indexOf`**: Este método se usa para buscar una subcadena dentro de una cadena. Si se encuentra la subcadena, `indexOf` devuelve el índice (o posición) de la primera aparición de esa subcadena. Si la subcadena no se encuentra, `indexOf` devuelve -1, lo que indica que la búsqueda no tuvo éxito.

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.indexOf("fox")); // 16
console.log(text.indexOf("cat")); // -1
```

- **El Método `includes()`**: Este método se usa para verificar si una cadena contiene una subcadena específica. Si la subcadena se encuentra dentro de la cadena, el método devuelve verdadero. De lo contrario, devuelve falso.

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.includes("fox")); // true
console.log(text.includes("cat")); // false
```

- **El Método `slice()`**: Este método extrae una parte de una cadena y devuelve una nueva cadena, sin modificar la cadena original. Toma dos parámetros: el índice de inicio y el índice final opcional.

```js
const text = "freeCodeCamp";
console.log(text.slice(0, 4));  // "free"
console.log(text.slice(4, 8));  // "Code"
console.log(text.slice(8, 12)); // "Camp"
```

- **El Método `toUpperCase()`**: Este método convierte todos los caracteres a letras mayúsculas y devuelve una nueva cadena con todos los caracteres en mayúsculas.

```js
const text = "Hello, world!";
console.log(text.toUpperCase()); // "HELLO, WORLD!"
```

- **El Método `toLowerCase()`**: Este método convierte todos los caracteres de una cadena a minúsculas.

```js
const text = "HELLO, WORLD!"
console.log(text.toLowerCase()); // "hello, world!"
```

- **El Método `replace()`**: Este método se usa para encontrar un valor especificado (como una palabra o caracter) en una cadena y reemplazarlo con otro valor.

```js
const text = "I like cats";
console.log(text.replace("cats", "dogs")); // "I like dogs"
```

- **El Método `repeat()`**: Este método se usa para repetir una cadena un número especificado de veces.

```js
const text = "Hello";
console.log(text.repeat(3)); // "HelloHelloHello"
```

- **El método `trim()`**: Este método se usa para eliminar espacios en blanco tanto del principio como del final de una cadena.

```js
const text = "  Hello, world!  ";
console.log(text.trim()); // "Hello, world!"
```

- **El método `trimStart()`**: Este método elimina espacios en blanco del inicio (o "comienzo") de la cadena.

```js
const text = "  Hello, world!  ";
console.log(text.trimStart()); // "Hello, world!  "
```

- **El método `trimEnd()`**: Este método elimina espacios en blanco del final de la cadena.

```js
const text = " Hello, world! ";
console.log(text.trimEnd()); // "  Hello, world!"
```

- **El método `prompt()`**: Este método del `window` se usa para obtener información de un usuario a través de un cuadro de diálogo. Este método toma dos argumentos. El primer argumento es el mensaje que aparecerá dentro del cuadro de diálogo, típicamente solicitando al usuario que ingrese información. El segundo es un valor por defecto que es opcional y llenará el campo de entrada inicialmente.

```js
const answer = window.prompt("What's your favorite animal?"); // This will change depending on what the user answers
```

## Trabajando con el Tipo de Dato Number

- **Definición**: El tipo `Number` de JavaScript incluye números enteros, números de punto flotante, `Infinity` y `NaN`. Los números de punto flotante son números con punto decimal. El `Infinity` positivo es un número mayor que cualquier otro número, mientras que `-Infinity` es un número menor que cualquier otro número. `NaN` (`Not a Number`) representa un valor numérico inválido como la cadena `"Jessica"`.

## Operaciones Aritméticas Comunes

- **Operador de Suma**: Este operador (`+`) se usa para calcular la suma de dos o más números.
- **Operador de Resta**: Este operador (`-`) se usa para calcular la diferencia entre dos números.
- **Operador de Multiplicación**: Este operador (`*`) se usa para calcular el producto de dos o más números.
- **Operador de División**: Este operador (`/`) se usa para calcular el cociente entre dos números.
- **División por Cero**: Si intentas dividir por cero, JavaScript devolverá `Infinity`.
- **Operador de Resto**: Este operador (`%`) devuelve el resto de una división.
- **Operador de Exponenciación**: Este operador (`**`) eleva un número a la potencia de otro.

## Cálculos con Números y Cadenas

- **Explicación**: Cuando usas el operador `+` con un número y una cadena, JavaScript convertirá el número en una cadena y concatenará los dos valores.  Cuando usas los operadores `-`, `*` o `/` con una cadena y un número, JavaScript convertirá la cadena en un número y el resultado será un número. Para `null` y `undefined`, JavaScript trata `null` como 0 y undefined como `NaN` en operaciones matemáticas.

```js
const result = 5 + '10';

console.log(result); // 510
console.log(typeof result); // string

const subtractionResult = '10' - 5;
console.log(subtractionResult); // 5
console.log(typeof subtractionResult); // number

const multiplicationResult = '10' * 2;
console.log(multiplicationResult); // 20
console.log(typeof multiplicationResult); // number

const divisionResult = '20' / 2;
console.log(divisionResult); // 10
console.log(typeof divisionResult); // number

const result1 = null + 5;
console.log(result1); // 5
console.log(typeof result1); // number

const result2 = undefined + 5;
console.log(result2); // NaN
console.log(typeof result2); // number
```

## Precedencia de Operadores

- **Definición**: La precedencia de los operadores determina el orden en que se evalúan las operaciones en una expresión. Los operadores con mayor precedencia se evalúan antes que aquellos con menor precedencia. Los valores dentro de los paréntesis se evaluarán primero y la multiplicación/división tendrá mayor precedencia que la suma/resta. Si los operadores tienen la misma precedencia, entonces JavaScript usará la asociatividad. La asociatividad es lo que indica a JavaScript si debe evaluar los operadores de izquierda a derecha o de derecha a izquierda. Por ejemplo, el operador de exponenciación también es asociativo de derecha a izquierda:

```js
const result = (2 + 3) * 4;

console.log(result); // 20

const result2 = 10 - 2 + 3;

console.log(result2); // 11

const result3 = 2 ** 3 ** 2;

console.log(result3); // 512
```

## Operadores de Incremento y Decremento

- **Operador de Incremento**: Este operador se usa para aumentar el valor en uno. La notación de prefijo `++num` aumenta el valor de la variable primero, luego devuelve un nuevo valor. La notación de sufijo `num++` devuelve el valor actual de la variable primero, luego lo incrementa.

```js
let x = 5;

console.log(++x); // 6
console.log(x); // 6


let y = 5;

console.log(y++); // 5
console.log(y); // 6
```

- **Operador de Decremento**: Este operador se usa para disminuir el valor en uno. La notación de prefijo y sufijo funciona de la misma manera que antes con el operador de incremento.

```js
let num = 5;

console.log(--num); // 4
console.log(num--); // 4
console.log(num); // 3
```

## Operadores de Asignación Compuestos

- **Operador de Asignación de Suma (`+=`)**: Este operador realiza la suma sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de Resta (`-=`)**: Este operador realiza la resta sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de Multiplicación (`*=`)**: Este operador realiza la multiplicación sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de División (`/=`)**: Este operador realiza la división sobre los valores y asigna el resultado a la variable.
- **Operador de Asignación de Resto (`%=`)**: Este operador divide una variable por el número especificado y asigna el resto a la variable.
- **Operador de Asignación de Exponenciación (`**=`)**: Este operador eleva una variable a la potencia del número especificado y reasigna el resultado a la variable.

## Booleanos e Igualdad

- **Definición de Booleano**: Un booleano es un tipo de dato que solo puede tener dos valores: `true` o `false`.
- **Operador de Igualdad (`==`)**: Este operador usa la coerción de tipos antes de verificar si los valores son iguales.

```js
console.log(5 == '5'); // true
```

- **Operador de Igualdad Estricta (`===`)**: Este operador no realiza la coerción de tipos y verifica si tanto los tipos como los valores son iguales.

```js
console.log(5 === '5'); // false
```

- **Operador de Desigualdad (`!=`)**: Este operador usa la coerción de tipos antes de verificar si los valores no son iguales.
- **Operador de Desigualdad Estricta (`!==`)**: Este operador no realiza la coerción de tipos y verifica si tanto los tipos como los valores no son iguales.

## Operadores de Comparación

- **Operador Mayor Que (`>`)**: Este operador verifica si el valor de la izquierda es mayor que el de la derecha.
- **Operador Mayor Que o Igual (`>=`)**: Este operador verifica si el valor de la izquierda es mayor o igual que el de la derecha.
- **Operador Menor Que (`<`)**: Este operador verifica si el valor de la izquierda es menor que el de la derecha.
- **Operador Menor Que o Igual (`<=`)**: Este operador verifica si el valor de la izquierda es menor o igual que el de la derecha.

## Operadores Unarios

- **Operador Unario de Suma**: Este operador convierte su operando en un número. Si el operando ya es un número, se mantiene sin cambios.

```js
const str = '42';
const num = +str;

console.log(num); // 42
console.log(typeof num); // number
```

- **Operador de Negación Unaria (`-`)**: Este operador niega el operando.

```js
const num = 4;
console.log(-num); // -4
```

- **Operador Lógico NO (`!`)**: Este operador invierte el valor booleano de su operando. Entonces, si el operando es `true`, se convierte en `false`, y si es `false`, se convierte en `true`. 

## Operadores Bit a Bit

- **Operador AND Bit a Bit (`&`)**: Este operador devuelve un 1 en cada posición de bit para la cual los bits correspondientes de ambos operandos son 1.
- **Operador de Asignación AND Bit a Bit (`&=`)**: Este operador realiza una operación `bitwise AND` con el número especificado y reasigna el resultado a la variable.
- **Operador OR a nivel de bit (`|`)**: Este operador devuelve un 1 en cada posición de bit para la cual los bits correspondientes de cualquiera o ambos operandos son 1.
- **Operador de asignación OR a nivel de bit (`|=`)**: Este operador realiza una operación `OR a nivel de bit` con el número especificado y reasigna el resultado a la variable.
- **Operador XOR a nivel de bit (`^`)**: Este operador devuelve un 1 en cada posición de bit para la cual los bits correspondientes de uno, pero no de ambos, operandos son 1.
- **Operador NOT a nivel de bit (`~`)**: Este operador invierte la representación binaria de un número.
- **Operador de desplazamiento a la izquierda (`<<`)**: Este operador desplaza todos los bits a la izquierda por un número especificado de posiciones.
- **Operador de desplazamiento a la derecha (`>>`)**: Este operador desplaza todos los bits a la derecha.

## Sentencias condicionales, valores truthy, valores falsy y el operador ternario

- **`if/else if/else`**: Una sentencia `if` toma una condición y ejecuta un bloque de código si esa condición es `truthy`. Si la condición es `false`, entonces pasa al bloque `else if`. Si ninguna de esas condiciones es `true`, entonces ejecutará la cláusula `else`. Los valores `truthy` son aquellos valores que resultan en `true` cuando se evalúan en un contexto booleano como una sentencia `if`. Los valores `falsy` son valores que evalúan como `false` en un contexto booleano.

```js
const score = 87;

if (score >= 90) {
 console.log('You got an A'); 
} else if (score >= 80) {
 console.log('You got a B'); // You got an B
} else if (score >= 70) {
 console.log('You got a C');
} else {
 console.log('You failed! You need to study more!');
}
```

- **Operador Ternario**: Este operador se utiliza a menudo como una forma más corta de escribir sentencias `if else`.

```js
const temperature = 30;
const weather = temperature > 25 ? 'sunny' : 'cool';

console.log(`It's a ${weather} day!`); // It's a sunny day!
```

## Operadores lógicos binarios

- **Operador lógico AND (`&&`)**: Este operador verifica si ambos operandos son truthy. Si el primer valor es truthy, entonces devolverá el segundo valor. Si el primer valor es falsy, entonces devolverá el primer valor.

```js
const result = true && 'hello';

console.log(result); // hello
```

- **Operador lógico OR (`||`)**: Este operador verifica si al menos uno de los operandos es truthy. Si el primer valor es truthy, entonces se devuelve. Si el primer valor es falsy, entonces se devuelve el segundo valor.
- **Operador de coalescencia nula (`??`)**: Este operador devolverá un valor solo si el primero es `null` o `undefined`.

```js
const userSettings = {
 theme: null,
 volume: 0,
 notifications: false,
};

let theme = userSettings.theme ?? 'light';
console.log(theme); // light
```

## El objeto `Math`

- **El método `Math.random()`**: Este método genera un número aleatorio de punto flotante entre 0 (inclusive) y 1 (exclusivo). Esto significa que la salida posible puede ser 0, pero nunca llegará realmente a 1.
- **El método `Math.max()`**: Este método toma un conjunto de números y devuelve el valor máximo.
- **El método `Math.min()`**: Este método toma un conjunto de números y devuelve el valor mínimo.
- **El método `Math.ceil()`**: Este método redondea un valor al alza al entero más cercano.
- **El método `Math.floor()`**: Este método redondea un valor a la baja al entero más cercano.
- **El método `Math.round()`**: Este método redondea un valor al entero más cercano.

```js
console.log(Math.round(2.3)); // 2
console.log(Math.round(4.5)); // 5
console.log(Math.round(4.8)); // 5
```

- **El método `Math.trunc()`**: Este método elimina la parte decimal de un número, devolviendo solo la porción entera, sin redondear.
- **El método `Math.sqrt()`**: Este método devuelve la raíz cuadrada de un número.
- **El método `Math.cbrt()`**: Este método devuelve la raíz cúbica de un número.
- **El método `Math.abs()`**: Este método devuelve el valor absoluto de un número.
- **El método `Math.pow()`**: Este método toma dos números y eleva el primero a la potencia del segundo.

## Métodos numéricos comunes

- **`isNaN()`**: `NaN` significa "Not-a-Number" (No es un número). Es un valor especial que representa un resultado numérico no representable o indefinido. La propiedad de función `isNaN()` se utiliza para determinar si un valor es `NaN` o no.  `Number.isNaN()` proporciona una forma más confiable de verificar valores `NaN`, especialmente en casos donde la coerción de tipos podría llevar a resultados inesperados con la función global `isNaN()`.

```js
console.log(isNaN(NaN));       // true
console.log(isNaN(undefined)); // true
console.log(isNaN({}));        // true

console.log(isNaN(true));      // false
console.log(isNaN(null));      // false
console.log(isNaN(37));        // false


console.log(Number.isNaN(NaN));        // true
console.log(Number.isNaN(Number.NaN)); // true
console.log(Number.isNaN(0 / 0));      // true

console.log(Number.isNaN("NaN"));      // false
console.log(Number.isNaN(undefined));  // false
```

- **El método `parseFloat()`**: Este método analiza un argumento cadena y devuelve un número de punto flotante. Está diseñado para extraer un número desde el principio de una cadena, incluso si la cadena contiene caracteres no numéricos más adelante.
- **El método `parseInt()`**: Este método analiza un argumento cadena y devuelve un entero. `parseInt()` deja de analizar al primer carácter no dígito que encuentra. Para números de punto flotante, solo devuelve la parte entera. Si no puede encontrar un entero válido al principio de la cadena, devuelve `NaN`.
- **El método `toFixed()`**: Este método se llama en un número y toma un argumento opcional, que es el número de dígitos que aparecerán después del punto decimal. Devuelve una representación en cadena del número con la cantidad de decimales especificada.

## Comparaciones y los tipos de datos `null` y `undefined`

- **Comparaciones y `undefined`**: Una variable es `undefined` cuando ha sido declarada pero no se le ha asignado un valor. Es el valor predeterminado de variables no inicializadas y parámetros de funciones a los que no se les proporcionó un argumento. `undefined` se convierte en `NaN` en contextos numéricos, lo que hace que todas las comparaciones numéricas con `undefined` devuelvan `false`.

```js
console.log(undefined > 0);  // false
console.log(undefined < 0);  // false
console.log(undefined == 0); // false
```

- **Comparaciones y `null`**: El tipo `null` representa la ausencia intencional de un valor. Al usar el operador de igualdad, `null` y `undefined` se consideran iguales. Sin embargo, cuando se utiliza el operador de igualdad estricta (`===`), que verifica tanto el valor como el tipo sin realizar coerción de tipos, `null` y `undefined` no son iguales.

```js
console.log(null == undefined); // true
console.log(null === undefined); // false
```

## Sentencias `switch`

- **Definición**: Una sentencia `switch` evalúa una expresión y compara su valor contra una serie de cláusulas `case`. Cuando se encuentra una coincidencia, se ejecuta el bloque de código asociado a ese caso.

```js
const dayOfWeek = 3; 

switch (dayOfWeek) {
  case 1:
    console.log("It's Monday! Time to start the week strong.");
    break;
  case 2:
    console.log("It's Tuesday! Keep the momentum going.");
    break;
  case 3:
    console.log("It's Wednesday! We're halfway there.");
    break;
  case 4:
    console.log("It's Thursday! Almost the weekend.");
    break;
  case 5:
    console.log("It's Friday! The weekend is near.");
    break;
  case 6:
    console.log("It's Saturday! Enjoy your weekend.");
    break;
  case 7:
    console.log("It's Sunday! Rest and recharge.");
    break;
  default:
    console.log("Invalid day! Please enter a number between 1 and 7.");
}
```

## Funciones de JavaScript

- Las funciones son bloques de código reutilizables que realizan una tarea específica.
- Las funciones se pueden definir usando la palabra clave `function` seguida de un nombre, una lista de parámetros y un bloque de código que realiza la tarea.
- Los argumentos son valores que se pasan a una función cuando se llama.
- Cuando una función termina su ejecución, siempre devolverá un valor.
- Por defecto, el valor de retorno de una función es `undefined`.
- La palabra clave `return` se utiliza para especificar el valor que se devolverá de la función y finaliza la ejecución de la función.

## Funciones flecha

- Las funciones flecha son una forma más concisa de escribir funciones en JavaScript.
- Las funciones flecha se definen usando la sintaxis `=>` entre los parámetros y el cuerpo de la función.
- Al definir una función flecha, no necesitas la palabra clave `function`.
- Si estás utilizando un solo parámetro, puedes omitir los paréntesis alrededor de la lista de parámetros.
- Si el cuerpo de la función consiste en una sola expresión, puedes omitir las llaves y la palabra clave `return`.

## Ámbito en la programación

- **Ámbito global**: Este es el ámbito más externo en JavaScript. Las variables declaradas en el ámbito global son accesibles desde cualquier parte del código y se denominan variables globales.
- **Ámbito local**: Esto refiere a variables declaradas dentro de una función. Estas variables solo son accesibles dentro de la función donde se declaran y se les llama variables locales.
- **Ámbito de bloque**: Un bloque es un conjunto de sentencias encerradas en llaves `{}` como en las sentencias `if` o los bucles.
- El ámbito de bloque con `let` y `const` proporciona un control aún más fino sobre la accesibilidad de variables, ayudando a prevenir errores y haciendo que tu código sea más predecible.

## Conceptos básicos de arreglos en JavaScript

- **Definición**: Un arreglo en JavaScript es una colección ordenada de valores, cada uno identificado por un índice numérico. Los valores en un arreglo de JavaScript pueden ser de diferentes tipos de datos, incluidos números, cadenas, booleanos, objetos e incluso otros arreglos. Los arreglos son continuos en memoria, lo que significa que todos los elementos se almacenan en un solo bloque continuo de ubicaciones de memoria, lo que permite una indexación eficiente y un acceso rápido a los elementos por su índice.

```js
const developers = ["Jessica", "Naomi", "Tom"];
```

- **Accediendo a elementos desde arreglos**: Para acceder a elementos de un arreglo, necesitas referenciar el arreglo seguido de su número de índice dentro de corchetes. Los arreglos en JavaScript tienen indexación basada en cero, lo que significa que el primer elemento está en el índice 0, el segundo elemento está en el índice 1, etc. Si intentas acceder a un índice que no existe para el arreglo, entonces JavaScript devolverá `undefined`.

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers[0] // "Jessica"
developers[1] // "Naomi"

developers[10] // undefined
```

- **Propiedad `length`**: Esta propiedad se utiliza para devolver el número de elementos en un arreglo.

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers.length // 3
```

- **Actualizando elementos en un arreglo**: Para actualizar un elemento en un arreglo, usas el operador de asignación (`=`) para asignar un nuevo valor al elemento en un índice específico.

```js
const fruits = ['apple', 'banana', 'cherry'];
fruits[1] = 'blueberry';

console.log(fruits); // ['apple', 'blueberry', 'cherry']
```

## Arreglos bidimensionales

- **Definición**: Un arreglo bidimensional es esencialmente un arreglo de arreglos. Se usa para representar datos que tienen una estructura natural en forma de cuadrícula, como un tablero de ajedrez, una hoja de cálculo o píxeles en una imagen. Para acceder a un elemento en un arreglo bidimensional, necesitas dos índices: uno para la fila y otro para la columna.

```js
const chessboard = [
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']
];

console.log(chessboard[0][3]); // "Q"
```

## Desestructuración de arreglos

- **Definición**: La desestructuración de arreglos es una característica en JavaScript que te permite extraer valores de arreglos y asignarlos a variables de una manera más concisa y legible. Proporciona una sintaxis conveniente para desempacar elementos de arreglos en variables distintas.

```js
const fruits = ["apple", "banana", "orange"];

const [first, second, third] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(third); // "orange"
```

- **Sintaxis de propagación**: Esto te permite capturar los elementos restantes de un arreglo que no han sido desestructurados en un nuevo arreglo.

```js
const fruits = ["apple", "banana", "orange", "mango", "kiwi"];
const [first, second, ...rest] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(rest); // ["orange", "mango", "kiwi"]
```

## Métodos comunes de arreglos

- **Método `push()`**: Este método se utiliza para agregar elementos al final del arreglo y devolverá la nueva longitud.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.push("ice cream");

console.log(desserts); // ["cake", "cookies", "pie", "ice cream"];
```

- **Método `pop()`**: Este método se utiliza para eliminar el último elemento de un arreglo y devolverá ese elemento eliminado. Si el arreglo está vacío, el valor de retorno será `undefined`.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.pop();

console.log(desserts); // ["cake", "cookies"];
```

- **Método `shift()`**: Este método se utiliza para eliminar el primer elemento de un arreglo y devolverá ese elemento eliminado. Si el arreglo está vacío, el valor de retorno será `undefined`.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.shift();

console.log(desserts); // ["cookies", "pie"];
```

- **Método `unshift()`**: Este método se utiliza para agregar elementos al principio del arreglo y devolverá la nueva longitud.

```js
const desserts = ["cake", "cookies", "pie"];
desserts.unshift("ice cream");

console.log(desserts); // ["ice cream", "cake", "cookies", "pie"];
```

- **Método `indexOf()`**: Este método es útil para encontrar el primer índice de un elemento específico dentro de un arreglo. If the element cannot be found, then it will return `-1`.

```js
const fruits = ["apple", "banana", "orange", "banana"];
const index = fruits.indexOf("banana");

console.log(index); // 1
console.log(fruits.indexOf("not found")); // -1
```

- **Método `splice()`**: Este método se utiliza para agregar o eliminar elementos de cualquier posición en un arreglo. El valor de retorno del método `splice()` será un arreglo de los elementos eliminados del arreglo. Si no se eliminó nada, se devolverá un arreglo vacío. Este método mutará el arreglo original, modificándolo en su lugar en lugar de crear un nuevo arreglo. El primer argumento especifica el índice en el que comenzar a modificar el arreglo. El segundo argumento es el número de elementos que deseas eliminar. Los siguientes argumentos son los elementos que deseas agregar.

```js
const colors = ["red", "green", "blue"];
colors.splice(1, 0, "yellow", "purple");

console.log(colors); // ["red", "yellow", "purple", "green", "blue"]
```

- **Método `includes()`**: Este método se utiliza para verificar si un arreglo contiene un valor específico. Este método devuelve `true` si el arreglo contiene el elemento especificado, y `false` de otra manera.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];

console.log(programmingLanguages.includes("Python")); // true
console.log(programmingLanguages.includes("Perl")); // false
```

- **Método `concat()`**: Este método crea un nuevo arreglo fusionando dos o más arreglos.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.concat("Perl");

console.log(newList); // ["JavaScript", "Python", "C++", "Perl"]
```

- **`slice()` Method**: This method returns a shallow copy of a portion of the array, starting from a specified index or the entire array. Una copia superficial copiará la referencia al arreglo en lugar de duplicarlo.

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.slice(1);

console.log(newList); // ["Python", "C++"]
```

- **Sintaxis de propagación**: La sintaxis de propagación se utiliza para crear copias superficiales de un arreglo.

```js
const originalArray = [1, 2, 3];
const shallowCopiedArray = [...originalArray];

shallowCopiedArray.push(4);

console.log(originalArray); // [1, 2, 3]
console.log(shallowCopiedArray); // [1, 2, 3, 4]
```

- **Método `split()`**: Este método divide una cadena en un arreglo de subcadenas y especifica dónde debe ocurrir cada división según un separador dado. Si no se proporciona un separador, el método devuelve un arreglo que contiene la cadena original como un solo elemento.

```js
const str = "hello";
const charArray = str.split("");

console.log(charArray); // ["h", "e", "l", "l", "o"]
```

- **Método `reverse()`**: Este método invierte un arreglo en su lugar.

```js
const desserts = ["cake", "cookies", "pie"];
console.log(desserts.reverse()); // ["pie", "cookies", "cake"]
```

- **Método `join()`**: Este método concatena todos los elementos de un arreglo en una sola cadena, con cada elemento separado por un separador especificado. Si no se proporciona un separador o se utiliza una cadena vacía (`""`), los elementos se unirán sin ningún separador.

```js
const reversedArray = ["o", "l", "l", "e", "h"];
const reversedString = reversedArray.join("");

console.log(reversedString); // "olleh"
```

## Conceptos básicos de objetos

- **Definición**: Un objeto es una estructura de datos que se compone de propiedades. Una propiedad consta de una clave y un valor. Para acceder a datos de un objeto, puedes usar notación de punto o notación de corchetes.

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};

console.log(person.name);  // Alice
console.log(person["name"]); // Alice
```

Para establecer una propiedad de un objeto existente, puedes usar tanto la notación de punto como la notación de corchetes junto con el operador de asignación.

```js
const person = {
  name: "Alice",
  age: 30
};

person.job = "Engineer"
person["hobby"] = "Knitting"
console.log(person);  // {name: 'Alice', age: 30, job: 'Engineer', hobby: 'Knitting'}
```

## Eliminar propiedades de un objeto

- **Operador `delete`**: Este operador se usa para eliminar una propiedad de un objeto.

```js
const person = {
  name: "Alice",
  age: 30,
  job: "Engineer"
};

delete person.job;

console.log(person.job); // undefined
```

## Comprobando si un objeto tiene una propiedad

- **Método `hasOwnProperty()`**: Este método devuelve un valor booleano que indica si el objeto tiene la propiedad especificada como su propia propiedad.

```js
const person = {
  name: "Alice",
  age: 30
};

console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("job")); // false
```

- **Operador `in`**: Este operador devolverá `true` si la propiedad existe en el objeto.

```js
const person = {
  name: "Bob",
  age: 25
};

console.log("name" in person);  // true
```

## Accediendo a propiedades de objetos anidados

- **Accediendo a Datos**: Acceder a propiedades de objetos anidados implica usar la notación de punto o la notación de corchetes, similar al acceso a propiedades de objetos simples. Sin embargo, necesitarás encadenar estos accesores para profundizar en la estructura anidada.

```js
const person = {
  name: "Alice",
  age: 30,
  contact: {
    email: "alice@example.com",
    phone: {
      home: "123-456-7890",
      work: "098-765-4321"
    }
  }
};

console.log(person.contact.phone.work); // "098-765-4321"
```

## Tipos de datos primitivos y no primitivos

- **Tipos de datos primitivos**: Estos tipos de datos incluyen números, cadenas, booleanos, `null`, `undefined` y símbolos. Estos tipos se llaman "primitivos" porque representan valores únicos y no son objetos. Los valores primitivos son inmutables, lo que significa que una vez que se crean, su valor no se puede cambiar.
- **Tipos de datos no primitivos**: En JavaScript, estos son objetos, que incluyen objetos regulares, arreglos y funciones. A diferencia de los primitivos, los tipos no primitivos pueden contener múltiples valores como propiedades o elementos.

## Métodos de objetos

- **Definición**: Los métodos de objeto son funciones que están asociadas a un objeto. Se definen como propiedades de un objeto y pueden acceder y manipular los datos del objeto. La palabra clave `this` dentro del método se refiere al propio objeto, lo que permite el acceso a sus propiedades.

```js
const person = {
  name: "Bob",
  age: 30,
  sayHello: function() {
    return "Hello, my name is " + this.name;
  }
};

console.log(person.sayHello()); // "Hello, my name is Bob"
```

## Constructor de objetos

- **Definición**: En JavaScript, un constructor es un tipo especial de función utilizado para crear e inicializar objetos. Se invoca con la palabra clave `new` y puede inicializar propiedades y métodos en el objeto recién creado. El constructor `Object()` crea un nuevo objeto vacío.

```js
new Object()
```

## Trabajando con el operador de encadenamiento opcional (`?.`)

- **Definición**: Este operador te permite acceder de forma segura a las propiedades de un objeto o llamar métodos sin preocuparte de si existen.

```js
const user = {
  name: "John",
  profile: {
    email: "john@example.com",
    address: {
      street: "123 Main St",
      city: "Somewhere"
    }
  }
};

console.log(user.profile?.address?.street); // "123 Main St"
console.log(user.profile?.phone?.number);   // undefined
```

## Desestructuración de Objeto

- **Definición**: La desestructuración de objetos te permite extraer valores de objetos y asignarlos a variables de manera más concisa y legible.

```js
const person = { name: "Alice", age: 30, city: "New York" };

const { name, age } = person;

console.log(name); // Alice
console.log(age);  // 30
```

## Trabajar con JSON

- **Definición**: JSON significa Notación de Objetos JavaScript. Es un formato de datos ligero y basado en texto que se usa comúnmente para intercambiar datos entre un servidor y una aplicación web.

```js
{
  "name": "Alice",
  "age": 30,
  "isStudent": false,
  "list of courses": ["Mathematics", "Physics", "Computer Science"]
}
```

- **`JSON.stringify()`**: Este método se usa para convertir un objeto JavaScript en una cadena JSON. Esto es útil cuando quieres almacenar o transmitir datos en un formato que pueda ser fácilmente compartido o transferido entre sistemas.

```js
const user = {
  name: "John",
  age: 30,
  isAdmin: true
};

const jsonString = JSON.stringify(user);
console.log(jsonString); // '{"name":"John","age":30,"isAdmin":true}'
```

- **`JSON.parse()`**: Este método convierte una cadena JSON de nuevo a un objeto de JavaScript. Esto es útil cuando recuperas datos JSON de un servidor web o localStorage y necesitas manipular los datos en tu aplicación.

```js
const jsonString = '{"name":"John","age":30,"isAdmin":true}';
const userObject = JSON.parse(jsonString);

// result: { name: 'John', age: 30, isAdmin: true }
console.log(userObject);
```


## Trabajar con Bucles

- **`for` Loop**: Este tipo de bucle se usa para repetir un bloque de código un cierto número de veces. Este bucle se divide en tres partes: la declaración de inicialización, la condición y la declaración de incremento/decremento. La sentencia de inicialización se ejecuta antes de que comience el bucle. Normalmente se utiliza para inicializar una variable contadora. La condición se evalúa antes de cada iteración del bucle. Una iteración es un único paso a través del bucle. Si la condición es `true`, el bloque de código dentro del bucle se ejecuta. Si la condición es `false`, el bucle se detiene y se pasa al siguiente bloque de código. La sentencia de incremento/decremento se ejecuta después de cada iteración del bucle. Normalmente se utiliza para incrementar o decrementar la variable contadora.

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

- **`for...of` Loop**: Este tipo de bucle se usa cuando necesitas iterar sobre valores de un iterable. Ejemplos de iterables son arreglos y cadenas.

```js
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num);
}
```

- **`for...in` Loop**: Este tipo de bucle es mejor usarlo cuando necesitas iterar sobre las propiedades de un objeto. Este bucle iterará sobre todas las propiedades enumerables de un objeto, incluidas propiedades heredadas y propiedades no numéricas.

```js
const fruit = {
  name: 'apple',
  color: 'red',
  price: 0.99
};

for (const prop in fruit) {
  console.log(fruit[prop]);
}
```

- **`while` Loop**: Este tipo de bucle ejecutará un bloque de código mientras la condición sea `true`.

```js
let i = 5;

while (i > 0) {
  console.log(i);
  i--;
}
```

- **`do...while` Loop**: Este tipo de bucle ejecutará el bloque de código al menos una vez antes de comprobar la condición.

```js
let userInput;

do {
  userInput = prompt("Please enter a number between 1 and 10");
} while (Number(userInput) < 1 || Number(userInput) > 10);

alert("You entered a valid number!");
```

## `break` y `continue` Sentencias

- **Definición**: Una sentencia `break` se usa para salir de un bucle anticipadamente, mientras que una sentencia `continue` se usa para saltar la iteración actual de un bucle y pasar a la siguiente.

```js
// Example of break statement
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, and 4

// Example of continue statement 
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    continue;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, 4, 6, 7, 8, and 9
```

## Constructor de Cadena y `toString()` Método

- **Definición**: Un objeto cadena se usa para representar una secuencia de caracteres. Los objetos cadena se crean usando la función constructora `String`, que envuelve el valor primitivo en un objeto.

```js
const greetingObject = new String("Hello, world!");

console.log(typeof greetingObject); // "object"
```

- **`toString()` Método**: Este método convierte un valor a su representación de cadena. Es un método que puedes usar para números, booleanos, arreglos y objetos.

```js
const num = 10;
console.log(num.toString()); // "10"

const arr = [1, 2, 3];
console.log(arr.toString()); // "1,2,3"
```

Este método acepta un radix opcional que es un número del 2 al 36. Este radix representa la base, como la base 2 para binario o base 8 para octal. Si el radix no se especifica, se establece por defecto en base 10, que es decimal.


```js
const num = 10;
console.log(num.toString(2)); // "1010"(binary)
```

## Constructor de Número

- **Definición**: El constructor `Number` se usa para crear un objeto número. El objeto número contiene algunas propiedades y métodos útiles como el método `isNaN` y `toFixed`. La mayor parte del tiempo, utilizarás el constructor `Number` para convertir otros tipos de datos al tipo de dato número.

```js
const myNum = new Number("34");
console.log(typeof myNum); // "object"

const num = Number('100');
console.log(num); // 100

console.log(typeof num); // number
```

## Mejores Prácticas para Nombrar Variables y Funciones

- **camelCasing**: Por convención, los desarrolladores de JavaScript usarán camel casing para nombrar variables y funciones. El camel casing es donde la primera palabra está en minúsculas y las palabras siguientes comienzan con una mayúscula. Ej. `isLoading`.

- **Nombrando Booleans**: Para variables booleanas, es una práctica común usar prefijos como "is", "has", o "can".

```js
let isLoading = true;
let hasPermission = false;
let canEdit = true;
```

- **Nombrando Funciones**: Para funciones, el nombre debe indicar claramente lo que hace la función. Para funciones que retornan un booleano (a menudo llamadas predicados), puedes usar los mismos prefijos "is", "has", o "can". Cuando tienes funciones que recuperan datos, es común comenzar con la palabra "get". Cuando tienes funciones que establecen datos, es común comenzar con la palabra "establecer". Para funciones manejadoras de eventos, podrías prefijar con "handle" o sufijar con "Handler".

```js
function getUserData() { /* ... */ }

function isValidEmail(email) { /* ... */ }

function getProductDetails(productId) { /* ... */ }

function setUserPreferences(preferences) { /* ... */ }

function handleClick() { /* ... */ }
```

- **Nombrando Variables Dentro de Bucles**: Al nombrar variables iteradoras en bucles, es común usar letras individuales como `i`, `j`, o `k`.

```js
for (let i = 0; i < array.length; i++) { /* ... */ }
```

## Trabajar con Arreglos Dispersos

- **Definición**: Es posible tener arreglos con posiciones vacías. Las posiciones vacías se definen como posiciones sin nada en ellas. Esto es diferente de las posiciones de un arreglo con el valor `undefined`. Estos tipos de arreglos se conocen como arreglos dispersos.

```js
const sparseArray = [1, , , 4];
console.log(sparseArray.length); // 4
```

## Linter y Formateadores

- **Linter**: Un linter es una herramienta de análisis de código estático que marca errores de programación, errores de estilo y construcciones sospechosas. Un ejemplo de un linter común sería ESLint.
- **Formateadores**: Los formateadores son herramientas que formatean tu código automáticamente para adherirse a una guía de estilo específica. Un ejemplo de un formateador común es Prettier.

## Gestión de Memoria

- **Definición**: La gestión de memoria es el proceso de controlar la memoria, asignándola cuando es necesaria y liberándola cuando ya no es necesaria. JavaScript usa gestión de memoria automática. Esto significa que JavaScript (más específicamente, el motor de JavaScript en tu navegador web) se encarga de la asignación y liberación de memoria por ti.  No tienes que liberar explícitamente la memoria en tu código. Este proceso automático se llama a menudo "recolección de basura".

## Clausuras

- **Definición**: Una clausura es una función que tiene acceso a variables en su ámbito léxico externo (envolvente), incluso después de que la función externa haya devuelto.

```js
function outerFunction(x) {
  let y = 10;
  function innerFunction() {
    console.log(x + y);
  }
  return innerFunction;
}

let closure = outerFunction(5);
closure(); // 15
```

## `var` Palabra Clave y Elevación

- **Definición**: `var` era la forma original de declarar variables antes de 2015. Pero había algunos problemas que surgían con `var` en términos de ámbito, redeclaración y más. Por eso, la programación moderna en JavaScript utiliza `let` y `const` en su lugar.
- **Redeclaración de Variables con `var`**: Si intentas redeclarar una variable usando `let`, entonces obtendrías un `SyntaxError`. Pero con `var`, se te permite redeclarar una variable.

```js
// Uncaught SyntaxError: Identifier 'num' has already been declared 
let num = 19;
let num = 18;

var myNum = 5;
var myNum = 10; // This is allowed and doesn't throw an error

console.log(myNum) // 10
```

- **`var` y Ámbito**: Las variables declaradas con `var` dentro de un bloque (como una sentencia `if` o un bucle `for`) aún son accesibles fuera de ese bloque.

```js
if (true) {
  var num = 5;
}
console.log(num); // 5
```

- **Elevación**: Este es el comportamiento predeterminado de JavaScript de mover las declaraciones al principio de sus respectivos ámbitos durante la fase de compilación antes de que se ejecute el código. Cuando declaras una variable usando la palabra clave `var`, JavaScript eleva la declaración al inicio de su ámbito.

```js
console.log(num); // undefined
var num = 5;
console.log(num); // 5
```

Cuando declaras una función usando la sintaxis de declaración de función, tanto el nombre de la función como el cuerpo de la función son elevados. Esto significa que puedes invocar una función antes de haberla declarado en tu código.

```js
sayHello(); // "Hello, World!"

function sayHello() {
  console.log("Hello, World!");
}
```

Las declaraciones de variables hechas con `let` o `const` son elevadas, pero no están inicializadas, y no puedes acceder a ellas antes de la declaración real en tu código. Este comportamiento se refiere a menudo como la "zona muerta temporal".

```js
console.log(num); // Throws a ReferenceError
let num = 10;
```

## Trabajar con Importaciones, Exportaciones y Módulos

- **Módulo**: Esta es una unidad de código autónoma que encapsula funciones relacionadas, clases o variables. Para crear un módulo, escribe tu código JavaScript en un archivo separado.
- **Exportaciones**: Cualquier variable, función o clase que desees poner a disposición de otras partes de tu aplicación debe exportarse explícitamente usando la palabra clave `export`. Hay dos tipos de exportación: exportación nombrada y exportación por defecto.
- **Importaciones**: Para usar los elementos exportados en otra parte de tu aplicación, necesitas importarlos usando la palabra clave `import`. Los tipos pueden ser importación nombrada, importación por defecto e importación de espacio de nombre.

```js
// Within a file called math.js, we export the following functions:

// Named export
export function add(num1, num2) {
  return num1 + num2;
}

// Default export
export default function subtract(num1, num2) {
  return num1 - num2;
}

// Within another file, we can import the functions from math.js.

// Named import - This line imports the add function.
// The name of the function must exactly match the one exported from math.js.
import { add } from './math.js';

// Default import - This line imports the subtract function.
// The name of the function can be anything.
import subtractFunc from './math.js';

// Namespace import - This line imports everything from the file.
import * as Math from './math.js';

console.log(add(5, 3)); // 8
console.log(subtractFunc(5, 3)); // 2
console.log(Math.add(5, 3)); // 8
console.log(Math.subtract(5, 3)); // 2
```

## Funciones de Retrollamada y el Método `forEach`

- **Definición**: En JavaScript, una función de retrollamada es una función que se pasa como argumento a otra función y se ejecuta después de que la función principal ha finalizado su ejecución.
- **`forEach()` Método**: Este método se usa para iterar sobre cada elemento en un arreglo y realizar una operación en cada elemento. La función de retrollamada en `forEach` puede tomar hasta tres argumentos: el elemento actual, el índice del elemento actual y el arreglo sobre el cual se llamó `forEach`.

```js
const numbers = [1, 2, 3, 4, 5];

// Result: 2 4 6 8 10
numbers.forEach((number) => {
  console.log(number * 2);
});
```

## Funciones de Orden Superior

- **Definición**: Una función de orden superior toma una o más funciones como argumentos y devuelve una función o valor como resultado.

```js
function operateOnArray(arr, operation) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(operation(arr[i]));
  }
  return result;
}

function double(x) {
  return x * 2;
}

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = operateOnArray(numbers, double);
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
```

- **`map()` Método**: Este método se usa para crear un nuevo arreglo aplicando una función dada a cada elemento del arreglo original. La función de retrollamada puede aceptar hasta tres argumentos: el elemento actual, el índice del elemento actual y el arreglo sobre el cual se llamó `map`.

```js
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);

console.log(numbers); // [1, 2, 3, 4, 5]
console.log(doubled); // [2, 4, 6, 8, 10]
```

- **`filter()` Método**: Este método se usa para crear un nuevo arreglo con elementos que pasan una prueba especificada, siendo útil para extraer elementos de manera selectiva según criterios. Al igual que el método `map`, la función de retrollamada para el método `filter` acepta los mismos tres argumentos: el elemento actual procesado, el índice, y el arreglo.

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter((num) => num % 2 === 0);

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

- **`reduce()` Método**: Este método se usa para procesar un arreglo y condensarlo en un único valor. Este único valor puede ser un número, una cadena, un objeto o incluso otro arreglo. El método `reduce()` funciona aplicando una función a cada elemento en el arreglo, en orden, pasando el resultado de cada cálculo al siguiente. Esta función se llama a menudo la función reductora. La función reductora toma dos parámetros principales: un acumulador y el valor actual. El acumulador es donde almacenas el resultado de tus operaciones, y el valor actual es el elemento del arreglo que se está procesando.

```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0
);

console.log(sum); // 15
```

## Encadenamiento de Métodos

- **Definición**: El encadenamiento de métodos es una técnica de programación que te permite llamar a múltiples métodos sobre el mismo objeto en una sola línea de código. Esta técnica puede hacer que tu código sea más legible y conciso, especialmente cuando realizas una serie de operaciones en el mismo objeto.

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

## Trabajar con el Método `sort`

- **Definición**: El método `sort` se utiliza para ordenar los elementos de un arreglo y devolver una referencia al arreglo ordenado. No se hace una copia en este caso porque los elementos se ordenan en su lugar.

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();

console.log(fruits); // ["Apple", "Banana", "Mango", "Orange"]
```

Si necesitas ordenar números, entonces deberás pasar una función de comparación. El método `sort` convierte los elementos a cadenas y luego compara sus secuencias de valores de unidades de código UTF-16. Las unidades de código UTF-16 son los valores numéricos que representan los caracteres en la cadena. Ejemplos de unidades de código UTF-16 son los números 65, 66, y 67 que representan respectivamente los caracteres "A", "B", y "C". Así, el número 200 aparece antes que el número 3 en un arreglo, porque la cadena "200" viene antes que la cadena "3" al comparar sus unidades de código UTF-16.

```js
const numbers = [414, 200, 5, 10, 3];

numbers.sort((a, b) => a - b);

console.log(numbers); // [3, 5, 10, 200, 414]
```

Los parámetros `a` y `b` son los dos elementos que se están comparando. La función de comparación deberá devolver un valor negativo si `a` debe estar antes de `b`, un valor positivo si `a` debe estar después de `b`, y cero si `a` y `b` son iguales.

## Trabajar con los Métodos `every` y `some`

- **`every()` Método**: Este método prueba si todos los elementos en un arreglo pasan una prueba implementada por una función proporcionada. El método `every()` devuelve `true` si la función proporcionada devuelve `true` para todos los elementos del arreglo. Si algún elemento no pasa la prueba, el método inmediatamente devuelve `false` y deja de verificar los elementos restantes.

```js
const numbers = [2, 4, 6, 8, 10];
const hasAllEvenNumbers = numbers.every((num) => num % 2 === 0);

console.log(hasAllEvenNumbers); // true
```

- **`some()` Método**: Este método verifica si al menos un elemento pasa la prueba. El método `some()` devuelve `true` tan pronto como encuentra un elemento que pasa la prueba. Si ningún elemento pasa la prueba, devuelve `false`.

```js
const numbers = [1, 3, 5, 7, 8, 9];
const hasSomeEvenNumbers = numbers.some((num) => num % 2 === 0);

console.log(hasSomeEvenNumbers); // true
```

## Trabajar con el DOM y Web APIs

- **API**: una API (Interfaz de Programación de Aplicaciones) es un conjunto de reglas y protocolos que permiten a las aplicaciones de software comunicarse entre sí e intercambiar datos de manera eficiente.
- **API Web**: Las API web están específicamente diseñadas para aplicaciones web. Estos tipos de API a menudo se dividen en dos categorías principales: API de navegadores y API de terceros.
- **API de Navegadores**: Estas API exponen datos del navegador. Como desarrollador web, puedes acceder y manipular estos datos usando JavaScript.
- **API Terceros**: Estas no están integradas en el navegador por defecto. Debes obtener su código de alguna manera. Por lo general, tendrán documentación detallada que explique cómo usar sus servicios. Un ejemplo es la API de Google Maps, que puedes usar para mostrar mapas interactivos en tu sitio web.
- **DOM**: El DOM significa Modelo de Objeto de Documento. Es una interfaz de programación que te permite interactuar con documentos HTML. Con el DOM, puedes agregar, modificar o eliminar elementos en una página web. La raíz del árbol DOM es el elemento `html`. Es el contenedor de nivel superior para todo el contenido de un documento HTML. Todos los demás nodos son descendientes de este nodo raíz. Luego, debajo del nodo raíz, encontramos otros nodos en la jerarquía. Un nodo primario es un elemento que contiene otros elementos. Un nodo hijo es un elemento que se encuentra dentro de otro elemento.
- **`navigator` Interfaz**: Esto proporciona información sobre el entorno del navegador, como la cadena del agente de usuario, la plataforma y la versión del navegador. Una cadena de agente de usuario es una cadena de texto que identifica el navegador y el sistema operativo que se está utilizando.
- **`window` Interfaz**: Esto representa la ventana del navegador que contiene el documento DOM. Proporciona métodos y propiedades para interactuar con la ventana del navegador, como cambiar el tamaño de la ventana, abrir nuevas ventanas y navegar a diferentes URL.

## Trabajar con los Métodos `querySelector()`, `querySelectorAll()` y `getElementById()`

- **`getElementById()` Método**: Este método se usa para obtener un objeto que representa el elemento HTML con el `id` especificado. Recuerda que los ID deben ser únicos en cada documento HTML, por lo que este método solo devolverá un objeto Element.

```html
<div id="container"></div>
```

```js
const container = document.getElementById("container");
```

- **Método `querySelector()`**: Este método se utiliza para obtener el primer elemento en el documento HTML que coincide con el selector CSS pasado como argumento.

```html
<section class="section"></section>
```

```js
const section = document.querySelector(".section");
```

- **`querySelectorAll()` Método**: Puedes usar este método para obtener una lista de todos los elementos DOM que coinciden con un selector CSS específico.

```html
<ul class="ingredients">
  <li>Sugar</li>
  <li>Milk</li>
  <li>Eggs</li>
</ul>
```

```js
const ingredients = document.querySelectorAll('ul.ingredients li');
```

## Trabajar con los Métodos `innerText()`, `innerHTML()`, `createElement()` y `textContent()`

- **`innerHTML` Propiedad**: Es una propiedad del `Elemento` que se usa para establecer o actualizar partes de la marca HTML.

```html
<div id="container">
  <!-- Add new elements here -->
</div>
```

```js
const container = document.getElementById("container");
container.innerHTML = '<ul><li>Cheese</li><li>Tomato</li></ul>';
```

- **`createElement` Método**: Esto se usa para crear un elemento HTML.

```js
const img = document.createElement("img");
```

- **`innerText`**: Esto representa el contenido de texto visible del elemento HTML y sus descendientes.

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.innerText);
```

- **`textContent`**: Esto devuelve el contenido de texto plano de un elemento, incluyendo todo el texto dentro de sus descendientes.

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.textContent);
```

## Trabajar con los Métodos `appendChild()` y `removeChild()`

- **`appendChild()` Método**: Este método se usa para añadir un nodo al final de la lista de hijos de un nodo padre especificado.

```html
<ul id="desserts">
  <li>Cake</li>
  <li>Pie</li>
</ul>
```

```js
const dessertsList = document.getElementById("desserts");
const listItem = document.createElement("li");

listItem.textContent = "Cookies";
dessertsList.appendChild(listItem);
```

- **`removeChild()` Método**: Este método se usa para eliminar un nodo del DOM.

```html
<section id="example-section">
  <h2>Example sub heading</h2>
  <p>first paragraph</p>
  <p>second paragraph</p>
</section>
```

```js
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");

sectionEl.removeChild(lastParagraph);
```

## Trabajar con el Método `setAttribute`

- **Definición**: Este método se usa para establecer el atributo para un elemento dado. Si el atributo ya existe, entonces se actualiza el valor. De lo contrario, se añade un nuevo atributo con un valor.

```html
<p id="para">I am a paragraph</p>
```

```js
const para = document.getElementById("para");
para.setAttribute("class", "my-class");
```

## Objeto Evento

- **Definición**: El objeto `Event` es un payload que se activa cuando un usuario interactúa con tu página web de alguna manera. Estas interacciones pueden ser cualquier cosa, desde hacer clic en un botón o enfocarse en una entrada hasta agitar su dispositivo móvil. Todos los objetos de `Evento` tendrán la propiedad `type`. Esta propiedad revela el tipo de evento que activó la carga útil, como pulsar una tecla o hacer clic. Estos valores corresponderán a los mismos valores que podrías pasar a `addEventListener`(), donde puedes capturar y utilizar el objeto `Evento`.

## Métodos de `addEventListener()` y `removeEventListener()`

- **Método `addEventListener`**: Este método se usa para escuchar eventos. Toma dos argumentos: el evento que deseas escuchar y una función que será llamada cuando ocurra el evento. Algunos ejemplos comunes de eventos son los eventos de clic, eventos de entrada y eventos de cambio.

```js
const btn = document.getElementById("btn");

btn.addEventListener("click", () => alert("You clicked the button"));
```

- **Método `removeEventListener`**: Este método se usa para eliminar un escuchador de eventos que fue previamente añadido a un elemento utilizando el método `addEventListener`. Esto es útil cuando deseas dejar de escuchar un evento particular en un elemento.

```js
const bodyEl = document.querySelector("body");
const para = document.getElementById("para");
const btn = document.getElementById("btn");

let isBgColorGrey = true;

function toggleBgColor() {
  bodyEl.style.backgroundColor = isBgColorGrey ? "blue" : "grey";
  isBgColorGrey = !isBgColorGrey;
}

btn.addEventListener("click", toggleBgColor);

para.addEventListener("mouseover", () => {
  btn.removeEventListener("click", toggleBgColor);
});
```

- **Manejadores de Eventos Inline**: Los manejadores de eventos inline son atributos especiales de un elemento HTML que se utilizan para ejecutar código de JavaScript cuando ocurre un evento. En JavaScript moderno, los manejadores de eventos inline no se consideran la mejor práctica. Se prefiere usar el método `addEventListener` en su lugar.

```html
<button onclick="alert('Hello World!')">Show alert</button>
```

## DOMContentLoaded

- **Definición**: El evento `DOMContentLoaded` se dispara cuando todo el documento HTML ha sido cargado y analizado. Si tienes hojas de estilo o imágenes externas, el evento `DOMContentLoaded` no esperará a que se carguen. Solo esperará a que se cargue el HTML.

## Trabajando con `style` y `classList`

- **Propiedad `Element.style`**: Esta propiedad es una propiedad de solo lectura que representa el estilo en línea de un elemento. Puedes usar esta propiedad para obtener o establecer el estilo de un elemento.

```js
const paraEl = document.getElementById("para");
paraEl.style.color = "red";
```

- **Propiedad `Element.classList`**: Esta propiedad es una propiedad de solo lectura que se puede usar para agregar, quitar o alternar clases en un elemento.

```js
// Example adding a class
const paraEl = document.getElementById("para");
paraEl.classList.add("highlight");

// Example removing a class
paraEl.classList.remove("blue-background");

// Example toggling a class
const menu = document.getElementById("menu");
const toggleBtn = document.getElementById("toggle-btn");

toggleBtn.addEventListener("click", () => menu.classList.toggle("show"));
```


## Trabajando con los Métodos `setTimeout` y `setInterval`

- **Método `setTimeout()`**: Este método te permite retrasar una acción por un tiempo especificado.

```js
setTimeout(() => {
 console.log('This runs after 3 seconds'); 
}, 3000);
```

- **Método `setInterval()`**: Este método sigue ejecutando un bloque de código repetidamente a un intervalo establecido. Dado que `setInterval()` continúa ejecutando la función proporcionada en el intervalo especificado, podrías querer detenerlo. Para esto, debes utilizar el método `clearInterval()`.

```js
setInterval(() => {
 console.log('This runs every 2 seconds');
}, 2000);

// Example using clearInterval
const intervalID = setInterval(() => {
 console.log('This will stop after 5 seconds');
}, 1000);

setTimeout(() => {
 clearInterval(intervalID);
}, 5000);
```

## El Método `requestAnimationFrame()`

- **Definición**: Este método te permite programar el próximo paso de tu animación antes de la siguiente actualización de pantalla, resultando en una experiencia visual fluida y atractiva. La siguiente actualización de pantalla se refiere al momento en que el navegador refresca la visualización de la página web. Esto ocurre múltiples veces por segundo, típicamente alrededor de 60 veces (o 60 cuadros por segundo) en la mayoría de las pantallas.

```js
function animate() {
 // Update the animation...
 // for example, move an element, change a style, and more.
 update();
 // Request the next frame
 requestAnimationFrame(animate);
}
```

## API de Animaciones Web

- **Definición**: La API de Animaciones Web te permite crear y controlar animaciones directamente dentro de JavaScript. 

```js
const square = document.querySelector('#square');

const animation = square.animate(
 [{ transform: 'translateX(0px)' }, { transform: 'translateX(100px)' }],
 {
   duration: 2000, // makes animation lasts 2 seconds
   iterations: Infinity, // loops indefinitely
   direction: 'alternate', // moves back and forth
   easing: 'ease-in-out', // smooth easing
 }
);
```

## La API Canvas

- **Definición**: La API de Canvas es una herramienta poderosa que te permite manipular gráficos directamente dentro de tu archivo JavaScript. Para trabajar con la API de Canvas, primero necesitas proporcionar un elemento `canvas` en HTML. Este elemento actúa como una superficie de dibujo que puedes manipular con los métodos de instancia y propiedades de las interfaces en la API de Canvas. Esta API tiene interfaces como `HTMLCanvasElement`, `CanvasRenderingContext2D`, `CanvasGradient`, `CanvasPattern` y `TextMetrics` que contienen métodos y propiedades que puedes usar para crear gráficos en tu archivo JavaScript.

```html
<canvas id="my-canvas" width="400" height="400"></canvas>
```

```js
const canvas = document.getElementById('my-canvas');

// Access the drawing context of the canvas. 
// "2d" allows you to draw in two dimensions 
const ctx = canvas.getContext('2d');

// Set the background color
ctx.fillStyle = 'crimson';

// Draw a rectangle
ctx.fillRect(1, 1, 150, 100);
```

## Abrir y cerrar diálogos y modales con JavaScript

- **Definiciones de Modal y Dialog**: Los diálogos te permiten mostrar información o acciones importantes a los usuarios. Con el elemento de diálogo incorporado en HTML, puedes crear fácilmente estos diálogos (tanto modales como no modales) en tus aplicaciones web. Un diálogo modal es un tipo de diálogo que obliga al usuario a interactuar con él antes de que puedan acceder al resto de la aplicación o página web. En cambio, un diálogo no modal permite al usuario seguir interactuando con otras partes de la página o aplicación incluso cuando el diálogo está abierto. No impide el acceso al resto del contenido.
- **Método `showModal()`**: Este método se usa para abrir un modal.

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');

openButton.addEventListener('click', () => {
  dialog.showModal();
});
```

- **Método `close()`**: Este método se usa para cerrar el modal.

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
   <button id="close-modal">Close Modal</button>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');
const closeButton = document.getElementById('close-modal');

openButton.addEventListener('click', () => {
  dialog.show();
});

closeButton.addEventListener('click', () => {
  dialog.close();
});
```

## El Evento de Cambio

- **Definición**: El evento de cambio es un evento especial que se activa cuando el usuario modifica el valor de ciertos elementos de entrada. Los ejemplos incluirían cuando se marca una casilla de verificación o un botón de opción. O cuando el usuario hace una selección de algo como un selector de fechas o un menú desplegable.

```html
<label>
  Choose a programming language:
  <select class="language" name="language">
    <option value="">---Select One---</option>
    <option value="JavaScript">JavaScript</option>
    <option value="Python">Python</option>
    <option value="C++">C++</option>
  </select>
</label>

<p class="result"></p>
```

```js 
const selectEl = document.querySelector(".language");
const result = document.querySelector(".result");

selectEl.addEventListener("change", (e) => {
  result.textContent = `You enjoy programming in ${e.target.value}.`;
});
```

## Propagación de Eventos

- **Definición**: La burbuja de eventos, o propagación, se refiere a cómo un evento "sube" hacia los objetos padre cuando se activa.

## Delegación de Eventos

- **Definición**: La delegación de eventos es el proceso de escuchar eventos que se han propagado a un elemento padre, en lugar de manejarlos directamente en el elemento que los activó.

## JavaScript and Accessibility

### Common ARIA Accessibility Attributes

- **`aria-expanded` attribute**: Used to convey the state of a toggle (or disclosure) feature to screen reader users.
- **`aria-haspopup` attribute**: This state is used to indicate that an interactive element will trigger a pop-up element when activated. You can only use the `aria-haspopup` attribute when the pop-up has one of the following roles: `menu`, `listbox`, `tree`, `grid`, or `dialog`. The value of `aria-haspopup` must be either one of these roles or `true`, which is the same as `menu`.
- **`aria-checked` attribute**: This attribute is used to indicate whether an element is in the checked state. It is most commonly used when creating custom checkboxes, radio buttons, switches, and listboxes.
- **`aria-disabled` attribute**: This state is used to indicate that an element is disabled only to people using assistive technologies, such as screen readers.
- **`aria-selected` attribute**: This state is used to indicate that an element is selected. You can use this state on custom controls like a tabbed interface, a listbox, or a grid.
- **`aria-controls` attribute**: Used to associate an element with another element that it controls. This helps people using assistive technologies understand the relationship between the elements.
- **`hidden` attribute**: Hides inactive panels from both visual and assistive technology users.

### Working with Live Regions and Dynamic Content

- **`aria-live` attribute**: Makes part of a webpage a live region, meaning any updates inside that area will be announced by a screen reader so users don't miss important changes.
- **`polite` value**: Most live regions use this value. This value means that the update is not urgent, so the screen reader can wait until it finishes any current announcement or the user completes their current action before announcing the update.

Here is an example of a live region that is dynamically updated by JavaScript:

```html
<div aria-live="polite" id="status"></div>
```

```js
const statusEl = document.getElementById("status");
statusEl.textContent = "Your file has been successfully uploaded.";
```

- **`contenteditable` attribute**: Turns the element into a live editor, allowing users to update its content as if it were a text field. When there is no visible label or heading for a contenteditable region, add an accessible name using the `aria-label` attribute to help screen reader users understand the purpose of the editable area.

```html
<div contenteditable="true" aria-label="Note editor">
  Editable content goes here
</div>
```

## `focus` and `blur` Events

- **`blur` event**: Fires when an element loses focus.

```js
element.addEventListener("blur", () => {
  // Handle when user leaves the element
});
```

- **`focus` event**: Fires when an element receives focus.

```js
element.addEventListener("focus", () => {
  // Handle when user enters the element
});
```

## Tipos Comunes de Mensajes de Error

- **SyntaxError**: Estos errores ocurren cuando escribes algo incorrectamente en tu código, como faltar un paréntesis o un corchete. Piensa en ello como un error gramatical en una oración.

```js
const arr = ["Beau", "Quincy" "Tom"]
```

- **ReferenceError**: Existen varios tipos de Errores de Referencia, activados de diferentes maneras. El primer tipo de error de referencia sería las variables no definidas. Otro ejemplo de ReferenceError es intentar acceder a una variable, declarada con `let` o `const`, antes de que haya sido definida.

```js
console.log(num);
const num = 50;
```

- **TypeError**: Estos errores ocurren cuando se intenta realizar una operación en el tipo equivocado.

```js
const developerObj = {
  name: "Jessica",
  country: "USA",
  isEmployed: true
};

developerObj.map()
```

- **Error de rango**: Estos errores ocurren cuando tu código intenta usar un valor que está fuera del rango que JavaScript puede manejar.

```js
const arr = [];
arr.length = -1; 
```

## La Sentencia `throw`

- **Definición**: La declaración `throw` en JavaScript se usa para lanzar una excepción definida por el usuario. Una excepción en programación es cuando ocurre un evento inesperado que interrumpe el flujo normal del programa.

```js
function validateNumber(input) {
  if (typeof input !== "number") {
    throw new TypeError("Expected a number, but received " + typeof input);
  }
  return input * 2;
}
```

## `try...catch...finally`

- **Definición**: El bloque `try` se utiliza para encerrar código que podría lanzar un error. Actúa como un espacio seguro para intentar algo que podría fallar. El bloque `catch` captura y maneja errores que ocurren en el bloque try. Puedes usar el objeto de error en catch para inspeccionar qué salió mal. El bloque `finally` se ejecuta después de los bloques try y catch, independientemente de si ocurrió un error. Se utiliza comúnmente para tareas de limpieza, como cerrar archivos o liberar recursos.

```js
function processInput(input) {
  if (typeof input !== "string") {
    throw new TypeError("Input must be a string.");
  }

  return input.toUpperCase();
}

try {
  console.log("Starting to process input...");
  const result = processInput(9);
  console.log("Processed result:", result);
} catch (error) {
  console.error("Error occurred:", error.message);
} 
```

## Técnicas de Depuración

- **Sentencia `debugger`**: Esta sentencia te permite pausar tu código en una línea específica para investigar qué está ocurriendo en el programa.

```js
let firstNumber = 5;
let secondNumber = 10;

debugger; // Code execution pauses here
let sum = firstNumber + secondNumber;

console.log(sum);
```

- **Puntos de interrupción**: Los puntos de interrupción te permiten pausar la ejecución de tu código en una línea específica de tu elección. Después de la pausa, puedes inspeccionar variables, evaluar expresiones y examinar la pila de llamadas.
- **Observadores**: Las expresiones de observación te permiten monitorear los valores de variables o expresiones mientras el código se ejecuta, incluso si están fuera del alcance actual.
- **Perfilaje**: El perfilaje te ayuda a identificar cuellos de botella de rendimiento permitiendo que capture capturas de pantalla y registre el uso de la CPU, llamadas de función y tiempo de ejecución.
- **`console.dir()`**: Este método se usa para mostrar una lista interactiva de las propiedades de un objeto JavaScript especificado. Muestra una lista jerárquica que se puede expandir para ver todas las propiedades anidadas.

```js
console.dir(document);
```

- **`console.table()`**: Este método muestra datos tabulares como una tabla en la consola. Toma un argumento obligatorio, que debe ser un arreglo o un objeto, y un argumento opcional para especificar qué propiedades (columnas) mostrar.

## Expresiones Regulares y Métodos Comunes

- **Definición**: Las expresiones regulares, o regex, se utilizan para crear un "patrón", que luego puedes usar para verificar una cadena, extraer texto y más.

```js
const regex = /freeCodeCamp/;
```

- **Método `test()`**: Este método acepta una cadena, que es la cadena a probar para coincidencias con la expresión regular. Este método devolverá un booleano si la cadena coincide con el regex.

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test); // false
```

- **Método `match()`**: Este método acepta una expresión regular, aunque también puedes pasar una cadena que se construirá en una expresión regular. El método `match` devuelve el arreglo de coincidencias para la cadena.

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match); // ["freeCodeCamp"]
```

- **Método `replace()`**: Este método acepta dos argumentos: la expresión regular a coincidir (o una cadena), y la cadena para reemplazar la coincidencia (o una función para ejecutar contra cada coincidencia).

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced); // "freeCodeCamp is rly kewl"
```

- **Método `replaceAll`**: Este método se utiliza para reemplazar todas las ocurrencias de un patrón especificado con una nueva cadena. Este método lanzará un error si le das una expresión regular sin el modificador global.

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

- **Método `matchAll`**: Este método se utiliza para recuperar todas las coincidencias de una expresión regular dada en una cadena, incluidos los grupos de captura, y las devuelve como un iterador. Un iterador es un objeto que te permite recorrer (o "iterar sobre") una colección de elementos.

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

## Modificadores de Expresiones Regulares

- **Definición**: Los modificadores, a menudo denominados "banderas", modifican el comportamiento de una expresión regular.
- **Bandera `i`**: Esta bandera hace que una expresión regular ignore las mayúsculas y minúsculas.

```js
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
```

- **Bandera `g`**: Esta bandera, o modificador global, permite que tu expresión regular coincida con un patrón más de una vez.

```js
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
```

- **Definición de ancla **: El ancla `^`, al principio de la expresión regular, indica "coincidir con el inicio de la cadena". El ancla `$`, al final de la expresión regular, indica "coincidir con el final de la cadena".

```js
const start = /^freeCodeCamp/i;
const end = /freeCodeCamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
```

- **Bandera `m`**: Los anclajes buscan el principio y el final de toda la cadena. Pero puedes hacer que una expresión regular maneje múltiples líneas con la bandera `m`, o el modificador de múltiples líneas.

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const str = `I love 
freecodecamp
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true

```

- **Bandera `d`**: Esta bandera amplía la información que obtienes en un objeto de coincidencia.

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

- **Bandera `u`**: Esto amplía la funcionalidad de una expresión regular para permitirle coincidir con caracteres unicode especiales. La bandera `u` te da acceso a clases especiales como `Extended_Pictographic` para coincidir con la mayoría de los emojis. También hay una bandera `v`, que amplía aún más la funcionalidad de la coincidencia unicode.
- **Bandera `y`**: El modificador sticky se comporta de manera muy similar al modificador global, pero con algunas excepciones. La más grande es que una expresión regular global comenzará desde lastIndex y buscará en todo el resto de la cadena otra coincidencia, pero una expresión regular sticky devolverá null y restablecerá lastIndex a 0 si no hay una coincidencia inmediatamente en el lastIndex anterior.
- **Bandera `s`**: El modificador de una sola línea permite a un carácter comodín, representado por un `.` en regex, coincidir con saltos de línea, tratando efectivamente la cadena como una sola línea de texto.

## Clases de Caracteres

- **Comodín `.`**: Las clases de caracteres son una sintaxis especial que puedes usar para coincidir con conjuntos o subconjuntos de caracteres. La primera clase de caracteres que deberías aprender es la clase del comodín. El comodín está representado por un punto, y coincide con CUALQUIER carácter individual EXCEPTO saltos de línea. Para permitir que la clase de comodines coincida con saltos de línea, recuerda que necesitarías usar la bandera `s`.

```js
const regex = /a./;
```

- **`\d`**: Esto coincidirá con todos los dígitos (`0-9`) en una cadena.

```js
const regex = /\d/;
```

- **`\w`**: Esto se usa para coincidir con cualquier carácter de palabra (`a-z0-9_`) en una cadena. Un carácter de palabra se define como cualquier letra, de la a a la z, o un número del 0 al 9, o el carácter guion bajo.

```js
const regex = /\w/;
```

- **`\s`**: La clase de espacio en blanco `\s`, representada por una barra diagonal invertida seguida de una `s`. Esta clase de caracteres coincidirá con cualquier espacio en blanco, incluidos nuevos saltos de línea, espacios, tabulaciones y caracteres de espacio unicode especiales.
- **Negación de Clases de Caracteres Especiales**: Para negar una de estas clases de caracteres, en lugar de usar una letra minúscula después de la barra diagonal, puedes usar el equivalente en mayúscula. El siguiente ejemplo no coincide con un carácter numérico. En cambio, coincide con cualquier carácter único que NO sea un carácter numérico.

```js
const regex = /\D/;
```

- **Clases de Caracteres Personalizadas**: Puedes crear clases de caracteres personalizadas colocando el carácter que deseas hacer coincidir dentro de un conjunto de corchetes.

```js
const regex = /[abcdf]/;
```

## Aserciones de Lookahead y Lookbehind

- **Definición**: Las aserciones de lookahead y lookbehind te permiten hacer coincidir patrones específicos según la presencia o falta de patrones circundantes.
- **Aserción de Lookahead Positiva**: Esta aserción coincidirá con un patrón cuando el patrón esté seguido de otro patrón. Para construir un lookahead positivo, necesitas comenzar con el patrón que deseas coincidir. Luego, usa paréntesis para envolver el patrón que deseas usar como tu condición. Después del paréntesis de apertura, usa `?=` para definir ese patrón como un lookahead positivo.

```js
const regex = /free(?=code)/i;
```

- **Aserción de Lookahead Negativa**: Esta es una clase de condición utilizada en expresiones regulares para verificar que no exista un cierto patrón más adelante en la cadena.

```js
const regex = /free(?!code)/i;
```

- **Aserción de Lookbehind Positiva**: Esta aserción solo coincidirá con un patrón si está precedido por otro patrón específico, sin incluir el patrón precedente en la coincidencia.

```js
const regex = /(?<=free)code/i;
```

- **Aserción de Lookbehind Negativa**: Esta aserción asegura que un patrón no esté precedido por otro patrón específico. Solo coincide si el patrón especificado no está inmediatamente precedido por la secuencia dada, sin incluir la secuencia precedente en la coincidencia.

```js
const regex = /(?<!free)code/i;
```

## Cuantificadores de Regex

- **Definición**: Los cuantificadores en expresiones regulares especifican cuántas veces debe aparecer un patrón (o parte de un patrón). Ayudan a controlar el número de apariciones de caracteres o grupos en una coincidencia. El siguiente ejemplo se usa para hacer coincidir el carácter anterior exactamente cuatro veces.

```js
const regex = /^\d{4}$/;
```

- **`*`** : Coincide con 0 o más ocurrencias del elemento precedente.
- **`+`**: Coincide con 1 o más ocurrencias del elemento precedente.
- **`?`**: Coincide con 0 o 1 ocurrencia del elemento precedente.
- **`{n}`**: Coincide exactamente con n ocurrencias del elemento precedente.
- **`{n,}`**: Coincide con n o más ocurrencias del elemento precedente.
- **`{n,m}`**: Coincide con entre n y m ocurrencias del elemento precedente.

## Grupos de Captura y Referencias Posteriores

- **Grupos de captura**: Un grupo de captura te permite "capturar" una parte de la cadena coincidente para usarla según necesites. Los grupos de captura son definidos por paréntesis que contienen el patrón a capturar, sin caracteres líderes como un lookahead.

```js
const regex = /free(code)camp/i;
```

- **Referencias Posteriores**: Una referencia posterior en expresiones regulares se refiere a una forma de reutilizar una parte del patrón que fue coincidente anteriormente en la misma expresión. Te permite referirte a un grupo capturado (una parte del patrón entre paréntesis) por su número. Por ejemplo, `$1` se refiere al primer grupo capturado.

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

## Validación de Formulario con JavaScript

- **API de Validación por Restricciones**: Ciertos elementos HTML, como los elementos `textarea` y `input`, exponen una API de validación por restricciones. Esta API te permite asegurar que el valor proporcionado por el usuario para ese elemento pasa cualquier validación de nivel HTML que hayas escrito, como longitud mínima o coincidencia de patrones.
- **Método `checkValidity()`**: Este método devuelve `true` si el elemento coincide con toda la validación HTML (basado en sus atributos), y `false` si falla.

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.setCustomValidity("You must use a .com email.")
  }
})
```

- **Método `reportValidity()`**: Este método le dice al navegador que la `input` es inválida.

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.reportValidity();
  }
})
```

- **Propiedad `validity`**: Esta propiedad se utiliza para obtener o establecer el estado de validez de los controles de formulario (como `<input>`, `<select>`, etc.) y proporciona información sobre si la entrada del usuario cumple con las restricciones definidas para ese elemento (por ejemplo, campos `requeridos`, restricciones de patrón, longitud máxima, etc.).

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.validity);
})
```

- **Propiedad `patternMismatch`**: Esto será `true` si el valor no coincide con el patrón de expresión regular especificado.

## Método `preventDefault()`

- **Definición**: Cada evento que se activa en el DOM tiene algún tipo de comportamiento por defecto. El evento de clic en una casilla de verificación alterna el estado de esa casilla de verificación, por defecto. Presionar la barra espaciadora en un botón enfocado activa el botón. El método `preventDefault()` en estos objetos `Evento` detiene que ese comportamiento ocurra.

```js
button.addEventListener('click', (event) => {
  // Prevent the default button click behavior  
  event.preventDefault(); 
  alert('Button click prevented!');
});
```

## Envío de Formularios

- **Definición**: Hay tres maneras de enviar un formulario. La primera es cuando el usuario hace clic en un botón en el formulario que tiene el atributo `type` configurado en `submit`. La segunda es cuando el usuario presiona la tecla `Enter` en cualquier campo `input` editable en el formulario. La tercera es a través de una llamada de JavaScript a los métodos `requestSubmit()` o `submit()` del elemento `form`.
- **`action` Atributo**: El atributo `action` debe contener una URL o una ruta relativa para el dominio actual. Este valor determina a dónde intenta enviar el formulario los datos; si no estableces un atributo `action`, el formulario enviará los datos a la URL de la página actual.

```html
<form action="https://freecodecamp.org">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`method` Atributo**: Este atributo acepta un método estándar `HTTP`, como `GET` o `POST`, y utiliza ese método al hacer la solicitud a la URL de acción. Cuando no se establece un método, el formulario por defecto hará una solicitud `GET`. Los datos del formulario serán codificados en la URL como pares `name=value` y añadidos a la URL de acción como parámetros de consulta.

```html
<form action="/data" method="POST">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`enctype` Atributo**: El elemento `form` acepta un atributo `enctype`, que representa el tipo de codificación a usar para los datos. Este atributo solo acepta tres valores: `application/x-www-form-urlencoded` (que es el predeterminado, enviando los datos como un cuerpo de formulario codificado en URL), `text/plain` (que envía los datos en forma de texto sin formato, en pares `nombre=valor` separados por nuevas líneas), o `multipart/form-data`, que es específicamente para manejar formularios con una carga de archivos.

## El Objeto `date()` y Métodos Comunes

- **Definición**: El objeto `date()` se usa para crear, manipular y dar formato a fechas y horas en JavaScript. En el siguiente ejemplo, se utiliza la palabra clave `new` para crear una nueva instancia del objeto `Date`, y luego se asigna al objeto `Date` a la variable `now`. Si registras el valor de `now` en la consola, verás la fecha y hora actual basado en el reloj del sistema de la computadora que ejecuta el código.

```js
const now = new Date();
```

- **`Date.now()` Método**: Este método se utiliza para obtener la fecha y hora actual. `Date.now()` devuelve el número de milisegundos desde el 1 de enero de 1970, 00:00:00 UTC. Esto se conoce como el tiempo de época Unix. El tiempo de época Unix es una forma común de representar fechas y horas en sistemas informáticos porque es un entero que se puede almacenar y manipular fácilmente. UTC significa Tiempo Universal Coordinado, que es el estándar de tiempo principal con el que el mundo regula los relojes y el tiempo.
- **`getDate()` Método**: Este método se usa para obtener el día del mes basado en la fecha actual. `getDate()` devolverá un valor entero entre 1 y 31, dependiendo del día del mes. Si la fecha no es válida, devolverá `NaN` (No es un Número).

```js
const now = new Date();
const date = now.getDate();
console.log(date); // 15
```

- **`getMonth()` Método**: Este método se usa para obtener el mes. El mes está basado en cero, por lo que Enero es 0, Febrero es 1, y así sucesivamente. En este ejemplo, la salida es 2, lo que corresponde a Marzo. Si el mes no es válido, devolverá `NaN`.

```js
const now = new Date();
const month = now.getMonth();
console.log(month); // 2
```

- **`getFullYear()` Método**: Este método se usa para obtener el año completo. Si el año no es válido, devolverá `NaN`.

```js
const now = new Date();
const year = now.getFullYear();
console.log(year); // 2024
```

## Diferentes Formas de Formatear Fechas

- **El método `toISOString()`**: Este método se usa para formatear la fecha en un formato extendido `ISO` (ISO 8601). ISO 8601 es un estándar internacional para representar fechas y horas. El formato es `YYYY-MM-DDTHH:mm:ss.sssZ`.

```js
const date = new Date();
console.log(date.toISOString());
```

- **`toLocaleDateString()` Método**: Este método se usa para dar formato a la fecha basado en la configuración regional del usuario.

```js
const date = new Date();
console.log(date.toLocaleDateString());  // 11/23/2024
```

El método `toLocaleDateString()` acepta dos parámetros opcionales: localidades y opciones.

El parámetro localidades es una cadena que representa la configuración regional a usar. Por ejemplo, puedes pasar `"en-US"` para Inglés (Estados Unidos) o `"fr-FR"` para Francés (Francia). Si no pasas un parámetro de localidades, se usa la configuración regional predeterminada. El segundo parámetro opcional es el parámetro de opciones. Este parámetro es un objeto que te permite especificar el formato de la cadena de fecha.

```js
const date = new Date();
const options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(date.toLocaleDateString("en-GB", options)); // Saturday, November 23, 2024
```

## El Constructor `Audio` y Métodos Comunes

- **Definición**: El constructor `Audio`, al igual que otros constructores, es una función especial que se llama con la palabra clave `new`. Devuelve un `HTMLAudioElement`, que puedes usar para reproducir audio para el usuario o añadirlo al DOM para que el usuario lo controle él mismo. Cuando llamas al constructor, puedes pasar opcionalmente una URL como (único) argumento. Esta URL debe apuntar a la fuente del archivo de audio que deseas reproducir. O, si necesitas cambiar la fuente dinámicamente, puedes asignar la URL a la propiedad `src` del elemento de audio devuelto.
- **Método `play()`**: Este método se usa con los elementos `audio` o `video` para comenzar la reproducción del medio.

```js
const audio = document.getElementById('audio');

// Starts playing the audio
audio.play();  
```

- **Método `pause()`**: Este método se usa con los elementos `audio` o `video` para pausar la reproducción del medio.

```js
function pauseAudio() {
  const audio = document.getElementById('myAudio');
  audio.pause();  // Pauses the audio playback
}
```

- **`addTextTrack()` Método**: Este método te permite especificar una pista de texto para asociar con el elemento multimedia, algo muy útil para añadir subtítulos a un video.
- **`fastSeek()` Método**: Este método te permite mover la posición de reproducción a un tiempo específico dentro del medio.

## Diferentes Formatos de Audio y Video

- **Tipo MIME**: Un tipo MIME, siglas de Multipurpose Internet Mail Extensions, es una manera estandarizada de indicar programáticamente un tipo de archivo. El tipo MIME puede decirle a una aplicación, como tu navegador, cómo manejar un archivo específico. En el caso de audio y video, el tipo MIME indica que es un formato multimedia que puede ser insertado en la página web.
- **`source` Elemento**: Se usa para especificar un tipo de archivo y fuente, y puede incluir múltiples tipos diferentes utilizando múltiples elementos fuente. Cuando haces esto, el navegador determinará el mejor formato para usar en el entorno actual del usuario.
- **MP3**: Este es un tipo de formato de archivo digital utilizado para almacenar música, audio o sonido. Es una versión comprimida de una grabación de audio que hace que el tamaño de archivo sea más pequeño, por lo que es más fácil de almacenar y compartir. Un archivo MP3 tiene el tipo MIME audio/mp3
- **MP4**: Un MP4 es un tipo de formato de archivo digital usado para almacenar video y audio. Sirve como un contenedor que contiene tanto el video (imágenes) como el sonido (música o habla) en un archivo. Un MP4 puede tener el tipo MIME audio/mp4 O video/mp4, dependiendo de si es un archivo de video o solo audio.

## codecs

- **Definición**: Un códec, abreviatura de "codificador/decodificador", es un algoritmo o software que puede convertir audio y video entre formatos analógicos y digitales. Los códecs pueden especificarse como parte del tipo MIME. La sintaxis básica para definir un códec es agregar un punto y coma después del tipo de medio, luego `codecs=` y el códec.

## API HTMLMediaElement

- **Definición**: El API `HTMLMediaElement` se usa para controlar el comportamiento de elementos de audio y video en tu página. Extiende la interfaz base `HTMLElement`, por lo que tienes acceso a las propiedades base así como a estos métodos útiles. Ejemplos de estos métodos incluyen `play()`, `fastSeek()`, y `pause()`.

## API de Captura de Medios y Streams

- **Definición**: El API de Captura de Medios y Streams, o el API MediaStream, se utiliza para capturar audio y video desde tu dispositivo. Para usar el API, necesitas crear el objeto `MediaStream`. Podrías hacer esto con el constructor, pero no estaría vinculado al hardware del usuario. En cambio, la propiedad `mediaDevices` del objeto global navigator tiene un método `getUserMedia()` para que lo uses.

```js
window.navigator.mediaDevices.getUserMedia({
  audio: true,
  video: {
    width: {
      min: 1280,
      ideal: 1920,
      max: 3840
    },
    height: {
      min: 720,
      ideal: 1080,
      max: 2160
    }
  }
});
```

## API de Captura de Pantalla

- **Definición**: La API de captura de pantalla se utiliza para grabar la pantalla de un usuario. Este API se expone llamando al método `getDisplayMedia()` del objeto `mediaDevices` y consumiendo el flujo de medios devuelto.

## API de Grabación de MediaStream

- **Definición**: El API de Grabación de MediaStream funciona en conjunto con los APIs de MediaStreams, permitiéndote grabar un MediaStream (o incluso un `HTMLMediaElement` directamente).

## API de Extensiones de Fuente de Medios

- **Tema**: La API de extensiones de fuente de medios es lo que te permite pasar directamente la transmisión de la cámara web de un usuario a un elemento de video con la propiedad `srcObject`.

## API de Audio Web

- **Definición**: El API de Audio Web que impulsa todo lo audible en la web. Este API incluye objetos importantes como un `AudioBuffer` (que representa un Búfer específicamente que contiene datos de audio) o el `AudioContext`.

## Conjuntos en JavaScript

- Un `Set` es una opción incorporada para manejar colecciones de datos.
- Los conjuntos garantizan que cada valor en ellos aparezca solo una vez, haciéndolos útiles para eliminar duplicados de un arreglo o manejar colecciones de valores distintos.
- Puedes crear un `Set` usando el constructor `Set()`:

```js
const set = new Set([1, 2, 3, 4, 5]);
console.log(set); // Set { 1, 2, 3, 4, 5 }
```

- Los conjuntos pueden ser manipulados usando estos métodos:

  - `add()`: Agrega un nuevo elemento al `Set`.
  - `delete()`: Elimina un elemento del `Set`.
  - `has()`: Verifica si un elemento existe en el `Set`.
  - `clear()`: Elimina todos los elementos del `Set`.

## Weaksets en JavaScript

- Un `WeakSet` es una colección de objetos que permite almacenar objetos débilmente retenidos.

## Conjuntos vs WeakSets

- A diferencia de los Sets, un `WeakSet` no soporta primitivas como números o cadenas.
- Un `WeakSet` solo almacena objetos, y las referencias a esos objetos son "débiles", lo que significa que si el objeto no se está utilizando en ningún otro lugar de tu código, se elimina automáticamente para liberar memoria.

## Mapas en JavaScript

- Un `Map` es un objeto incorporado que almacena pares clave-valor al igual que un objeto.
- Los mapas difieren de los objetos estándar de JavaScript con su habilidad para permitir claves de cualquier tipo, incluidos objetos y funciones.
- Un `Map` proporciona un mejor rendimiento sobre el objeto estándar cuando se trata de adiciones y eliminaciones frecuentes de pares clave-valor.
- Puedes crear un `Map` usando el constructor `Map()`:

```js
const map = new Map([
  ['flower', 'rose'],
  ['fruit', 'apple'],
  ['vegetable', 'carrot']
]);
console.log(map); // Map(3) { 'flower' => 'rose', 'fruit' => 'apple', 'vegetable' => 'carrot' }
```

- Los mapas pueden ser manipulados usando estos métodos:

  - `set()`: Agrega un nuevo par clave-valor al `Map`.
  - `get()`: Recupera el valor de una clave del `Map`.
  - `delete()`: Elimina un par clave-valor del `Map`.
  - `has()`: Verifica si una clave existe en el `Map`.
  - `clear()`: Elimina todos los pares clave-valor del `Map`.

## WeakMaps en JavaScript

- Un `WeakMap` es una colección de pares clave-valor igual que `Map`, pero con referencias débiles a las claves. Las claves deben ser un objeto y los valores pueden ser cualquier cosa que desees.

## Mapas vs WeakMaps

- Los WeakMaps son similares a los WeakSets en que solo almacenan objetos y las referencias a esos objetos son "débiles".

## Almacenamiento Persistente

- **Definición**: El almacenamiento persistente se refiere a una forma de guardar datos de modo que permanezcan disponibles incluso después de que se apague o reinicie el dispositivo.

## Crear, Leer, Actualizar, Eliminar (CRUD)

- **Crear**: Esto se refiere al proceso de crear nuevos datos. Por ejemplo, en una aplicación web, esto podría ser cuando un usuario añade una nueva entrada en un blog.
- **Leer**: Esta es la operación donde se recuperan datos de una base de datos. Por ejemplo, cuando visitas una publicación de blog o ves tu perfil en un sitio web, estás realizando una operación de lectura para obtener y mostrar datos almacenados en la base de datos.
- **Actualizar**: Esto implica modificar datos existentes en la base de datos. Un ejemplo sería editar una entrada de blog o actualizar la información de su perfil.
- **Eliminar**: Esta es la operación que elimina datos de una base de datos. Por ejemplo, cuando eliminas una publicación de blog o una cuenta, estás realizando una operación de eliminación.

## Métodos HTTP

- **Definición**: HTTP significa Protocolo de Transferencia de Hipertexto y es la base para la comunicación de datos en la web. Hay métodos HTTP que definen las acciones que pueden realizarse sobre recursos en la web. Los métodos comunes son GET, POST, PUT, PATCH, DELETE.
- **`GET` Método**: Se usa para obtener datos de un servidor.
- **`POST` Método**: Se utiliza para enviar datos a un servidor que crea un nuevo recurso.
- **`PUT` Método**: Se utiliza para actualizar un recurso al reemplazarlo por completo.
- **`PATCH` Método**: Se usa para actualizar parcialmente un recurso.
- **`DELETE` Método**: Se usa para eliminar registros de una base de datos.

## Propiedades `localStorage` y `sessionStorage`

- **API de Almacenamiento Web**: Esta API proporciona un mecanismo para que los navegadores almacenen pares clave-valor directamente dentro del navegador, permitiendo a los desarrolladores almacenar información que puede ser usada a través de diferentes recargas de página y sesiones. Los dos componentes principales para el API de Almacenamiento Web son las propiedades `localStorage` y `sessionStorage`.
- **`localStorage` Propiedad**: `localStorage` es la parte del API de Almacenamiento Web que permite que los datos persistan incluso después de que la ventana del navegador se cierre o la página se actualice. Estos datos permanecen disponibles hasta que son eliminados explícitamente por la aplicación o el usuario.
- **`localStorage.setItem()` Método**: Se utiliza para almacenar un par clave-valor en `localStorage`.

```js
localStorage.setItem('username', 'Jessica');
```

- **`localStorage.getItem()` Método**: Se usa para recuperar el valor de una clave específica de `localStorage`.

```js
localStorage.setItem('username', 'codingRules');

let username = localStorage.getItem('username');
console.log(username); // codingRules
```

- **`localStorage.removeItem()` Método**: Este método se utiliza para eliminar un elemento específico de `localStorage` utilizando su clave.

```js
localStorage.removeItem('username');
```

- **`localStorage.clear()` Método**: Se usa para limpiar todos los datos almacenados en `localStorage`.

```js
localStorage.clear();
```

- **`sessionStorage` Propiedad**: Almacena datos que solo duran para la sesión actual y se limpia cuando la pestaña del navegador o la ventana se cierran.
- **`sessionStorage.setItem()` Método**: Se usa para almacenar un par clave-valor en `sessionStorage`.

```js
sessionStorage.setItem('cart', '3 items');
```

- **`sessionStorage.getItem()` Método**: Este método se usa para recuperar el valor de una clave determinada de `sessionStorage`.

```js
sessionStorage.setItem('cart', '3 items');

let cart = sessionStorage.getItem('cart');
console.log(cart); // '3 items'
```

- **`sessionStorage.removeItem()` Método**: Se usa para eliminar un elemento específico de `sessionStorage` utilizando su clave.

```js
sessionStorage.removeItem('cart');
```

- **`sessionStorage.clear()` Método**: Se usa para eliminar todos los datos almacenados en `sessionStorage`.

```js
sessionStorage.clear();
```

## Trabajando con Cookies

- **Definición**: Las cookies, también conocidas como cookies web o cookies del navegador, son pequeñas piezas de datos que un servidor envía al navegador web de un usuario. Estas cookies se almacenan en el dispositivo del usuario y se envían de vuelta al servidor con solicitudes posteriores. Las cookies son esenciales para ayudar a las aplicaciones web a mantener el estado y recordar la información del usuario, lo cual es especialmente importante dado que HTTP es un protocolo sin estado.
- **Cookies de Sesión**: Estas cookies duran solo durante la sesión del usuario en el sitio web. Una vez que el usuario cierra el navegador o la pestaña, la cookie de sesión se elimina. Estas cookies se utilizan típicamente para tareas como mantener a un usuario conectado durante su visita.
- **Cookies Seguras**: Estas cookies solo se envían a través de HTTPS, asegurando que no puedan ser interceptadas por un atacante durante el tránsito.
- **Cookies HttpOnly**: Estas cookies no pueden ser accedidas o modificadas por JavaScript que se ejecuta en el navegador, haciéndolas más seguras contra ataques de scripts entre sitios (XSS).
- **Encabezado Set-Cookie**: Cuando visitas un sitio web, el servidor puede enviar un encabezado Set-Cookie en la respuesta HTTP. Este encabezado le indica a tu navegador que guarde una cookie con información específica. Por ejemplo, puede almacenar un ID único que ayuda al sitio a reconocerte la próxima vez que lo visites. Puedes establecer manualmente una cookie en JavaScript usando `document.cookie`:

```js
document.cookie = "organization=freeCodeCamp; expires=Fri, 31 Dec 2021 23:59:59 GMT; path=/";
```

Para eliminar una cookie, puedes establecer su fecha de expiración en un momento en el pasado.

```js
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
```

## API de Caché

- **Definición**: La caché es el proceso de almacenar copias de archivos en una ubicación de almacenamiento temporal, para que se puedan acceder más rápidamente.  La API de Caché se usa para almacenar solicitudes y respuestas de red, haciendo que las aplicaciones web funcionen de manera más eficiente e incluso operen sin conexión. Es parte de la API de Service Worker más amplia y es crucial para crear Aplicaciones Web Progresivas (PWAs) que puedan funcionar bajo condiciones de red poco fiables o lentas. La API de Caché es un mecanismo de almacenamiento que guarda objetos de Request y Response. Cuando se hace una solicitud a un servidor, la aplicación puede almacenar la respuesta y luego recuperarla del caché en lugar de hacer una nueva solicitud de red. Esto reduce los tiempos de carga, ahorra ancho de banda y mejora la experiencia general del usuario.
- **Almacenamiento en Caché**: Esto se usa para almacenar pares clave-valor de solicitudes HTTP y sus respuestas correspondientes. Esto permite la recuperación eficiente de recursos solicitados anteriormente, reduciendo la necesidad de obtenerlos de la red en visitas posteriores y mejorando el rendimiento.
- **Control de Caché**: Los desarrolladores pueden definir cuánto tiempo debe mantenerse un recurso en caché, y si debe revalidarse o servirse directamente desde el caché.
- **Soporte Offline**: Usando la API de Caché, puedes crear aplicaciones web que prioricen el uso sin conexión. Por ejemplo, un PWA puede servir recursos en caché cuando el usuario está desconectado de la red.

## Patrones Negativos y Almacenamiento en el Lado del Cliente

- **Seguimiento Excesivo**: Esto se refiere a la práctica de recopilar y almacenar una sobreabundancia de datos del usuario en el almacenamiento del lado del cliente (como cookies, almacenamiento local o almacenamiento de sesión) sin un consentimiento claro, informado o una necesidad legítima. Esto a menudo implica seguir el comportamiento, preferencias e interacciones del usuario a través de múltiples sitios o sesiones, lo que puede infringir la privacidad del usuario.
- **Huella Digital del Navegador**: Una técnica utilizada para seguir e identificar usuarios individuales basándose en características únicas de su dispositivo y navegador, en lugar de depender de cookies u otros métodos tradicionales de seguimiento. A diferencia de las cookies, que se almacenan localmente en el dispositivo del usuario, la huella digital implica la recopilación de un rango de información que puede usarse para crear una "huella" distintiva de una sesión de navegación del usuario.
- **Configuración de Contraseñas en LocalStorage**: Esto podría parecer un patrón negativo más obvio, pero establecer cualquier dato sensible como contraseñas en el almacenamiento local representa un riesgo de seguridad. El Almacenamiento Local no está encriptado y se puede acceder fácilmente. Por lo tanto, nunca debes almacenar ningún tipo de datos sensibles allí.

## IndexedDB

- **Definición**: IndexedDB se usa para almacenar datos estructurados en el navegador. Esto está incorporado en los navegadores web modernos, permitiendo a las aplicaciones web almacenar y obtener objetos en Javascript de manera eficiente.

## Caché/Service Workers

- **Definición**: Un Service Worker es un script que se ejecuta en segundo plano, separado de tu página web. Puede interceptar solicitudes de red, acceder al cache, y hacer que la aplicación web funcione sin conexión. Este es un componente clave de las aplicaciones web progresivas.

## Conceptos Básicos de Trabajo con Clases

- **Definición**: Las clases en JavaScript se usan para definir planos para crear objetos, y encapsular datos. Las clases incluyen un constructor que es un método especial que se llama automáticamente cuando se crea un nuevo objeto a partir de la clase. Se utiliza para inicializar las propiedades del objeto. La palabra clave `this` se usa aquí para referirse a la instancia actual de la clase. Debajo del constructor, puedes tener lo que se llaman métodos. Los métodos son funciones definidas dentro de una clase que realizan acciones u operaciones sobre los datos o estado de la clase. Se utilizan para definir comportamientos que las instancias de la clase pueden realizar.

```js
class Dog {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
}
```

Para crear una nueva instancia de la clase, usarás la palabra clave `new` seguida del nombre de la clase:

```js
const dog = new Dog("Gino");
```

También puedes crear clases como expresiones de clase. Esto es cuando la clase es anónima y se asigna a una variable.

```js
const Dog = class {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
};
```

## Herencia de Clase

- **Definición**: En programación, la herencia te permite definir clases que heredan propiedades y métodos de clases padres. Esto promueve la reutilización del código y establece una relación jerárquica entre las clases. Una clase padre es una clase que actúa como un plano para otras clases. Define propiedades y métodos que son heredados por otras clases. Una clase hija es una clase que hereda las propiedades y métodos de otra clase. Las clases hijas también pueden ampliar la funcionalidad de sus clases padres agregando nuevas propiedades y métodos. En JavaScript, usamos la palabra clave `extends` para implementar la herencia. Esta palabra clave indica que una clase es la clase hija de otra clase.

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

La palabra clave `super` se usa para acceder a los métodos, constructores y campos de la clase padre.


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

## Trabajando con Métodos y Propiedades Estáticas

- **Métodos estáticos**: Estos métodos son a menudo utilizados para funciones utilitarias que no necesitan acceso al estado específico de un objeto. Se definen dentro de las clases para encapsular una funcionalidad relacionada. Los métodos estáticos también son útiles para implementar métodos "factory". Un método factory es un método que defines además del constructor para crear objetos basados en criterios específicos.

```js
class Movie {
  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }
}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);

Movie.compareMovies(movieA, movieB);
```

- **Propiedades Estáticas**: Estas propiedades se usan para definir valores o atributos que están asociados con una clase en sí, más que con instancias de la clase. Las propiedades estáticas se comparten entre todas las instancias de la clase y pueden ser accedidas sin crear una instancia de la clase.

```js
class Car {
  // Static property
  static numberOfWheels = 4;

  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  // Instance method
  getCarInfo() {
    return `${this.make} ${this.model}`;
  }

  // Static method
  static getNumberOfWheels() {
    return Car.numberOfWheels;
  }
}

// Accessing static property directly from the class
console.log(Car.numberOfWheels); 
```


- La recursión es un concepto de programación que te permite llamar a una función repetidamente hasta alcanzar un caso base.

Aquí hay un ejemplo de una función recursiva que calcula el factorial de un número:

```js
function findFactorial(n) {
  if (n === 0) {
    return 1;
  }
  return n * findFactorial(n - 1);
}
```

En el ejemplo anterior, la función `findFactorial` se llama recursivamente hasta que `n` alcanza `0`. Cuando `n` es `0`, se alcanza el caso base y la función devuelve `1`. La función entonces devuelve el producto de `n` y el resultado de la llamada recursiva a `findFactorial(n - 1)`.

- La recursión te permite manejar algo con una profundidad desconocida, como objetos/matrices anidados o un árbol de archivos.
- Una pila de llamadas se usa para hacer un seguimiento de las llamadas de función en una función recursiva. Cada vez que se llama a una función, se añade a la pila de llamadas. Cuando se alcanza el caso base, las llamadas de función se eliminan del stack.
- Debes definir cuidadosamente el caso base ya que llamarlo indefinidamente puede hacer que tu Código deje de funcionar. Esto se debe a que la recursión sigue acumulando más y más llamadas de función hasta que el sistema se queda sin memoria.
- Las recursiones encuentran su utilidad en resolver problemas matemáticos como el factorial y el Fibonacci, recorrer árboles y grafos, generar permutaciones y combinaciones y mucho más.

## Funciones Puras vs Impuras

- Una función pura es aquella que siempre produce la misma salida para la misma entrada y no tiene efectos secundarios. Su salida depende solo de su entrada y no modifica ningún estado externo.
- Las funciones impuras tienen efectos secundarios, que son cambios en el estado del programa que son observables fuera de la función.

## Programación funcional

- La Programación Funcional es un enfoque para el desarrollo de software que enfatiza el uso de funciones para resolver problemas, enfocándose en qué necesita hacerse en lugar de cómo hacerlo.
- La programación funcional fomenta el uso de técnicas que ayudan a evitar los efectos secundarios, como el uso de estructuras de datos inmutables y funciones de orden superior.
- Cuando se usan correctamente, los principios de programación funcional conducen a un código más limpio y más fácil de mantener.

## Currying

- El Currying es una técnica de programación funcional que transforma una función con múltiples argumentos en una secuencia de funciones, cada una tomando un solo argumento.

Aquí tienes un ejemplo de una función regular vs una función curried:

```js
// Regular function

function average(a, b, c) {
  return (a + b + c) / 3;
}

// Curried function

function curriedAverage(a) {
  return function(b) {
    return function(c) {
      return (a + b + c) / 3;
    };
  };
}

// Usage of curried function

const avg = curriedAverage(2)(3)(4);
```

- El Currying puede ser particularmente poderoso cuando se trabaja con funciones que toman muchos argumentos.
- El Currying hace que tu Código sea más flexible y fácil de reutilizar.
- Puedes usar funciones de flecha para crear funciones curriadas más concisamente:

```js
const curriedAverage = a => b => c => (a + b + c) / 3;
```

- Mientras que el Currying puede conducir a un Código más flexible y reutilizable, también puede hacer que el Código sea más difícil de leer si se usa en exceso.

- **JavaScript Sincrónico** se ejecuta secuencialmente y espera a que la operación anterior termine antes de pasar a la siguiente.
- **JavaScript Asíncrono** permite que múltiples operaciones se ejecuten en segundo plano sin bloquear el hilo principal.
- **Hilo** es una secuencia de instrucciones que puede ser ejecutada independientemente del flujo principal del programa.
- Las **funciones de devolución de llamada** son funciones que se pasan como argumentos a otras funciones y se ejecutan después de la finalización de la operación o como resultado de un evento.

## El motor de JavaScript y tiempo de ejecución de JavaScript

- El **motor de JavaScript** es un programa que ejecuta Código de JavaScript en un navegador web. Funciona como un conversor que toma tu Código, lo convierte en instrucciones que la computadora puede entender y funciona en consecuencia.
- V8 es un ejemplo de un motor de JavaScript desarrollado por Google.
- El **tiempo de ejecución de JavaScript** es el entorno en el que se ejecuta el Código de JavaScript. Incluye el motor de JavaScript que procesa y ejecuta el Código, y características adicionales como un navegador web o Node.js.

## La API Fetch

- La API Fetch permite a las aplicaciones web realizar solicitudes de red, típicamente para recuperar o enviar datos al servidor. Proporciona un método `fetch()` que puedes usar para hacer estas solicitudes.
- Puedes recuperar texto, imágenes, audio, JSON y otros tipos de datos usando la API Fetch.

## Métodos HTTP para la API Fetch

La API Fetch soporta varios métodos HTTP para interactuar con el servidor. Los métodos más comunes son:

- **GET**: Se usa para obtener datos del servidor. Por defecto, la API Fetch utiliza el método `GET` para recuperar datos.

```js
fetch('https://api.example.com/data')
```

Para usar los datos obtenidos, deben ser convertidos al formato JSON usando el método `.json()`:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

En este código, la respuesta que viene de la API Fetch es una promesa y el manejador `.then` está convirtiendo la respuesta a un formato JSON.

- **POST**: Se usa para enviar datos al servidor. El método `POST` se utiliza para crear nuevos recursos en el servidor.

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

En este ejemplo, estamos enviando una solicitud `POST` para crear un nuevo usuario. Hemos especificado el método como `POST`, establecido los encabezados apropiados, e incluido un cuerpo con los datos que queremos enviar. El cuerpo necesita ser una cadena, así que usamos `JSON.stringify()` para convertir nuestro objeto en una cadena JSON.

- **PUT**: Se usa para actualizar datos en el servidor. El método `PUT` se utiliza para actualizar recursos existentes en el servidor.

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

En este ejemplo, estamos actualizando el ID `45` que se especifica al final de la URL. Hemos utilizado el método `PUT` en el Código y también especificado los datos como el cuerpo que se usarán para actualizar los datos identificados.

- **DELETE**: Se usa para eliminar datos en el servidor. El método `DELETE` se usa para eliminar recursos en el servidor.

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

En este ejemplo, estamos enviando una solicitud `DELETE` para eliminar un usuario con el ID `45`.

## Promesas y encadenamiento de promesas

- Las **promesas** son objetos que representan la eventual conclusión o falla de una operación asíncrona y su valor resultante. El valor de la promesa se conoce solo cuando la operación `async` se ha completado.
- Aquí hay un ejemplo para crear una promesa simple:

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- El método `.then()` se usa en una Promesa para especificar qué debe ocurrir cuando la Promesa se cumple, mientras que `.catch()` se usa para manejar cualquier error que ocurra.
- Aquí hay un ejemplo de uso de `.then()` y `.catch()` con una Promesa:

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

En el ejemplo anterior, el método `.then()` se usa para registrar los datos recibidos de la Promesa, mientras que el método `.catch()` se usa para registrar cualquier error que ocurra.

- **Encadenamiento de Promesas**: Una de las características poderosas de las Promesas es que podemos encadenar múltiples operaciones asíncronas juntas. Cada `.then()` puede devolver una nueva Promesa, permitiéndote realizar una secuencia de operaciones asíncronas una tras otra.
- Aquí hay un ejemplo de encadenamiento de Promesas:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

En el ejemplo anterior, primero obtenemos datos de una URL, luego obtenemos datos de otra URL basada en la primera respuesta, y finalmente registramos los segundos datos recibidos.

El método `catch` manejaría cualquier error que ocurra durante el proceso. Esto significa que no necesitas añadir manejo de errores a cada paso individual, lo que puede simplificar mucho tu Código.

## Uso de `async/await` para manejar promesas

Async/await hace que escribir & leer Código asíncrono sea más fácil, el cual está construido sobre Promesas.

- **async**: La palabra clave `async` se usa para definir una función asíncrona. Una función `async` retorna una Promesa, que se resuelve con el valor retornado por la función `async`.
- **await**: La palabra clave `await` se usa dentro de una función `async` para pausar la ejecución de la función hasta que la Promesa se resuelva. Sólo se puede usar dentro de una función `async`.
- Aquí hay un ejemplo de uso de `async/await`:

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

En el ejemplo anterior, la función `delayedGreeting` es una función `async` que pausa durante 2 segundos antes de imprimir el mensaje de saludo. La palabra clave `await` se usa para pausar la ejecución de la función hasta que la `Promise` se resuelva.

- Una de las mayores ventajas de `async/await` es el manejo de errores a través de bloques `try/catch`. Aquí tienes un ejemplo:

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

En el ejemplo anterior, el bloque `try` contiene el Código que podría lanzar un error, y el bloque `catch` maneja el error si se produce. Esto hace que el manejo de errores sea más directo y legible.

## El atributo `async`

- El atributo `async` le dice al navegador que descargue el archivo de script de manera asíncrona mientras continúa analizando el documento HTML.
- Una vez que el script se descarga, el análisis del HTML se detiene, el script se ejecuta y luego el análisis del HTML se reanuda.
- Debes usar `async` para guiones independientes donde el orden de ejecución no importa

## El atributo `defer`

- El atributo `defer` también descarga el script de manera asíncrona, pero difiere la ejecución del script hasta después de que el documento HTML ha sido completamente analizado.
- Los scripts con `defer` mantienen el orden de ejecución tal como aparecen en el documento HTML.

- Es importante observar que ambos atributos `async` y `defer` se ignoran para scripts en línea y solo funcionan para archivos de script externos.

- Cuando se presentan ambos atributos `async` y `defer`, el atributo `async` toma precedencia.

## API de Geolocalización

- La API de Geolocalización proporciona una manera para que los sitios web soliciten la ubicación del usuario.

- El ejemplo a continuación demuestra el método `getCurrentPosition()` de la API que se utiliza para obtener la ubicación actual del usuario.

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

En este código, estamos llamando a `getCurrentPosition` y pasándole una función que se llamará cuando la posición se obtenga con éxito.

El objeto `position` contiene una variedad de información, pero aquí hemos seleccionado solo `latitude` y `longitude`.

Si hay algún problema para obtener la `position`, entonces el error se registrará en la consola. Es importante respetar la privacidad del usuario y solo solicitar su ubicación cuando sea necesario.


# --assignment--

Revise los temas y conceptos de JavaScript.
