---
id: 5cd9a70215d3c4e65518328f
title: 建置倒數計時器
challengeType: 26
dashedName: build-a-countdown
---

# --description--

在這個實驗中，你將建置一個 `countdown` 函式（程式），該函式接受一個起始數字並產生一個倒數列表。

當你呼叫 `countdown(n)` 時，它應該傳回一個從 `n` 開始並以 1 遞減直到達到 1 的陣列。

例如：

- `countdown(5)` 應該傳回 `[5, 4, 3, 2, 1]`
- `countdown(1)` 應該傳回 `[1]`

如果起始數字小於 `1`，則沒有任何東西可倒數，因此傳回空陣列：

- `countdown(0)` 應該傳回 `[]`
- `countdown(-3)` 應該傳回 `[]`

要完成此實驗，你必須使用遞迴來建置結果，且不得使用迴圈（`for`、`while`）或陣列迭代方法（`forEach`、`map`、`filter`、`reduce`）。每次呼叫都應該產生自己的結果陣列（不要使用全域的變數來儲存倒數）。

**目標：** 完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 你應該創建一個名為 `countdown` 的函式（程式）。
2. `countdown` 函式（程式）應該接受一個單一的引數 `n`（一個數字）。
3. 如果 `n` 小於 `1`，`countdown` 應該傳回一個空的陣列。
4. 否則，`countdown` 應該傳回一個包含從 `n` 到 1 以遞減順序排列的整數的陣列。
5. 你必須使用遞迴（該函式應該呼叫自身），且不得使用任何形式的迴圈（`for`、`while`，或像 `forEach`、`map`、`filter`、`reduce` 這類高階方法）。
6. 每次遞迴呼叫應該使用比前一次呼叫更小的值（例如，`n - 1`），以便函式（程式）達到其基底情況。
7. 該解法不應使用全域變數來儲存或快取結果陣列。
8. 多次以不同輸入呼叫 `countdown` 時，應始終傳回正確且獨立的結果。

# --hints--

你應該有一個名為 `countdown` 的函式（程式）。

```js
assert.isFunction(countdown);
```

`countdown(-1)` 應該傳回一個空的陣列。

```js
assert.isEmpty(countdown(-1));
```

`countdown(10)` 應該傳回 `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(10), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
```

`countdown(5)` 應該傳回 `[5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

你的程式碼不應該依賴任何類型的迴圈（`for`、`while` 或較高階的函式（程式）例如 `forEach`、`map`、`filter` 和 `reduce`）。

```js
assert(
  !__helpers.removeJSComments(code).match(/for|while|forEach|map|filter|reduce/g)
);
```

你應該使用遞迴來解決這個問題。

```js
assert(
  countdown.toString().match(/countdown\s*\(.+\)/)
);
```

不應該使用全域變數來快取陣列。

```js
countdown(1)
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
function countdown(n) {
  if (n < 1) {
    return [];
  }

  return [n, ...countdown(n - 1)];
}
```
