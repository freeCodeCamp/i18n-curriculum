---
id: 67d1ebb595f4f619c0e35d1a
title: 如何更新狀態中的物件？
challengeType: 19
dashedName: how-do-you-update-objects-in-state
---

# --description--

如果你習慣直接更改物件屬性值，在 React 中更新狀態中的物件可能會很棘手。

React 將 state 視為不可變的，這表示你不應該直接修改它。

讓我們來看看如果你嘗試直接更改 React 狀態中的物件會發生什麼，然後深入探討正確的做法。

假設你在你的組件狀態中有一個物件，表述使用者的評測，並且你想讓使用者更新他們的年齡： 

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({
    name: "John Doe",
    age: 31,
    city: "LA",
  });

  // Change user age directly
  const handleAgeChange = (e) => {
    user.age = e.target.value;
    console.log(user);
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" value={user.age} onChange={handleAgeChange} />
    </div>
  );
}

export default Profile;
```

這段程式碼無法運作，因為你直接修改了 `user.age` 屬性。

即使 `console.log(user)` 會在主控台顯示新的 age，React 也不會重新算繪組件來在使用者介面中顯示它，因為你沒有使用設值函式 `setUser`。

要直接在狀態中更新物件，你需要使用設值函式來創建一個具有更新值的新物件。例如：

```js
const handleAgeChange = (e) => {
  setUser({
    age: e.target.value,
  });
};
```

這樣可以。但如果你現在查看頁面，使用者的年齡會被更新，但名稱和城市的值會遺失。

這是因為你傳遞給設值函式的新物件只包含 `age` 的鍵/值配對。

為了防止這種情況發生，你可以先複製現有的物件，然後只更新你想要更新的屬性，在這個例子中是 `age`。

為此，你可以將一個稱為更新函式的特殊函式傳遞給你的設值函式 `setUser`。更新函式會將待處理狀態作為引數，在此稱為 `prevUser`，並且應該傳回下一個狀態：

```js
const handleAgeChange = (e) => {
  setUser((prevUser) => {
    const updatedUser = { ...prevUser, age: e.target.value };
    console.log('Previous State:', prevUser);
    console.log('Updated State:', updatedUser);
    return updatedUser;
  });
};
```

如你所見，我們使用展開語法複製待處理的使用者物件 `...prevUser`，並創建一個名為 `updatedUser` 的新使用者物件。接著，我們根據表單輸入更新年齡，並在函式底部傳回 `updatedUser` 作為下一個狀態。

現在你的專案運作如預期，且對年齡輸入的更新不會影響使用者的姓名或城市名稱。你也可以在主控台中看到先前和更新後的狀態。

這是在狀態中更新物件的理想方式，特別是當你沒有更新所有屬性時。

要更新剩餘的 `name` 和 `city` 屬性，你可以將它們寫成獨立的設定函式，並將它們連接到各自的輸入。

```js
const handleNameChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    name: e.target.value,
  }));
};

const handleCityChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    city: e.target.value,
  }));
};
```

或者你可以將它們合併成一個單一的設值函式，如下所示：

```js
const handleChange = (e) => {
  const { name, value } = e.target;
  setUser((prevUser) => ({
    ...prevUser,
    [name]: value,
  }));
};
```

為了讓這個功能運作，每個輸入欄位必須有一個 `name` 屬性。

這是完整的程式碼：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

# --questions--

## --text--

React 如何處理組件中的 state？

## --answers--

作為可變的，允許直接修改。

### --feedback--

思考 React 確保可預測狀態變更的方法。

---

作為不可變的，表示它不應該被直接修改。

---

作為所有組件中可存取的全域變數。

### --feedback--

思考 React 確保可預測狀態變更的方法。

---

作為在每次 `render` 時重設的暫時變數。

### --feedback--

思考 React 確保可預測狀態變更的方法。

## --video-solution--

2

## --text--

你應該如何更新儲存在 React 狀態中的物件？

## --answers--

使用設值函式來創建新的物件。

---

直接在 state 中修改物件。

### --feedback--

React 將狀態視為不可變的，因此避免直接修改。

---

使用 `Object.assign()`，但不呼叫設值函式。

### --feedback--

React 將狀態視為不可變的，因此避免直接修改。

---

使用 `push()` 方法為你的物件添加屬性。

### --feedback--

React 將狀態視為不可變的，因此避免直接修改。

## --video-solution--

1

## --text--

這段 `code` 中的設值函式是什麼？

```js
const [user, setUser] = useState({
   name: 'John Doe',
   age: 31,
   city: 'LA',
 });
```

## --answers--

`user`

### --feedback--

設值函式會更新 `state` 變數。

---

`useState`

### --feedback--

設值函式會更新 `state` 變數。

---

`age`

### --feedback--

設值函式會更新 `state` 變數。

---

`setUser`

## --video-solution--

4
