---
id: 68c1a929005bf54d342aa8d5
title: "挑战 58：太空周 第 4 天：着陆点"
challengeType: 28
dashedName: challenge-58
---

# --description--

在太空周的第四天，你将获得一个数字矩阵（数组的数组），表现你的漫游车潜在的着陆点。根据以下规则查找最安全的着陆点：

- 矩阵中的每个位置都将包含一个从 `0-9`（含）之间的数字。
- 任何 `0` 表示一个潜在的着陆点。
- 除 `0` 以外的任何数字都太危险，无法着陆。数字越大，危险越大。
- 最安全的位置被定义为 `0` 单元格，其周围的单元格（最多 4 个邻居，忽略对角线）具有最低的总危险值。
- 忽略超出边界的邻居（角落和边缘的邻居数量较少）。
- 返回最安全着陆点的索引。始终只有一个最安全的点。

例如，给定：

```js
[
  [1, 0],
  [2, 0]
]
```

返回 `[0, 1]`，第一个数组中 `0` 的索引。

# --hints--

`findLandingSpot([[1, 0], [2, 0]])` 应该返回 `[0, 1]`。

```js
assert.deepEqual(findLandingSpot([[1, 0], [2, 0]]), [0, 1]);
```

`findLandingSpot([[9, 0, 3], [7, 0, 4], [8, 0, 5]])` 应该返回 `[1, 1]`。

```js
assert.deepEqual(findLandingSpot([[9, 0, 3], [7, 0, 4], [8, 0, 5]]), [1, 1]);
```

`findLandingSpot([[1, 2, 1], [0, 0, 2], [3, 0, 0]])` 应该返回 `[2, 2]`。

```js
assert.deepEqual(findLandingSpot([[1, 2, 1], [0, 0, 2], [3, 0, 0]]), [2, 2]);
```

`findLandingSpot([[9, 6, 0, 8], [7, 1, 1, 0], [3, 0, 3, 9], [8, 6, 0, 9]])` 应该返回 `[2, 1]`。

```js
assert.deepEqual(findLandingSpot([[9, 6, 0, 8], [7, 1, 1, 0], [3, 0, 3, 9], [8, 6, 0, 9]]), [2, 1]);
```

# --seed--

## --seed-contents--

```js
function findLandingSpot(matrix) {

  return matrix;
}
```

# --solutions--

```js
function findLandingSpot(matrix) {
  let bestSpot = null;
  let lowestNeighborSum = Infinity;

  for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {

      if (matrix[i][j] === 0) {
        let currentNeighborSum = 0;

        if (i > 0) currentNeighborSum += matrix[i - 1][j];
        if (j < matrix[i].length - 1) currentNeighborSum += matrix[i][j + 1];
        if (i < matrix.length - 1) currentNeighborSum += matrix[i + 1][j];
        if (j > 0) currentNeighborSum += matrix[i][j - 1];

        if (currentNeighborSum < lowestNeighborSum) {
          lowestNeighborSum = currentNeighborSum;
          bestSpot = [i, j];
        }
      }
    }
  }

  return bestSpot;
}
```
