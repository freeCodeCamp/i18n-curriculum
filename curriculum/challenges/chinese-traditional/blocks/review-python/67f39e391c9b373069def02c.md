---
id: 67f39e391c9b373069def02c
title: Python 複習
challengeType: 31
dashedName: review-python
---

# --description--

## 什麼是 Python？

- **介紹**：Python 是一種通用程式設計語言，以其簡單和易用性著稱。Python 被用於許多領域，如資料科學和機器學習、網頁開發、腳本和自動化、嵌入式系統和物聯網，以及更多其他領域。
- **常見使用案例**：Python 用於資料科學、機器學習、網頁開發、網路安全、自動化以及像 Raspberry Pi 和相容 MicroPython 板的微型計算機。

## 在你的區域的環境中使用 Python

- **安裝**：在 Windows、Mac 和 Linux 上安裝 Python 的最佳方式是從官方 Python 網站（`https://www.python.org/`）下載安裝程式。

## 變數

- **宣告變數**：要宣告變數，你從變數名稱開始，接著是指定運算子（`=`），然後是值。這可以是數字、字串、布林值等。以下是一些範例：

```py
name = 'John Doe'
age = 25
```

- **變數命名慣例**：以下是你應該用於變數的命名慣例：

  - 變數名稱只能以字母或底線（_）開頭，不能以數字開頭。
  - 變數名稱只能包含英數字元（a-z、A-Z、0-9）和底線（_）。
  - 變數名稱區分大小寫 — `age`、`Age` 和 `AGE` 都被視為獨立的名稱。
  - 變數名稱不能是 Python 的保留關鍵字之一，例如 `if`、`class` 或 `def`。
  - 多字的變數名稱以底線分隔。例如 `snake_case`。


## 註解

- **單行註解**：這種類型的註解應用於你想在程式碼中留下的簡短備註。

```py
# This is a single line comment
```

- **多行字串**：這種類型的字串可以用來留下較長的註解或註解掉程式碼區段。

```py
"""
This is a multi-line string.
Here is some code commented out.

name = 'John Doe'
age = 25
"""
```

- **`print()` 函式（程式）**：要將資料列印到主控台，你可以像這樣使用 `print()` 函式（程式）：

```py
print('Hello world!') # Hello world!
```

## Python 中的常見資料型別

- **介紹**：Python 是一種動態型別語言，像 JavaScript 一樣，這表示你不需要明確地宣告變數的型別。語言會根據你指定給變數的值來判斷變數的型別。
- **整數**：沒有小數的整數：

```py
my_integer_var = 10
print('Integer:', my_integer_var) # Integer: 10
```

- **Float**：帶有小數的數字：

```py
my_float_var = 4.50
print('Float:', my_float_var) # Float: 4.5
```

- **字串**：一串以引號包覆的字元：

```py
my_string_var = 'hello'
print('String:', my_string_var) # String: hello
```

- **布林值**：一個表述 `True` 或 `False` 的值：

```py
my_boolean_var = True
print('Boolean:', my_boolean_var) # Boolean: True
```

- **Set**：一個無序且唯一元素的群集：

```py
my_set_var = {7, 5, 8}
print('Set:', my_set_var) # Set: {7, 5, 8}
```

- **字典**：一個由鍵值對組成的群集，包在大括號中：

```py
my_dictionary_var = {"name": "Alice", "age": 25}
print('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}
```

- **Tuple**：一個不可變的有序群集，包在小括弧內：

```py
my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)
```

- **範圍**：一連串的數字，常用於迴圈：

```py
my_range_var = range(5)
print(my_range_var) # range(0, 5)
```

- **列表**：一個有序的群集，支援不同的資料型別：

```py
my_list = [22, 'Hello world', 3.14, True]
print(my_list) # [22, 'Hello world', 3.14, True]
```

- **None**：一個特殊的值，用來表述沒有值的狀態：

```py
my_none_var = None
print('None:', my_none_var) # None: None
```

## 不可變的和可變的型別

- **不可變的型別**：這些型別在宣告後無法改變，儘管你可以將它們的變數指向新的東西，這稱為重新指派。它們包括整數、浮點數、複數、布林值、字串、tuple、範圍、以及 `None`。
- **可變的型別**：這些型別在宣告後可以改變。你可以添加、移除或更新它們的條款。它們包括像列表、集合和字典這類的群集型別。
- **`type()` 函式（程式）**：要查看變數的型別，你可以像這樣使用 `type()` 函式（程式）：

```py
greeting = 'Hello there!'
age = 21

print(type(greeting)) # <class 'str'>
print(type(age)) # <class 'int'>
```

- **`isinstance()` 函式（程式）**：這用於檢查變數是否符合特定資料型別：

```py
print(isinstance('Hello world', str)) # True
print(isinstance('John Doe', int)) # False
```

## 處理字串

- **定義**：如你從 JavaScript 中回想，字串是不可變的，這表示你在創建後無法更改它們。在 Python 中，你可以使用單引號或雙引號。建議選擇一個規則並堅持使用：

```py
developer = 'Jessica'
city = 'Los Angeles'
```

- **從字串存取字元**：你可以使用括號表示法從字串中存取字元，如下所示：

```py
my_str = "Hello world"

print(my_str[0])  # H
print(my_str[6])  # w

print(my_str[-1])  # d
print(my_str[-2]) # l
```

- **字串跳脫**：如果你的字串包含像這樣的引號，你可以使用反斜線（`\`）：

```py
msg = 'It\'s a sunny day'
quote = "She said, \"Hello!\""
```

- **字串串接**：要串接字串，你可以像這樣使用 `+` 運算子：

```py
developer = 'Jessica'
print('My name is ' + developer + '.') # My name is Jessica.
```

另一種串接字串的方法是使用 `+=` 運算子。這用於在同一步驟中執行串接和指派，如下所示：

```py
greeting = 'My name is '
developer = 'Jessica.'

greeting += developer
print(greeting) # My name is Jessica.
```

- **`f-strings`**：這是格式化字串字面值的縮寫。它允許你控制代碼插值，並且以簡潔且易讀的語法進行一些串接：

```py
developer = 'Jessica'
greeting = f'My name is {developer}.'
print(greeting) # My name is Jessica.
```

- **字串切片**：這是當你可以擷取字串的部分內容。以下是基本語法：

```py
str[start:stop:step]
```

起始位置表述擷取應該開始的索引。停止位置是切片應該結束的地方。此位置不包含在內。步進位置表述切片遞增的間隔。以下是一些範例：

```py
message = 'Python is fun!'

print(message[0:6])  # Python
print(message[7:])  # is fun!
print(message[::2])  # Pto sfn
```

- **取得字串長度**：`len()` 函式用來傳回字串中的字元數：

```py
developer = 'Jessica'

print(len(developer)) # 7
```

## 使用 `in` 運算子

- **`in` 運算子**：這會傳回一個布林值，用以指定該字元或字元群是否存在於字串中：

```py
my_str = 'Hello world'

print('Hello' in my_str)  # True
print('hey' in my_str)    # False
print('hi' in my_str)    # False
print('e' in my_str)  # True
print('f' in my_str)  # False
```

## 常用字串方法

- **`str.upper()`**：這會傳回一個新的字串，所有字元都轉換為大寫：

```py
developer = 'Jessica'

print(developer.upper()) # JESSICA
```

- **`str.lower()`**：這會傳回一個所有字元都轉成小寫的新字串：

```py
developer = 'Jessica'

print(developer.lower()) # jessica
```

- **`str.strip()`**：這會傳回一個字串的複本，並移除指定的前置和後置字元（如果沒有傳入引數給此方法，則會移除前置和後置的空白字元）。

```py
greeting = '  hello world  '

trimmed_my_str = greeting.strip()
print(trimmed_my_str)  # 'hello world'
```

- **`replace()`**：這會傳回一個新的字串，所有舊字串的出現都被新的字串取代。

```py
greeting = 'hello world'

replaced_my_str = greeting.replace('hello', 'hi')
print(replaced_my_str)  # 'hi world'
```

- **`split()`**：這用於使用指定的分隔符將字串拆分成列表。分隔符是一個字串，用來指定拆分的位置。

```py
dashed_name = 'example-dashed-name'

split_words = dashed_name.split('-')
print(split_words)  # ['example', 'dashed', 'name']
```

- **`join()`**：用於將可迭代物件的元素以分隔符連接成字串。可迭代物件是可以像列表、字串或元組一樣被迴圈遍歷的元素群集。

```py
example_list = ['example', 'dashed', 'name']

joined_str = ' '.join(example_list)
print(joined_str)  # example dashed name
```

- **`str.startswith(prefix)`**：這會傳回一個布林值，表示字串是否以指定的前置式開始：

```py
developer = 'Naomi'

result = developer.startswith('N')
print(result)  # True
```

- **`str.endswith(suffix)`**：這會傳回一個布林值，表示字串是否以指定的後綴結尾：

```py
developer = 'Naomi'

result = developer.endswith('N')
print(result)  # False
```

- **`str.find()`**：這會傳回子字串第一次出現的位置索引。如果找不到，則傳回 `-1`：

```py
developer = 'Naomi'

result = developer.find('N')
print(result)  # 0

city = 'Los Angeles'
print(city.find('New')) # -1
```

- **`str.count(substring)`**：這會計算子字串在字串中出現了多少次：

```py
city = 'Los Angeles'
print(city.count('e')) # 2
```

- **`str.capitalize()`**：這會傳回一個新的字串，該字串的第一個字元為大寫，其他字元為小寫：

```py
dessert = 'chocolate cake'
print(dessert.capitalize()) # Chocolate cake
```

- **`str.isupper()`**：如果字串中所有字母皆為大寫，則傳回 `True`，否則傳回 `False`：

```py
dessert = 'chocolate cake'
print(dessert.isupper()) # False
```

- **`str.islower()`**：如果字串中所有字母都是小寫，這會傳回 `True`，否則傳回 `False`：

```py
dessert = 'chocolate cake'
print(dessert.islower()) # True
```

- **`str.title()`**：這會傳回一個新的字串，其中每個字的第一個字母皆為大寫：

```py
city = 'los angeles'
print(city.title()) # Los Angeles
```

- **`str.maketrans()`**：此方法用於創建一個 1 對 1 字元對應的轉換表。它通常與 `translate()` 方法一起使用，該方法將該轉換表套用到字串並傳回翻譯結果。

```py
trans_table = str.maketrans('abc', '123')
print(trans_table) # {97: 49, 98: 50, 99: 51}

result = 'abcabc'.translate(trans_table)
print(result)  # 123123
```

## 整數和浮點數常用的操作

- **基本數學操作**：在 Python 中，你可以對整數和浮點數進行基本數學操作，包括加法、減法、乘法和除法：

```py
int_1 = 56
int_2 = 12
float_1 = 5.4
float_2 = 12.0

# Addition

print('Integer Addition:', int_1 + int_2) # Integer Addition: 68
print('Float Addition:', float_1 + float_2) # Float Addition: 17.4

# Subtraction

print('Int Subtraction:', int_1 - int_2) # Int Subtraction: 44
print('Float Subtraction:',  float_2 - float_1) # Float Subtraction: 6.6

# Multiplication

print('Int Multiplication:', int_1 * int_2) # Int Multiplication: 672
print('Float Multiplication:', float_2 * float_1) # Float Multiplication: 64.80000000000001

# Division

print('Int Division:', int_1 / int_2) # Int Division: 4.666666666666667
print('Float Division:', float_2 / float_1) # Float Division: 2.222222222222222
```

當你將浮點數和整數相加時，結果將會被轉換為浮點數，如下所示：

```py
int_1 = 56
float_1 = 5.4

print(int_1 + float_1) # 61.4
```

- **取模運算子 (`%`)**：這會傳回一個數字除以另一個數字後的餘數：

```py
int_1 = 56
int_2 = 12

print(int_1 % int_2) # 8
```

- **向下取整除法 (`//`)**：此運算子用於除以兩個數字並將結果向下取整到最接近的整數：

```py
int_1 = 56
int_2 = 12

print(int_1 // int_2) # 4
```

- **冪次運算子 (`**`)**：此運算子用於將一個數字引發為另一個數字的次方：

```py
int_1 = 4
int_2 = 2

print(int_1 ** int_2) # 16
```

- **`float()` 函式（程式）**：你可以使用此函式將整數轉換為浮點數。

```py
num = 4

print(float(num)) # 4.0
```

- **`int()` 函式（程式）**：你可以使用此函式（程式）將浮點數轉換為整數。

```py
num = 4.0

print(int(num)) # 4
```

- **`round()` 函式（程式）**：這用於將數字四捨五入到最接近的整數：

```py
num_1 = 3.4
num_2 = 7.7

print(round(num_1)) # 3
print(round(num_2)) # 8
```

- **`abs()` 函式（程式）**：這用於傳回數字的絕對值：

```py
num = -13

print(abs(num)) # 13
```

- **`bin()` 函式（程式）**：這用於將整數轉換為其二進位表述的字串：

```py
num = 56

print(bin(num))  # 0b111000
```

- **`oct()` 函式（程式）**：此函式用於將整數轉換為其八進位字串表述：

```py
num = 56

print(oct(num))  # 0o70
```

- **`hex()` 函式（程式）**：這用於將整數轉換為其十六進位字串表述。

```py
num = 56

print(hex(num))  # 0x38
```

- **`pow()` 函式（程式）**：這用於將一個數字引發到另一個數字的次方：

```py
result = pow(2, 3) 
print(result)  # 8
```

## 增強指派

- **定義**：增強指派將二進位操作與指派結合成一步驟。它會取一個變數，對它與另一個值執行操作，並將結果存回同一個變數。

```py
# Addition assignment 
my_var = 10
my_var += 5

print(my_var) # 15

# Subtraction assignment
count = 14
count -= 3

print(count) # 11

# Multiplication assignment 
product = 65
product *= 7

print(product) # 455

# Division assignment 
price = 100
price /= 4

print(price) # 25.0

# Floor Division assignment 
total_pages = 23
total_pages //= 5

print(total_pages) # 4

# Modulus assignment 
bits = 35
bits %= 2

print(bits) # 1

# Exponentiation assignment 
power = 2
power **= 3

print(power) # 8
```

還有其他增強型指定運算子，例如以 bit 為單元逐一... 運算子的指定運算子。它們包括 `&=`、`^=`、`>>=` 和 `<<=`。

## 使用函式（程式）

- **定義**：函式是可重複使用的程式碼片段，會接受輸入（引數）並傳回輸出。要呼叫函式，你需要取用函式名稱，後面接一組括號：

```py
# Defining a function

def get_sum(num_1, num_2):
    return num_1 + num_2

result = get_sum(3, 4) # function call
print(result) # 7
```

如果函式（程式）沒有明確地傳回值，則預設的返回值是 `None`：

```py
def greet():
    print('hello') 

result = greet() # hello
print(result) # None
```

你也可以這樣為參數提供預設值：

```py
def get_sum(num_1, num_2=2):
    return num_1 + num_2

result = get_sum(3) 
print(result) # 5
```

如果你呼叫函式時引數數量不正確，將會得到 `TypeError`：

```py
def calculate_sum(a, b):
    print(a + b)

calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'
```

## 常用內建函式（程式）

- **`input()` 函式（程式）**：這用來提示使用者輸入一些資料：

```py
name = input('What is your name?') # User types 'Kolade' and presses Enter  
print('Hello', name) # Hello Kolade
```

- **`int()` 函式（程式）**：此函式用於將數字、布林值或數字字串轉換成整數：

```py
print(int(3.14)) # 3
print(int('42')) # 42
print(int(True)) # 1
print(int(False)) # 0 
```

## Python 中的範圍、作用域

- **區域的範圍**：當變數在函式（程式）或類別內宣告時，只能在該函式（程式）或類別內存取。

```py
def my_func():
    num = 10
    print(num)
```

- **包覆作用域**：當一個函式（程式）巢狀在另一個函式（程式）內時，它可以存取它所巢狀的函式（程式）的變數。

```py
def outer_func():
    msg = 'Hello there!'
    
    def inner_func():
        print(msg)
    inner_func()

print(outer_func()) # Hello there!
```

- **全域的作用域**：這是指宣告在任何函式或類別之外的變數，可以在程式中的任何地方存取。

```py
tax = 0.70 

def get_total(subtotal):
    total = subtotal + (subtotal * tax)
    return total

print(get_total(100))  # 170.0
```

- **內建範圍**：Python 中為預定義函式（程式）、模組、關鍵字和物件保留的名稱。

```py
print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False
```

## 比較運算子

- **相等 (`==`)**：檢查兩個值是否相等：

```py
print(3 == 4) # False
```

- **不相等 (`!=`)**：檢查兩個值是否不相等：

```py
print(3 != 4) # True
```

- **嚴格大於 (`>`)**：檢查一個值是否大於另一個值：

```py
print(3 > 4) # False
```

- **嚴格小於 (`<`)**：檢查一個值是否小於另一個值：

```py
print(3 < 4) # True
```

- **大於或相等(`>=`)**：檢查一個值是否大於或相等於另一個值：

```py
print(3 >= 4) # False
```

- **小於或相等(`<=`)**：檢查一個值是否小於或相等於另一個值：

```py
print(3 <= 4) # True
```

## 使用 `if`、`elif` 和 `else` 述語

- **`if` 述語**：這些是用來判斷某件事是否為真的條件。如果條件計算結果為 `True`，則該區塊的程式碼將會執行。

```py
age = 18

if age >= 18:
    print('You are an adult') # You are an adult
```

- **`elif` 述語**：這些是接在 `if` 述語之後的條件。如果 `elif` 條件計算結果為 `True`，則該區塊的程式碼將會執行。

```py
age = 16

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')  # You are a teenager
```

- **`else` 語句**：如果沒有其他條件計算為 `True`，這將會執行。

```py
age = 12

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')
else:
    print('You are a child')  # You are a child
```

你也可以像這樣使用巢狀的 `if` 述語：

```py
is_citizen = True
age = 25

if is_citizen:
    if age >= 18:
        print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

## 真值與假值

- **定義**：在 Python 中，每個值都有固有的布林值，或在邏輯背景關係中應被視為 `True` 或 `False` 的內建判斷。許多值被視為 truthy，也就是它們在邏輯背景關係中會被計算為 `True`。其他則是 falsy，意指它們會被計算為 `False`。以下是一些 falsy 值的範例：

```md
None
False
Integer 0
Float 0.0
Empty strings ''
```

其他值像是非零數字和非空字串都是真值。

## 使用 `bool()` 函式（程式）

- **定義**：如果你想檢查一個值是否為真值或假值，你可以使用內建的 `bool()` 函式。它會明確地將一個值轉換為其布林值等價，並對真值傳回 `True`，對假值傳回 `False`。以下是一些範例：

```py
print(bool(False)) # False
print(bool(0))  # False
print(bool('')) # False

print(bool(True)) # True
print(bool(1)) # True
print(bool('Hello')) # True
```

## 布林值運算子與短路評估

- **定義**：這些是特殊的運算子，允許你組合多個表達式，以在你的程式碼中創建更複雜的決策邏輯。Python 中有三個布林值運算子：`and`、`or` 和 `not`。
- **`and` 運算子**：此運算子接受兩個運算元，若第一個運算元為假值，則傳回第一個運算元，否則傳回第二個運算元。兩個運算元皆須為真值，表達式才會傳回真值。

```py
is_citizen = True
age = 25

print(is_citizen and age) # 25
```

你也可以在條件判斷中使用 `and` 運算子，如下所示：

```py
is_citizen = True
age = 25

if is_citizen and age >= 18:
    print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

- **`or` 運算子**：此運算子會傳回第一個運算元（如果它為真值），否則傳回第二個運算元。只要至少有一個運算元為真值，`or` 表達式就會傳回真值。以下是一個範例：

```py
age = 19
is_employed = False

print(age or is_employed) # 19
```

就像使用 `and` 運算子一樣，你也可以在條件判斷中這樣使用 `or` 運算子：

```py
age = 19
is_student = True

if age < 18 or is_student:
    print('You are eligible for a student discount') # You are eligible for a student discount
else:
    print('You are not eligible for a student discount')
```

- **短路**：`and` 和 `or` 運算子被稱為短路運算子。短路意指 Python 從左到右檢查值，並在確定最終結果後立即停止。
- **`not` 運算子**：此運算子接受單一運算元並反轉其布林值。它將真值轉換為 `False`，將假值轉換為 `True`。與我們之前看到的運算子不同，`not` 總是傳回 `True` 或 `False`。以下是一些範例：

```py
print(not '') # True, because empty string is falsy
print(not 'Hello') # False, because non-empty string is truthy
print(not 0) # True, because 0 is falsy
print(not 1) # False, because 1 is truthy
print(not False) # True, because False is falsy
print(not True) # False, because True is truthy
```

以下是條件中 `not` 運算子的範例： 

```py
is_admin = False

if not is_admin:
    print('Access denied for non-administrators.') # Access denied for non-administrators.
else:
    print('Welcome, Administrator!')
```


## Python 列表

- **介紹**：在 Python 中，`list` 資料型別是一個有序的元素序列，元素可以是字串、數字甚至其他 `list`。`list` 是可變的，且以零為起始索引。

```python
cities = ['Los Angeles', 'London', 'Tokyo']
```

- **存取列表中的元素**：要從 `cities` 列表中存取元素，你可以取用其在序列中的索引編號：

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[0] # Los Angeles
```

- **使用負索引存取元素**：要存取任何列表的最後一個元素，你可以使用 `-1` 作為索引數字：

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[-1] # Tokyo
```

- 負索引用於從列表的末端開始存取元素，而不是從索引 `0` 的開頭開始。

- **使用 `list()` 建構式創建列表**：列表也可以使用 `list()` 建構式創建。`list()` 建構式用於將可迭代物件轉換成列表：

```python
developer = 'Jessica'

print(list(developer)) 
# Result: ['J', 'e', 's', 's', 'i', 'c', 'a']
```

- **取得列表長度**：你可以使用 `len()` 函式來取得列表的長度：

```python
numbers = [1, 2, 3, 4, 5]
len(numbers) # 5
```

- **列表的可變性**：列表是可變的，這表示只要你傳入有效的索引數字，就可以更新列表中的任何元素。要在特定索引處更新列表，你可以為該索引指定一個新值：

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[0] = 'JavaScript'
print(programming_languages) # ['JavaScript', 'Java', 'C++', 'Rust']
```

- **索引超出範圍錯誤**：如果你傳入的索引（正數或負數）超出列表的範圍，則會收到 `IndexError`：

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[10] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
"""
```

- **從列表中移除元素**：可以使用 `del` 關鍵字從列表中移除元素：

```python
developer = ['Jane Doe', 23, 'Python Developer']
del developer[1]
print(developer) # ['Jane Doe', 'Python Developer']
```

- **檢查元素是否存在於列表中**：可以使用 `in` 關鍵字來檢查元素是否存在於列表中：

```py
programming_languages = ['Python', 'Java', 'C++', 'Rust']

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **巢狀列表**：列表可以巢狀在其他列表中：

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
```

- 要存取巢狀列表，你需要使用索引 `2` 來存取它，因為列表是從零開始編號的。

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2] # ['Python', 'Rust', 'C++']
```

- 若要進一步存取該巢狀列表中的第二種語言，你需要使用索引 `1` 來存取它：

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2][1] # Rust
```

- **從列表中解包值：** 從列表中解包值是一種用來將列表中的值指定到新變數的技巧。以下是一個範例，將 `developer` 列表解包到名為 `name`、`age` 和 `job` 的新變數中，如下所示：

```py
developer = ['Alice', 34, 'Rust Developer']
name, age, job = developer
```

- **從列表中收集剩餘的項目**：要從列表中收集任何剩餘的元素，你可以像這樣使用星號（`*`）運算子：

```py
developer = ['Alice', 34, 'Rust Developer']
name, *rest = developer
```

- 如果指定運算子左側的變數數量與列表中項目的總數不符，則你會收到 `ValueError`。

- **切片列表**：切片是使用切片運算子 `:` 來存取列表部分的概念。若要切片一個從索引 `1` 開始到索引 `3` 結束的列表，你可以使用以下語法：

```python
desserts = ['Cake', 'Cookies', 'Ice Cream', 'Pie']
desserts[1:3] # ['Cookies', 'Ice Cream']
```

- **步進間隔**：也可以指定步進間隔，用來決定索引之間的遞增量。如果你想使用切片擷取一個僅包含偶數的列表，以下是一個範例：

```python
numbers = [1, 2, 3, 4, 5, 6]
numbers[1::2] # [2, 4, 6]
```

## 列表方法

- **append()**：用於將一個項目添加到列表的末尾。以下是使用 `append()` 方法將數字 `6` 添加到此 `numbers` 列表的範例：

```py
numbers = [1, 2, 3, 4, 5]
numbers.append(6)
print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **附加列表**：`append()` 方法也可以用來將一個列表添加到另一個列表的末尾：

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.append(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, [6, 8, 10]]
```

- **extend()**：用於將多個項目添加到列表的末尾。以下是將數字 `6`、`8` 和 `10` 添加到 `numbers` 列表末尾的範例：

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.extend(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, 6, 8, 10]
```

- **insert()**：用於在列表中的特定索引插入一個項目。以下是使用 `insert()` 方法的範例：

```py
numbers = [1, 2, 3, 4, 5]
numbers.insert(2, 2.5)

print(numbers) # [1, 2, 2.5, 3, 4, 5]
```

- **remove():** 用於從列表中移除一個項目。`remove()` 方法只會移除列表中第一個出現的項目：

```py
numbers = [1, 2, 3, 4, 5, 5, 5]
numbers.remove(5)

print(numbers) # [1, 2, 3, 4, 5, 5]

```

- **pop()**：用於從列表中移除特定項目並傳回該項目：

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop(1) # The number 2 is returned
```

- 如果你沒有為 `pop` 方法指定元素，則會移除最後一個元素。

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop() # The number 5 is returned
```

- **clear()**：用於從列表中移除所有項目：

```py
numbers = [1, 2, 3, 4, 5]
numbers.clear()

print(numbers) # []
```

- **sort()**：`sort()` 方法用於就地排序元素。以下是一個就地排序隨機 `numbers` 列表的範例：

```py
numbers = [19, 2, 35, 1, 67, 41]
numbers.sort()

print(numbers) # [1, 2, 19, 35, 41, 67]
```

- **sorted()**：用於排序列表中的元素並傳回一個新的已排序列表，而不是修改原始列表。

- **reverse()**：用於反轉列表中元素的順序：

```py
numbers = [6, 5, 4, 3, 2, 1]
numbers.reverse()

print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **index()**：用於尋找元素在列表中首次出現的位置：

```python
programming_languages = ['Rust', 'Java', 'Python', 'C++']
programming_languages.index('Java') # 1
```

- 如果無法使用 `index()` 方法找到該元素，則結果將會是 `ValueError`。

## Python 中的元組

- **定義**：元組是 Python 的一種資料型別，用於創建有序的值序列。元組可以包含混合的資料型別：

```py
developer = ('Alice', 34, 'Rust Developer')
```

- Tuple 是不可變的，這表示 tuple 中的元素在創建後無法更改。如果你嘗試更新 tuple 中的某一個項目，將會得到 `TypeError`：

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')
programming_languages[0] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object does not support item assignment
"""
```

- **從 Tuple 存取元素**：要從 tuple 存取元素，請使用括號表示法和索引號碼：

```py
developer = ('Alice', 34, 'Rust Developer')
developer[1] # 34
```

- 可以使用負索引從 `tuple` 的末端存取元素：

```py
numbers = (1, 2, 3, 4, 5)
numbers[-2] # 4
```

- 如果你嘗試傳入一個大於或相等於 tuple 長度的索引數字，則你會收到 `IndexError`：

```py
numbers = (1, 2, 3, 4, 5)
numbers[7]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: tuple index out of range
"""
```

- 也可以使用 `tuple()` 建構式來創建一個 tuple。在建構式中，你可以傳入不同的可迭代物件，例如字串、列表，甚至其他 tuple。

```python
developer = 'Jessica'

print(tuple(developer)) 
# Result: ('J', 'e', 's', 's', 'i', 'c', 'a')
```

- **驗證 Tuple 中的項目**：要檢查某個項目是否在 tuple 中，你可以像這樣使用 `in` 關鍵字：

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **解包元組**：可以像這樣從元組中解包條款：

```py
developer = ('Alice', 34, 'Rust Developer')
name, age, job = developer
```

- 如果你需要收集元組中任何剩餘的元素，你可以像這樣使用星號（`*`）運算子：

```py
developer = ('Alice', 34, 'Rust Developer')
name, *rest = developer
```

- **切片元組**：切片可用來擷取元組的一部分。例如，項目 `pie` 和 `cookies` 可以被切片成一個獨立的元組：

```py
desserts = ('cake', 'pie', 'cookies', 'ice cream')
desserts[1:3] # ('pie', 'cookies')
```

- **從元組中移除項目**：從元組中移除一個項目會引發 `TypeError`，因為元組是不可變的：

```py
developer = ('Jane Doe', 23, 'Python Developer')
del developer[1]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object doesn't support item deletion
"""
```

- **何時使用 Tuple 與 List？**：如果你需要一個可動態新增、移除及更新元素的群集，則你應該使用列表。如果你知道你正在處理一個固定且不可變的資料群集，則你應該使用 tuple。

## 常用的 Tuple 方法

- **`count()`**：用來判斷一個項目在 tuple 中出現了多少次。 例如，你可以檢查語言 `'Rust'` 在 tuple 中出現了多少次：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('Rust') # 2
```

- 如果 `count()` 函式中的指定項目在元組中完全不存在，則返回值將是 `0`：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('JavaScript') # 0
```

- 如果沒有引數傳遞給 `count()` 函式，Python 就會傳回 `TypeError`。

- **index()**：用於尋找特定項目在 tuple 中出現的索引。以下是使用 `index()` 方法尋找語言 `'Java'` 索引的範例：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.index('Java') # 1
```

- 如果找不到指定的項目，Python 將會傳回 `ValueError`。

- 你可以將選用的起始索引傳遞給 `index()` 方法，以指定從元組中的哪裡開始搜尋該項目：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
programming_languages.index('Python', 3) # 5
```

- 你也可以將選用的結束索引傳入 `index()` 方法，以指定在 tuple 中停止搜尋該項目的位置：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python', 'JavaScript', 'Python')
programming_languages.index('Python', 2, 5) # 2
```

- **`sorted()`**：用於排序任何可迭代物件中的元素並傳回一個新的排序後列表。以下是使用 `sorted()` 函式建立一個新的數字列表的範例：

```py
numbers = (13, 2, 78, 3, 45, 67, 18, 7)
sorted(numbers) # [2, 3, 7, 13, 18, 45, 67, 78]
```

- **修改排序行為**：你可以使用選用的 `reverse` 和 `key` 引數來自訂可迭代物件的排序行為。以下是使用 `key` 引數依長度排序元組中項目的範例：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
sorted(programming_languages, key=len)

# Result
# ['C++', 'Rust', 'Java', 'Rust', 'Python', 'Python']
```

- 你可以使用 `reverse` 引數來創建一個反向順序的新值列表，如下所示：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')

print(sorted(programming_languages, reverse=True))

# Result
# ['Rust', 'Rust', 'Python', 'Python', 'Java', 'C++']
```

## Python 中的迴圈

- **定義**：迴圈用於重複執行一個區塊的程式碼指定的次數。

- **`for` 迴圈**：用於對序列（例如列表、元組或字串）進行迭代，並對該序列中的每個項目執行一個區塊的程式碼。以下是使用 `for` 迴圈來迭代列表並將每個語言列印到主控台的範例：

```py
programming_languages = ['Rust', 'Java', 'Python', 'C++']

for language in programming_languages:
    print(language)

"""
Result 

Rust
Java
Python
C++
"""
```

- 這是一個使用 `for` 迴圈來遍歷字串 `code` 並列印出每個字元的範例：

```py
for char in 'code':
    print(char)

"""
Result 

c
o
d
e
"""
```

- `for` 迴圈可以巢狀使用。以下是使用巢狀 `for` 迴圈的範例：

```py
categories = ['Fruit', 'Vegetable']
foods = ['Apple', 'Carrot', 'Banana']

for category in categories:
    for food in foods:
        print(category, food)

"""
Result

Fruit Apple
Fruit Carrot
Fruit Banana
Vegetable Apple
Vegetable Carrot
Vegetable Banana
"""

```

- **`while` 迴圈**：重複執行一個區塊的程式碼直到條件為 `False`。以下是一個使用 `while` 迴圈進行猜數字遊戲的範例：

```py
secret_number = 3
guess = 0

while guess != secret_number:
    guess = int(input('Guess the number (1-5): '))
    if guess != secret_number:
        print('Wrong! Try again.')

print('You got it!')

"""
Result

Guess the number (1-5): 2
Wrong! Try again.
Guess the number (1-5): 1
Wrong! Try again.
Guess the number (1-5): 3
You got it!
"""

```

- **`break` 和 `continue` 述語**：用於迴圈中以修改迴圈的執行。

- 當符合某個條件時，`break` 述語用於立即離開迴圈。以下是使用 `break` 述語處理 `developer_names` 列表的範例：

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        break
    print(developer)
```

- `continue` 述語用於跳過當前的迴圈迭代並進入下一次迴圈迭代。以下是一個使用 `continue` 述語取代 `break` 述語的範例：

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        continue
    print(developer)
```

- `for` 和 `while` 迴圈都可以與 `else` 語句結合，該語句僅在迴圈未被 `break` 終止時執行：

```python
words = ['sky', 'apple', 'rhythm', 'fly', 'orange']

for word in words:
    for letter in word:
        if letter.lower() in 'aeiou':
            print(f"'{word}' contains the vowel '{letter}'")
            break
    else:
        print(f"'{word}' has no vowels")
```

## 範圍與其在迴圈中的使用

- **`range()` 函式**：用於產生一連串整數。

```py
range(start, stop, step)
```

- 必要的 `stop` 引數是一個整數（不包含該值），用來表述所產生數字序列的終點。以下是使用 `range()` 函式的範例：

```py
for num in range(3):
    print(num)
```

- 如果沒有指定 `start` 引數，則預設值為 `0`。 預設情況下，整數序列將以 `1` 遞增。 你可以使用選用的 `step` 引數來更改預設的遞增值。 以下是生成從 2 到但不包含 11（即包含 10）的偶數序列的範例。

```py
for num in range(2, 11, 2):
    print(num)
```

- 如果你沒有為 `range()` 函式提供任何引數，則會得到 `TypeError`。

- `range()` 函式（程式）只接受整數作為引數，而不接受浮點數。使用浮點數也會導致 `TypeError`：

```py
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
```

- 你可以對 `step` 引數使用負整數，以產生遞減順序的整數序列：

```py
for num in range(40, 0, -10):
    print(num)
```

- `range()` 函式（程式）也可以搭配 `list` 建構式用來產生整數列表。`list` 建構式用於將可迭代物件轉換成列表。以下是產生包含 2 到 10（含）之間偶數列表的範例：

```py
numbers = list(range(2, 11, 2))
print(numbers) # [2, 4, 6, 8, 10]
```

## Python 中的 `enumerate()` 和 `zip()` 函式（程式）

- **`enumerate()`**：用於迭代序列並追蹤該序列中每個項目的索引。`enumerate()` 函式以可迭代物件作為引數，並傳回一個 `enumerate` 物件，該物件包含可迭代物件中每個項目的索引和值。

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

for index, language in enumerate(languages):
    print(f'Index {index} and language {language}')

# Result
# Index 0 and language Spanish
# Index 1 and language English
# Index 2 and language Russian
# Index 3 and language Chinese

```

- `enumerate()` 函式（程式）也可以在 `for` 迴圈之外使用：

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

print(list(enumerate(languages)))
# [(0, 'Spanish'), (1, 'English'), (2, 'Russian'), (3, 'Chinese')]
```

- `enumerate()` 函式（程式）也接受一個選用的 `start` 引數，用來指定計數的起始值。如果省略此引數，計數將從 `0` 開始。

-  **`zip()`** ：用於平行迭代多個可迭代物件。以下是使用 `zip()` 函式（程式）來迭代 `developers` 和 `ids` 的範例：

```python
developers = ['Naomi', 'Dario', 'Jessica', 'Tom']
ids = [1, 2, 3, 4]

for name, id in zip(developers, ids):
    print(f'Name: {name}')
    print(f'ID: {id}')


"""
Result

Name: Naomi
ID: 1
Name: Dario
ID: 2
Name: Jessica
ID: 3
Name: Tom
ID: 4
"""

```

## Python 中的列表推導式

- **定義**：列表推導式允許你在一行中直接在方括號內結合迴圈和條件來創建一個新的列表。這使程式碼更簡短且通常更易於閱讀。

```py
even_numbers = [num for num in range(21) if num % 2 == 0]
print(even_numbers)
```

## 可疊代方法

- **`filter()`**：用來根據條件篩選可迭代物件中的元素。它傳回一個只包含符合條件元素的迭代器。以下是一個建立只包含長度超過四個字元的字的新列表的範例：

```py
words = ['tree', 'sky', 'mountain', 'river', 'cloud', 'sun']

def is_long_word(word):
    return len(word) > 4

long_words = list(filter(is_long_word, words))
print(long_words) # ['mountain', 'river', 'cloud']
```

- **`map()`**：用於將函式應用到可迭代物件中的每個項目，並傳回一個包含結果的新可迭代物件。以下是使用 `map()` 函式將攝氏溫度列表轉換為華氏溫度的範例：

```py
celsius = [0, 10, 20, 30, 40]

def to_fahrenheit(temp):
    return (temp * 9/5) + 32

fahrenheit = list(map(to_fahrenheit, celsius))
print(fahrenheit) # [32.0, 50.0, 68.0, 86.0, 104.0]
```

- **`sum()`**：用於從可迭代物件如列表或元組取得總和。以下是使用 `sum()` 函式的範例：

```py
numbers = [5, 10, 15, 20]
total = sum(numbers)
print(total) # Result: 50
```

- 你也可以傳入選用的 `start` 引數，該引數設定加總的初始值。以下是使用 `start` 引數作為位置引數的更新範例：

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, 10) # positional argument
print(total) # 60
```

- 你也可以選擇將 `start` 引數作為關鍵字引數這樣使用：

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, start=10) # keyword argument
print(total) # 60
```

## Lambda 函式（程式）

- **定義**：Python 中的 lambda 函式（程式）是一種簡潔的方式，用來創建沒有名稱的函式（匿名函式）。
- Lambda 函式（程式）經常被用作另一個函式（程式）的引數。以下是一個 lambda 函式（程式）的範例：

```py
numbers = [1, 2, 3, 4, 5]

even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]
```

- 使用 lambda 函式（程式）的最佳實踐包括不要將它們指定給變數、保持簡單且易讀，以及用於短暫且一次性的函式（程式）。

## 字典

- **字典**：字典是內建的資料結構，用來儲存鍵值配對的群集。鍵必須是不可變的資料型別。這是 Python 字典的一般語法：

```python
dictionary = {
    key1: value1,
    key2: value2
}
```

- **`dict()` 建構式**：`dict()` 建構式是建置字典的另一種方式。你將一個包含多個元組的列表作為引數傳遞給 `dict()` 建構式。這些元組的第一個元素是鍵，第二個元素是值。

```python
pizza = dict([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250), ('toppings', ['mozzarella', 'basil'])])
```

- **括號表示法**：要存取鍵值對的值，你可以使用稱為括號表示法的語法。

```python
dictionary[key]
```

## 常用字典方法

- **`get()` 方法**：`get()` 方法會取得與鍵相關的值。它類似於括號表示法，但允許你設定預設值，避免在鍵不存在時發生錯誤。

```python
dictionary.get(key, default)
```

- **`keys()` 和 `values()` 方法**：`keys()` 和 `values()` 方法分別傳回包含字典中所有鍵與值的檢視物件。檢視物件是一種查看字典內容而不建立資料獨立副本的方式。

```python
pizza = {
    'name': 'Margherita Pizza',
    'price': 8.9,
    'calories_per_slice': 250
}

pizza.keys()
# dict_keys(['name', 'price', 'calories_per_slice'])

pizza.values()
# dict_values(['Margherita Pizza', 8.9, 250])
```

- **`items()` 方法**：`items()` 方法傳回一個檢視物件，該物件包含字典中所有的鍵值對組，包括鍵和值。

```python
pizza.items()
# dict_items([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250)])
```

- **`clear()` 方法**：`clear()` 方法會從字典中移除所有的鍵值配對。

```python
pizza.clear()
```

- **`pop()` 方法**：`pop()` 方法會移除以第一個引數指定的鍵的鍵值對，並傳回其值。如果該鍵不存在，則傳回第二個引數指定的預設值。如果該鍵不存在且未指定預設值，則會引發 `KeyError`。

```python
pizza.pop('price', 10)
pizza.pop('total_price') # KeyError
```

- **`popitem()` 方法**：在 Python 3.7 及以上版本中，`popitem()` 方法會移除最後插入的項目。

```python
pizza.popitem()
```

- **`update()` 方法**：`update()` 方法會使用另一個字典的鍵值對來更新鍵值對。如果它們有共同的鍵，則其值會被覆寫。新的鍵會作為新的鍵值對被添加到字典中。

```python
pizza.update({ 'price': 15, 'total_time': 25 })
```

## 對字典進行迴圈

- **迭代值**：如果你需要迭代字典中的值，你可以寫一個帶有 `values()` 的 `for` 迴圈來取得字典的所有值。

```python
products = {
    'Laptop': 990,
    'Smartphone': 600,
    'Tablet': 250,
    'Headphones': 70,
}

for price in products.values():
    print(price)
```

輸出：

```md
990
600
250
70
```

- **迭代鍵**：如果你需要迭代上述 `products` 字典中的鍵，你可以寫 `products.keys()` 或直接寫 `products`。

```python
for product in products.keys():
    print(product)
    
# Or

for product in products:
    print(product)
```

輸出：

```md
Laptop
Smartphone
Tablet
Headphones
```

- **迭代鍵值配對**：如果你需要同時迭代鍵及其對應的值，你可以迭代 `products.items()`。你會得到包含鍵及其對應值的個別元組。

```python
for product in products.items():
    print(product)
```

輸出：

```md
('Laptop', 990)
('Smartphone', 600)
('Tablet', 250)
('Headphones', 70)
```

要將鍵和值儲存在不同的迴圈變數中，你需要用逗號將它們分開。第一個變數儲存鍵，第二個變數儲存值。

```python
for product, price in products.items():
    print(product, price)
```

輸出：

```md
Laptop 990
Smartphone 600
Tablet 250
Headphones 70
```

- **`enumerate()` 函式**：如果你需要在迭代字典時同時追蹤計數器，你可以呼叫 `enumerate()` 函式。該函式傳回一個 `enumerate` 物件，會為每個項目指定一個整數，像是計數器。你可以從任何數字開始計數，但預設值是從 0 開始。

將索引和項目指定給不同的迴圈變數是使用 `enumerate()` 的常見方式。 例如，使用 `products.items()`，你可以取得整個鍵值對組以及索引：

```python
for index, product in enumerate(products.items()):
    print(index, product)
```

輸出：

```md
0 ('Laptop', 990)
1 ('Smartphone', 600)
2 ('Tablet', 250)
3 ('Headphones', 70)
```

要自訂計數的初始值，你可以傳遞第二個引數給 `enumerate()`。例如，這裡我們從 1 開始計數。

```python
for index, product in enumerate(products.items(), 1):
    print(index, product)
```

輸出：

```md
1 ('Laptop', 990)
2 ('Smartphone', 600)
3 ('Tablet', 250)
4 ('Headphones', 70)
```

## 集合

- **集合**：集合是 Python 內建的資料結構，不允許重複的值。集合是可變的且無序的，這表示其元素不會以特定順序儲存，因此你無法使用索引或鍵來存取它們。此外，集合只能包含不可變資料型別的值，例如數字、字串和元組。

- **定義集合**：要定義集合，你需要將其元素寫在大括號內並以逗號分隔。

```python
my_set = {1, 2, 3, 4, 5}
```

- **定義空集合**：如果你需要定義空集合，必須使用 `set()` 函式。僅寫空的大括號會自動創建字典。

```python
set() # Set
{}    # Dictionary
```

## 常用集合方法

- **`add()` 方法**：你可以使用 `add()` 方法為集合添加元素，並將新元素作為引數傳入。

```python
my_set.add(6)
```

- **`remove()` 和 `discard()` 方法**：要從集合中移除元素，你可以使用 `remove()` 方法或 `discard()` 方法，並將你想移除的元素作為引數傳入。若找不到該元素，`remove()` 方法會引發 `KeyError`，而 `discard()` 方法則不會。

```python
my_set.remove(4)
my_set.discard(4)
```

- **`clear()` 方法**：`clear()` 方法會移除集合中的所有元素。

```python
my_set.clear()
```

## 數學集合操作

- **`issubset()` 和 `issuperset()` 方法**：`issubset()` 和 `issuperset()` 方法分別檢查一個集合是否為另一個集合的子集合或超集合。

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 5}

print(your_set.issubset(my_set)) # True
print(my_set.issuperset(your_set)) # True
```

- **`isdisjoint()` 方法**：`isdisjoint()` 方法用來檢查兩個集合是否不相交，即它們沒有共同的元素。

```python
my_set = {1, 2, 3}
your_set = {4, 5, 6}

print(my_set.isdisjoint(your_set)) # True
```

- **聯集（數學）運算子 (`|`)**：聯集（數學）運算子 `|` 傳回一個包含兩個集合中所有元素的新集合。

```python
my_set = {1, 2, 3}
your_set = {4, 5, 6}

my_set | your_set # {1, 2, 3, 4, 5, 6}
```

- **交集運算子 (`&`)**：交集運算子 `&` 傳回一個只包含集合共同元素的新集合。

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

my_set & your_set # {2, 3, 4}
```

- **差集運算子 (`-`)**：差集運算子 `-` 傳回一個新集合，該集合包含第一個集合中不在其他集合內的元素。

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

my_set - your_set # {1, 5}
```

- **對稱差運算子 (`^`)**：對稱差運算子 `^` 傳回一個新集合，該集合包含只存在於第一個集合或第二個集合中，但不包含兩者皆有的元素。

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

my_set ^ your_set # {1, 5, 6}
```

- **`in` 運算子**：你可以使用 `in` 運算子檢查元素是否在集合中。

```python
print(5 in my_set)
```

## Python 標準程式庫

- **Python 標準程式庫**：函式庫提供你預先撰寫且可重複使用的程式碼，例如函式、類別和資料結構，你可以在你的專案中重複使用。Python 擁有廣泛的標準程式庫，內建模組實作了許多問題和任務的標準化解決方案。一些受歡迎的內建模組範例有 `math`、`random`、`re`（「regular expressions」的縮寫）和 `datetime`。

## 匯入述語

- **匯入述語**：為了存取內建模組中定義的元素，你使用匯入述語。匯入述語通常寫在檔案的頂端。匯入述語對於函式（程式）、類別、常數、變數以及模組中定義的任何其他元素皆適用。

- **基本匯入述語**：你可以使用 `import` 關鍵字，後面接模組名稱：

```python
import module_name
```

然後，如果你需要從該模組呼叫一個方法，你會使用點記法，先寫模組名稱，接著寫方法名稱。

```python
module_name.method_name()
```

例如，你會在你的程式碼中寫下以下內容來匯入 `math` 模組並取得 36 的平方根：

```python
import math

math.sqrt(36)
```

- **以不同名稱匯入模組**：如果你需要以不同名稱（也稱為「別名」）匯入模組，你可以在匯入述語的結尾使用 `as` 後接別名。這通常用於模組名稱過長或避免命名衝突。

```python
import module_name as module_alias
```

例如，要在你的程式碼中將 `math` 模組指涉為 `m`，你可以這樣指定別名：

```python
import math as m
```

然後，你可以使用別名來存取該模組的元素：

```python
m.sqrt(36)
```

- **匯入特定元素**：如果你不需要模組中的所有內容，你可以使用 `from` 匯入特定元素。在這種情況下，匯入述語以 `from` 開頭，接著是模組名稱，然後是 `import` 關鍵字，最後是你想匯入的元素名稱。

```python
from module_name import name1, name2
```

然後，你可以在你的 Python 腳本中使用這些名稱，而不需要模組前置式。 例如：

```python
from math import radians, sin, cos

angle_degrees = 40
angle_radians = radians(angle_degrees)

sine_value = sin(angle_radians)
cos_value = cos(angle_radians)

print(sine_value) # 0.6427876096865393
print(cos_value)  # 0.766044443118978
```
 
這很有幫助，但如果你已經有相同名稱的函式或變數，可能會導致命名衝突。選擇你想使用的匯入述語型別時，請記住這一點。

如果你需要為這些名稱指定別名，也可以使用 `as` 關鍵字，後面接別名。

```python
from module_name import name1 as alias1, name2 as alias2
```

- **使用星號（`*`）的匯入述語**：星號告訴 Python 你想要匯入該模組中的所有內容，但你想要匯入的方式是不需要使用該模組名稱作為前置式。

```python
from module_name import *
```

例如，如果你使用這個來匯入 `math` 模組，你將能夠呼叫該模組中定義的任何函式，而無需指定模組名稱作為前置式。

```python
from math import *
print(sqrt(36))  # 6.0
```

然而，這通常不建議，因為它可能導致命名空間衝突，並使得難以知道名稱的來源。

## `if __name__ == '__main__'`

- **`__name__` 變數**：`__name__` 是 Python 中一個特殊的內建變數。當一個 Python 檔案被直接執行時，Python 會將此變數的值設為字串 `"__main__"`。但如果該 Python 檔案被匯入為另一個 Python 腳本的模組，則 `__name__` 變數的值會被設為該模組的名稱。

這就是為什麼你經常會在 Python 腳本中看到這個條件。它包含你只想在 Python 腳本作為主要程式執行時**才**執行的程式碼。

```python
if __name__ == '__main__': 
    # Code
```

## Python 中的常見錯誤

- **SyntaxError**：當你的程式碼不符合其語法規則時，Python 引發的錯誤。 例如，程式碼 `print("Hello there"` 會導致語法錯誤，並顯示訊息 `SyntaxError: '(' was never closed`，因為程式碼缺少關閉的括號。
- **NameError**：當你嘗試存取尚未定義的變數或函式時，Python 會引發 `NameError`。例如，如果你的程式碼中有 `print(username)` 這一行，但你並未先定義 `username` 變數，你將會收到帶有訊息 `NameError: name 'username' is not defined` 的名稱錯誤。
- **TypeError**：當你對兩個或多個不相容的資料型別執行操作時，Python 會發出這個錯誤。例如，如果你嘗試將字串加到數字上，你會得到錯誤 `TypeError: can only concatenate str (not "int") to str`。
- **IndexError**：如果你存取列表或其他序列（例如 tuple 和字串）中不存在的索引，就會得到 `IndexError`。例如，在 `Hello world` 字串中，最後一個字元的索引是 `11`。如果你繼續這樣存取字元，`greet = "hello world"; print(greet[12])`，你會得到訊息為 `IndexError: string index out of range` 的錯誤。
- **AttributeError**：當你嘗試在該型別的物件中使用不存在的方法或屬性時，Python 會引發此錯誤。<dfn>例如</dfn>，在字串 `"hello".append("!")` 上呼叫 `.append()` 會導致錯誤，並顯示訊息 `AttributeError: 'str' object has no attribute 'append'`。

## Python 中良好的偵錯技巧

- **使用 `print` 函式**：在偵錯時，將 `print()` 述語插入程式碼中各個位置，有助於你查看變數的值以及程式碼的流程。
- **使用 Python 內建的除錯器 (`pdb`)**：Python 提供了 `pdb` 模組用於偵錯。它是 Python 標準程式庫的零件，因此你隨時都可以使用。使用 `pdb`，你可以透過 `set_trace()` 方法設定追蹤點，這樣你就可以開始逐步執行程式碼並以互動方式檢查變數。
- **利用整合開發環境偵錯工具**：許多整合開發環境（IDE）和程式碼編輯器，如 Pycharm 和 VS Code，提供具有中斷點、逐步執行、變數檢查及其他偵錯特性的偵錯工具。

## 例外處理

- **`try...except`**: This is used to execute a block of code that might raise an exception. The `try` block is  where you anticipate an error might occur, while the `except` block takes a specified exception and runs if that specified error is raised. Here's an example:

  ```py
  try:
    print(22 / 0)
  except ZeroDivisionError:
    print('You can\'t divide by zero!')
    # You can't divide by zero!
  ```

  You can also chain multiple `except` blocks so you can handle more types of exceptions:

  ```py
  try:
    number = int(input('Enter a number: '))
    print(22 / number)
  except ZeroDivisionError:
    print('You cannot divide by zero!')
    # You cannot divide by zero! prints when you enter 0
  except ValueError:
    print('Please enter a valid number!')
    # Please enter a valid number! prints when you enter a string  
  ```

- **`else` 和 `finally`**：這些區塊擴充了 `try...except`。如果沒有發生例外，則會執行 `else` 區塊。無論是否有錯誤，`finally` 區塊都會執行。

  ```py
  try:
    result = 100 / 4
  except ZeroDivisionError:
    print('You cannot divide by zero!') # This will not run
  else:
    print(f'Result is {result}') # Result is 25.0
  finally:
    print('Execution complete!') # Execution complete!
  ```

- **例外物件**：這讓你能存取例外本身，以便更好地偵錯和列印直接的錯誤訊息。要存取例外物件，你需要使用 `as` 關鍵字。以下是一個範例：

  ```py
  try:
      value = int('This will raise an error')
  except ValueError as e:
      print(f'Caught an error: {e}')
      # Caught an error: invalid literal for int() with base 10: 'This will raise an error'
  ```

- **`raise` 述語**：這讓你可以手動引發例外。當符合某個條件時，你可以使用它來丟出例外。以下是一個範例：

  ```py
  def divide(a, b):
      if b == 0:
          raise ZeroDivisionError('You cannot divide by zero')
      return a / b
  ```
  
## 例外信號
  
  當你創建自己的訂製例外時，`raise` 述語也很有用，因為你可以用它來發出帶有訂製訊息的例外。以下是一個範例：

  ```py
  class InvalidCredentialsError(Exception):
      def __init__(self, message="Invalid username or password"):
          self.message = message
          super().__init__(self.message)

  def login(username, password):
      stored_username = "admin"
      stored_password = "password123"
      
      if username != stored_username or password != stored_password:
          raise InvalidCredentialsError()
      
      return f"Welcome, {username}!"
  ```  

  以下是你如何使用來自 `InvalidCredentialsError` 例外的 `login` 函式（程式）：

  ```py
  # failed login attempt
  try:
      message = login("user", "wrongpassword")
      print(message)
  except InvalidCredentialsError as e:
      print(f"Login failed: {e}")

  # successful login attempt
  try:
      message = login("admin", "password123")
      print(message)
  except InvalidCredentialsError as e:
      # This block is not executed because the login was successful
      print(f"Login failed: {e}")
  else:
      # The else block runs if the 'try' block completes without an exception
      print(message)
  ```

  `raise` 述語也可以與 `from` 字一起使用，以串鏈例外，顯示不同錯誤之間的關係：

  ```py
  def parse_config(filename):
    try:
        with open(filename, 'r') as file:
            data = file.read()
            return int(data)
    except FileNotFoundError:
        raise ValueError('Configuration file is missing') from None
    except ValueError as e:
        raise ValueError('Invalid configuration format') from e

  config = parse_config('config.txt')
```

## Python 類別和物件

- **類別定義**：類別是用來建立物件的藍圖。它透過其屬性和方法定義物件將會有的行為。以下是在 Python 中類別定義的基本範例：

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f'{self.name.upper()} says woof woof!')
```

- **創建物件**：物件是類別的實體。它們是透過使用必要的引數呼叫類別來創建的。

```python
dog1 = Dog('Jack', 3)
dog2 = Dog('Thatcher', 5)

dog1.bark()  # JACK says woof woof!
dog2.bark()  # THATCHER says woof woof!
```

- **使用物件呼叫方法**：你可以對物件呼叫方法以執行動作或取得資訊。

```python
objectName1.methodName()
objectName2.methodName()
```

- **類別與物件的差異**：類別是可重複使用的模板，而物件是該類別具有實際資料的特定實體。

## 屬性

- **實體屬性**：在 `__init__()` 中使用 `self` 定義，且每個物件皆獨有。
- **類別屬性**：直接定義在類別內並由所有實體共用。

```python
class Dog:
    species = 'French Bulldog'  # Class attribute

    def __init__(self, name):
        self.name = name  # Instance attribute

print(Dog.species) # French Bulldog

jack = Dog('Jack')
print(jack.name)     # Jack
print(jack.species)  # French Bulldog
```

## 方法、行為、函式

- **方法**：定義在類別內、用來操作物件屬性的函式。

```python
class Car:
    def __init__(self, color, model):
        self.color = color
        self.model = model

    def describe(self):
        return f'This car is a {self.color} {self.model}'

my_car_1 = Car('red', 'Tesla Model S')
print(my_car_1.describe())  # This car is a red Tesla Model S
```

- **存取方法**：使用點記法對物件呼叫方法。以下是對兩個不同汽車物件呼叫 `describe` 方法的範例：

```python
class Car:
 def __init__(self, color, model):
   self.color = color  
   self.model = model  

 def describe(self):
   return f'This car is a {self.color} {self.model}'

my_car_1 = Car('red', 'Tesla Model S')
my_car_2 = Car('green', 'Lamborghini Revuelto')

print(my_car_1.describe()) # Calling methods using the dot notation

print(my_car_2.describe()) # Calling methods using the dot notation
```

## 雙底線（魔術）方法

- **定義**：以雙底線開頭和結尾的特殊方法（例如 `__init__`、`__len__`、`__str__`、`__eq__`）。Python 內部使用它們來執行內建操作。

```python
class Book:
    def __init__(self, title, pages):
        self.title = title
        self.pages = pages

    def __len__(self):
        return self.pages

    def __str__(self):
        return f"'{self.title}' has {self.pages} pages"

    def __eq__(self, other):
        return self.pages == other.pages

book1 = Book('Built Wealth Like a Boss', 420)
print(len(book1))        # 420
print(str(book1))        # 'Built Wealth Like a Boss' has 420 pages
```

- **間接呼叫 dunder 方法**：你不需要直接呼叫 dunder 方法。相反地，當發生某些操作時，Python 會自動呼叫它們。這些操作包括：

  - **像加法、減法、乘法、除法等算術操作**。此外，會呼叫 `__add__()`，減法則呼叫 `__sub__()`，乘法呼叫 `__mul__()`，除法呼叫 `__truediv__()`。
        
  - **字串操作行為，例如串接、重複、格式化和轉換為文字**。`__add__()` 用於串接，`__mul__()` 用於重複，`__format__()` 用於格式化，`__str__()` 和 `__repr__()` 用於文字轉換，等等。
        
  - **比較操作行為像是相等性、小於、大於等**。`__eq__()` 用於相等性檢查，`__lt__()` 用於小於，`__gt__()` 用於大於，依此類推。
        
  - **像是讓物件可迭代以及在項目中前進的迭代操作**。會呼叫 `__iter__()` 來傳回迭代器，並呼叫 `__next__()` 來取得下一個項目。

## 實際範例：購物車

- **具有雙底線方法的 Cart 類別**：允許使用內建行為來添加、移除、迭代和檢查內容。

```python
class Cart:
    def __init__(self):
        self.items = []

    def add(self, item):
        self.items.append(item)

    def remove(self, item):
        if item in self.items:
            self.items.remove(item)
        else:
            print(f'{item} is not in cart')

    def list_items(self):
        return self.items

    def __len__(self):
        return len(self.items)

    def __getitem__(self, index):
        return self.items[index]

    def __contains__(self, item):
        return item in self.items

    def __iter__(self):
        return iter(self.items)

cart = Cart()
cart.add('Laptop')
print(len(cart))        # 1
print('Laptop' in cart) # True
```

## 什麼是物件導向程式設計？

- **物件導向程式設計**：一種程式設計風格，開發者將程式碼中的所有事物視為真實世界的物件。它通常被稱為 OOP。幫助你有效組織和管理程式碼的四大關鍵原則是 **封裝**、**繼承**、**多型** 和 **抽象體**。
- **類別**：用於創建物件的藍圖。每個由類別創建的物件都有定義資料的屬性和決定物件行為的方法。

## 什麼是封裝？

- **封裝**：將物件的屬性和方法封裝成一個單一單元。它讓你能夠將物件的內部狀態隱藏在一組簡單的公開方法和屬性背後，這些方法和屬性就像門一樣。在這些門的背後是私有的屬性和方法，控制資料如何變更以及誰可以看到它。
- **封裝範例**：如果你想追蹤錢包餘額，你會允許存款和提款，但你不會想讓任何人竄改錢包餘額本身：

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

- **單底線與雙底線前置式屬性之間的差異**：為屬性和方法前置單底線表示它們是供內部使用的。這是一種慣例，並不會強制禁止從外部存取屬性。為屬性和方法前置雙底線則有效防止它們被從類別外部存取。

## 什麼是取值函式和設值函式？

- **取值函式和設值函式**：讓你控制類別屬性如何被存取和修改的方法。你使用取值函式來取得值，使用設值函式來設定值。
- **屬性**：它們連接取值函式和設值函式，並允許存取資料。當你取得、設定或刪除值時，它們會在幕後執行額外邏輯。
- **為什麼使用屬性而非方法**：屬性用於取代方法，以提升可讀性和程式碼整潔度。它們讓你像存取一般屬性一樣，使用點記法存取值，而不需要小括弧。
- **創建取值函式**：要創建取值函式，你使用 `@property` 裝飾器。這裡有一個取得圓半徑的取值函式：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

- **創建設值函式**：為了創建將設定半徑的設值函式，你必須定義另一個同名的方法，並在其上方使用 `@<property_name>.setter`：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

- **Python 如何控制取值函式和設值函式**：一旦你定義了取值函式和設值函式，Python 在你以這種方式使用一般屬性語法時，會自動在背後呼叫它們：

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

 當設定值時，你不應該指定給屬性名稱本身，因為那會導致 `RecursionError`。請使用一個獨立的內部名稱，通常帶有底線，來儲存該值。

- **Deleter**：在使用設值函式和取值函式設定及取得值之後，你可以使用 `deleter` 控制它如何被刪除。當你對屬性使用 `del` 述語時，deleter 會執行訂製邏輯。要創建 deleter，你需要使用 `@<property_name>.deleter` 裝飾器。

```py
  # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

## 什麼是繼承以及它如何促進程式碼重複使用？

- **繼承**：子類別使用父類別的屬性和方法的處理程序。繼承促進程式碼重複使用，提供清晰的階層結構，並且在不重寫所有內容的情況下自訂行為。要實作繼承，子類別需接收父類別的名稱：

```py
class Parent:
    # Parent attributes and methods

class Child(Parent):
    # Child inherits, extends, and/or overrides where necessary
```

- **單一繼承和多重繼承**：當子類別從單一父類別繼承屬性和方法時，如上所示，該處理程序稱為**單一繼承**。當子類別從多個父類別繼承屬性和方法時，則稱為**多重繼承**。以下是其語法：

```py
class Parent:
    # Attributes and methods for Parent

class Child:
    # Attributes and methods for Child

class GrandChild(Parent, Child):
    # GrandChild inherits from both Parent and Child
    # GrandChild can combine or override behavior from each
```

- **`super()` 函式**：一個讓你在子類別中改寫父類別方法的函式。

## 什麼是多型以及它如何促進程式碼重複使用？

- **多型**：物件導向程式設計的原則，讓不同的類別使用相同的行為名稱，但每個類別在被呼叫時會以不同方式實作。以下是它的語法：

```py
class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # Works for A, B, or C
```

- **基於繼承的多型**：父類別設定一個方法，而每個子類別都會將它調整為自己的用途。

## 什麼是 Name Mangling 以及它如何運作？

- **名稱改寫**：Python 內部將以雙底線為前置式的屬性重新命名的處理程序，方法是加上一個底線和類別名稱作為前置式，將 `__attribute` 變成 `_ClassName__attribute`。
- **名稱改編的目的**：名稱改編的主要目的是在你使用繼承時防止意外的屬性和方法覆寫。以下是一段讓這點更容易理解的程式碼：

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

## 什麼是抽象性以及它如何幫助保持複雜系統的組織性？

- **抽象性**：一種程式設計概念，其中物件或系統的複雜實作細節被隱藏，僅顯示必要的特性。在 Python 和其他程式語言中，抽象性透過提高可重複使用性來簡化複雜系統。
- **抽象性的範例**：生活中抽象性的好範例是汽車讓你只使用方向盤、踏板和排檔桿，而不需要知道引擎或煞車如何運作。
- **Python 如何實作抽象性**：Python 透過 `abc` 模組實作抽象性。該模組提供 `ABC` 類別（抽象的基礎類別）和 `@abstractmethod` 裝飾器。抽象的基礎類別（ABC）定義子類別必須實作的共用方法和屬性。它無法被具現化。
- **抽象方法的定義方式**：抽象方法是以 `@abstractmethod` 定義，且即使有預設實作，也必須在子類別中覆寫。抽象性的基本語法如下：

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

## 演算法與 Big O 符號

- **演算法**：一組明確無誤的指令，用於解決問題或執行任務。演算法必須在有限的步驟內完成，且每個步驟必須精確且明確無誤。

- **Big O 符號**：描述演算法在輸入大小增加時的最壞效率、性能或成長速率。它著重於資源使用量隨輸入大小的成長，忽略常數因子和低階項。

### 常見時間複雜度

- **O(1) - 常數時間**：演算法無論輸入大小，所需時間皆相同。

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

- **O(log n) - 對數時間**：隨著輸入成長，時間緩慢增加。常見於反覆將問題規模縮小一部分（如二分搜尋法）的演算法。

- **O(n) - 線性時間**：執行時間隨輸入大小成比例增加。

```python
for grade in grades:
    print(grade)
```

- **O(n log n) - 對數線性時間**：高效排序演算法如合併排序和快速排序的常見時間複雜度。

- **O(n²) - 二次時間複雜度**：執行時間以二次方增加。常見於巢狀迴圈中。

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

### 空間複雜度

- **O(1) - 常數空間**：演算法使用相同數量的記憶體，無論輸入大小為何。
- **O(n) - 線性空間**：記憶體使用量隨輸入大小成比例增加。
- **O(n²) - 二次方空間**：記憶體使用量隨輸入大小二次方成長。

## 問題解決技巧

- **理解問題**：多次閱讀問題述語。識別輸入、預期輸出，以及如何將輸入轉換為輸出。

- **偽程式碼**：獨立於語言的演算法邏輯高層次描述。使用一般書面語言混合程式設計構件如 `IF`、`ELSE`、`FOR`、`WHILE`。

```md
GET original_string
SET reversed_string = ""
FOR EACH character IN original_string:
  ADD character TO THE BEGINNING OF reversed_string
DISPLAY reversed_string
```

- **邊界情況**：演算法應該控制代碼的邊界上發生的特定且有效的輸入。務必考慮並測試邊界情況。

## 陣列

- **靜態陣列**：在初始化時具有固定大小。元素儲存在相鄰的記憶體位置。大小在程式執行期間無法更改。

- **動態陣列**：可以在程式執行期間自動擴展或縮小。當需要時，透過自動複製到較大的陣列來控制大小調整。

### Python 列表（動態陣列）

```python
numbers = [3, 4, 5, 6]

# Access elements
numbers[0]  # 3

# Update elements
numbers[2] = 16

# Add elements
numbers.append(7)
numbers.insert(3, 15)  # Insert at specific index

# Remove elements
numbers.pop(2)  # Remove at specific index
numbers.pop()   # Remove last element
```

### 動態陣列的時間複雜度

- **存取**：O(1)
- **插入於末端**：平均 O(1)，需要調整大小時為 O(n)
- **插入於中間**：O(n)
- **刪除**：中間為 O(n)，結尾為 O(1)

## 堆疊

- **堆疊**：後進先出（LIFO）的資料結構。元素僅能從頂部添加和移除。

- **Push 操作行為**：將元素添加到堆疊頂端。時間複雜度：O(1)。

- **Pop 操作行為**：從堆疊頂端移除一個元素。時間複雜度：O(1)。

```python
# Using Python list as stack
stack = []

# Push operations
stack.append(1)
stack.append(2)
stack.append(3)

# Pop operations
top_element = stack.pop()  # Returns 3
```

## 佇列

- **佇列**：先進先出（FIFO）資料結構。元素從後方加入，從前方移除。

- **入佇列操作**：將元素添加到佇列的尾端。時間複雜度：O(1)。

- **Dequeue 操作行為**：從佇列前端移除一個元素。時間複雜度：O(1)。

```python
from collections import deque

# Using deque for efficient queue operations
queue = deque()

# Enqueue operations
queue.append(1)
queue.append(2)
queue.append(3)

# Dequeue operations
first_element = queue.popleft()  # Returns 1
```

## 鏈結串列

- **鏈結串列**：線性資料結構，其中每個節點包含資料和指向下一個節點的引用。節點像串鏈一樣連結。

### 單向鏈結串列

- **結構**：每個節點都有資料和一個指向下一個節點的引用。
- **遍歷**：只能從頭部向尾部前進。
- **Head Node**：列表中的第一個節點，通常是唯一可直接存取的節點。
- **尾節點**：列表中的最後一個節點，指向 `None`。

### 操作行為與時間複雜度

- **在開頭插入**：O(1)
- **插入於結尾**：O(n) - 必須巡訪至結尾
- **插入中間**：O(n) - 必須巡訪到該位置
- **從開頭刪除**：O(1)
- **從尾端刪除**：O(n) - 必須巡訪以找到前一個節點
- **從中間刪除**：O(n) - 必須巡訪以找到節點

### 雙向鏈結串列

- **結構**：每個節點都有資料和兩個引用：下一個節點和前一個節點。
- **遍歷**：可以雙向移動。
- **記憶體**：由於額外的引用，所需的記憶體比單向鏈結串列多。

## 雜湊映射和集合

### 映射和雜湊映射

- **Map（抽象資料型別）**：管理鍵值配對的群集。每個鍵必須唯一，但值可以重複。

- **Hash Map**：使用雜湊技術的映射 ADT 具體實作。使用雜湊函式（`hash function`）為鍵產生雜湊值，該值決定底層陣列中的儲存位置。

### Python 字典（雜湊映射）

```python
# Creating dictionaries
my_dictionary = {
    "A": 1,
    "B": 2, 
    "C": 3
}

# Alternative creation
my_dictionary = dict(A=1, B=2, C=3)

# Access and modify
value = my_dictionary["A"]  # 1
my_dictionary["A"] = 4      # Update value
del my_dictionary["A"]      # Remove key-value pair

# Check membership
"C" in my_dictionary

# Get keys, values, items
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

### 雜湊映射的時間複雜度

- **平均情況**：插入、取得、刪除皆為 O(1)
- **最壞情況**：當發生大量雜湊碰撞時為 O(n)

### 集合

- **集合**：無序且元素唯一的群集。不允許重複，且不維護特定順序。

- **僅限不可變元素**：集合只能包含不可變的資料型別（數字、字串、元組），因為雜湊值必須保持不變。

```python
# Creating sets
numbers = {1, 2, 3, 4}
empty_set = set()  # Must use set(), not {}

# Add and remove elements
numbers.add(5)
numbers.remove(4)      # Raises KeyError if not found
numbers.discard(4)     # No error if not found

# Set operations
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

# Union, intersection, difference, symmetric difference
set_a.union(set_b)                    # or set_a | set_b
set_a.intersection(set_b)             # or set_a & set_b
set_a.difference(set_b)               # or set_a - set_b
set_a.symmetric_difference(set_b)     # or set_a ^ set_b

# Subset and superset checks
set_a.issubset(set_b)
set_a.issuperset(set_b)
set_a.isdisjoint(set_b)

# Membership testing
5 in numbers
```

### 集合的時間複雜度

- **平均情況**：對於新增、移除、成員測試為 O(1)
- **最壞情況**：由於雜湊碰撞，時間複雜度為 O(n)

## 雜湊碰撞

- **雜湊碰撞**：當兩個不同的鍵產生相同的雜湊值時發生。

- **碰撞決議策略**：
  - **串鏈**：每個陣列索引指向一個鏈結串列，該串列儲存所有具有相同雜湊值的元素
  - **開放定址法**：使用預定義序列搜尋下一個可用索引

## 何時使用每種資料結構

- **列表**：當你需要有序、索引存取且事先不知道大小時
- **堆疊**：用於 LIFO 操作（復原功能、表達式評估、回溯）
- **佇列**：用於 FIFO 操作（任務排程、廣度優先搜尋）
- **鏈結串列**：當頻繁在開頭插入/刪除、大小未知、且不需要隨機存取時
- **雜湊映射**：用於快速鍵值查找、計數出現次數、快取
- **集合**：用於唯一性檢查、數學集合操作、移除重複項目

## 搜尋演算法

搜尋演算法讓你在特定的項目列表中搜尋標的。

在計算機科學中，有兩種搜尋演算法你應該了解。它們是**線性搜尋**和**二分搜尋法**演算法。了解這兩種演算法的差異以及何時使用各自非常重要。

### 線性搜尋

- 線性搜尋會從列表的開頭開始，逐一迭代每個項目，直到找到標的項目為止。
- 如果找到標的項目，則傳回該項目在列表中的索引。
- 如果找不到標的，則傳回 `-1`，這在大多數程式語言中表示**無效索引**。
- 因為線性搜尋會檢查每一個項目直到找到標的，所以對於大量項目的列表來說並不高效。
- 線性搜尋的時間複雜度是 `O(n)`，因為搜尋整個列表所需的時間會隨著列表大小線性增加。
- 線性搜尋的空間複雜度是 `O(1)`，因為它不需要任何額外空間來搜尋整個列表。

### 二元搜尋

- 二分搜尋法透過將列表的項目對半分割，並檢查標的值是否位於列表中間來運作。
- 二分搜尋法能運作的條件是列表中的項目必須是遞增排序。
- 二分搜尋法是一種更高效的演算法，用於搜尋大量條款的列表，因為它將條款列表對半分割，並忽略任何未找到標的的那一半。
- 如果在列表中間找到標的項目，則傳回標的項目的索引。
- 如果找不到該項目，演算法會檢查標的項目是在列表的左半部還是右半部。
- 它會持續將列表中剩餘的零件一分為二，直到找到標的項目。
- 如果最終在列表中找不到標的項目，則傳回 `-1`
- 二分搜尋法的時間複雜度是 `O(log n)`，因為搜尋列表所需的時間會隨著列表大小以對數方式成長。
- 二分搜尋法的空間複雜度是 `O(1)`，因為它在搜尋列表時不需要任何額外空間。

### 線性搜尋與二元搜尋的差異

- 與線性搜尋相比，二分搜尋法更適合用於大型列表的項目。
- 線性搜尋的時間複雜度是 `O(n)`，因為搜尋整個列表所需的時間會隨著列表大小線性增加。
- 二分搜尋法的時間複雜度是 `O(log n)`，因為搜尋列表所需的時間會隨著列表大小以對數方式成長。

## 排序演算法與分治法

在計算機科學中，分而治之是一種用來將問題拆解成較小子問題的技術，使其更容易解決。遞迴是分而治之中常用的技術，而分而治之是一種強大的策略，用於實作許多高效的排序演算法，如合併排序。

### 合併排序

- 合併排序是一種遵循分而治之方法的排序演算法。
- 它的運作方式是透過遞迴地將一個列表分割成更小的子列表，直到每個子列表只包含一個元素。
- 然後它會反覆將子列表以排序的順序合併回去。
- 合併排序的時間複雜度是 `O(n log n)`，因為列表會持續被對半切分 `(log n)`，然後再合併在一起 `(O(n))`。
- 合併排序的空間複雜度是 `O(n)`，因為它不是就地排序演算法。

## 圖表總覽

圖是一組由邊（連接）連接的節點（頂點）。每個節點可以連接到多個其他節點，形成一個網路。不同型別的圖包括：

- 有向：邊具有方向性（從一個節點到另一個節點），通常以直線和箭頭表述。
- 無向：邊沒有方向，以簡單線條表述。
- 頂點：每個節點都與一個標籤或識別符號相關。
- 循環：包含循環（從同一節點開始並結束的路徑）。
- 非循環（DAG）：不包含循環。
- 邊的標籤：每條邊都有一個標籤，通常繪製在對應邊的旁邊。
- 加權：邊具有相關的權重（數值），可用於執行算術操作。
- 不連通：包含兩個或以上未被任何邊連接的節點。

圖形用於各種應用，例如地圖、網路、推薦系統、相依性決議程序。

## 圖形遍歷

這涉及到造訪圖中的所有節點。兩個主要的演算法是：

- **廣度優先搜尋 (BFS)**
  - 使用佇列。
  - 逐層探索。
  - 尋找無權重圖中的最短路徑。

- **深度優先搜尋 (DFS)**
  - 使用堆疊（或遞迴）。
  - 在回溯之前完全探索一個分支。
  - 對於循環檢測和路徑尋找非常有用。

## 圖形表述

圖形可以用兩種主要方式表述：

- **鄰接列表**
  - 每個節點都有一個鄰居的列表。
  - 對稀疏圖而言空間高效。
  - 易於對鄰居進行迭代。

- **鄰接矩陣**
  - 一個二維陣列，其中列和行表述節點。
  - 對大型圖形而言空間密集。
  - 快速檢查兩個節點之間是否存在邊。

## 樹

樹是一種特殊型別的圖，具有無環且連通的特性。主要屬性包括：

- 它們沒有迴圈或循環（起點和終點節點相同的路徑）。
- 它們必須是連通的（每個節點都可以從其他每個節點到達）。

### 常見的樹型別

最常見的樹的型別有：

- 二元樹
  - 每個節點最多有兩個子節點，分別是左子節點和右子節點。

- 二元搜尋樹（BST）
  - 一個二元樹，其中每個左子節點都小於其父節點，每個右子節點都大於其父節點。


## 嘗試

也稱為前置式樹，用於儲存字串集合，其中每個節點表現一個字元。

共用的前置式只儲存一次，使它們在自動完成和拼字檢查等任務中高效。

搜尋和插入操作的時間複雜度為 O(L)，其中 L 是字串的長度。

## 優先權佇列

優先權佇列是一種抽象的資料型別，其中每個元素都有一個優先權。

佇列和堆疊只考慮插入的順序，而優先權佇列則考慮元素的優先權。 

標準佇列遵循 FIFO（先進先出），堆疊遵循 LIFO（後進先出）。然而，在優先權佇列中，具有較高優先權的元素會在較低優先權的元素之前被處理，無論它們的插入順序為何。

## 堆積

它是一種專門的基於樹的資料結構，具有一個非常特定的屬性，稱為堆積屬性。 

堆積屬性決定父節點與子節點之間的關係。有兩種堆積型別：

- 最大堆積
  - 每個父節點的值大於或相等於其子節點的值。
  - 最大元素位於根節點。

- 最小堆積
  - 每個父節點的值小於或相等於其子節點的值。
  - 最小的元素位於根節點。

### Python `heap` 模組範例

```py
import heapq

# Create empty heap
my_heap = []

# Insert elements
heapq.heappush(my_heap, 9)
heapq.heappush(my_heap, 3)
heapq.heappush(my_heap, 5)

# Remove smallest element
print(heapq.heappop(my_heap))  # 3

# Push + Pop in one step
print(heapq.heappushpop(my_heap, 2)) # 2

# Transform list into heap
nums = [5, 7, 3, 1]
heapq.heapify(nums)
```

### 使用優先權

```py
my_heap = []
heapq.heappush(my_heap, (3, "A"))
heapq.heappush(my_heap, (2, "B"))
heapq.heappush(my_heap, (1, "C"))

# Removes lowest number = highest priority
print(heapq.heappop(my_heap))  # (1, "C")
```

## 動態規劃簡介

- **定義**：動態規劃是一種演算法技術，透過將複雜問題拆解成較簡單的子問題並儲存結果，以避免重複計算來解決問題。
- **重疊子問題**：在解決較大問題時，相同的較小問題會出現多次。與其反覆重新計算這些子問題，不如將它們的解決方案儲存起來。
- **最佳子結構**：問題的最佳解法包含其子問題的最佳解法。這表示我們可以透過結合較小零件的最佳解法來建置最佳解法。

## 動態規劃解法

- **備忘錄化（自頂向下方法）**：備忘錄化會儲存昂貴函式（程式）呼叫的結果，並在相同輸入再次出現時傳回快取結果。

```py
def climb_stairs_memo(n, memo={}):
    """Dynamic programming with memoization"""
    # Check if we've already calculated this value
    if n in memo:
        return memo[n]  # Return cached result - O(1) lookup!
    
    # Base cases
    if n <= 2:
        return n
    
    # Calculate once and store in memo for future use
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    return memo[n]
```

- **表格法（自底向上方法）**：表格法從基礎開始建置解決方案，透過填寫一個表格來存放子問題的解答。

```py
def climb_stairs_tabulation(n):
    """Dynamic programming with tabulation"""
    if n <= 2:
        return n
    
    # Create array to store results for all steps from 0 to n
    dp = [0] * (n + 1)
    dp[1] = 1  # 1 way to reach step 1
    dp[2] = 2  # 2 ways to reach step 2
    
    # Build up the solution iteratively
    for i in range(3, n + 1):
        # Ways to reach step i = ways to reach (i-1) + ways to reach (i-2)
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

## 使用動態規劃的實際應用

- **路徑優化**：GPS 系統使用動態規劃演算法來尋找位置之間的最短路徑。
- **文字處理**：拼字檢查器和自動完成特性通常依賴動態程式設計來計算字與字之間的編輯距離。
- **財務模式化**：投資策略和投資組合優化經常使用動態程式設計技術。
- **資源分配**：背包問題及其變體出現在排程、預算編列和資源管理中。

## 何時使用動態規劃

你應該考慮在以下情況使用動態程式設計：

- 這個問題可以拆解成重疊的子問題。
- 該問題展現最佳子結構。
- 一個天真的遞迴解法會涉及重複計算。
- 你需要以空間複雜度為代價來最佳化時間複雜度。

# --assignment--

檢視 Python 主題和概念。
