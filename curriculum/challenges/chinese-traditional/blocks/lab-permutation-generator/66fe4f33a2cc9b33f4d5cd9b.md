---
id: 66fe4f33a2cc9b33f4d5cd9b
title: 建置排列產生器
challengeType: 26
dashedName: build-a-permutation-generator
---

# --description--

在這個實驗中，你將建置一個排列產生器，該產生器會接受一個字串並傳回該字串中所有字元的所有可能排列。 例如，字串 `cat` 的可能排列有 `cat`、`cta`、`act`、`atc`、`tac` 和 `tca`。

遞迴建立字串排列組合的方式是透過儲存字串中固定的起始零件（前置式），並建立其餘部分的排列組合。

例如，讓我們考慮字 `machine`。第一輪建立排列組合會將 `m` 固定為字串的前置式，然後建立剩餘字串 `achine` 的排列組合。

對於剩餘的字串，排列組合以相同方式繼續。一個字母被添加到前置式，可能是 `c`，因此前置式變成 `mc`。接著，`ahine` 的每個排列組合都會接到前置式後面。

這會持續直到前置式擁有所有字母，且剩餘的字串為空，這表示已經創建了一個排列組合。

**目標：** 完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 你應該創建一個名為 `permuteString` 的函式（程式）。
2. `permuteString` 函式（程式）應該接受三個參數：一個字串、一個前置式值以及一個用於儲存和傳回結果的空陣列。前置式值應該是一個用來累積字元以形成排列組合的字串。
3. 在函式（程式）內，你應該檢查傳入字串的長度是否為 `0`。如果是，將目前的前置式推入結果中並傳回結果。
4. 對輸入字串中的每個字元進行迭代，並且在每次迭代中，從字串中移除目前的字元，然後使用更新後的引數遞迴呼叫 `permuteString` 函式以建置剩餘的排列組合。
5. 你應該傳回最終結果陣列。
6. 你應該透過移除重複項來確保排列組合是唯一的。

# --hints--

你應該有一個函式 `permuteString`。

```js
assert.isFunction(permuteString);
```

你應該在你的 `permuteString` 函式中使用遞迴。

```js
assert.match(permuteString.toString(), /permuteString\s*\(/);
```

`permuteString("far")` 應該傳回 `[ "far", "fra", "afr", "arf", "rfa", "raf" ]`。

```js
assert.sameMembers(permuteString("far"), [ "far", "fra", "afr", "arf", "rfa", "raf" ]);
```

`permuteString("fcc")` 應該傳回 `[ "fcc", "cfc", "ccf" ]`。

```js
assert.sameMembers(permuteString("fcc"), [ "fcc", "cfc", "ccf" ]);
```

`permuteString("p")` 應該傳回 `[ "p" ]`。

```js
assert.deepStrictEqual(permuteString("p"), ["p"]);
```

`permuteString("")` 應該傳回 `[""]`。

```js
let emptyArr= permuteString("");

// 1 because the empty string is being pushed and is a permutation of itself
assert.lengthOf(emptyArr, 1);

```

`permuteString("walk")` 應該傳回 `["walk", "wakl", "wlak", "wlka", "wkla", "wkal", "awlk", "awkl", "alwk", "alkw", "aklw", "akwl", "lawk", "lakw", "lwak", "lwka", "lkaw", "lkwa", "kawl", "kalw", "kwal", "kwla", "klaw", "klwa"]`。

```js
assert.sameMembers(permuteString("walk"), ["walk", "wakl", "wlak", "wlka", "wkla", "wkal", "awlk", "awkl", "alwk", "alkw", "aklw", "akwl", "lawk", "lakw", "lwak", "lwka", "lkaw", "lkwa", "kawl", "kalw", "kwal", "kwla", "klaw", "klwa"]);
```

`permuteString` 應該傳回正確的結果。

```js
// tests to prevent hard coding
assert.sameMembers(permuteString("road"), [ "road",
  "roda",
  "raod",
  "rado",
  "rdoa",
  "rdao",
  "orad",
  "orda",
  "oard",
  "oadr",
  "odra",
  "odar",
  "arod",
  "ardo",
  "aord",
  "aodr",
  "adro",
  "ador",
  "droa",
  "drao",
  "dora",
  "doar",
  "daro",
  "daor" ]);

assert.sameMembers(permuteString("fog"), [ "fog",
  "fgo",
  "ofg",
  "ogf",
  "gfo",
  "gof" ]);

assert.sameMembers(permuteString("bird"), [ "bird",
  "bidr",
  "brid",
  "brdi",
  "bdir",
  "bdri",
  "ibrd",
  "ibdr",
  "irbd",
  "irdb",
  "idbr",
  "idrb",
  "rbid",
  "rbdi",
  "ribd",
  "ridb",
  "rdbi",
  "rdib",
  "dbir",
  "dbri",
  "dibr",
  "dirb",
  "drbi",
  "drib" ]);

```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
const permuteString = (str, prefix = "", result = []) => {
  if (str.length === 0) {
    result.push(prefix);
    return result;
  }

  // Sort the string initially to group duplicates
  const sortedStr = str.split("").sort().join("");

  for (let i = 0; i < sortedStr.length; i++) {
    if (i > 0 && sortedStr[i] === sortedStr[i - 1]) {
      // Skip duplicate characters
      continue;
    }

    const rem = sortedStr.slice(0, i) + sortedStr.slice(i + 1);
    permuteString(rem, prefix + sortedStr[i], result);
  }

  return result;
};
```
