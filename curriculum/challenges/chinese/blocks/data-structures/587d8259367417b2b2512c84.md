---
id: 587d8259367417b2b2512c84
title: 创建Trie搜索树
challengeType: 1
forumTopicId: 301634
dashedName: create-a-trie-search-tree
---

# --description--

在这里，我们将继续从二叉搜索树开始，看看另一种称为trie的树结构。 Trie 是一种有序的搜索树，通常用于保存字符串，或者更一般的关联数组或动态数据集，其中的键是字符串。 当许多键具有重叠前缀时，它们非常擅长存储数据集，例如，字典中的所有单词。 与二叉树不同，节点不与实际值相关联。 相反，节点的路径表示特定的键。 例如，如果我们想将字符串“code”存储在 trie 中，我们将有四个节点，每个字母对应一个节点：c — o — d — e。 沿着通过所有这些节点的路径将创建代码作为字符串——该路径是我们存储的键。 然后，如果我们想要添加字符串“coding”，它将与“code”共享前三个节点，然后在 d 之后分支出去。 通过这种方式，可以非常紧凑地存储大型数据集。 此外，搜索可以非常快，因为它有效地限制了所存储的字符串的长度。 此外，与二叉树不同，节点可以存储任意数量的子节点。 正如您可能从上面的示例中猜测到的那样，一些元数据通常存储在保存密钥末端的节点上，以便在以后的遍历中仍然可以检索该密钥。 例如，如果我们在上面的例子中添加了代码，我们需要一些方法来知道代码中的 e 表示之前输入的键的末尾。 否则，在添加代码时，此信息将有效地丢失。

# --instructions--

说明：让我们创建一个存储单词的trie。 它将通过 `add` 方法接受单词并将这些单词存储在一个 trie 数据结构中。  It will also allow us to query if a given string is a word with an `isWord` method, and retrieve all the words entered into the trie with a `print` method. `isWord` should return a boolean value and `print` should return an array of all these words as string values. 为了验证此数据结构是否正确实现，我们为树中的每个节点提供了一个 `Node` 结构。 每个节点都是一个带有 `keys` 属性的对象，它是一个 JavaScript Map 对象。 这将保存作为每个节点的有效键的单个字母。 我们还在节点上创建了一个 < code > end </code > 属性，如果节点表示一个单词的终止，那么可以将该属性设置为 < code > true </code > 。

# --hints--

< code > Trie </code > 应该有一个 < code > add </code > 方法。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    return typeof test.add == 'function';
  })()
);
```

< code > Trie </code > 应该有一个 < code > print </code > 方法。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    return typeof test.print == 'function';
  })()
);
```

< code > Trie </code > 应该有一个 < code > add </code > 方法。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    return typeof test.isWord == 'function';
  })()
);
```

< code > print </code > 方法应该返回以字符串形式添加到 trie 中的所有项。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    test.add('jump');
    test.add('jumps');
    test.add('jumped');
    test.add('house');
    test.add('mouse');
    var added = test.print();
    return (
      added.indexOf('jump') != -1 &&
      added.indexOf('jumps') != -1 &&
      added.indexOf('jumped') != -1 &&
      added.indexOf('house') != -1 &&
      added.indexOf('mouse') != -1 &&
      added.length == 5
    );
  })()
);
```

`has` 方法，对于已经添加的项目应该返回 `true`, 缺失的项目返回`false` 。

```js
assert(
  (function testTrie() {
    var test = false;
    if (typeof Trie !== 'undefined') {
      test = new Trie();
    } else {
      return false;
    }
    test.add('hop');
    test.add('hops');
    test.add('hopped');
    test.add('hoppy');
    test.add('hope');
    return (
      test.isWord('hop') &&
      !test.isWord('ho') &&
      test.isWord('hopped') &&
      !test.isWord('hopp') &&
      test.isWord('hoppy') &&
      !test.isWord('hoping')
    );
  })()
);
```

# --seed--

## --seed-contents--

```js
var displayTree = tree => console.log(JSON.stringify(tree, null, 2));
var Node = function() {
  this.keys = new Map();
  this.end = false;
  this.setEnd = function() {
    this.end = true;
  };
  this.isEnd = function() {
    return this.end;
  };
};
var Trie = function() {
  // Only change code below this line
  
  // Only change code above this line
};
```

# --solutions--

```js
// solution required
```
