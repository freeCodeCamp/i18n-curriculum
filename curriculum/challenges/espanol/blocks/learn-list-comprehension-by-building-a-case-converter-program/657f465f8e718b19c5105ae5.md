---
id: 657f465f8e718b19c5105ae5
title: Paso 20
challengeType: 20
dashedName: step-20
---

# --description--

Las comprensiones de listas aceptan declaraciones condicionales, para evaluar la expresión proporcionada solo si se cumplen ciertas condiciones:

```py
spam = [i * 2 for i in iterable if i > 0]
```

Como puedes ver en la salida, la lista de caracteres generada a partir de `pascal_or_camel_cased_string` ha sido unida. Dado que la expresión dentro de la comprensión de listas se evalúa para cada carácter, el resultado es una cadena en minúsculas con todos los caracteres separados por un guion bajo.

Sigue el ejemplo anterior para agregar una cláusula `if` a tu comprensión de listas de modo que la expresión se ejecute solo si el carácter está en mayúscula.

# --hints--

Debes agregar una cláusula `if` con la condición `char.isupper()` a tu comprensión de listas.

```js
({ 
    test: () => assert(runPython(`
    ifs = _Node(_code).find_function("convert_to_snake_case").find_variable("snake_cased_char_list").find_comp_ifs()
    len(ifs) == 1 and ifs[0].is_equivalent("char.isupper()")
    `))
})
```

# --seed--

## --seed-contents--

```py
def convert_to_snake_case(pascal_or_camel_cased_string):
    # snake_cased_char_list = []
    # for char in pascal_or_camel_cased_string:
    #     if char.isupper():
    #       converted_character = '_' + char.lower()
    #       snake_cased_char_list.append(converted_character)
    #     else:
    #         snake_cased_char_list.append(char)
    # snake_cased_string = ''.join(snake_cased_char_list)
    # clean_snake_cased_string = snake_cased_string.strip('_')

    # return clean_snake_cased_string

--fcc-editable-region--
    snake_cased_char_list = ['_' + char.lower() for char in pascal_or_camel_cased_string]
--fcc-editable-region--
    return ''.join(snake_cased_char_list).strip('_')

def main():
    print(convert_to_snake_case('aLongAndComplexString'))

main()
```
