---
id: 6881705cd9860639e98d639d
title: 什么是 N+1 问题？
challengeType: 19
dashedName: what-is-the-n-plus-1-problem
---

# --description--

N+1 问题是数据库驱动应用中常见的性能瓶颈。如果你曾经在使用应用时经历过非常长的装载时间，很可能与 N+1 问题有关。该问题发生在为了获取你请求的数据而执行许多小查询的序列时。

但是为什么你要按序列执行多个查询？你可能这样做是为了查询记录列表及这些记录的附加信息。你会先执行一次初始查询以获取记录列表，然后对每条记录执行额外查询，以获取关于它们的附加信息。

即使你直觉上认为执行许多小而简单的查询比执行一个大而复杂的查询更高效，通常情况并非如此。你执行的查询越多，整个进程所需的时间就越长，因为你需要将每个查询发送到服务器，在数据库中查找数据，然后接收服务器为该查询发送的数据。这可能对你的应用性能产生非常显著的影响。

为了向你展示一个实际的例子，假设你正在开发一个食品配送服务的应用，并且你运行一个查询以获取数据库中前 50 个订单。首先，你将从一个 `orders` 表格中获得包含这些订单的列表，如下所示：

```sql
order_id | product   | quantity | customer_id
1        | pizza     | 2        | 3422
2        | salad     | 1        | 1255
3        | ice cream | 4        | 2344
4        | donuts    | 10       | 3455
.        | .         | .        | .
.        | .         | .        | .
.        | .         | .        | .
```

但是如果你还需要获取提交这些订单的客户的 `data` 呢？这些信息将存储在不同的 `customers` 表格中。

一种方法是先获取订单列表，然后对每个订单运行一次查询以获取客户的信息。要获取订单列表，你可以运行如下查询，从 `orders` 表格中获取前 50 条记录：

```sql
SELECT * FROM orders LIMIT 50;
```

这就是 N+1 中的 1 的来源。它是初始的查询，给你返回记录列表。然后，你需要为这些记录中的每一条执行另一个查询，以获取提交订单的客户信息。为此，你可能会在一个异步的函数中编写一个循环来处理订单和客户。`getCustomerData()` 函数将执行一个 SQL 查询，以获取下单客户的数据。它将对每个下的订单按序列执行此操作：

```js
for (const order of orders) {
  const customerId = order.customer_id;
  const customerData = await getCustomerData(customerId);
  // Process the customer's data.
}
```

这就是 N+1 中的 N 的来源。N 表现为将要执行的查询数量，以获取每条记录的额外数据。

这种方法看起来可能简单直观，但你可能会惊讶地发现这正是你不应该做的。你应该避免在 `loop` 中进行 `query`，因为执行多个小的 `query` 会比执行一个更大、更完整的 `query` 来获取所有 `data` 花费更多时间。

你应该尽量使用 SQL 提供的工具来尽可能减少查询次数。在这种情况下，我们可以使用 `JOIN` 操作将 `orders` 和 `customers` 表格连接起来。

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name AS customer_name,
  customers.email AS customer_email,
  customers.address AS customer_address
FROM orders
JOIN customers ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50)
```

通过 `JOIN` 操作，我们可以仅用一次查询检索数据库中前 50 个订单的数据，包括客户的数据、他们的姓名、电子邮件和地址。看起来可能更复杂，但实际上这样更高效。

现在你知道了 N+1 问题涉及什么，因此你可以识别并防止它，以高效地与你的数据库交互。

# --questions--

## --text--

在 SQL 的上下文中，N+1 问题的主要特征是什么？

## --answers--

单次 `query` 返回过多 `data`。

### --feedback--

考虑通常涉及的查询数量以及首次查询后触发额外查询的触发器。

---

执行一个初始查询，随后执行 N 个用于相关数据的附加查询。

---

数据库索引的低效使用。

### --feedback--

考虑通常涉及的查询数量以及首次查询后触发额外查询的触发器。

---

由并发数据库事务引起的冲突。

### --feedback--

考虑通常涉及的查询数量以及首次查询后触发额外查询的触发器。

## --video-solution--

2

## --text--

N+1 问题的主要性能影响是什么？

## --answers--

由于复杂连接导致数据库服务器上的 CPU 使用率增加。

### --feedback--

考虑应用与数据库之间通信关联的额外开销。

---

由于相关 `data` 不一致导致的 `data` 完整性降低。

### --feedback--

考虑应用与数据库之间通信关联的额外开销。

---

由于大量结果集，应用服务器上的内存消耗较高。

### --feedback--

考虑应用与数据库之间通信关联的额外开销。

---

增加了数据库往返次数，导致装载时间增加。

## --video-solution--

4

## --text--

一种减少检索相关数据时数据库查询次数并避免 N+1 问题的策略包括：

## --answers--

增加数据库连接池大小。

### --feedback--

考虑如何将主 `data` 及其相关 `information` 的检索合并为一次数据库交互。

---

优化单个 `SQL` 查询的速度。

### --feedback--

考虑如何将主 `data` 及其相关 `information` 的检索合并为一次数据库交互。

---

使用 JOIN 子句在初始查询中获取相关数据。

---

实现客户端数据过滤和排序。

### --feedback--

考虑如何将主 `data` 及其相关 `information` 的检索合并为一次数据库交互。

## --video-solution--

3
