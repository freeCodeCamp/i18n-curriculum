---
id: 673403dbf5c9835898632c84
title: 类中的静态属性和方法是什么？
challengeType: 19
dashedName: what-are-static-properties-and-methods-in-classes
---

# --interactive--

静态属性和方法属于类本身，而不属于类的各个实例。你可以直接通过类名访问它们，而无需创建类的实例。它们在类中定义，以封装相关的功能性。

你可以通过在方法名称前写 `static` 关键字来定义静态方法。

```js
class MyClass {
  static staticMethod() { ... }
}
```

然后，你可以直接在类上使用点符号调用静态方法，并传递任何必要的参数：

```js
MyClass.staticMethod();
```

请注意，你可以在不创建该类的实例的情况下调用该方法。这是静态方法的一个关键特征。

这是一个示例。假设我们正在创建一个电影应用，并且我们想要能够根据评分比较电影。

我们可以将这种比较方法视为一种更高级的方法，它不针对任何电影。

```js
if (movieA.rating < movieB.rating) {
  console.log(`${movieB.title} has a higher rating.`);
} 
```

这就像是与 `Movie` 类相关的一个更通用的方法。

为了可读性和维护性，最好在 `Movie` 类中定义它，以使所有相关方法相对集中。

因此，这正是静态方法的理想候选。你可以在这里看到它，就在构造函数下面：

:::interactive_editor

```js
class Movie {

  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }

}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);
console.log(movieA);
```

:::

静态方法使用 `static` 关键字定义，名为 `compareMovies`。它有两个参数：`movieA` 和 `movieB`。这些将是 `Movie` 类的实例。

我们将基于它们的评分，在 `0` 到 `100` 的范围内进行比较。此逻辑通过条件式实现，并将根据哪部电影评分更高打印相应的消息。

一旦方法被定义，你就可以在类上调用它。但首先，你需要在你的程序中准备好并定义参数。

在这种情况下，该方法接受两个电影实例作为参数，因此我们在这里定义这些实例：

```js
let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);
```

你可以看到 `movieA` 的评分高于 `movieB`。让我们看看这个方法的输出。

要调用该方法，你只需对类本身使用点符号。你写出类的名称（`Movie`），后跟一个点，然后是静态方法的名称（`compareMovies`）。

然后，你在括号内传递参数。在这种情况下，它们是该方法所需的两个电影实例。

```js
Movie.compareMovies(movieA, movieB);
```

这是更新后的示例：

:::interactive_editor

```js
class Movie {

  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }

}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);
Movie.compareMovies(movieA, movieB);
console.log(movieA);
```

:::

静态方法对于实现“工厂”方法也很有帮助。工厂方法是你在构造函数之外定义的一个方法，用于根据特定条件创建对象。

这是一个带有 `Pizza` 类的示例。静态方法 `createMargherita` 是一个工厂方法，你可以调用它来创建一个类型和价格已设置好的 Margherita 披萨实例。

```js
class Pizza {
  constructor(type, price) {
    this.type = type;
    this.price = price;
  }

  static createMargherita() {
    return new this("Margherita", 6.99);
  }
}
```

这也引出了关于静态方法的一个非常重要的问题。

静态方法中 `this` 关键字的值是类本身，因为静态方法属于该类。

这就是为什么我们可以使用 `this` 来创建 `Pizza` 类的新实例。

如果你在 `Pizza` 类本身上调用此方法并将返回的实例赋值给一个变量，就像这个例子中一样：

```js
let myPizza = Pizza.createMargherita();
```

你可以在代码中任何需要的地方使用它。例如，你可以将它打印到控制台：

```js
console.log(myPizza);
```

这是输出：

```js
Pizza { type: 'Margherita', price: 6.99 }
```

你也可以使用点表示法来调用它的 `methods` 和访问它的 `properties`，如下所示：

```js
console.log(myPizza.type);
```

这是完整的示例：

:::interactive_editor

```js
class Pizza {
  constructor(type, price) {
    this.type = type;
    this.price = price;
  }

  static createMargherita() {
    return new this("Margherita", 6.99);
  }
}

let myPizza = Pizza.createMargherita();
console.log(myPizza);
console.log(myPizza.type);
```

:::

除了方法，你还可以使用 `static` 关键字定义静态属性。

在此示例中，我们有一个静态的 `numberOfPizzasSold` 属性。

```js
class Pizza {
  static numberOfPizzasSold = 0;

  constructor(type) {
    this.type = type;
    Pizza.numberOfPizzasSold++;
  }
}
```

它是静态的，因为它不属于任何特定的披萨实例，它属于类本身。

它的初始值为 `0`，并且每次创建新建实例时都会更新。

如果你创建两个 pizza 实例，值将被更新两次：

```js
let pizza1 = new Pizza("Margherita");
let pizza2 = new Pizza("Neapolitan");
```

要访问静态属性的值，只需对类本身使用点表示法，因为该属性属于类。

```js
class Pizza {
  static numberOfPizzasSold = 0;

  constructor(type) {
    this.type = type;
    Pizza.numberOfPizzasSold++;
  }
}

let pizza1 = new Pizza("Margherita");
let pizza2 = new Pizza("Neapolitan");

console.log(Pizza.numberOfPizzasSold);
```

在这个分支中，输出是 `2`，因为卖出了两张披萨。

这些是 JavaScript 中静态属性和方法的基础知识。理解静态成员对于创建可重用且高效的类至关重要。

# --questions--

## --text--

JavaScript 类中静态方法的主要目的是什么？

## --answers--

创建该类的新实例。

### --feedback--

考虑静态方法如何与类本身相关，而不是与单个对象相关。

---

访问类实例的属性。

### --feedback--

考虑静态方法如何与类本身相关，而不是与单个对象相关。

---

定义可以在不创建类的实例的情况下访问的方法。

---

从父类继承属性和方法。

### --feedback--

考虑静态方法如何与类本身相关，而不是与单个对象相关。

## --video-solution--

3

## --text--

JavaScript 中静态方法和实例方法的主要区别是什么？

## --answers--

静态方法只能在类内使用，而实例方法可以在类外使用。

### --feedback--

考虑静态和实例方法的作用域和访问。

---

静态方法可以访问实例属性，而实例方法不能访问实例属性。

### --feedback--

考虑静态和实例方法的作用域和访问。

---

静态方法与类本身关联，而实例方法与类的特定实例关联。

---

静态方法始终是公共的，而实例方法可以是公共的或私有的。

### --feedback--

考虑静态和实例方法的作用域和访问。

## --video-solution--

3

## --text--

你如何访问 JavaScript 中一个类的静态属性？

## --answers--

通过使用 `this` 关键字。

### --feedback--

考虑静态属性如何与类本身关联。

---

通过创建类的实例并通过该实例访问属性。

### --feedback--

考虑静态属性如何与类本身关联。

---

通过直接使用类名和属性名。

---

通过使用该类的 `prototype` 属性。

### --feedback--

考虑静态属性如何与类本身关联。

## --video-solution--

3
