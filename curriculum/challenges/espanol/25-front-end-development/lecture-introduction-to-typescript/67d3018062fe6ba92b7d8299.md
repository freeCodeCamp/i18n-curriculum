---
id: 67d3018062fe6ba92b7d8299
title: '¿Cómo funcionan los diferentes tipos en TypeScript?'
challengeType: 19
dashedName: how-do-the-different-types-work-in-typescript
---

# --description--

Ya has visto uno en la lección anterior: `string[]`, que representa un array de cadenas. Pero ¿cómo funciona eso realmente?

Para los tipos de datos primitivos `string`, `null`, `undefined`, `number`, `boolean` y `bigint`, TypeScript ofrece palabras clave de tipo correspondientes. En nuestro ejemplo, estamos usando estos tipos para anotar nuestras variables:

```js
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

Ahora, hemos declarado explícitamente `str` como `string` - lo que podría parecer confuso porque ya le asignamos un valor de cadena, pero esta anotación asegura que no podamos reasignar un tipo de valor diferente (como un número) a esa variable.

Pero ¿qué pasa con los arrays y los objetos? ¡Bueno, ya has visto la sintaxis para un array! Puedes definir un array de tipo específico con dos sintaxis diferentes:

```js
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

Fundamentalmente, estas dos sintaxis son iguales, y la elección entre las dos es generalmente una cuestión de preferencia.

Los objetos se vuelven un poco más complicados. Puedes definir la estructura exacta de un objeto:

```js
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

Esta sintaxis significa que la propiedad `a` debe ser siempre una cadena, la propiedad `b` debe ser siempre un número, y no se pueden añadir ni eliminar propiedades.

¿Pero tal vez no quieres restringir las propiedades? Tal vez quieras un objeto con cualquier clave, pero los valores deben ser cadenas. Hay dos maneras de hacer esto:

```js
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

Al igual que los tipos de array, estos son fundamentalmente similares. Con estos tipos de objeto, debes definir tanto el tipo de las claves como el tipo de los valores. Las claves deben ser siempre cadenas, pero puedes definir tipos de cadena personalizados para restringir aún más esas claves.

Además de estos tipos, TypeScript ofrece otros cuatro tipos útiles. El primero es `any`, que indica que un valor puede tener cualquier tipo. Esto es, efectivamente, el Código Konami de TypeScript - le dice al compilador que deje de preocuparse por el tipo de esa variable y te deja hacer lo que quieras.

El segundo es `unknown`, que generalmente se prefiere sobre `any`. El tipo `unknown` le dice a TypeScript que te importan los tipos de los valores, pero que no sabes cuáles son. Si intentas realizar acciones específicas de tipo (como el operador de resta o el método `slice()` para realizar una operación específica de cadena), TypeScript esperará que reduzcas el tipo de ese valor primero. Aprenderás más sobre el estrechamiento de tipos en una próxima lección.

El tercero es `void`. Este es un tipo especial que típicamente usarás solo al definir funciones. Es efectivamente lo opuesto a `any` - representa la ausencia de cualquier tipo. Las funciones que no tienen un valor de retorno, como `console.log()`, tienen un tipo de retorno `void`.

Finalmente, está el tipo `never`. Probablemente no lo utilizarás con frecuencia - representa un tipo que nunca existirá. Por ejemplo, pasar un objeto simulado a una función en tu suite de pruebas podría ser un buen uso de `never` para indicar que tal objeto nunca se pasaría realmente a la función.

Ampliando sobre estos tipos, tienes acceso a la palabra clave `type`. Esta palabra clave es como `const`, pero en lugar de declarar una variable puedes declarar un tipo:

```js
type myString = string;
```

Esto podría no parecer muy útil por sí solo, pero cuando se asocia con tipos de unión se vuelve poderoso. Un tipo de unión te permite combinar dos o más tipos en uno. Aquí tienes un ejemplo:

```js
type stringOrNumber = string | number;
```

Nuestro tipo `stringOrNumber` se corresponde con valores que son cadenas y valores que son números. Luego, puedes combinar tu tipo con otros tipos, como un array:

```js
const stuff: stringOrNumber[] = ["a", 2, "c", 1000];
```

También puedes definir tipos más estrictos que incluyan solo valores específicos:

```js
type bot = "camperchan" | "camperbot" | "naomi";
type digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
```

Luego podrías combinar esos tipos para crear restricciones más específicas en un objeto:

```js
const artificialIntelligence: Record<bot, digit> = { camperchan: 5 }
```

Aunque si necesitas más control sobre la estructura de un objeto, es probable que recurras a nuestro tipo final: `interface`. Las interfaces son clases efectivamente, pero para los tipos. Pueden implementar o extender otras interfaces, son tipos de objetos específicos y generalmente se prefieren a menos que necesites una característica específica ofrecida por una declaración de tipo.

```js
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

Finalmente, las funciones también pueden tener firmas de tipo. En la lección anterior, viste cómo definir el tipo de un parámetro particular:

```js
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Pero también puedes definir el tipo de retorno de la función.

```js
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

En este ejemplo, le hemos dicho a TypeScript que la función debe devolver una cadena. Si intentamos devolver cualquier otra cosa, TypeScript proporcionará un error de compilación para notificarnos.

Y eso cubre los conceptos básicos del sistema de tipos de TypeScript. Es bastante complejo, y tiene muchas partes móviles, pero a menudo puede ayudar pensar en él como un reflejo de los tipos de JavaScript.

# --questions--

## --text--

¿Cuál de los siguientes NO es un tipo de dato primitivo en TypeScript?

## --answers--

`string`

### --feedback--

Los tipos de datos primitivos son los tipos de datos más básicos disponibles en TypeScript.

---

`number`

### --feedback--

Los tipos de datos primitivos son los tipos de datos más básicos disponibles en TypeScript.

---

`boolean`

### --feedback--

Los tipos de datos primitivos son los tipos de datos más básicos disponibles en TypeScript.

---

`array`

## --video-solution--

4

## --text--

¿Cuál es el propósito del tipo `unknown` en TypeScript?

## --answers--

Permite asignar cualquier tipo de valor sin verificación de tipo.

### --feedback--

A diferencia de `any`, `unknown` requiere un estrechamiento de tipo antes de que se puedan realizar operaciones específicas.

---

Indica que no se conoce el tipo y que se debe restringir antes de usarlo.

---

Representa la ausencia de cualquier tipo.

### --feedback--

A diferencia de `any`, `unknown` requiere un estrechamiento de tipo antes de que se puedan realizar operaciones específicas.

---

Representa un tipo que nunca existirá.

### --feedback--

A diferencia de `any`, `unknown` requiere un estrechamiento de tipo antes de que se puedan realizar operaciones específicas.

## --video-solution--

2

## --text--

¿Qué palabra clave se utiliza para declarar un tipo personalizado en TypeScript?

## --answers--

`interface`

### --feedback--

Esta palabra clave se utiliza para definir un contrato para formas de objetos, no para declarar tipos personalizados.

---

`type`

---

`custom`

### --feedback--

Esta no es una palabra clave válida en TypeScript.

---

`define`

### --feedback--

Esta no es una palabra clave válida en TypeScript.

## --video-solution--

2
