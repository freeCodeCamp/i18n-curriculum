---
id: 697dc755c709772fad37de9d
title: ¿Cómo funcionan Depth First y Breadth First Search?
challengeType: 19
dashedName: how-do-depth-first-and-breadth-first-search-work
---

# --description--

Al comenzar a trabajar con estructuras de datos y algoritmos, pronto te darás cuenta de que una de las operaciones comunes que necesitarás realizar es visitar cada nodo.

Este proceso se conoce como "traversing" la estructura de datos.

Los recorridos se usan para hacer algo con cada nodo en la estructura de datos, como imprimir sus valores, encontrar un valor específico o realizar ciertas operaciones en los nodos.

Al visitar sistemáticamente cada nodo, te aseguras de que el proceso no omita ningún nodo.

¿Pero cómo determinas el orden en el que debes recorrer la estructura de datos? ¿Dónde debería comenzar el proceso y cómo se debe seleccionar el siguiente nodo?

Sin una forma clara de recorrer la estructura de datos, atravesarla sería como caminar por un laberinto sin un camino específico que seguir.

Ahí es donde algoritmos como breadth-first search (BFS) y depth-first search (DFS) se vuelven realmente importantes. Se usan comúnmente para recorrer grafos y para encontrar un camino entre dos nodos.

Cuando se usan para recorrer una estructura de datos, definen el orden en que se deben visitar los nodos para asegurarse de que ninguno sea omitido.

Comencemos con la búsqueda en anchura (BFS).

## Búsqueda en Anchura (BFS)

**Breadth-first search (BFS)** es un algoritmo que visita todos los nodos vecinos antes de pasar al siguiente nivel en el grafo.

Se puede usar para encontrar el camino más corto entre dos nodos en un grafo no ponderado porque analiza todos los nodos en cada nivel, por lo que encuentra primero el camino con menos aristas.

Este algoritmo se implementa comúnmente usando una estructura de datos de cola para llevar un registro de los nodos que han sido visitados. Las colas siguen el método FIFO (first in, first out), donde el primer nodo que se agregó a la cola es el primero en ser eliminado.

El algoritmo funciona así:

* Comienzas en un nodo específico.
    
* Ese nodo está marcado como visitado y agregado a la cola.
    
* Mientras la cola no esté vacía, el nodo actual se elimina de la cola (dequeued). Luego, para cada uno de sus vecinos, si el vecino no ha sido visitado, se marca como visitado y se añade a la cola.
    

Una consideración importante es que, dado que la búsqueda en anchura (BFS) requiere almacenar una cola en memoria, y esta cola puede tener un gran número de nodos, los requisitos de espacio de este algoritmo pueden ser considerables. Esto es especialmente cierto para grafos con un gran número de nodos en el mismo nivel.

Veamos un ejemplo de BFS aplicado a un tipo específico de grafo llamado árbol.

Aprenderás más sobre árboles en una lección próxima, pero esencialmente son grafos sin ciclos, donde los nodos están organizados en una jerarquía. Los ciclos son caminos que comienzan y terminan en el mismo nodo.

Apliquemos el algoritmo de búsqueda en anchura (BFS) a este árbol:

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-1.png" alt="A tree diagram showing nodes A through G arranged in a hierarchy. Node A is at the root, with children B and C. Node B has children D and E, and node C has children F and G.">

**Paso 1:**

Comenzamos en la raíz del árbol, el nodo A. Añadimos A a la cola y lo marcamos inmediatamente como visitado.

* **Cola:** `[A]`
    
* **Visitado:** `{A}`
    

**Paso 2:**

Desencolamos el nodo A. Agregamos sus hijos no visitados (nodo B y luego nodo C) a la cola y los marcamos como visitados.

* **Cola:** `[B, C]`
    
* **Visitados:** `{A, B, C}`
    

El orden en que los nodos en el mismo nivel se agregan a la cola está definido por la implementación de la estructura de datos y el orden en que las aristas (conexiones) se almacenan en la representación del grafo.

Si la implementación es consistente, el orden específico en que se recorren los nodos en el mismo nivel no afectará la corrección del algoritmo. Aún visitará cada nodo nivel por nivel.

**Paso 3:**

Desencolamos el nodo B. Añadimos sus hijos no visitados, (nodo D y luego nodo E), a la cola y los marcamos como visitados.

* **Cola:** `[C, D, E]`
    
* **Visitados:** `{A, B, C, D, E}`
    

**Paso 4:**

Desencolamos el nodo C. Agregamos sus hijos no visitados, (nodo F y luego nodo G), a la cola y los marcamos como visitados.

* **Cola:** `[D, E, F, G]`
    
* **Visitados:** `{A, B, C, D, E, F, G}`
    

**Paso 5:**

Desencolamos el nodo D. Este nodo no tiene hijos no visitados, por lo que no cambia nada en el conjunto de visitados.

* **Cola:** `[E, F, G]`
    
* **Visitados:** `{A, B, C, D, E, F, G}`
    

**Paso 6:**

Desencolamos el nodo E. Este nodo no tiene hijos no visitados, por lo que no cambia nada en el conjunto de visitados.

* **Cola:** `[F, G]`
    
* **Visitados:** `{A, B, C, D, E, F, G}`
    

**Paso 7:**

Desencolamos F. Este nodo no tiene hijos no visitados, por lo que no cambia nada en el conjunto de visitados.

* **Cola:** `[G]`
    
* **Visitados:** `{A, B, C, D, E, F, G}`
    

**Paso 8:**

Desencolamos G. Este nodo no tiene hijos no visitados, por lo que no cambia nada en el conjunto de visitados.

* **Cola:** `[]`
    
* **Visitados:** `{A, B, C, D, E, F, G}`
    

Cuando la cola está vacía, el recorrido está completo.

Los nodos fueron recorridos en este orden:

**A → B → C → D → E → F → G**

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-2.png" alt="The same tree diagram with arrows showing the BFS traversal order: A to B to C to D to E to F to G, demonstrating level-by-level visitation.">

Observa cómo el algoritmo visita los nodos por nivel.

Comenzamos en el nodo A, luego pasamos al siguiente nivel para visitar los nodos B y C, después al siguiente nivel para los nodos D, E, F y G. Ese es el principio básico de la búsqueda en anchura (BFS).

## Búsqueda en profundidad (DFS)

Mientras que la búsqueda en anchura (BFS) primero visita todos los nodos vecinos en el mismo nivel, la **búsqueda en profundidad (DFS)** sigue cada rama tan profundo como sea posible antes de retroceder.

Puedes imaginar este algoritmo como explorar un laberinto eligiendo un camino específico y siguiéndolo hasta que llegues a un callejón sin salida o a la salida. Si llegas a un callejón sin salida, regresas y eliges un camino diferente.

La búsqueda en profundidad (DFS) se usa comúnmente para resolver rompecabezas con una única solución, detectar ciclos en un grafo y encontrar componentes conectados en un grafo.

Este algoritmo puede implementarse usando recursión o una estructura de datos tipo pila para llevar el control de los nodos visitados.

Las pilas siguen el método LIFO (último en entrar, primero en salir), donde el último nodo que se agregó a la pila es el primero en ser removido de la pila.

El algoritmo funciona así:

* Comienza en un nodo específico.
    
* Ese nodo está marcado como visitado y agregado a la pila.
    
* Mientras la pila no esté vacía, el nodo actual se extrae (elimina). Es entonces cuando "visitas" o procesas el nodo (por ejemplo, imprimiendo su valor). Luego, todos sus vecinos no visitados se marcan como visitados y se agregan a la pila.
    

Una de las limitaciones de este algoritmo es que no siempre garantiza encontrar el camino más corto entre dos nodos en un grafo no ponderado.

Veamos un ejemplo de Depth-First Search (DFS) aplicado a nuestro ejemplo de árbol.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-3.png" alt="The same tree diagram as before, showing nodes A through G in their hierarchical structure, ready for DFS demonstration.">

**Paso 1:**

Comenzamos en el nodo raíz A. Lo marcamos como visitado y lo añadimos a la pila.

* **Pila:** `[A]`
    
* **Visitado:** `{A}`
    

**Paso 2:**

Sacamos el nodo A de la pila.

Luego, añadimos sus hijos no visitados, el nodo B y el nodo C, a la pila. Los añadiremos en orden inverso, `C` primero y luego `B`, para que `B` esté en la cima (LIFO) y se procese a continuación. También los marcamos como visitados.

* **Pila:** `[C, B]`
    
* **Visitados:** `{A, B, C}`
    

**Paso 3:**

Sacamos el nodo B de la pila.

Luego, añadimos sus hijos no visitados, el nodo D y el nodo E, a la pila en orden inverso (`E` luego `D`). También los marcamos como visitados.

* **Pila:** `[C, E, D]`
    
* **Visitados:** `{A, B, C, D, E}`
    

**Paso 4:**

Sacamos el nodo D de la pila. Este nodo no tiene hijos para agregar a la pila.

* **Pila:** `[C, E]`
    
* **Visitados:** `{A, B, C, D, E}`
    

**Paso 5:**

Sacamos el nodo E de la pila. Este nodo no tiene hijos para agregar a la pila.

* **Pila:** `[C]`
    
* **Visitados:** `{A, B, C, D, E}`
    

**Paso 6:**

Eliminamos el nodo C.

Luego, añadimos sus hijos, el nodo F y el nodo G, a la pila en orden inverso (nodo G y luego nodo F) y los marcamos como visitados.

* **Pila:** `[G, F]`
    
* **Visitados:** `{A, B, C, D, E, F, G}`
    

**Paso 7:**

Sacamos el nodo F de la pila. Este nodo no tiene hijos para agregar a la pila.

* **Pila:** `[G]`
    
* **Visitados:** `{A, B, C, D, E, F, G}`
    

**Paso 8:**

Extraemos el nodo G. Este nodo no tiene hijos para agregar a la pila.

* **Pila:** `[]`
    
* **Visitados:** `{A, B, C, D, E, F, G}`
    

Cuando la pila está vacía, el recorrido se completa y todos los nodos han sido visitados.

El algoritmo visitó los nodos en este orden:

**A → B → D → E → C → F → G**

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-4.png" alt="The tree diagram with numbers showing the DFS traversal order: A(1), B(2), D(3), E(4), C(5), F(6), G(7), demonstrating depth-first exploration of branches.">

Observa cómo comenzamos en el nodo A, y luego bajamos por todo el árbol hasta el nodo B, y los nodos D y E, antes de subir nuevamente al nodo C y luego a los nodos F y G. Este es el principio central de la búsqueda en profundidad (DFS), recorriendo rutas completas antes de retroceder y encontrar otras rutas.

En este caso, resolvimos este ejemplo usando una pila. Alternativamente, la búsqueda en profundidad (DFS) puede implementarse usando recursión, donde la función procesa el nodo actual y luego se llama a sí misma para cada uno de sus vecinos no visitados. La pila de llamadas de función gestiona implícitamente el orden LIFO (last-in, first-out).

Tanto el algoritmo de búsqueda en anchura (BFS) como el de búsqueda en profundidad (DFS) son algoritmos esenciales para recorrer grafos y árboles. La búsqueda en anchura (BFS) explora los nodos nivel por nivel, lo que es perfecto para encontrar el camino más corto en un grafo no ponderado. Por otro lado, la búsqueda en profundidad (DFS) sigue una rama tan profundo como sea posible antes de retroceder, lo que es ideal para resolver laberintos y detectar ciclos. Entender sus ventajas y desventajas es útil para elegir el adecuado para un problema en particular.

# --questions--

## --text--

¿Cuál de las siguientes estructuras de datos se usa comúnmente para implementar un algoritmo estándar de búsqueda en anchura (BFS)?

## --answers--

Pila

### --feedback--

Piensa en cómo una cola procesa datos y cómo eso se relaciona con visitar nodos nivel por nivel.

---

Cola

---

Lista enlazada

### --feedback--

Piensa en cómo una cola procesa datos y cómo eso se relaciona con visitar nodos nivel por nivel.

---

Árbol

### --feedback--

Piensa en cómo una cola procesa datos y cómo eso se relaciona con visitar nodos nivel por nivel.

## --video-solution--

2

## --text--

¿Cuál de las siguientes afirmaciones sobre la búsqueda en profundidad (DFS) es verdadera?

## --answers--

La búsqueda en profundidad garantiza encontrar el camino más corto entre dos nodos en un grafo no ponderado.

### --feedback--

Piensa en la estrategia que usa depth-first search (DFS) para recorrer la estructura de datos.

---

La búsqueda en profundidad visita todos los vecinos en el nivel actual antes de pasar al siguiente nivel.

### --feedback--

Piensa en la estrategia que usa depth-first search (DFS) para recorrer la estructura de datos.

---

La búsqueda en profundidad siempre es más eficiente en espacio que BFS.

### --feedback--

Piensa en la estrategia que usa depth-first search (DFS) para recorrer la estructura de datos.

---

La búsqueda en profundidad generalmente se implementa usando recursión o una pila.

## --video-solution--

4

## --text--

Si quisieras encontrar el camino más corto desde un nodo inicial hasta un nodo objetivo en un grafo no ponderado, ¿qué algoritmo sería la opción más adecuada?

## --answers--

Búsqueda en anchura (BFS)

---

Búsqueda en profundidad (DFS)

### --feedback--

Piensa en la estrategia central de recorrido de breadth-first search y depth-first search y cuál garantiza encontrar el camino más corto entre dos nodos.

---

Búsqueda binaria

### --feedback--

Piensa en la estrategia central de recorrido de breadth-first search y depth-first search y cuál garantiza encontrar el camino más corto entre dos nodos.

---

Ordenamiento por mezcla

### --feedback--

Piensa en la estrategia central de recorrido de breadth-first search y depth-first search y cuál garantiza encontrar el camino más corto entre dos nodos.

## --video-solution--

1
