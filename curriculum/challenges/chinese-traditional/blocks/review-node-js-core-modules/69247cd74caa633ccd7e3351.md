---
id: 69247cd74caa633ccd7e3351
title: Node.js 核心模組回顧
challengeType: 31
dashedName: review-node-js-core-modules
---

# --description--

## Node.js 核心模組簡介

- **Node.js 核心模組**：隨 Node.js 預先安裝的內建模組，提供檔案操作、密碼學、作業系統互動等基本功能。
- **標準模組**：無需單獨安裝；只要安裝了 Node.js 即可使用。
- **匯入語法**：使用 `require()` 將核心模組匯入你的應用程式。

```javascript
const fs = require("fs");
const crypto = require("crypto");
const os = require("os");
```

## 檔案系統（fs）模組

- **目的**：提供用於處理檔案和資料夾的行為，包括開啟、關閉、讀取、寫入和刪除操作。
- **匯入**：`const fs = require("fs");`
- **彈性**：以三種表單提供的方法：回呼、`promises` 和同步。

### 方法使用樣式

- **非同步與回呼**：預設行為，非阻塞。

```javascript
fs.writeFile("filePath", "content", "utf8", (err) => {
  if (err) throw err;
  console.log("File written to!");
});
```

- **基於 Promises**：現代應用程式的首選，使用 `async/await`。

```javascript
const fs = require("fs/promises");

async function writeToFile() {
  try {
    await fs.writeFile("article.md", "## Node fs Module");
    console.log("File written to!");
  } catch (err) {
    console.error(err);
  }
}
```

- **同步**：阻塞操作，適用於簡單腳本。

```javascript
try {
  fs.writeFileSync("article.md", "## Node fs Module", "utf8");
  console.log("File written to!");
} catch (err) {
  console.error(err);
}
```

### 核心檔案操作

- **`writeFile()` 方法**：創建或覆寫具有指定內容的檔案。

```javascript
await fs.writeFile("article.md", "## Node fs Module: The Complete Guide");
```

- **`appendFile()` 方法**：將內容添加到現有檔案的結尾。

```javascript
await fs.appendFile("article.md", "\n\nIn this article, you will learn...");
```

- **`readFile()` 方法**：讀取檔案的內容。

```javascript
const content = await fs.readFile("article.md", "utf8");
console.log("File content:", content);
```

- **`unlink()` 方法**：從檔案系統中刪除檔案。

```javascript
await fs.unlink("article.md");
console.log("File deleted successfully");
```

### 字元編碼

- **UTF-8 編碼**：指定 `"utf8"` 以將檔案讀取為文字字串。
- **緩衝區格式**：若未指定編碼，檔案將以二進位緩衝區物件讀取。

```javascript
// Returns string
const textContent = await fs.readFile("file.txt", "utf8");

// Returns Buffer
const bufferContent = await fs.readFile("file.txt");
```

## 緩衝區模組

- **目的**：直接在記憶體中處理檔案、影像和網路資料流的二進位資料。
- **匯入**：`const { Buffer } = require("buffer");`
- **使用案例**：檔案輸入輸出、TCP 資料流、影像處理，以及二進位資料操作。

### 緩衝區產生

- **`Buffer.from()` 方法**：從字串、陣列或其他資料創建 buffer。

```javascript
// From string
const myStrBuffer = Buffer.from("freeCodeCamp");
console.log(myStrBuffer); // <Buffer 66 72 65 65 43 6f 64 65 43 61 6d 70>

// From array of numbers
const myNumBuffer = Buffer.from([70, 82, 69, 69, 67, 79, 68, 69, 67, 65, 77, 80]);
```

- **`Buffer.alloc()` 方法**：創建指定大小且填充為零的緩衝區。

```javascript
const someBuffer = Buffer.alloc(10);
console.log(someBuffer); // <Buffer 00 00 00 00 00 00 00 00 00 00>
```

### 緩衝區操作

- **類陣列存取**：使用索引表示法存取單一緩衝區元素。

```javascript
console.log(myStrBuffer[0]); // 102 (byte value for 'f')
```

- **`toString()` 方法**：將緩衝區轉換為可讀取的字串。

```javascript
console.log(myStrBuffer.toString()); // "freeCodeCamp"
```

- **`Buffer.write()` 方法**：將資料寫入已配置的緩衝區。

```javascript
someBuffer.write("Hello fCC");
console.log(someBuffer.toString()); // "Hello fCC"
```

- **`Buffer.byteLength()` 方法**：傳回儲存字串所需的位元組數。

```javascript
console.log(Buffer.byteLength("Hello freeCodeCamp")); // 18
```

### 額外的緩衝區方法

- **`Buffer.isBuffer()`**：檢查物件是否為緩衝區。
- **`Buffer.compare()`**：比較兩個緩衝區並傳回排序順序。
- **`Buffer.concat()`**：將多個緩衝區合併為一個。

## 加密模組

- **目的**：提供密碼學功能，包括雜湊、加密、解密和數位簽名。
- **匯入**：`const crypto = require("crypto");`
- **安全注意**：在生產環境的身份驗證中使用經過充分測試的函式庫，如 `bcrypt` 或 `jsonwebtoken`。

### 雜湊方法

- **`createHash()` 方法**：使用像 SHA256、SHA512 或 MD5 的演算法產生單向雜湊。

```javascript
const hashedPassword = crypto
  .createHash("sha256")
  .update("myPassword123")
  .digest("hex");

console.log("createHash result:", hashedPassword);
```

- **`createHmac()` 方法**：使用祕密金鑰創建用於驗證和資料完整性的雜湊。

```javascript
const hashedMessage = crypto
  .createHmac("sha256", "secret-key")
  .update("Hello World")
  .digest("hex");
```

### 加密與解密

- **`createCipheriv()` 和 `createDecipheriv()` 方法**：使用演算法、金鑰和初始化向量來加密和解密資料。

```javascript
const key = Buffer.from("12345678901234567890123456789012"); // 32 bytes for AES-256
const iv = Buffer.from("1234567890123456"); // 16 bytes for AES

// Encryption
const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
let encrypted = cipher.update("Hello campers!", "utf8", "hex");
encrypted += cipher.final("hex");

// Decryption
const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
let decrypted = decipher.update(encrypted, "hex", "utf8");
decrypted += decipher.final("utf8");
```

### 隨機值產生

- **`randomBytes()` 方法**：產生密碼學安全的隨機位元組。

```javascript
console.log("Random Bytes:", crypto.randomBytes(16).toString("hex"));
// Output: a6154ef5a296fa176ad0f332bd94d712
```

- **`randomInt()` 方法**：在指定範圍內產生安全的隨機整數。

```javascript
console.log("Random Int:", crypto.randomInt(0, 100)); // Random number 0-99
```

### 金鑰管理

- **`createSecretKey()` 方法**：從未經處理的位元組生成加密金鑰物件。

```javascript
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export().toString('hex'));
```

### 數位標記

- **`sign()` 和 `verify()` 方法**：使用私鑰/公鑰配對創建並驗證數位簽名。
- **使用案例**：證明資料的真實性和完整性。

### 額外的加密方法

- **`createPublicKey()` 和 `createPrivateKey()`**：處理外部產生的金鑰。
- **`createDiffieHellman()`**：啟用安全的共享祕密生成。
- **`Certificate()`**：控制 HTTPS 證書的操作行為。

## 作業系統模組

- **目的**：提供與作業系統相關的工具，用於系統資訊和跨平台相容性。
- **匯入**：`const os = require("os");`
- **使用案例**：系統監控、跨平台腳本、硬體資訊。

### 系統資訊方法

- **`platform()` 方法**：傳回作業系統平台。

```javascript
console.log(os.platform()); // 'darwin', 'win32', 'linux', etc.

// Cross-platform usage
if (os.platform() === 'win32') {
  // Windows-specific code
} else {
  // Unix-like systems
}
```

- **`arch()` 方法**：傳回 CPU 架構。

```javascript
console.log(os.arch()); // 'arm64', 'x64', 'arm', 'ia32', etc.
```

- **`type()` 方法**：傳回官方作業系統名稱。

```javascript
console.log(os.type()); // 'Darwin', 'Linux', 'Windows_NT'
```

### 版本資訊

- **`release()` 方法**：顯示（作業系統）核心版本。

```javascript
console.log(os.release()); // '25.0.0'
```

- **`version()` 方法**：傳回詳細的作業系統版本資訊。

```javascript
console.log(os.version());
// Darwin Kernel Version 25.0.0: Wed Sep 17 21:41:39 PDT 2025
```

### 硬體資訊

- **`cpus()` 方法**：傳回 CPU 核心資訊的陣列。

```javascript
console.log(os.cpus()); // Array of CPU core objects with model, speed, times
```

- **`uptime()` 方法**：傳回系統運行時間（秒）。

```javascript
console.log(os.uptime()); // 23047 (seconds since system boot)
```

### 記憶體資訊

- **`totalmem()` 方法**：傳回系統總記憶體的位元組數。
- **`freemem()` 方法**：傳回系統中可用的記憶體位元組數。

## 最佳實務

### 效率考量

- **避免同步方法**：在生產應用程式中使用非同步方法以防止阻塞。
- **優先使用 Promises**：使用基於 promises 的 API 搭配 `async/await`，以撰寫更乾淨、易於維護的程式碼。
- **錯誤處理**：務必使用 try-catch 區塊或錯誤回呼來實作適當的錯誤處理。

### 安全指引

- **Crypto 模組**：使用既有的函式庫進行驗證，而非建置訂製的加密解決方案。
- **輸入驗證**：驗證檔案路徑和使用者輸入以防止安全漏洞。
- **金鑰管理**：安全地儲存加密金鑰，切勿將它們硬編碼在原始碼中。

### 跨平台開發

- **OS 模組使用**：使用 OS 模組方法以達成跨平台相容性。
- **路徑處理**：使用 `path` 模組進行跨平台檔案路徑操作。
- **環境變數**：檢查平台特定的環境變數和設定。

## 常見使用案例

### 檔案操作

- 設定檔案管理
- 日誌檔案的產生與維護
- 資料匯出/匯入功能
- 模板處理程序

### 資料安全

- 用於使用者驗證的密碼雜湊
- 敏感資訊的資料加密
- 會話的隨機語彙單元產生
- 數位標記驗證

### 系統整合

- 跨平台應用程式部署
- 系統資源監控
- 硬體相容性檢查
- 基於系統能力的效率優化

# --assignment--

檢視 Node.js 核心模組的主題和概念。
