---
id: 695cc8f280fef0cc3bed02c8
title: 什麼是 Crypto 模組以及它如何運作？
challengeType: 19
dashedName: what-is-the-crypto-module-and-how-does-it-work
---

# --description--

Crypto 是另一個內建於 Node.js 的核心模組。它包含用於雜湊、加密、解密和建立數位標記等工具，這些工具都用來保護敏感資訊並維持你的應用程式安全。

話雖如此，`crypto` 給你的是低層次的建置區塊，而非即插即用的安全性。如果你不小心，自己撰寫加密或驗證程式碼可能會不安全。在大多數情況下，最好使用經過充分測試的函式庫，例如用於密碼雜湊的 `bcrypt` 或用於處理登入和語彙單元的 `jsonwebtoken`（JWT）。

話雖如此，了解 `crypto` 模組中某些方法的運作方式仍然很有用。

要使用這些方法，你需要匯入 `crypto` 模組：

```js
const crypto = require("crypto");
```

有些方法用於資料轉換目的，例如用於雜湊和加密資料的方法，有些則用於金鑰和安全管理，例如用於產生隨機值和建立秘密的方法。

我們先來看看用於雜湊和加密資料的 `methods`。

`createHash()` 方法透過接收像是 `sha256`、`sha512` 或 `md5` 的演算法來創建一個雜湊物件。這是一個單向操作，因此你無法反轉它。

`createHash()` 對於雜湊密碼和指紋辨識檔案非常有用。要使用它，你需要傳入你的演算法，使用 `update()` 方法來輸入資料，最後使用帶有編碼的 `digest()` 來取得雜湊值：

```js
const crypto = require("crypto");

const hashedPassword = crypto
  .createHash("sha256")
  .update("myStrongPassword")
  .digest("hex");

console.log("createHash result:", hashedPassword);
// createHash result: f92c9cfa0ead1bcec05ca75888a4074ba994ad237e5e2a8c7cc6a620378c061d
```

`createHmac()` 幾乎與 `createHash()` 做相同的事情，但它透過接受一個祕密金鑰將功能提升到下一個層級，因此只有擁有該金鑰的人才能驗證雜湊值。它非常適合用於驗證和確認資料完整性：

```js
const crypto = require("crypto");

const hashedMessage = crypto
  .createHmac("sha256", "secretkey")
  .update("important-secret-message")
  .digest("hex");

console.log("createHmac result:", hashedMessage);
// createHmac result: da48d6f026b6036286b1fb872c63264130d5cc4271f3a213bb6ddca5a023e77e
```

`createCipheriv()` 和 `createDecipheriv()` 方法用於加密和解密資料。它們都會接收一個演算法、一個金鑰，以及一個 `iv`，`iv` 是一個隨機或唯一的區塊資料，用於加密過程的開始：

```js
createCipheriv(algorithm, key, iv);
createDecipheriv(algorithm, key, iv);
```

要解密資料，金鑰必須相同，否則解密將失敗，你將會收到錯誤或是無法閱讀的亂碼，而非原始訊息。

以下是兩者的實際運作：

```js
const crypto = require("crypto");

// A key must match the algorithm length. Here AES-256 is 32 bytes
const key = Buffer.from("12345678901234567890123456789012");

// A fixed IV, 16 bytes for AES
const iv = Buffer.from("1234567890123456");

const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);

let encrypted = cipher.update("Hello campers!", "utf8", "hex");
encrypted += cipher.final("hex");

console.log("Encrypted data:", encrypted);
// Encrypted data: 4ee93aa398ab44e3540e4a67ca96bc8c

// Decrypt the "Hello campers!" message
const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
let decrypted = decipher.update(encrypted, "hex", "utf8");
decrypted += decipher.final("utf8");

console.log("Decrypted data:", decrypted);
// Decrypted data: Hello campers!
```

另一種用於資料轉換的加密方法是 `sign()` 和 `verify()`。 

`sign()` 使用私鑰從某些資料中創建數位標記。此標記證明該資料來自私鑰持有者且未被篡改。

`verify()` 然後檢查該標記，如果資料或標記不匹配則失敗。

現在，讓我們來看看用於產生隨機值和建立秘密的加密方法。

`randomBytes()` 接收一個 `size` 並產生加密安全的語彙單元。這使它非常適合用來產生 UUID（通用唯一識別碼）。此外，它也是 `Math.random()` 的良好替代方案，因為後者對語彙單元和金鑰來說並不安全。

```js
console.log("Random Bytes:", crypto.randomBytes(16));
// Random Bytes: <Buffer 01 88 aa 1e 2c 38 48 39 26 e1 6b a9 d8 c5 ed 49>
```

輸出預設為緩衝區。如你在 Buffer 模組課程中所學，你可以使用 `toString()` 方法將該緩衝區轉換為字串：

```js
console.log("Random Bytes:", crypto.randomBytes(16).toString("hex"));
// Random Bytes: a6154ef5a296fa176ad0f332bd94d712
```

這裡 `toString('hex')` 中的 `'hex'` 引數告訴 Node 將 Buffer 的二進位資料編碼為十六進位字串。

`randomInt()` 方法接受 `min` 和 `max` 值，並在它們之間產生一個安全的隨機整數。它對於 OTP 和隨機選擇非常有用。

```js
console.log("Random Int:", crypto.randomInt(0, 100)); // 89
```

再次強調，這個方法相較於 `Math.random()` 和 `Math.floor()` 的升級之處在於它在底層使用了密碼學安全的隨機性，因此攻擊者無法預測產生的隨機數。

另一個方法是 `createSecretKey()`。它接受一個緩衝區並產生一個包裝在 `KeyObject` 中的未經處理的位元組：

```js
const crypto = require("crypto");

const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret); // SecretKeyObject [KeyObject] { [Symbol(kKeyType)]: 'secret' }
```

你接著可以使用 `export` 方法來匯出該 `KeyObject`：

```js
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export());
// <Buffer 53 06 a1 c7 75 69 8b 38 8b a4 b2 f7 1b bc b8
// ae e2 d1 bf 67 af 1a 6a 0a 6e a0 29 62 bb 52 52 32>
```

最後，對緩衝區使用 `toString()` 以查看它的字串表現：

```js
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export().toString('hex'));
// 32dfe5917668580160986f1623bf8152913329c71163be9c3404a110cd78efd6
```

除了這些之外，還有：

- `createPublicKey()` 和 `createPrivateKey()`，讓你可以使用其他地方產生的金鑰
- `createDiffieHellman()` 讓雙方在不直接傳送秘密的情況下產生共享秘密。
- `Certificate()` 用於處理 HTTPS 中使用的憑證，因此你可以解析、匯出及驗證憑證內容。

# --questions--

## --text--

以下哪一種方式是匯入 Node.js crypto 模組的正確方法？

## --answers--

`const crypto = require('crypto')`

---

`const crypto = import('crypto')`

### --feedback--

專注於 Node.js 用於引入內建模組的語法。

---

`import crypto from 'nodes:crypto'`

### --feedback--

專注於 Node.js 用於引入內建模組的語法。

---

`crypto = requireModule('crypto')`

### --feedback--

專注於 Node.js 用於引入內建模組的語法。

## --video-solution--

1

## --text--

關於 `sign()` 和 `verify()`，以下哪一個述語是正確的？

## --answers--

`sign()` 使用公鑰來創建標記，`verify()` 使用私鑰來檢查它。

### --feedback--

請記住，數位簽名是與私鑰–公鑰配對一起運作的。

---

`sign()` 和 `verify()` 都只需要私鑰。

### --feedback--

請記住，數位簽名是與私鑰–公鑰配對一起運作的。

---

`sign()` 使用私鑰創建數位標記，`verify()` 使用對應的公鑰進行驗證。

---

`verify()` 可以在不需要任何金鑰的情況下檢查標記。

### --feedback--

請記住，數位簽名是與私鑰–公鑰配對一起運作的。

## --video-solution--

3

## --text--

加密模組中，哪個方法會使用像 `sha256`、`sha512` 或 `md5` 這類演算法來創建單向雜湊物件？

## --answers--

`createCipheriv()`

### --feedback--

這個方法經常用於對密碼進行雜湊以及對檔案進行指紋辨識。

---

`createDiffieHellman()`

### --feedback--

這個方法經常用於對密碼進行雜湊以及對檔案進行指紋辨識。

---

`createSign()`

### --feedback--

這個方法經常用於對密碼進行雜湊以及對檔案進行指紋辨識。

---

`createHash()`

## --video-solution--

4
