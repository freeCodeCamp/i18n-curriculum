---
id: 67c2bbd476f6e540b4c0b0d4
title: Revisión de Estado y Hooks de React
challengeType: 31
dashedName: review-react-state-and-hooks
---

# --description--

## Trabajando con Eventos en React

- **Sistema de Eventos Sintéticos**: Esta es la forma en que React maneja los eventos. Sirve como un envoltorio alrededor de los eventos nativos como los eventos de `click`, `keydown` y `submit`. Los manejadores de eventos en React utilizan la convención de nomenclatura de camel casing. (Ej. `onClick`, `onSubmit`, etc.)

Aquí hay un ejemplo de uso del atributo `onClick` para un elemento `button` en React:

```jsx
function handleClick() {
  console.log("Button clicked!");
}

<button onClick={handleClick}>Click Me</button>;
```

En React, las funciones manejadoras de eventos usualmente comienzan con el prefijo `handle` para indicar que son responsables de manejar eventos, como `handleClick` o `handleSubmit`.

Cuando una acción del usuario dispara un evento, React pasa un objeto de Evento Sintético a tu manejador. Este objeto se comporta mucho como el objeto Evento nativo en JavaScript puro, proporcionando propiedades como `type`, `target` y `currentTarget`.

Para prevenir comportamientos predeterminados como la actualización del navegador durante un evento `onSubmit`, por ejemplo, puedes llamar al método `preventDefault()`:

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("Form submitted!");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>Submit</button>
</form>;
```

También puedes envolver una función manejadora en una función de flecha de esta forma:

```jsx
function handleDelete(id) {
  console.log("Deleting item:", id);
}

<button onClick={() => handleDelete(1)}>Delete Item</button>;
```

## Trabajando con Estado y el Hook `useState`

- **Definición de estado**: En React, el estado es un objeto que contiene datos para un componente. Cuando el estado se actualiza, el componente se volverá a renderizar. React trata el estado como inmutable, lo que significa que no debe modificarlo directamente.
- **`useState()` Hook**: El hook `useState` es una función que te permite declarar variables de estado en componentes funcionales.  Aquí está una sintaxis básica:

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

En la variable de estado tienes lo siguiente:

- `stateVariable` contiene el valor actual del estado
- `setStateFunction` (la función que establece) actualiza la variable de estado
- `initialValue` establece el estado inicial

Aquí está un ejemplo completo para un componente `Counter`:

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

## Renderizando y Componentes de React

- **Definición**: En React, el renderizado es el proceso por el cual los componentes aparecen en la interfaz de usuario (UI), generalmente en el navegador. El proceso de renderizado consta de tres etapas: activación, renderizado y compromiso.

La etapa de activación ocurre cuando React detecta que algo ha cambiado y la interfaz de usuario (UI) podría necesitar ser actualizada. Este cambio a menudo se debe a una actualización en el estado o en las propiedades.

Una vez que se activa algo, React entra en la etapa de renderización. Aquí, React vuelve a evaluar tus componentes y determina qué mostrar. Para hacer esto, React utiliza una copia ligera del "DOM real" llamada DOM virtual. Con el DOM virtual, React puede verificar rápidamente qué necesita cambiar en el componente.

La etapa de compromiso es donde React toma los cambios preparados del DOM virtual y los aplica al DOM real. En otras palabras, esta es la etapa donde ves el resultado final en la pantalla.

## Actualizando Objetos y Arrays en el Estado

- **Actualizando Objetos en el Estado**: Si necesitas actualizar un objeto en el estado, debes crear un nuevo objeto o copiar un objeto existente primero, y luego establecer el estado para ese nuevo objeto. Cualquier objeto puesto en el estado debe considerarse como de solo lectura. Aquí está un ejemplo de cómo establecer el nombre, la edad y la ciudad de un usuario. La función `handleChange` se usa para manejar actualizaciones de la información del usuario:

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **Actualizando Arrays en el Estado**: Al actualizar arrays en el estado, es importante no modificar directamente el array usando métodos como `push()` o `pop()`. En cambio, deberías crear un nuevo array al actualizar el estado:

```js
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

Si quieres eliminar elementos de un array, deberías usar el método `filter()`, que devuelve un nuevo array después de filtrar lo que quieres eliminar:

```js
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## Referenciando Valores Usando Refs

- **Atributo `ref`**: Puedes acceder a un nodo del DOM en React usando el atributo `ref`. Aquí está un ejemplo para mostrar un `ref` para enfocar un elemento `input`. Se utiliza la propiedad `current` para acceder al valor actual de ese `ref`:

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Focus;
```

## Trabajando con el Hook `useEffect`

- **Hook `useEffect()`**: En React, un efecto es cualquier cosa que sucede fuera del proceso de renderizado de un componente. Es decir, cualquier cosa que React no maneja directamente como parte del renderizado de la UI. Ejemplos comunes incluyen la obtención de datos, la actualización del título de la pestaña del navegador, la lectura o escritura en el almacenamiento local del navegador, la obtención de la ubicación del usuario y mucho más. Estas operaciones interactúan con el mundo exterior y se conocen como efectos secundarios. React proporciona el hook `useEffect` para que puedas manejar estos efectos secundarios. `useEffect` te permite ejecutar una función después de que el componente se renderice o actualice.

```js
import { useEffect } from "react";

useEffect(() => {
 // Your side effect logic (usually a function) goes here
}, [dependencies]);
```

La función de efecto se ejecuta después de que el componente se renderice, mientras que el argumento opcional `dependencies` controla cuándo se ejecuta el efecto.

Ten en cuenta que `dependencies` puede ser un array de "valores reactivos" (estado, propiedades, funciones, variables, etc.), un array vacío, o omitirse completamente. Así es como todas esas opciones controlan cómo funciona `useEffect`:

- Si `dependencies` es un array que incluye uno o más valores reactivos, el efecto se ejecutará cada vez que cambien.

- Si `dependencies` es un array vacío, `useEffect` solo se ejecuta una vez cuando el componente se renderiza por primera vez.

- Si omites `dependencies`, el efecto se ejecuta cada vez que el componente se renderiza o actualiza.

## Cómo Crear Hooks Personalizados

- **Hooks Personalizados**: Un hook personalizado te permite extraer lógica reutilizable de los componentes, como la obtención de datos, la gestión de estado, alternar y efectos secundarios como rastrear el estado en línea. En React, todos los hooks incorporados comienzan con la palabra `use`, por lo que tu hook personalizado debe seguir la misma convención.

Aquí está un ejemplo de creación de un hook `useDebounce`:

```js
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

# --assignment--

Revisa los temas y conceptos de estado y hooks de React.
