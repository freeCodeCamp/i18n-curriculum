---
id: 692aba0a78ca391f10455b4b
title: ¿Cómo funcionan las importaciones y exportaciones con los módulos CommonJS?
challengeType: 19
dashedName: how-do-imports-and-exports-work-with-commonjs-modules
---

# --description--

En el desarrollo web moderno, puedes dividir tu código en múltiples archivos llamados "módulos".

Puedes pensar en un módulo como un bloque de código autónomo y reutilizable.

Al importar módulos en otros módulos, puedes reutilizar su funcionalidad mientras mantienes el código en archivos separados, lo que es más mantenible, especialmente para aplicaciones web grandes y complejas.

En Node.js, cada archivo se considera un módulo.

Node tiene dos sistemas diferentes para trabajar con módulos: CommonJS y ES.

CommonJS es la forma original y predeterminada de trabajar con paquetes en Node.js. Carga módulos de manera síncrona, lo que significa que tiene que esperar a que un módulo se cargue completamente antes de comenzar a cargar el siguiente o continuar ejecutando el código.

Todavía se usa mucho, pero gradualmente está siendo reemplazado por la sintaxis más nueva de ES.

CommonJS usa la función `require()` para importar un módulo, tomando su ruta relativa como argumento.

Por ejemplo, digamos que tenemos un módulo llamado `math.js`, donde definimos operaciones matemáticas básicas.

Solo usaremos una función de multiplicación aquí para mantener este ejemplo simple y enfocado:

```js
function multiply(a, b) {
  return a * b;
}
```

¿Cómo podemos reutilizar esta función fuera de nuestro módulo actual? Por defecto, las funciones y variables definidas en un módulo de Node.js son **privadas** — otros módulos no pueden acceder a ellas a menos que las exportemos explícitamente. Hay varias formas de hacerlo.

Una forma común es asignar un valor a `module.exports`. Este objeto representa lo que el módulo devolverá cuando se importe en otro lugar, dando a otros módulos acceso a las funciones, variables u objetos que has elegido exponer.

En este ejemplo, asignamos un objeto con una propiedad `multiply` a `module.exports`. El valor de esa propiedad es una referencia a la función `multiply` que definimos anteriormente. Esto exportará la función, para que podamos llamarla desde otros módulos si la necesitamos.

```javascript
function multiply(a, b) {
  return a * b;
}

module.exports = {
  multiply: multiply
};
```

Supongamos que intentamos importar el módulo `math.js` en otro módulo. Llamamos a la función `require()` y pasamos la ruta relativa como argumento. Luego, asignamos el objeto devuelto por `require()` a la variable `math`.

```javascript
const math = require('./math');
```

Vamos a revisar el valor de `math` en la consola imprimiéndolo con `console.log()`:

```javascript
console.log(math);
```

Esta es la salida. Es un objeto con una propiedad `multiply` y una función como valor:

```javascript
{ multiply: [Function: multiply] }
```

Si llamamos a esta función con `math.multiply()`, pasando los números `6` y `7` como argumentos, la salida es `42`. La función se ejecuta correctamente y, sin embargo, ¡está en otro archivo! Así que nuestra declaración de importación funcionó correctamente.

```javascript
const math = require('./math');

console.log(math.multiply(6, 7)); // 42
```

Pero hay otras formas de exportar una función, variable u objeto.

Por ejemplo, si solo necesitas exportar una función, variable u objeto, puedes asignarla directamente como el valor de `module.exports`:

```javascript
function multiply(a, b) {
  return a * b;
}

module.exports = multiply;
```

Si necesitas exportar múltiples funciones, solo tienes que agregarlas al objeto `module.exports`, separadas por una coma.

Aquí, puedes ver que el objeto exportado tiene dos propiedades: `subtract` y `multiply`. Sus valores son referencias a sus funciones correspondientes, por lo que tendrás acceso a ambas en cualquier módulo que importe `math.js`:

```javascript
function subtract(a, b) {
  return a - b;
}

function multiply(a, b) {
  return a * b;
}

module.exports = {
  subtract: subtract,
  multiply: multiply
};
```

Cuando el objeto `module.exports` tiene múltiples propiedades, tendrás la opción de elegir si quieres importar todo o importar las propiedades individualmente.

En este ejemplo, estamos importando el objeto completo que fue exportado por `math.js`, así que tendremos acceso tanto a `subtract` como a `multiply`:

```javascript
const math = require('./math');

console.log(math.subtract(6, 7));  // -1
console.log(math.multiply(6, 7));  // 42
```

Si solo queremos importar `multiply`, simplemente necesitamos escribir su nombre dentro de llaves, después de la palabra clave `const`. Básicamente, estás usando la sintaxis de asignación por desestructuración para obtener su valor del objeto exportado. Luego, podemos referirnos a él directamente por su nombre en nuestro código:

```javascript
const { multiply } = require('./math');

console.log(multiply(6, 7));
```

Esto también funciona para múltiples elementos. Solo necesitas separarlos con una coma dentro de las llaves. Aquí, estamos importando tanto las funciones `subtract` como `multiply`:

```javascript
const { subtract, multiply } = require('./math');
```

Por defecto, Node.js tratará lo siguiente como módulos CommonJS:

* Archivos con una extensión `.cjs`.
    
* Archivos con extensión `.js` cuando el archivo `package.json` padre más cercano contiene un campo de nivel superior `"type"` con un valor de `"commonjs"`.
    
* Archivos con una extensión `.js` o sin extensión, cuando el archivo `package.json` padre más cercano no contiene un campo de nivel superior `"type"`, o no hay ningún `package.json` en ninguna carpeta padre.
    
* Archivos con una extensión que no sea `.mjs`, `.cjs`, `.json`, `.node` o `.js`.
    

Aunque los módulos ES están reemplazando gradualmente a los módulos CommonJS, entenderlos sigue siendo esencial para los desarrolladores que trabajan con bases de código Node.js existentes y muchos paquetes npm.

# --questions--

## --text--

¿Qué función se usa para importar módulos en CommonJS?

## --answers--

`import()`

### --feedback--

Piensa en qué palabra clave se usa para importar código externo en entornos Node.js.

---

`require()`

---

`export()`

### --feedback--

Piensa en qué palabra clave se usa para importar código externo en entornos Node.js.

---

`include()`

### --feedback--

Piensa en qué palabra clave se usa para importar código externo en entornos Node.js.

## --video-solution--

2

## --text--

¿Cuál de las siguientes es la forma principal de exportar un módulo en CommonJS?

## --answers--

`export default`

### --feedback--

Piensa en qué objeto se usa para definir qué hace disponible un módulo a otros archivos.

---

`module.exports`

---

`export const`

### --feedback--

Piensa en qué objeto se usa para definir qué hace disponible un módulo a otros archivos.

---

`import from`

### --feedback--

Piensa en qué objeto se usa para definir qué hace disponible un módulo a otros archivos.

## --video-solution--

2

## --text--

¿Qué tipo de carga usa CommonJS?

## --answers--

Carga asíncrona

### --feedback--

¿El código espera a que un módulo se cargue completamente antes de reanudar su ejecución?

---

Carga diferida

### --feedback--

¿El código espera a que un módulo se cargue completamente antes de reanudar su ejecución?

---

Carga síncrona

---

Carga condicional

### --feedback--

¿El código espera a que un módulo se cargue completamente antes de reanudar su ejecución?

## --video-solution--

3
