---
id: 69162d64f96574d9bb629efc
title: "挑戰 111：球的軌跡"
challengeType: 29
dashedName: challenge-111
---

# --description--

今天的挑戰靈感來自於於 1972 年 11 月 29 日發行的遊戲 Pong。

給定一個矩陣（陣列的陣列），其中包含球的位置（`2`）和球的先前位置（`1`），傳回球下一個位置的矩陣索引。

- 球總是沿直線移動。
- 移動方向由球從 `1` 移動到 `2` 的方式決定。
- 矩陣的邊緣被視為牆壁。如果球撞到：
  - 當碰到頂部或底部牆壁時，它會透過反轉其垂直方向來反彈。
  - 當碰到左邊或右邊牆壁時，它會透過反轉其水平方向來反彈。
  - 在角落，它會透過反轉兩個方向來反彈。

# --hints--

`get_next_location([[0,0,0,0], [0,0,0,0], [0,1,2,0], [0,0,0,0]])` 應該傳回 `[2, 3]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(get_next_location([[0,0,0,0], [0,0,0,0], [0,1,2,0], [0,0,0,0]]), [2, 3])`)
}})
```

`get_next_location([[0,0,0,0], [0,0,1,0], [0,2,0,0], [0,0,0,0]])` 應該傳回 `[3, 0]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(get_next_location([[0,0,0,0], [0,0,1,0], [0,2,0,0], [0,0,0,0]]), [3, 0])`)
}})
```

`get_next_location([[0,2,0,0], [1,0,0,0], [0,0,0,0], [0,0,0,0]])` 應該傳回 `[1, 2]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(get_next_location([[0,2,0,0], [1,0,0,0], [0,0,0,0], [0,0,0,0]]), [1, 2])`)
}})
```

`get_next_location([[0,0,0,0], [0,0,0,0], [2,0,0,0], [0,1,0,0]])` 應該傳回 `[1, 1]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(get_next_location([[0,0,0,0], [0,0,0,0], [2,0,0,0], [0,1,0,0]]), [1, 1])`)
}})
```

`get_next_location([[0,0,0,0], [0,0,0,0], [0,0,1,0], [0,0,0,2]])` 應該傳回 `[2, 2]`。

```js
({test: () => { runPython(`
from unittest import TestCase
TestCase().assertEqual(get_next_location([[0,0,0,0], [0,0,0,0], [0,0,1,0], [0,0,0,2]]), [2, 2])`)
}})
```

# --seed--

## --seed-contents--

```py
def get_next_location(matrix):

    return matrix
```

# --solutions--

```py
def get_next_location(matrix):
    prev = None
    curr = None

    for r in range(len(matrix)):
        for c in range(len(matrix[0])):
            if matrix[r][c] == 1:
                prev = (r, c)
            if matrix[r][c] == 2:
                curr = (r, c)

    prev_row, prev_col = prev
    curr_row, curr_col = curr

    dir_x = curr_col - prev_col
    dir_y = curr_row - prev_row

    next_row = curr_row + dir_y
    next_col = curr_col + dir_x

    max_row = len(matrix) - 1
    max_col = len(matrix[0]) - 1

    if next_col < 0 or next_col > max_col:
        dir_x *= -1
    if next_row < 0 or next_row > max_row:
        dir_y *= -1

    next_row = curr_row + dir_y
    next_col = curr_col + dir_x

    return [next_row, next_col]
```
