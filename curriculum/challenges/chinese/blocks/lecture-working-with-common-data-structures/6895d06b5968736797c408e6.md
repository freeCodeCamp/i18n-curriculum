---
id: 6895d06b5968736797c408e6
title: 单向链表如何工作以及它们与双向链表有何不同？
challengeType: 19
dashedName: how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list
---

# --description--

**链表** 是一种线性数据结构，其中每个节点都连接到序列中的下一个节点。

这些连接创建了一个看起来像节点链的 数据结构，其中每个节点保存数据和对链表中下一个节点的引用。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-1.png" alt="linked list basic structure visualization">

我们使用这些引用从第一个节点跳转到下一个节点，依此类推。

链表通常用于实现其他数据结构，例如栈、队列和双端队列。它们也可以用于实现基本的图算法，例如深度优先搜索和广度优先搜索。

## 单向链表

**单向链表** 是一种链表类型，其中每个节点都连接到序列中的下一个节点。

每个节点通过存储对下一个节点的引用来连接。

每个节点只有一个引用，这使你能够从开始到结束单向遍历链表。

查找只能向前移动，不能向后移动。

在此示例中，你将从头节点 `node A` 开始。

**head** 节点是链表中的第一个节点。

在单向链表中，头节点通常是唯一可以直接访问的节点。当你尝试查找特定节点时，查找进程将从这里开始。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-2.webp" alt="singly linked list traversal visualization">

该进程将从节点 A 开始，然后继续到节点 B，再到节点 C，最后到 **tail** 节点。如果你在代码中实现了特定逻辑，它也可能在此之前停止。

**tail** 节点是最后一个节点。它用于确定进程何时已到达链表的末尾。

### **插入节点**

链表的一个优点是它们没有固定大小。只需更新节点之间的连接，就可以根据需要扩展或缩小。

你可以在链表的开始、中间和末尾**插入**节点。

链表不一定需要以特定顺序保存节点。顺序将由节点之间的连接决定。

但是，如果你确实需要为你的特定用例保持节点的特定顺序，你可以通过在你的代码中实现该逻辑来做到这一点，而你实现的条件将决定节点是插入在开始、中间还是结尾。

要在链表的开头插入一个节点，你只需为新节点和原来的头节点创建一个连接，并将新节点设为头节点。

这是一个示例，我们在开头插入节点 E 并将此新节点设为链表的头节点。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-3.png" alt="singly linked list insert at beginning visualization">

在链表开头插入节点具有常量时间复杂度 `O(1)`，因为它只需要更新对头节点的引用以及新头节点与序列中下一个节点之间的连接。

在这个例子中，我们将节点 E 插入到链表的开头。这将正常工作。但如果我们想保持链表按字母顺序排序，节点 E 则必须插入到链表的末尾。

要在链表末尾插入节点，首先你需要到达末尾，然后将连接添加到新节点，使其成为新的尾节点。

此操作具有线性时间复杂度，`O(n)`，其中 n 是链表中保存的节点数，因为首先你需要到达链表的末尾进行插入，这需要从一个节点到下一个节点，依此类推直到到达末尾。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-4.png" alt="singly linked list insert at end visualization">

如果节点必须插入到链表的中间某处，节点之间的连接也必须更新。序列中的前一个节点应连接到新建节点，新建节点应连接到下一个节点，如下图所示。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-5.webp" alt="singly linked list insert in middle visualization">

插入操作具有常量空间复杂度 `O(1)`，因为插入新节点只需创建它并更新节点之间的连接。此操作不依赖于链表本身的大小。

### **移除节点**

正如你可以插入节点一样，你也可以从链表的开始、中间和结尾删除它们。

要从开头移除一个节点，你需要更新对头节点的引用，该引用应指向序列中的下一个节点。

此操作具有常量时间复杂度 `O(1)`，因为它只需要更新链表对头节点的引用。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-6.png" alt="singly linked list remove from beginning visualization">

要从链表的中间移除一个节点，你需要更新前一个节点的引用，将其连接到序列中的下一个节点，形成它们之间的一种“桥梁”，如图所示。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-7.png" alt="singly linked list remove from middle visualization">

这将从连接序列中移除你想要移除的节点，在这个分支中是节点 B，因此下次遍历时不会到达它。

要从链表的末尾删除一个节点，你需要删除前一个节点的连接，并使该节点成为新的尾节点。现在链表将以新的尾节点结束。

此操作具有线性时间复杂度 `O(n)`，因为你首先必须到达链表的末尾。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-8.png" alt="singly linked list remove from end visualization">

删除操作具有常量空间复杂度 `O(1)`，因为删除节点不需要额外的内存。

## 双向链表

既然你已经了解了更多关于单向链表的内容，现在让我们来谈谈双向链表。

在**双向链表**中，每个节点保存两个引用：一个指向序列中下一个节点的引用，和一个指向上一个节点的引用。

这意味着双向链表可以双向遍历。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-9.webp" alt="doubly linked list structure visualization">

在这种类型的链表中，通常也会在链表本身中保留对尾节点的引用，以便在必要时从末尾开始遍历。

听起来很棒，对吧？它们比单链表更灵活。

然而，双向链表确实比单向链表需要更多的内存，因为每个节点保存 **两个** 引用，而不是一个。

当你为你的项目选择合适的数据结构时，这是你应该牢记的事情。

确实存在权衡。

插入和删除操作完全相同。唯一的区别是现在你需要更新每个节点的两个引用，并跟踪尾节点的引用，以便在双向链表的末尾高效地插入元素，并在必要时从后面开始遍历进程。

单向链表和双向链表是计算机科学中用于以循序的顺序存储和操作元素的基本数据结构。理解它们的区别对于为你的特定应用选择合适的链表至关重要。

# --questions--

## --text--

什么是链表？

## --answers--

一种将元素保存于连续内存块中的数据结构。

### --feedback--

考虑链表中节点是如何连接的。

---

一种通过引用连接节点的数据结构。

---

一个始终排序的 数据结构。

### --feedback--

考虑链表中节点是如何连接的。

---

具有固定大小的数据结构。

### --feedback--

考虑链表中节点是如何连接的。

## --video-solution--

2

## --text--

单链表和双链表有什么区别？

## --answers--

单向链表有头节点和尾节点，而双向链表没有。

### --feedback--

考虑每种链表中包含的引用。

---

单向链表只能向一个方向遍历，而双向链表可以向两个方向遍历。

---

单向链表在末尾插入元素更高效，而双向链表在开头插入元素更高效。

### --feedback--

考虑每种链表中包含的引用。

---

单向链表比双向链表需要更多内存。

### --feedback--

考虑每种链表中包含的引用。

## --video-solution--

2

## --text--

在单向 `Linked list` 开头插入节点的时间复杂度是多少？

## --answers--

`O(1)`

---

`O(n)`

### --feedback--

考虑在链表开头插入节点所需的操作数量。

---

`O(n^2)`

### --feedback--

考虑在链表开头插入节点所需的操作数量。

---

`O(log n)`

### --feedback--

考虑在链表开头插入节点所需的操作数量。

## --video-solution--

1

