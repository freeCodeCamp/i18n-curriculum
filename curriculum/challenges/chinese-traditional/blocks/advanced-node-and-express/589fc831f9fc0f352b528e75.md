---
id: 589fc831f9fc0f352b528e75
title: 透過發射進行通訊
challengeType: 2
forumTopicId: 301550
dashedName: communicate-by-emitting
---

# --description--

<dfn>Emit</dfn> 是你最常使用的溝通方式。當你從伺服端向 `io` 發出時，你會將事件的名稱和資料傳送給所有已連接的插口。這個概念的一個好例子是，每當有新使用者連接時，發出目前連接使用者的計數！

在你目前監聽連接之前，先添加一個變數來追蹤使用者。

```js
let currentUsers = 0;
```

現在，當有人連接時，你應該在發出計數之前先遞增計數。因此，你會想要將遞增器添加到 `connection` 監聽器中。

```js
++currentUsers;
```

最後，在遞增計數後，你應該觸發該事件（仍在連線監聽器內）。該事件應命名為 'user count'，資料應該只是 `currentUsers`。

```js
io.emit('user count', currentUsers);
```

現在，你可以為你的客戶端實作一種方式來監聽這個事件！類似於在伺服端監聽連線，你將使用 `on` 關鍵字。

```js
socket.on('user count', function(data) {
  console.log(data);
});
```

現在，嘗試載入你的應用程式，進行驗證，你應該會在你的客戶端主控台看到 '1'，表現目前的使用者數量！嘗試載入更多客戶端並進行驗證，以看到數字上升。

當你認為頁面已經正確時，請提交你的頁面。如果你遇到錯誤，你可以<a href="https://forum.freecodecamp.org/t/advanced-node-and-express/567135#communicate-by-emitting-7" target="_blank" rel="noopener noreferrer nofollow">查看至此為止完成的專案</a>。

# --hints--

應該定義 `currentUsers`。

```js
  const url = new URL("/_api/server.js", code);
  const res = await fetch(url);
  const data = await res.text();
  assert.match(
    data,
    /currentUsers/s,
    'You should have variable currentUsers defined'
  );
```

伺服端應在每次新連線時發出當前使用者數量。

```js
  const url = new URL("/_api/server.js", code);
  const res = await fetch(url);
  const data = await res.text();
  assert.match(
    data,
    /io.emit.*('|")user count('|").*currentUsers/s,
    'You should emit "user count" with data currentUsers'
  );
```

你的客戶端應該在監聽 `'user count'` 事件。

```js
  const url = new URL("/public/client.js", code);
  const res = await fetch(url);
  const data = await res.text();
  assert.match(
    data,
    /socket.on.*('|")user count('|")/s,
    'Your client should be connection to server with the connection defined as socket'
  );
```

