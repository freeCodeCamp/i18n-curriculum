---
id: 5a24c314108439a4d4036156
title: 使用中介層來控制非同步動作
challengeType: 6
forumTopicId: 301451
dashedName: use-middleware-to-handle-asynchronous-actions
---

# --description--

到目前為止，這些挑戰都避免討論非同步動作，但它們是網頁開發中無法避免的部分。在某個時候，你需要在你的 Redux 應用程式中呼叫非同步端點，那麼你要如何控制代碼這些類型的請求？Redux 提供專門為此目的設計的中介層，稱為 Redux Thunk 中介層。以下是如何在 Redux 中使用它的簡要說明。

要包含 Redux Thunk 中介層，你將它作為引數傳遞給 `Redux.applyMiddleware()`。接著，這個述語會作為第二個選用參數提供給 `createStore()` 函式。請查看編輯器底部的程式碼以了解此用法。然後，為了創建非同步動作，你在動作產生器中傳回一個函式，該函式以 `dispatch` 作為引數。在這個函式內，你可以分派動作並執行非同步請求。

在此範例中，使用 `setTimeout()` 呼叫模擬非同步請求。通常會在啟動任何非同步行為之前分派一個動作，讓你的應用程式狀態知道正在請求某些資料（例如，這個狀態可以顯示載入圖示）。然後，一旦你收到資料，就會分派另一個動作，該動作攜帶資料作為有效負載以及動作已完成的資訊。

請記住你正在將 `dispatch` 作為參數傳遞給這個特殊的 action creator。這就是你用來分派你的 actions 的方式，你只需將 action 直接傳遞給 `dispatch`，中介層會處理其餘的部分。

# --instructions--

在 `handleAsync()` action creator 中撰寫兩個分派。在 `setTimeout()`（模擬的 API 呼叫）之前分派 `requestingData()`。然後，在你收到（假裝的）資料後，分派 `receivedData()` action，並傳入這些資料。現在你知道如何在 Redux 中控制非同步 action。其他一切繼續如往常般運作。

# --hints--

`requestingData` action creator 應該傳回一個型別相等於 `REQUESTING_DATA` 值的物件。

```js
assert(requestingData().type === REQUESTING_DATA);
```

`receivedData` action creator 應該傳回一個型別與 `RECEIVED_DATA` 值相等的物件。

```js
assert(receivedData('data').type === RECEIVED_DATA);
```

`asyncDataReducer` 應該是一個函式（程式）。

```js
assert(typeof asyncDataReducer === 'function');
```

分派 `requestingData` action creator 應該會將 store `state` 的 fetching 屬性更新為 `true`。

```js
assert(
  (function () {
    const initialState = store.getState();
    store.dispatch(requestingData());
    const reqState = store.getState();
    return initialState.fetching === false && reqState.fetching === true;
  })()
);
```

分派 `handleAsync` 應該先分派資料請求動作，然後在延遲後分派接收到的資料動作。

```js
assert(
  (function () {
    const noWhiteSpace = __helpers.removeWhiteSpace(handleAsync.toString());
    return (
      noWhiteSpace.includes('dispatch(requestingData())') === true &&
      noWhiteSpace.includes('dispatch(receivedData(data))') === true
    );
  })()
);
```

# --seed--

## --seed-contents--

```js
const REQUESTING_DATA = 'REQUESTING_DATA'
const RECEIVED_DATA = 'RECEIVED_DATA'

const requestingData = () => { return {type: REQUESTING_DATA} }
const receivedData = (data) => { return {type: RECEIVED_DATA, users: data.users} }

const handleAsync = () => {
  return function(dispatch) {
    // Dispatch request action here

    setTimeout(function() {
      let data = {
        users: ['Jeff', 'William', 'Alice']
      }
      // Dispatch received data action here

    }, 2500);
  }
};

const defaultState = {
  fetching: false,
  users: []
};

const asyncDataReducer = (state = defaultState, action) => {
  switch(action.type) {
    case REQUESTING_DATA:
      return {
        fetching: true,
        users: []
      }
    case RECEIVED_DATA:
      return {
        fetching: false,
        users: action.users
      }
    default:
      return state;
  }
};

const store = Redux.createStore(
  asyncDataReducer,
  Redux.applyMiddleware(ReduxThunk.default)
);
```

# --solutions--

```js
const REQUESTING_DATA = 'REQUESTING_DATA'
const RECEIVED_DATA = 'RECEIVED_DATA'

const requestingData = () => { return {type: REQUESTING_DATA} }
const receivedData = (data) => { return {type: RECEIVED_DATA, users: data.users} }

const handleAsync = () => {
  return function(dispatch) {
    dispatch(requestingData());
    setTimeout(function() {
      let data = {
        users: ['Jeff', 'William', 'Alice']
      }
      dispatch(receivedData(data));
    }, 2500);
  }
};

const defaultState = {
  fetching: false,
  users: []
};

const asyncDataReducer = (state = defaultState, action) => {
  switch(action.type) {
    case REQUESTING_DATA:
      return {
        fetching: true,
        users: []
      }
    case RECEIVED_DATA:
      return {
        fetching: false,
        users: action.users
      }
    default:
      return state;
  }
};

const store = Redux.createStore(
  asyncDataReducer,
  Redux.applyMiddleware(ReduxThunk.default)
);
```
