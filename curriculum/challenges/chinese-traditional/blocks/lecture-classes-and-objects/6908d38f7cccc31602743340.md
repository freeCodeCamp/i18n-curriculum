---
id: 6908d38f7cccc31602743340
title: 如何動態控制代碼物件屬性？
challengeType: 19
dashedName: how-to-handle-object-attributes-dynamically
---

# --description--

在之前的課程中，你學到了屬性是屬於物件的變數。這表示它們保存描述物件狀態或行為的資料。

例如，汽車通常會有品牌和型號。品牌和型號可以成為 `Car` 類別的屬性：

```python
class Car: 
    def __init__(self, brand, model): 
        self.brand = brand 
        self.model = model 

my_car = Car('Lamborghini', 'Gallardo') 
print(my_car.brand) # Lamborghini 
print(my_car.model) # Gallardo 
```

但有時候，你可能不知道你需要哪些屬性，直到你的程式正在執行。想像你正在撰寫一個腳本，該腳本從使用者或設定檔案接收屬性名稱。那些不是你可以事先硬編碼的屬性。

這就是動態處理屬性發揮作用的地方。透過這種方式，你可以使用屬性的名稱作為變數來存取、修改、檢查甚至刪除屬性，而不是在你的程式碼中使用固定名稱。這為你的程式提供了彈性，能夠即時回應不同的資料或使用者輸入。

Python 提供你四個方便的內建函式（程式）來動態操作物件屬性。它們是 `getattr()`、`setattr()`、`hasattr()` 和 `delattr()`。

它們讓你使用變數名稱來存取、創建、檢查和移除屬性。讓我們來看看每一個的實際操作。 

`getattr()` 讓你能在執行期才知道名稱時，從物件讀取屬性。如果該屬性不存在，會引發 `AttributeError`，除非你提供預設值。

要使用它，你需要傳入物件、屬性名稱，以及選用的預設值： 

```python
getattr(object, attribute_name, default_value) 
```

這裡有一個範例：

```python
class Person: 
    def __init__(self, name, age): 
        self.name = name 
        self.age = age 

person = Person('John Doe', 30) 
 
print(getattr(person, 'name')) # John Doe 
print(getattr(person, 'age')) # 30 
print(getattr(person, 'city', 'Milano')) # Milano
```

在上述範例中，`Milano` 是預設值，因為 `city` 不存在於 `Person` 類別中。 

如同我們先前所說，`getattr()` 的真正威力在於屬性名稱來自變數時顯現，例如來自使用者輸入或某個檔案。

在那種情況下，你無法使用一般的 `object.attribute_name` 語法，因為屬性名稱不是固定的。

```python
class Person: 
    def __init__(self, name, age): 
        self.name = name 
        self.age = age 

person = Person('John Doe', 30)

attr_name = input('Enter the attribute you want to see: ')
print(getattr(person, attr_name, 'Attribute not found'))
```

在這種情況下，如果使用者輸入 `name`，他們會看到 `John Doe`，如果他們輸入 `age`，他們會看到 `30`。如果他們輸入類別中不存在的東西，例如 `email`，他們會看到 `Attribute not found`。

這正是動態屬性處理發揮作用的地方。它讓你的程式碼能夠回應之前未曾見過的輸入和資料。

此外，你可能想查看物件擁有的所有屬性，而不只是你已經知道的那些。內建的 `dir()` 函式讓你可以做到這一點。它會傳回物件上所有屬性名稱的列表。以下是使用方法：

```python
class Person: 
    def __init__(self, name, age): 
        self.name = name 
        self.age = age 

person = Person('John Doe', 30)

# Loop through all attributes of the person object with dir() function
for attr in dir(person):
    # Ignore dunder methods like __init__ or __str__ and regular methods
    if not attr.startswith('__') and not callable(getattr(person, attr)): 
        value = getattr(person, attr)
        print(f'{attr}: {value}')

# Output
# age: 30
# name: John Doe
```

`setattr()` 函式（程式）讓你動態地創建新的屬性或更新現有的屬性。語法如下： 

```python
setattr(object, attribute_name, value) 
```

這是一個範例，根據某些設定或環境變數檔案中的資料設定 config 屬性： 

```python
class Configuration:
    pass

# Data loaded at runtime (like from a config or env file)
settings_data = {
    'server_url': 'https://api.example.com',
    'timeout_sec': 30,
    'max_retries': 5
}

config_obj = Configuration()

# Dynamically set attributes using dictionary keys and values
for attr_name, attr_value in settings_data.items():
    setattr(config_obj, attr_name, attr_value)

print(config_obj.server_url) # https://api.example.com
print(config_obj.timeout_sec) # 30
```

還有 `hasattr()`。在你對屬性做某些操作或刪除它之前，檢查它是否存在是一個良好的習慣。這就是 `hasattr()` 所能做到的。它會檢查屬性是否存在，並根據結果傳回 `True` 或 `False`。 

以下是基本語法：

```python
hasattr(object, attribute_name)  
```

以下是一個範例，動態檢查 `Product` 類別實體中屬性的存在性：

```python
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price

product_a = Product('T-Shirt', 25)

required_attributes = ['name', 'price', 'inventory_id']

for attr in required_attributes:
    if not hasattr(product_a, attr):
        print(f"ERROR: Product is missing the required attribute: '{attr}'")
    else:
        # Access the attributes dynamically once their existence is confirmed
        print(f'{attr}: {getattr(product_a, attr)}')

# Output:
# name: T-Shirt
# price: 25
# ERROR: Product is missing the required attribute: 'inventory_id'
```

錯誤輸出發生是因為 `Product` 類別及其實體中缺少 `inventory_id`。

最後，`delattr()` 讓你動態移除屬性： 

```python
delattr(object, attribute_name) 
```

例如，想像一個物件已經被完全處理程序，然後你決定在儲存最終版本之前清理任何可能存在的敏感或暫時屬性。之後，你可以使用 `dir()` 來迴圈瀏覽剩餘的屬性：

```python
class UserSession:
    def __init__(self, user_id, token):
        self.user_id = user_id
        self.auth_token = token # sensitive
        self.temp_counter = 0 # temporary

session = UserSession(101, 'a1b2c3d4e5')

# List of attributes to remove dynamically before "saving" the session
attributes_to_clean = ['auth_token', 'temp_counter']

# Dynamically remove specified attributes
for attr in attributes_to_clean:
    if hasattr(session, attr):
        delattr(session, attr)
        print(f'Removed attribute: {attr}')

print('\nFinal attributes remaining:')

# Loop through the remaining attributes with dir()
for attr in dir(session):
    # Ignore dunder methods like __init__ or __str__ and regular methods
    if not attr.startswith('__') and not callable(getattr(session, attr)):
        print(f' - {attr}: {getattr(session, attr)}')

# Output:
# Removed attribute: auth_token
# Removed attribute: temp_counter

# Final attributes remaining:
#  - user_id: 101
```

這就是你如何動態控制代碼屬性的方法！

# --questions--

## --text--

**Python 中的** `getattr()` **函式（程式）允許你做什麼？**

## --answers--

在執行期名稱未知時，從物件讀取屬性。

---

從物件中刪除屬性。

### --feedback--

思考哪個函式（程式）能幫助你動態*取得*屬性。

---

在物件上設定新的屬性。

### --feedback--

思考哪個函式（程式）能幫助你動態*取得*屬性。

---

檢查物件中是否存在某個屬性。

### --feedback--

思考哪個函式（程式）能幫助你動態*取得*屬性。

## --video-solution--

1

## --text--

為什麼你會想要在 Python 中動態控制代碼物件屬性？

## --answers--

自動將屬性轉換為列表。

### --feedback--

思考如何動態回應使用者輸入或外部資料。

---

在執行期使屬性成為唯讀。

### --feedback--

思考如何動態回應使用者輸入或外部資料。

---

為了減少創建的類別屬性數量。

### --feedback--

思考如何動態回應使用者輸入或外部資料。

---

要處理名稱直到執行期才知道的屬性。

## --video-solution--

4

## --text--

在 Python 中檢查物件是否具有特定屬性的正確語法是什麼？

## --answers--

`checkattr(object, attribute_name)`

### --feedback--

想想哪個函式名稱字面上暗示「有屬性」。

---

`hasattr(object, attribute_name)`

---

`setattr(object, attribute_name)`

### --feedback--

想想哪個函式名稱字面上暗示「有屬性」。

---

`getattr(object, attribute_name)`

### --feedback--

想想哪個函式名稱字面上暗示「有屬性」。

## --video-solution--

2
