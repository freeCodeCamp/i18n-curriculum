---
id: 6881705cd9860639e98d639d
title: 什麼是 N+1 問題？
challengeType: 19
dashedName: what-is-the-n-plus-1-problem
---

# --description--

N+1 問題是資料庫驅動應用程式中常見的效率瓶頸。如果你曾經在使用應用程式時遇到非常長的載入時間，很可能與 N+1 問題有關。當為了取得你請求的資料而連續執行許多小查詢時，就會發生這個問題。

但是為什麼你會連續執行多個查詢？你可能會這麼做是為了查詢一個記錄列表以及關於那些記錄的額外資訊。你會先執行初始查詢以取得記錄列表，然後對每一筆記錄執行額外查詢，以取得關於它們的額外資訊。

即使你直覺上認為執行許多小且簡單的查詢會比執行一個大型且複雜的查詢更高效，通常情況並非如此。你執行的查詢越多，整個處理程序所需的時間就越長，因為你需要將每個查詢傳送到伺服器、在資料庫中尋找資料，然後接收伺服器針對該查詢所傳送的資料。這可能對你的應用程式造成非常顯著的效率、性能影響。

為了向你展示一個實際的範例，假設你正在開發一個外送服務的應用程式，並且你執行一個查詢以取得資料庫中前 50 筆訂單。首先，你會從 `orders` 資料表取得這些訂單的列表，如下所示：

```sql
order_id | product   | quantity | customer_id
1        | pizza     | 2        | 3422
2        | salad     | 1        | 1255
3        | ice cream | 4        | 2344
4        | donuts    | 10       | 3455
.        | .         | .        | .
.        | .         | .        | .
.        | .         | .        | .
```

但是如果你還需要取得提交這些訂單的客戶的資料呢？這些資訊會儲存在不同的 `customers` 表格中。

一種方法是先取得訂單列表，然後對每筆訂單執行一個查詢以取得客戶的資訊。要取得訂單列表，你可以執行像這樣的查詢，以從 `orders` 資料表中取得前 50 筆記錄：

```sql
SELECT * FROM orders LIMIT 50;
```

這就是 1 in N+1 的由來。這是初始查詢，會給你記錄的列表。然後，你需要對這些記錄中的每一筆執行另一個查詢，以取得提交訂單的客戶資訊。為此，你可能會在非同步函式中撰寫一個迴圈，以處理訂單和客戶。`getCustomerData()` 函式（程式）將執行 SQL 查詢，以取得下特定訂單的客戶資料。它會依序對每筆訂單執行此操作：

```js
for (const order of orders) {
  const customerId = order.customer_id;
  const customerData = await getCustomerData(customerId);
  // Process the customer's data.
}
```

這就是 N+1 中的 N 來源。N 表示將對每一筆記錄執行以取得額外資料的查詢數量。

這種方法看起來可能簡單且直覺，但你可能會驚訝地發現這正是你不應該做的。你應該避免在迴圈中進行查詢，因為執行多次小型查詢會比執行一次較大的查詢以取得所有資料花費更多時間。

你應該嘗試使用 SQL 提供給你的工具，以盡可能減少查詢次數。在這種情況下，我們可以使用 `JOIN` 操作來連接 `orders` 和 `customers` 資料表。

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name AS customer_name,
  customers.email AS customer_email,
  customers.address AS customer_address
FROM orders
JOIN customers ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50)
```

使用 `JOIN` 操作，我們可以只用一個查詢就取得資料庫中前 50 筆訂單的資料，包括客戶的資料、他們的姓名、電子郵件和位址。這看起來可能比較複雜，但這樣其實更高效。

現在你知道 N+1 問題涉及什麼，因此你可以識別並防止它，以高效地與你的資料庫互動。

# --questions--

## --text--

在 SQL 的背景關係中，N+1 問題的主要特徵是什麼？

## --answers--

單一查詢中傳回過多資料。

### --feedback--

請考慮通常涉及的查詢數量以及第一次之後觸發額外查詢的條件。

---

執行一個初始查詢，接著執行 N 個額外的查詢以取得相關資料。

---

資料庫索引的低效使用。

### --feedback--

請考慮通常涉及的查詢數量以及第一次之後觸發額外查詢的條件。

---

由並行資料庫交易引起的衝突。

### --feedback--

請考慮通常涉及的查詢數量以及第一次之後觸發額外查詢的條件。

## --video-solution--

2

## --text--

N+1 問題的主要效率、性能影響是什麼？

## --answers--

由於複雜的連接，資料庫伺服器上的 CPU 使用率增加。

### --feedback--

考慮應用程式與資料庫之間通訊相關的額外負擔。

---

由於相關資料不一致導致的資料完整性降低。

### --feedback--

考慮應用程式與資料庫之間通訊相關的額外負擔。

---

由於大量結果集，應用程式伺服端的記憶體消耗較高。

### --feedback--

考慮應用程式與資料庫之間通訊相關的額外負擔。

---

增加資料庫往返次數，導致載入時間增加。

## --video-solution--

4

## --text--

一種在擷取相關資料時減少資料庫查詢次數並避免 N+1 問題的策略包括：

## --answers--

增加資料庫連接池大小。

### --feedback--

思考如何將主要資料及其相關資訊的擷取合併為一次資料庫互動。

---

優化單一 `SQL` 查詢的速度。

### --feedback--

思考如何將主要資料及其相關資訊的擷取合併為一次資料庫互動。

---

使用 JOIN 語句在初始查詢中擷取相關資料。

---

實作客戶端資料篩選和排序。

### --feedback--

思考如何將主要資料及其相關資訊的擷取合併為一次資料庫互動。

## --video-solution--

3
