---
id: 68d275dd800f404d22a07564
title: 实现深度优先搜索算法
challengeType: 27
dashedName: lab-depth-first-search
---

# --description--

在本实验中，你将实现一种称为 <dfn>深度优先搜索</dfn> 的图遍历算法。

而 <dfn>广度优先搜索</dfn> 是从源节点开始按边的增量长度进行查找，<dfn>深度优先搜索</dfn> 则首先沿着一条边的路径尽可能深入。

一旦到达路径的一端，搜索将回溯到具有未访问边缘路径的最后一个节点并继续搜索。

与广度优先查找不同，每次访问一个节点时，它不会访问所有邻居。相反，它首先访问其中一个邻居，并沿着该路径继续，直到该路径上没有更多节点可访问。

要实现这个算法，你需要使用一个栈（一个数组，其中最后添加的元素是第一个被移除的，遵循 <dfn>后进先出</dfn> 原则）。栈在深度优先搜索算法中非常有用，因为当你将邻居添加到栈中时，你希望先访问最近添加的邻居并将它们从栈中移除。

该算法的简单输出是可从给定节点到达的节点列表。 因此，在实施此算法时，你需要跟踪你已经访问过的节点。

**目标**：完成以下用户故事并通过所有测试以完成实验。

**用户故事：**

1. 你应该有一个名为 `dfs` 的函数。
1. `dfs` 函数应接受两个参数：
   - 一个无向的邻接矩阵。
   - 节点标签，是节点的数值，介于 `0` 和 `n - 1` 之间，其中 `n` 是图中节点的总数。
1. `dfs` 函数应实现深度优先搜索算法，以输出从传入节点可达的所有节点的列表。

# --hints--

你应该有一个名为 `dfs` 的函数，它接受两个参数。

```js
({ test: () => runPython(`
  import inspect
  assert inspect.isfunction(dfs)
  sig = inspect.signature(dfs)
  assert len(sig.parameters) == 2
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1)` 应返回包含 `1`、`2`、`3` 和 `0` 的列表。

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1)
  assert isinstance(result, list)
  assert len(result) == 4
  assert set(result) == {1, 2, 3, 0}
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3)` 应该返回一个包含 `1`、`2`、`3` 和 `0` 的列表。

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3)
  assert isinstance(result, list)
  assert len(result) == 4
  assert set(result) == {3, 2, 1, 0}
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], 3)` 应该返回 `[3]`。

```js
({ test: () => runPython(`
  assert dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], 3) == [3]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 3)` 应返回一个包含 `3` 和 `2` 的列表。

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 3)
  assert result == [3, 2] or result == [2, 3]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 0)` 应返回包含 `0` 和 `1` 的列表。

```js
({ test: () => runPython(`
  result = dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 0)
  assert result == [0, 1] or result == [1, 0]
`) })
```

`dfs` 函数应返回正确的结果。

```js
({ test: () => runPython(`
  import random

  def solve(g, s):
      v, q = set(), [s]
      while q:
          u = q.pop()
          if u not in v:
              v.add(u)
              q.extend([i for i, x in enumerate(g[u]) if x == 1 and i not in v])
      return v

  random.seed(0)

  for _ in range(10):
      n = 6
      mat = [[0]*n for _ in range(n)]
      for i in range(n):
          for j in range(i+1, n):
              if random.random() > 0.5:
                  mat[i][j] = mat[j][i] = 1

      start = random.randint(0, n-1)
      assert set(dfs(mat, start)) == solve(mat, start), "Random graph check failed"
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def dfs(graph, root):
    stack = []
    temp_v = None
    visited = []
    temp_v_neighbors = []
    stack.append(root)
    while stack:
        temp_v = stack.pop()
        if temp_v not in visited:
            visited.append(temp_v)
            temp_v_neighbors = graph[temp_v]
            for n, is_neighbor in enumerate(temp_v_neighbors):
                if is_neighbor == 1:
                    stack.append(n)
    return visited
```
