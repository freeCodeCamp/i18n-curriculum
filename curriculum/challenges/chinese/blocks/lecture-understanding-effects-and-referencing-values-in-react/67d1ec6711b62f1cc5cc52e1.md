---
id: 67d1ec6711b62f1cc5cc52e1
title: React 中的效果是什么，以及 `useEffect` 钩子如何工作？
challengeType: 19
dashedName: what-are-effects-in-react-and-how-does-the-useeffect-hook-work
---

# --description--

在 React 中，效果是指发生在组件渲染进程之外的任何事情。也就是说，任何 React 不直接作为渲染 UI 一部分处理的事情。

常见示例包括获取数据、更新浏览器标签（页）的标题、从浏览器的局部存储读取或写入、获取用户的位置等等。这些操作与外部世界交互，被称为副作用。

React 提供了 `useEffect` 钩子，让你处理那些副作用。`useEffect` 让你在组件渲染或更新后运行一个函数。

让我们看看 `useEffect` 钩子如何工作以及为什么它对现代 React 开发至关重要。

要使用 `useEffect` 钩子，首先需要导入它：

```js
import { useEffect } from "react";
```

然后你像这样将它用作函数：

```js
useEffect(() => {
  // Your side effect logic (usually a function) here
}, [dependencies]);
```

效果函数在组件渲染后运行，而可选的 `dependencies` 参数控制效果的运行时机。

请注意，`dependencies` 可以是一个包含“响应式值”（状态、属性、函数、变量等）的数组、一个空数组，或者完全省略。以下是所有这些选项如何控制 `useEffect` 的工作方式：

- 如果 `dependencies` 是包含一个或多个响应式值的数组，则每当它们变化时，效果将运行。

- 如果 `dependencies` 是一个空数组，`useEffect` 只会在组件首次渲染时运行一次。

- 如果你省略 `dependencies`，该效果将在组件每次渲染或更新时运行。

例如，在这个 `Counter` 应用中，我们没有传入 `dependencies` 参数，因此该效果会在组件渲染时以及每次更新时运行：

```jsx
import { useState, useEffect } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Component renders");
  });

  return (
    <div
      style={{
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
      }}
    >
      <h2>{count}</h2>
      <div>
        <button onClick={() => setCount(count + 1)}>Increase</button>
        <button onClick={() => setCount(count - 1)}>Decrease</button>
      </div>
    </div>
  );
};

export default Counter;
```

但是如果我们传入一个空数组作为依赖，效果只会在第一次渲染时运行：

```js
useEffect(() => {
  console.log('Component renders');
}, []);
```

如果你将 `count` 状态作为依赖传入，<dfn>effect</dfn> 会在组件首次渲染时以及 `count` 变化时运行：

```js
useEffect(() => {
  document.title = `The current count is ${count}`;
  console.log('component renders');
}, [count]);
```

请注意，如果你设置的效果在组件的渲染生命周期之外持续存在，你可能需要另一个函数在组件渲染或更新后“clean up”该函数。

例如，如果你的效果函数使用了 `setInterval()`，设置了像 `window.addEventListener()` 这样的事件监听器，或者连接到了服务器，你将需要一个清理函数来分别运行 `clearInterval()`、`window.removeEventListener()` 和断开服务器连接。

以下是从 `useEffect` 钩子返回清理函数的语法：

```js
useEffect(() => {
  // Your side effect logic here
  return () => {
    // Cleanup logic here (optional)
  };
}, [dependencies]);
```

例如，如果你为滚动事件添加监听器，可以在你的清理函数中通过移除它来进行清理：

```js
useEffect(() => {
  const handleScroll = () => {
    // Handle scroll logic
  };
  window.addEventListener("scroll", handleScroll);

  return () => {
    window.removeEventListener("scroll", handleScroll);
  };
}, []);
```

# --questions--

## --text--

在 React 中，什么被视为 `effect`？

## --answers--

对组件状态的任何更新。

### --feedback--

效果涉及 React 在渲染期间不控制的操作。

---

React 不管理的渲染进程之外的操作。

---

在每次状态更新后渲染 UI。

### --feedback--

效果涉及 React 在渲染期间不控制的操作。

---

更新组件的 props。

### --feedback--

效果涉及 React 在渲染期间不控制的操作。

## --video-solution--

2

## --text--

是什么决定了 React 应用中副作用的运行方式？

## --answers--

效果总是运行一次，无论依赖关系如何。

### --feedback--

effect 的行为取决于 dependency 数组的内容。

---

效果仅在 props 变化时运行，忽略 state。

### --feedback--

effect 的行为取决于 dependency 数组的内容。

---

依赖数组决定效果何时运行。

---

效果总是在每次 `Render` 时运行，除非被显式禁用。

### --feedback--

effect 的行为取决于 dependency 数组的内容。

## --video-solution--

3

## --text--

React 中副作用的常见示例有哪些？

## --answers--

渲染组件和更新状态。

### --feedback--

副作用涉及与 React 渲染进程外部的世界交互。

---

将 props 传递给子组件。

### --feedback--

副作用涉及与 React 渲染进程外部的世界交互。

---

定义组件样式和版型。

### --feedback--

副作用涉及与 React 渲染进程外部的世界交互。

---

获取数据，更新标签（页）标题，以及从存储中读取。

## --video-solution--

4
