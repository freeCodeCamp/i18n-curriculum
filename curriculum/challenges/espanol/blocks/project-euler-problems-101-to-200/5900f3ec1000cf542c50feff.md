---
id: 5900f3ec1000cf542c50feff
title: 'Problema 128: Diferencias en baldosas hexagonales'
challengeType: 1
forumTopicId: 301755
dashedName: problem-128-hexagonal-tile-differences
---

# --description--

Una loseta hexagonal con el número 1 está rodeada por un anillo de seis losetas hexagonales, comenzando a las "12 en punto" y numerando las losetas del 2 al 7 en dirección antihoraria.

Los nuevos anillos se agregan de la misma manera, con los siguientes anillos numerados del 8 al 19, del 20 al 37, del 38 al 61, y así sucesivamente. El diagrama a continuación muestra los primeros tres anillos.

<img alt="three first rings of arranged hexagonal tiles with numbers 1 to 37, and with highlighted tiles 8 and 17" src="https://cdn.freecodecamp.org/curriculum/project-euler/hexagonal-tile-differences.png" style="background-color: white; padding: 10px; display: block; margin-right: auto; margin-left: auto; margin-bottom: 1.2rem;">

Al encontrar la diferencia entre la baldosa $n$ y cada uno de sus seis vecinos, definiremos $PD(n)$ como el número de esas diferencias que son primos.

Por ejemplo, trabajando en el sentido de las agujas del reloj alrededor de la baldosa 8, las diferencias son 12, 29, 11, 6, 1 y 13. Entonces $PD(8) = 3$.

De la misma manera, las diferencias alrededor de la baldosa 17 son 1, 17, 16, 1, 11 y 10, por lo tanto $PD(17) = 2$.

Se puede demostrar que el valor máximo de $PD(n)$ es $3$.

Si todas las fichas para las cuales $PD(n) = 3$ se enumeran en orden ascendente para formar una secuencia, la décima ficha sería 271.

Encuentra la baldosa número 2000 en esta secuencia.

# --hints--

`hexagonalTile(10)` debería devolver `271`.

```js
assert.strictEqual(hexagonalTile(10), 271);
```

`hexagonalTile(2000)` debería devolver `14516824220`.

```js
assert.strictEqual(hexagonalTile(2000), 14516824220);
```

# --seed--

## --seed-contents--

```js
function hexagonalTile(tileIndex) {

  return true;
}

hexagonalTile(10);
```

# --solutions--

```js
class PrimeSeive {
  constructor(num) {
    const seive = Array(Math.floor((num - 1) / 2)).fill(true);
    const upper = Math.floor((num - 1) / 2);
    const sqrtUpper = Math.floor((Math.sqrt(num) - 1) / 2);

    for (let i = 0; i <= sqrtUpper; i++) {
      if (seive[i]) {
        // Mark value in seive array
        const prime = 2 * i + 3;
        // Mark all multiples of this number as false (not prime)
        const primeSquaredIndex = 2 * i ** 2 + 6 * i + 3;
        for (let j = primeSquaredIndex; j < upper; j += prime) {
          seive[j] = false;
        }
      }
    }

    this._seive = seive;
  }

  isPrime(num) {
    return num === 2
      ? true
      : num % 2 === 0
        ? false
        : this.isOddPrime(num);
  }

  isOddPrime(num) {
    return this._seive[(num - 3) / 2];
  }
};

function hexagonalTile(tileIndex) {
  const primeSeive = new PrimeSeive(tileIndex * 420);
  let count = 1;
  let n = 1;
  let number = 0;

  while (count < tileIndex) {
    if (primeSeive.isPrime(6*n - 1) &&
        primeSeive.isPrime(6*n + 1) &&
        primeSeive.isPrime(12*n + 5)) {
      number = 3*n*n - 3*n + 2;
      count++;
      if (count >= tileIndex) break;
    }
    if (primeSeive.isPrime(6*n + 5) &&
        primeSeive.isPrime(6*n - 1) &&
        primeSeive.isPrime(12*n - 7) && n != 1) {
      number = 3*n*n + 3*n + 1;
      count++;
    }
    n++;
  }
  return number;
}
```
