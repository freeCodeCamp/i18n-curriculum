---
id: 5e44414f903586ffb414c950
title: 建置一個機率計算器專案
challengeType: 23
saveSubmissionToDB: true
forumTopicId: 462364
dashedName: build-a-probability-calculator-project
---

# --description--

假設有一頂帽子裡面有 5 顆藍球、4 顆紅球和 2 顆綠球。隨機抽取 4 顆球中至少包含 1 顆紅球和 2 顆綠球的機率是多少？雖然可以使用進階數學來計算機率，但更簡單的方法是撰寫一個程式來執行大量實驗，以估算近似機率。

在這個專案中，你將撰寫一個程式來判斷從帽子中隨機抽取特定球的近似機率。

首先，在 `main.py` 中創建一個 `Hat` 類別。該類別應該接受可變數量的引數，用以指定帽子中每種顏色球的數量。舉例來說，可以用以下任一方式創建類別物件：

```py
hat1 = Hat(yellow=3, blue=2, green=6)
hat2 = Hat(red=5, orange=4)
hat3 = Hat(red=5, orange=4, black=1, blue=0, pink=2, striped=9)
```

帽子在產生時至少會包含一個球。傳入帽子物件的引數應該轉換為 `contents` 實體變數。`contents` 應該是一個字串列表，包含帽子中每個球的條款。列表中的每個條款應該是表述該顏色單一球的顏色名稱。例如，如果你的帽子是 `{'red': 2, 'blue': 1}`，`contents` 應該是 `['red', 'red', 'blue']`。

`Hat` 類別應該有一個 `draw` 方法，該方法接受一個引數，表示要從帽子中抽取的球數量。此方法應該從 `contents` 中隨機移除球，並將這些球以字串列表的形式傳回。抽取過程中球不應該放回帽子，類似於無放回的骨灰甕實驗。如果要抽取的球數超過可用數量，則傳回所有球。

接著，在 `main.py` 中創建一個 `experiment` 函式（不要放在 `Hat` 類別內）。此函式應接受以下引數：

- `hat`：一個包含球的帽子物件，應該在函式內被複製。
- `expected_balls`：一個物件，表示要從帽子中嘗試抽取的確切球群組。例如，要確定從帽子中抽出 2 顆藍球和 1 顆紅球的機率，請將 `expected_balls` 設為 `{'blue':2, 'red':1}`。
- `num_balls_drawn`：每次實驗中從帽子中抽取的球數量。
- `num_experiments`：要執行的實驗次數。（執行的實驗越多，近似機率將越準確。）

`experiment` 函式（程式）應該傳回一個機率。

例如，如果你想要判斷從一頂包含六個黑球、四個紅球和三個綠球的帽子中抽取五個球時，至少抽到兩個紅球和一個綠球的機率。為此，你將執行 `N` 次實驗，計算你獲得至少兩個紅球和一個綠球的次數 `M`，並將機率估計為 `M/N`。每次實驗包括從包含指定球的帽子開始，抽取數個球，並檢查你是否抽到了你嘗試抽取的球。

以下是根據上述範例，如何呼叫 `experiment` 函式（程式）並執行 2000 次實驗的方法：

```py
hat = Hat(black=6, red=4, green=3)
probability = experiment(hat=hat,
                  expected_balls={'red':2,'green':1},
                  num_balls_drawn=5,
                  num_experiments=2000)
```

輸出會是類似這樣：

```bash
0.356
```

由於這是基於隨機抽取，每次執行程式碼時機率會略有不同。

*提示：考慮使用已在檔案頂部匯入的模組。不要在檔案中初始化隨機種子。*

注意：請按 F12 開啟瀏覽器主控台，以查看測試的更詳細輸出。

# --hints--

`hat` 物件的產生應該添加正確的內容。

```js
({
  test: () => {
    pyodide.FS.writeFile("/home/pyodide/probability_calculator.py", code);
    pyodide.FS.writeFile(
      "/home/pyodide/test_module.py",
      `
import unittest
import probability_calculator
from importlib import reload

reload(probability_calculator)

probability_calculator.random.seed(95)
class UnitTests(unittest.TestCase):
    maxDiff = None
    def test_hat_class_contents(self):
        hat = probability_calculator.Hat(red=3,blue=2)
        actual = hat.contents
        expected = ["red","red","red","blue","blue"]
        self.assertEqual(actual, expected, 'Expected creation of hat object to add correct contents.')
        `
    );
    const testCode = `
from unittest import main
import test_module
from importlib import reload

reload(test_module)
t = main(module='test_module', exit=False)
t.result.wasSuccessful()
`;
    const out = runPython(testCode);
    assert(out);
  },
});
```

`hat` 類別中的 `draw` 方法應該減少 contents 中的項目數量。


```js
({
  test: () => {
    pyodide.FS.writeFile("/home/pyodide/probability_calculator.py", code);
    pyodide.FS.writeFile(
      "/home/pyodide/test_module.py",
      `
import unittest
import probability_calculator
from importlib import reload

reload(probability_calculator)

probability_calculator.random.seed(95)

class UnitTests(unittest.TestCase):
    maxDiff = None
    def test_hat_draw(self):
        hat = probability_calculator.Hat(red=5,blue=2)
        actual = hat.draw(2)
        expected = ['blue', 'red']
        self.assertEqual(actual, expected, 'Expected hat draw to return two random items from hat contents.')
        actual = len(hat.contents)
        expected = 5
        self.assertEqual(actual, expected, 'Expected hat draw to reduce number of items in contents.')
        `
    );
    const testCode = `
from unittest import main
import test_module
from importlib import reload

reload(test_module)
t = main(module='test_module', exit=False)
t.result.wasSuccessful()
`;
    const out = runPython(testCode);
    assert(out);
  },
});
```

當要抽取的球數量大於帽子中球的數量時，`draw` 方法應該正確運作。

```js
({
  test: () => {
    pyodide.FS.writeFile("/home/pyodide/probability_calculator.py", code);
    pyodide.FS.writeFile(
      "/home/pyodide/test_module.py",
      `
import unittest
import probability_calculator
from importlib import reload

reload(probability_calculator)

probability_calculator.random.seed(95)
class UnitTests(unittest.TestCase):
    maxDiff = None
    def test_hat_draw_2(self):
        hat = probability_calculator.Hat(yellow=5,red=1,green=3,blue=9,test=1)
        actual = sorted(hat.draw(20))
        expected = sorted(['yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'red', 'green', 'green', 'green', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'test'])
        self.assertEqual(actual, expected, 'Expected hat draw to return all items from hat contents.')
        actual = len(hat.contents)
        expected = 0
        self.assertEqual(actual, expected, 'Expected hat draw to leave no items in contents.')
        `
    );
    const testCode = `
from unittest import main
import test_module
from importlib import reload

reload(test_module)
t = main(module='test_module', exit=False)
t.result.wasSuccessful()
`;
    const out = runPython(testCode);
    assert(out);
  },
});
```

`experiment` 方法應該傳回不同的機率。


```js
({
  test: () => {
    pyodide.FS.writeFile("/home/pyodide/probability_calculator.py", code);
    pyodide.FS.writeFile(
      "/home/pyodide/test_module.py",
      `
import unittest
import probability_calculator
from importlib import reload

reload(probability_calculator)

probability_calculator.random.seed(95)
class UnitTests(unittest.TestCase):
    maxDiff = None
    def test_prob_experiment(self):
        hat = probability_calculator.Hat(blue=3,red=2,green=6)
        probability = probability_calculator.experiment(hat=hat, expected_balls={"blue":2,"green":1}, num_balls_drawn=4, num_experiments=1000)
        actual = probability
        expected = 0.272
        self.assertAlmostEqual(actual, expected, delta = 0.01, msg = 'Expected experiment method to return a different probability.')
        hat = probability_calculator.Hat(yellow=5,red=1,green=3,blue=9,test=1)
        probability = probability_calculator.experiment(hat=hat, expected_balls={"yellow":2,"blue":3,"test":1}, num_balls_drawn=20, num_experiments=100)
        actual = probability
        expected = 1.0
        self.assertAlmostEqual(actual, expected, delta = 0.01, msg = 'Expected experiment method to return a different probability.')
        `
    );
    const testCode = `
from unittest import main
import test_module
from importlib import reload

reload(test_module)
t = main(module='test_module', exit=False)
t.result.wasSuccessful()
`;
    const out = runPython(testCode);
    assert(out);
  },
});
```

# --seed--

## --seed-contents--

```py
import copy
import random

class Hat:
    pass

def experiment(hat, expected_balls, num_balls_drawn, num_experiments):
    pass
```

# --solutions--

```py
import copy
import random

class Hat:
    def __init__(self, **hat):
        self.hat = hat
        contents = []
        for i in hat:
            for j in range(hat[i]):
                contents.append(i)           
        self.contents = contents
               

    def draw(self, number): 
        drawn = []
        if number >= len(self.contents):
            drawn.extend(self.contents)
            self.contents = []
        else:
            for i in range(number):
                drawn.append(
                    self.contents.pop(random.randrange(len(self.contents)))
                )                
        return drawn

def experiment(hat, expected_balls, num_balls_drawn, num_experiments):    
    expected_balls_list = []
    drawn_list = []
    success = 0
    for i in expected_balls:
        for j in range(expected_balls[i]):
            expected_balls_list.append(i)
    for j in range(num_experiments):
        hat_copy = copy.deepcopy(hat)
        drawn_list.append(hat_copy.draw(num_balls_drawn))        
        exp_ball_list_copy = expected_balls_list[:]
        for k in range(len(drawn_list[j])):
            try:
                ind = exp_ball_list_copy.index(drawn_list[j][k])
                exp_ball_list_copy.pop(ind)
            except:
                continue
        if len(exp_ball_list_copy) == 0:
            success += 1        
    probability = success/num_experiments    
    return probability
```
