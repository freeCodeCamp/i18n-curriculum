---
id: 6895d06b5968736797c408e6
title: 單向鏈結串列如何運作以及它們與雙向鏈結串列有何不同？
challengeType: 19
dashedName: how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list
---

# --description--

**鏈結串列** 是一種線性資料結構，其中每個節點都與序列中的下一個節點相連結。

這些連接產生一個看起來像節點串鏈的資料結構，其中每個節點儲存資料和指向鏈結串列中下一個節點的引用。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-1.png" alt="linked list basic structure visualization">

我們使用這些引用來從第一個節點前往下一個節點，依此類推。

鏈結串列通常用於實作其他資料結構，例如堆疊、佇列和雙端佇列。它們也可以用來實作重要的圖形演算法，例如深度優先搜尋和廣度優先搜尋。

## 單向鏈結串列

**單向鏈結串列** 是一種鏈結串列，其中每個節點都連結到序列中的下一個節點。

每個節點透過儲存對下一個節點的引用來連接。

每個節點只有一個引用，允許你從開始到結束單向巡訪鏈結串列。

搜尋只能向前移動，不能向後移動。

在這個範例中，你會從頭節點，也就是節點 A 開始。

**head** 節點是鏈結串列中的第一個節點。

在單向鏈結串列中，頭節點通常是唯一可以直接存取的節點。當你嘗試尋找特定節點時，搜尋處理程序將從這裡開始。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-2.webp" alt="singly linked list traversal visualization">

該行程將從節點 A 開始，然後繼續到節點 B，再到節點 C，最後到節點 D，即**尾端**節點。如果你在你的程式碼中實作特定邏輯，它也可能在此之前停止。

**tail** 節點是最後一個節點。它用來判斷處理程序是否已經到達鏈結串列的結尾。

### **插入節點**

鏈結串列的優點之一是它們沒有固定大小。只要更新節點之間的連接，就可以根據需要擴展或縮小。

你可以在鏈結串列的開始、中間和結尾**插入**節點。

鏈結串列不一定需要以特定順序儲存節點。順序將由節點之間的連接決定。

但是，如果你確實需要為你的特定使用案例保持節點的特定順序，你可以透過在你的程式碼中實作該邏輯來達成，而你實作的條件將決定節點是插入在開始、中間還是結尾。

要在鏈結串列的開頭插入節點，你只需要在新節點和原本作為頭節點的節點之間創建連接，並將新節點設為頭節點。

這是一個範例，我們在開頭插入節點 E，並將這個新節點設為鏈結串列的頭節點。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-3.png" alt="singly linked list insert at beginning visualization">

在鏈結串列開頭插入節點具有恆定時間複雜度 `O(1)`，因為它只需要更新對頭節點的引用以及新頭節點與序列中下一節點之間的連接。

在這個範例中，我們將節點 E 插入鏈結串列的開頭。這樣做會正確運作。但如果我們想要保持鏈結串列按字母順序排序，節點 E 就必須插入鏈結串列的末端。

要在鏈結串列的末端插入節點，首先你需要到達末端，然後將一個連接添加到新節點，使其成為新的尾節點。

此操作具有線性時間複雜度，`O(n)`，其中 n 是儲存在鏈結串列中的節點數，因為你首先需要到達鏈結串列的末端才能進行插入，這需要從一個節點移動到下一個節點，依此類推直到到達末端。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-4.png" alt="singly linked list insert at end visualization">

如果節點必須插入到鏈結串列的中間某處，節點之間的連接也必須更新。序列中的前一個節點應該連接到新的節點，而新的節點應該連接到下一個節點，如下圖所示。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-5.webp" alt="singly linked list insert in middle visualization">

插入操作具有恆定的空間複雜度 `O(1)`，因為插入新節點只需要建立它並更新節點之間的連接。此操作不依賴於鏈結串列本身的大小。

### **移除節點**

正如你可以插入節點，你也可以從鏈結串列的開始、中間和結尾移除它們。

要從開頭移除節點，你需要更新對頭節點的引用，該引用應該指向序列中的下一個節點。

此操作行為具有常數時間複雜度 `O(1)`，因為它只需要更新鏈結串列對頭節點的引用。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-6.png" alt="singly linked list remove from beginning visualization">

要從鏈結串列的中間移除節點，你需要更新前一個節點的引用，使其連結到序列中的下一個節點，形成它們之間的一種「橋樑」，如這個圖示所示。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-7.png" alt="singly linked list remove from middle visualization">

這將會從連接序列中移除你想要移除的節點，在此案例中為節點 B，因此下次你巡訪時不會到達它。

要從鏈結串列的尾端移除節點，你需要移除前一個節點的連接，並將此節點設為新的尾節點。現在鏈結串列將在新的尾節點結束。

此操作行為具有線性時間複雜度 `O(n)`，因為你必須先到達鏈結串列的末端。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-8.png" alt="singly linked list remove from end visualization">

刪除操作具有恆定的空間複雜度 `O(1)`，因為刪除節點不需要額外的記憶體。

## 雙向鏈結串列

既然你已經更了解單向鏈結串列，讓我們來談談雙向鏈結串列。

在**雙向鏈結串列**中，每個節點儲存兩個引用：一個是指向下一個節點的引用，另一個是指向序列中前一個節點的引用。

這表示雙向鏈結串列可以雙向巡訪。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-9.webp" alt="doubly linked list structure visualization">

在這種類型的鏈結串列中，也常見在鏈結串列本身中保留對尾節點的引用，以便在必要時從尾端開始遍歷。

聽起來很棒，對吧？它們比單向鏈結串列更靈活。

然而，雙向鏈結串列確實比單向鏈結串列需要更多記憶體，因為每個節點儲存 **兩個** 引用，而非一個。

當你為你的專案選擇合適的資料結構時，這是你應該記住的事情。

這是有取捨的。

插入和刪除操作行為的運作方式完全相同。唯一的差別是現在你需要更新每個節點的兩個引用，並且追蹤尾節點的引用，以便能夠在雙向鏈結串列的尾端高效地插入元素，並在必要時從後方開始遍歷處理程序。

單向鏈結串列和雙向鏈結串列是電腦科學中用於以順序方式儲存和操作元素的基本資料結構。了解它們的差異對於為你的特定應用選擇合適的鏈結串列至關重要。

# --questions--

## --text--

什麼是鏈結串列？

## --answers--

一種將元素儲存在連續記憶體區塊中的資料結構。

### --feedback--

思考節點如何在鏈結串列中連接。

---

一種使用引用連接節點的資料結構。

---

一個始終排序的資料結構。

### --feedback--

思考節點如何在鏈結串列中連接。

---

具有固定大小的資料結構。

### --feedback--

思考節點如何在鏈結串列中連接。

## --video-solution--

2

## --text--

單向鏈結串列和雙向鏈結串列之間有什麼差異？

## --answers--

單向鏈結串列有一個頭節點和尾節點，而雙向鏈結串列則沒有。

### --feedback--

思考每種鏈結串列中所包含的引用。

---

單向鏈結串列只能朝一個方向巡訪，而雙向鏈結串列可以朝兩個方向巡訪。

---

單向鏈結串列在尾端插入元素較為高效，而雙向鏈結串列在開頭插入元素較為高效。

### --feedback--

思考每種鏈結串列中所包含的引用。

---

單向鏈結串列比雙向鏈結串列需要更多記憶體。

### --feedback--

思考每種鏈結串列中所包含的引用。

## --video-solution--

2

## --text--

在單向鏈結串列的開頭插入節點的時間複雜度是什麼？

## --answers--

`O(1)`

---

`O(n)`

### --feedback--

思考在鏈結串列開頭插入節點所需的操作行為數量。

---

`O(n^2)`

### --feedback--

思考在鏈結串列開頭插入節點所需的操作行為數量。

---

`O(log n)`

### --feedback--

思考在鏈結串列開頭插入節點所需的操作行為數量。

## --video-solution--

1

