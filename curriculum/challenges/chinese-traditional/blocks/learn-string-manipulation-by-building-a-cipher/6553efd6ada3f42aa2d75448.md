---
id: 6553efd6ada3f42aa2d75448
title: 步驟 53
challengeType: 20
dashedName: step-53
---

# --description--

現在你應該會再次看到輸出。雖然這種方法有效，但它並不會顯著提升程式碼的重複使用性。重複呼叫你的函式會產生相同的結果。然而，函式可以使用 *參數* 來介紹多樣性和訂製功能：

```py
def function_name(param_1, param_2):
    <code>
```

參數是在你的函式（程式）內可以使用的變數。函式（程式）可以宣告不同數量的參數。在上面的範例中，`param_1` 和 `param_2` 是參數。

修改你的函式（程式）宣告式，使其接受兩個名為 `message` 和 `offset` 的參數。

之後，你會在終端機中看到錯誤訊息。你會在接下來的步驟中看到如何解決它。

# --hints--

你的 `caesar` 函式應該接受 `message` 和 `offset` 作為參數。請記得用逗號分隔參數。

```js
assert.match(code, /^def\s+caesar\s*\(\s*message\s*,\s*offset\s*\)\s*:/m)
```

# --seed--

## --seed-contents--

```py
text = 'Hello Zaira'
shift = 3
--fcc-editable-region--
def caesar():
--fcc-editable-region--
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    encrypted_text = ''

    for char in text.lower():
        if char == ' ':
            encrypted_text += char
        else:
            index = alphabet.find(char)
            new_index = (index + shift) % len(alphabet)
            encrypted_text += alphabet[new_index]
    print('plain text:', text)
    print('encrypted text:', encrypted_text)

caesar()
```
