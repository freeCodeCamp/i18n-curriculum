---
id: 67f41341453c2247fb2828f7
title: 資料結構測驗
challengeType: 8
dashedName: quiz-data-structures
---

# --description--

要通過測驗，你必須在以下 20 題中正確回答至少 18 題。

# --quizzes--

## --quiz--

### --question--

#### --text--

Big O 符號在演算法分析中描述什麼？

#### --distractors--

特定電腦的精確執行期（秒）。

---

執行期間執行的程式碼行百分比。

---

程式碼對其他開發者的可讀性有多高。

#### --answer--

時間或空間相對於輸入大小的增長方式（上限）。

### --question--

#### --text--

當開始一個演算法挑戰時，最好的第一步是什麼？

#### --distractors--

立即開始編碼以獲得動力。

---

在你了解問題之前，先為效率、性能最佳化。

---

完成解法後才撰寫單元測試。

#### --answer--

用範例和邊界情況釐清問題和條件。

### --question--

#### --text--

動態陣列和靜態陣列之間的主要差異是什麼？

#### --distractors--

動態陣列儲存不同型別的值；靜態陣列無法。

---

靜態陣列允許重複值；動態陣列不允許。

---

動態陣列在每個操作行為上都比靜態陣列更快。

#### --answer--

動態陣列可以透過調整大小來增長或縮小；靜態陣列具有固定大小。

### --question--

#### --text--

將元素附加到動態陣列末端的攤銷時間複雜度是什麼？

#### --distractors--

`O(n)`

---

`O(log n)`

---

`O(n log n)`

#### --answer--

攤銷 `O(1)`。

### --question--

#### --text--

為什麼在單向鏈結串列中，透過索引存取第 k 個元素需要 `O(n)` 時間？

#### --distractors--

必須在任何 `access` 之前調整 `list` 的大小。

---

索引會被雜湊並在表格中查找。

---

節點是連續儲存的，因此需要位移。

#### --answer--

你必須從頭節點逐一巡訪到第 k 個節點。

### --question--

#### --text--

雙向鏈結串列具有單向鏈結串列所沒有的哪個特性？

#### --distractors--

在 `O(1)` 時間內隨機存取任何索引。

---

一個內建的陣列緩衝區，用於更快速的迭代。

---

自動維護列表長度為常數。

#### --answer--

同時指向下一個和前一個節點的指標，使得能夠向後遍歷。

### --question--

#### --text--

下列哪一項最能描述堆疊？

#### --distractors--

先進先出（`FIFO`），並從前端移除。

---

一種結構體，其中任何元素都可以在 `O(1)` 時間內被移除。

---

具有恆定時間隨機存取的環形緩衝區。

#### --answer--

後進先出（`LIFO`），在頂端使用 `push` 和 `pop`。

### --question--

#### --text--

哪一個操作會移除佇列前端的元素？

#### --distractors--

`push`

---

`pop`

---

`peek`

#### --answer--

`dequeue`

### --question--

#### --text--

在雜湊映射中，透過鍵查找值的典型平均情況時間複雜度是多少？

#### --distractors--

`O(n)` 因為所有鍵必須依序掃描。

---

由於桶內的二分搜尋法，時間複雜度為 `O(log n)`。

---

`O(n log n)`，因為鍵在插入過程中會被排序。

#### --answer--

平均在 `O(1)`，前提是有良好的雜湊函式和低載入因子。

### --question--

#### --text--

集合資料結構提供了什麼保證？

#### --distractors--

元素預設以排序順序儲存。

---

允許重複值並將其保留在一起。

---

元素依其插入位置編號。

#### --answer--

它只儲存唯一元素（無重複）。

### --question--

#### --text--

在動態陣列中，在索引 i（非尾端）插入元素的最壞情況時間複雜度是什麼？

#### --distractors--

`O(1)`

---

`O(log n)`

---

`O(1)` 攤銷

#### --answer--

`O(n)`

### --question--

#### --text--

在單向鏈結串列的表頭插入新節點的時間複雜度是什麼？

#### --distractors--

`O(n)`

---

`O(log n)`

---

`O(n log n)`

#### --answer--

`O(1)`

### --question--

#### --text--

哪一個操作會傳回堆疊頂端的元素而不將其移除？

#### --distractors--

`push`

---

`pop`

---

插入到底部。

#### --answer--

`peek`

### --question--

#### --text--

以下哪一項最能描述佇列？

#### --distractors--

後進先出（`LIFO`），從頂部移除。

---

在 `O(1)` 時間內隨機存取任何索引。

---

元素會自動保持排序狀態。

#### --answer--

先進先出（`FIFO`），在尾端使用 `enqueue`，在前端使用 `dequeue`。

### --question--

#### --text--

什麼是哈希映射中的哈希碰撞？

#### --distractors--

當一個鍵設計上對應多個不同的值時。

---

當兩個相同的鍵儲存在不同的桶中。

---

當地圖的記憶體用盡且必須調整大小時。

#### --answer--

當兩個不同的鍵產生相同的雜湊索引。

### --question--

#### --text--

為什麼哈希映射在成長時會調整大小（重新哈希）？

#### --distractors--

為了更快的迭代，將鍵按升冪排序。

---

壓縮數值並減少記憶體碎片化。

---

為避免觸發該語言的垃圾回收器。

#### --answer--

為了保持載入因子低，使平均操作行為維持在 `O(1)`。

### --question--

#### --text--

關於集合，哪個述語是正確的？

#### --distractors--

集合依照定義保留插入順序。

---

集合允許重複元素並保持計數。

---

集合成員測試平均為 `O(n log n)`。

#### --answer--

成員測試平均來說通常是 `O(1)`。

### --question--

#### --text--

當 n 變大時，哪種時間複雜度比 `O(n log n)` 增長得更快？

#### --distractors--

`O(n)`

---

`O(log n)`

---

`O(1)`

#### --answer--

`O(n^2)`

### --question--

#### --text--

在實作暴力解法之後，下一個好的步驟是什麼？

#### --distractors--

在測量之前微最佳化常數因子。

---

捨棄測試並從頭重寫解法。

---

避免考慮邊緣案例以保持程式碼簡單。

#### --answer--

分析其時間／空間複雜度並最佳化已識別的瓶頸。

### --question--

#### --text--

空間複雜度衡量什麼？

#### --distractors--

程式使用多少個 CPU 核心。

---

程式碼行數的長度。

---

一個程式編譯所需的時間。

#### --answer--

記憶體使用量相對於輸入大小的增長情況。

