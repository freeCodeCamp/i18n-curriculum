---
id: 69691ff777d428294168d47e
title: O que é Divide and Conquer e como o Merge Sort funciona?
challengeType: 19
dashedName: what-is-divide-and-conquer-and-how-does-merge-sort-work
---

# --description--

O paradigma divide e conquista em ciência da computação é uma técnica para dividir recursivamente problemas em subproblemas menores. Um dos aspectos principais dessa técnica é a recursão, que acontece quando uma função chama a si mesma repetidamente até que um caso base seja alcançado. Nesta lição, vamos analisar o algoritmo merge sort para entender melhor como a técnica divide e conquista funciona.

Vamos supor que temos esta lista de números:

```md
42 37 53 17
```

O objetivo é ordenar essa lista do menor para o maior usando o algoritmo `merge sort`. O primeiro passo é dividir essa lista ao meio:

```md
42 37 | 53 17
```

Então precisamos olhar para o lado esquerdo da lista:

```md
42 37
```

Pegamos essa sublista e dividimos ao meio novamente até que cada sublista tenha apenas um item:

```md
42 | 37
```

Uma lista com apenas um item é ordenada por padrão. Em seguida, precisamos mesclar cada uma dessas sublistas de um elemento em uma lista ordenada:

```md
37 42
```

Então seguimos o mesmo processo para o lado direito da lista original:

```javascript
// right side of original list
53 17

// divide the list in half
53 | 17

// merge the lists in sorted order
17 53
```

Agora que ambas as metades da lista original estão ordenadas, nós unimos essas duas metades e ordenamos os elementos:

```markdown
17 37 42 53
```

Aqui está como o algoritmo se parece em código:

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }

    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));

    const sorted = [];
    let i = 0;
    let j = 0;

    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            sorted.push(left[i]);
            i += 1;
        } else {
            sorted.push(right[j]);
            j += 1;
        }
    }

    return sorted.concat(left.slice(i)).concat(right.slice(j));
}
```

A complexidade de tempo para merge sort seria `O(n log n)` porque a lista é continuamente dividida ao meio (`log n`) e depois mesclada (`O(n)`). Ao contrário de outros algoritmos de ordenação como bubble sort, merge sort não é ordenado in place e tem uma complexidade de espaço de `O(n)`.

# --questions--

## --text--

O que é o paradigma divide and conquer em ciência da computação?

## --answers--

Uma técnica para detectar um ciclo em iterações de valor de função usando apenas dois iteradores.

### --feedback--

Revise o início da lição.

---

Um algoritmo para comparar dois elementos e trocá-los do menor para o maior se necessário.

### --feedback--

Revise o início da lição.

---

Uma técnica para dividir recursivamente problemas em subproblemas menores.

---

Um algoritmo para calcular a rede de conexão mais curta para pontos em um plano.

### --feedback--

Revise o início da lição.

## --video-solution--

3

## --text--

Qual é a complexidade de tempo para o algoritmo `merge sort`?

## --answers--

`O(n log n)`

---

`O(log n²)`

### --feedback--

Revise o final da lição.

---

`O(n³ log n)`

### --feedback--

Revise o final da lição.

---

`O(log n³)`

### --feedback--

Revise o final da lição.

## --video-solution--

1

## --text--

Qual é a complexidade de espaço para o algoritmo `merge sort`?

## --answers--

`O(n²)`

### --feedback--

Revise o final da lição.

---

`O(1)`

### --feedback--

Revise o final da lição.

---

`O(n log n)`

### --feedback--

Revise o final da lição.

---

`O(n)`

## --video-solution--

4
