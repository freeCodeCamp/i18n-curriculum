---
id: 6882915386c73273ac489f38
title: ¿Cuáles son algunas mejores prácticas para desarrollar una estrategia de ramificación en Git?
challengeType: 19
dashedName: what-are-some-best-practices-for-developing-a-git-branching-strategy
---

# --description--

Hablamos un poco sobre las ramas en las lecciones anteriores. Aprendiste cómo crear ramas, por qué no deberías hacer commits directamente en `main` y cosas similares. Pero, ¿cuándo y por qué deberías crear ramas realmente?

Primero, hablemos de por qué no deberías simplemente subir un montón de commits a `main`. Tu rama por defecto debería ser confiablemente estable; es decir, en cualquier momento debería poder descargar tu rama actual `main` y construir, ejecutar y probar tu aplicación. Si estás subiendo características parcialmente completadas o commits en progreso (WIP), entonces esto puede no ser siempre cierto.

Además, es muy común trabajar en múltiples características al mismo tiempo. Si estás enviando trabajo parcial a `main` para varias características simultáneamente, se vuelve mucho más difícil depurar un posible problema porque no tienes cambios aislados. Además, cambiar de contexto (o cambiar las tareas en las que estás trabajando) no es para nada tan limpio.

Entonces, ¿cuándo deberías crear una rama? Una regla general es crear una rama para cada unidad de trabajo aislada. Es decir, si estás trabajando en una nueva función OAuth, ese trabajo debería estar en una rama dedicada. Si luego necesitas corregir un error en tu autenticación de contraseña, ese trabajo debería estar en su propia rama dedicada. ¿Necesitas rediseñar la página de perfil de usuario? Esa es otra rama.

Ten en cuenta que siempre debes crear tus ramas a partir de `main`. Entonces, si estás trabajando en una rama para tu función OAuth, debes hacer checkout de `main` antes de crear una nueva rama para la corrección de autenticación por contraseña. De lo contrario, si creas una rama para la corrección de la contraseña directamente desde tu rama OAuth, terminarás con los commits de tu trabajo en OAuth y el historial se verá confuso.

¿Pero cómo deberías nombrar tus ramas? Bueno, eso depende completamente de ti (o del proyecto al que estés contribuyendo), pero aquí tienes algunas convenciones comunes:

`scope/description` - donde `scope` es algo como `feat` o `fix`, y `description` es una explicación muy breve de los cambios en la rama. Por ejemplo: `feat/oauth-support`.

`scope/issue/description` - similar a la convención anterior, pero incluyendo el número asociado con el issue relacionado. Por ejemplo: `fix/25/password-auth`.

`username/scope/description` - Para proyectos donde todos trabajan en ramas del repositorio original en lugar de bifurcarlo (esto es común en repositorios internos privados), puede ser útil incluir tu nombre de usuario al inicio de la rama. Por ejemplo: `naomi-lgbt/feat/profile-redesign`.

Cubrámos algunas otras notas sobre estrategias de branching.

Para trabajos de características de larga duración, como una característica beta que requiere muchas horas de desarrollador, puede que quieras usar un feature flag para habilitar la lógica de forma selectiva en lugar de una rama. Cuanto más tiempo permanezca una rama sin fusionar, más probable es que encuentres conflictos.

Sin embargo, puede que desees mantener ramas dedicadas para entornos de despliegue o versiones. Por ejemplo, el repositorio de freeCodeCamp usa `prod-staging` y `prod-current` para activar despliegues en los servidores de staging y producción, respectivamente. Esto puede liberar al equipo para iterar más rápido, fusionando a medida que las cosas están listas y aprobadas sin tener que activar un despliegue por cada fusión. En cambio, los despliegues se crean fusionando el último `main` en esas ramas de producción.

También puede que quieras mantener "release branches", o ramas que representan una versión principal de tu producto. Esto te permite tener un estado limpio para cada lanzamiento importante, de modo que si necesitas aplicar un parche de seguridad crítico a una versión anterior, puedas hacerlo sin tener que incluir ninguno de los cambios de la nueva versión.

Y finalmente, debes evitar fusionar tus ramas en `main` usando la CLI local. En su lugar, crea un pull request con tus cambios y fusiona a través de ese flujo. Esto te da la oportunidad de asegurarte de que todas las pruebas pasen en tu CI (sobre lo que aprenderás en una lección futura), y de revisar dos veces la vista de diferencias para asegurarte de que solo has incluido los cambios que quieres fusionar.

Con estos consejos, ¡puedes comenzar a ramificar tu camino hacia el éxito!

# --questions--

## --text--

¿Por qué deberías evitar hacer commits directamente en la rama `main`?

## --answers--

Porque Git no permite commits directos a `main`.

### --feedback--

Piensa en los requisitos de estabilidad y confiabilidad de la rama por defecto.

---

Porque la rama `main` debe permanecer confiablemente estable en todo momento.

---

Porque los commits en `main` están bloqueados permanentemente y no se pueden cambiar.

### --feedback--

Piensa en los requisitos de estabilidad y confiabilidad de la rama por defecto.

---

Porque las ramas `main` tienen un rendimiento más lento que las ramas de características.

### --feedback--

Piensa en los requisitos de estabilidad y confiabilidad de la rama por defecto.

## --video-solution--

2

## --text--

¿Cuál de las siguientes es una mejor práctica al crear una nueva rama?

## --answers--

Crea nuevas ramas desde tu rama de función actual.

### --feedback--

Piensa en mantener limpias las historias de las ramas y evitar la inclusión no intencionada de código.

---

Siempre crea nuevas ramas desde `main`.

---

Solo crea ramas para características principales.

### --feedback--

Piensa en mantener limpias las historias de las ramas y evitar la inclusión no intencionada de código.

---

Limítate a una rama por semana.

### --feedback--

Piensa en mantener limpias las historias de las ramas y evitar la inclusión no intencionada de código.

## --video-solution--

2

## --text--

¿Cuál es una estructura recomendada para manejar trabajo de características de larga duración?

## --answers--

Crea una rama masiva que contenga todo el trabajo relacionado.

### --feedback--

Considera el potencial de conflictos de fusión con las ramas que permanecen sin fusionar por largos períodos.

---

Usa feature flags en lugar de ramas de larga duración.

---

Siempre fusiona directamente a `main` usando la CLI local.

### --feedback--

Considera el potencial de conflictos de fusión con las ramas que permanecen sin fusionar por largos períodos.

---

Crea un nuevo repositorio para cada característica principal.

### --feedback--

Considera el potencial de conflictos de fusión con las ramas que permanecen sin fusionar por largos períodos.

## --video-solution--

2
