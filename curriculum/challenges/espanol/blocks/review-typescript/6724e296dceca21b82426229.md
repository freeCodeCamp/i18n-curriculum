---
id: 6724e296dceca21b82426229
title: Revisión de TypeScript
challengeType: 31
dashedName: review-typescript
---

# --description--

## ¿Qué es TypeScript?

- **JavaScript**: JavaScript es un lenguaje de tipado dinámico. Esto significa que las variables pueden recibir cualquier valor en tiempo de ejecución. El reto de un lenguaje de tipado dinámico es que la falta de seguridad de tipos puede introducir errores.

Por ejemplo, incluso si tu función de JavaScript espera un arreglo, se puede llamar con un número:

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

La salida de `console` para el ejemplo anterior será `undefined`.

- **TypeScript**: TypeScript amplía el lenguaje JavaScript para incluir tipado estático, lo que ayuda a detectar errores causados por desajustes de tipos antes de ejecutar el código.

Por ejemplo, puedes definir un tipo para el parámetro `array` de la siguiente manera:

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Esta definición de tipo indica a TypeScript que el parámetro `array` debe ser un arreglo de cadenas. Luego, cuando llamas a `getRandomValue` y pasas un número, obtienes un error llamado error de compilador.

- **Compilador**: Primero necesitas compilar el código TypeScript a JavaScript normal. Cuando ejecutas el compilador, TypeScript evaluará tu código y lanzará un error para cualquier problema donde los tipos no coincidan.

## Tipos de Datos en TypeScript

- **Tipos de Datos Primitivos en TypeScript**: Para los tipos de datos primitivos `cadena`, `null`, `undefined`, `número`, `booleano`, y `bigint`, TypeScript ofrece palabras clave de tipo correspondientes.

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **Arreglo**: Puedes definir un arreglo de un tipo específico con dos sintaxis diferentes.

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **Objetos**: Puedes definir la estructura exacta de un objeto.

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

Si quieres un objeto con cualquier clave, pero donde todos los valores deben ser cadenas, hay dos maneras de definirlo:

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **Otros Tipos Útiles en TypeScript**:
  - **`cualquier`**: `cualquier` indica que un valor puede tener cualquier tipo. Le dice al compilador que deje de preocuparse por el tipo de esa variable.
  - **`unknown`**: `unknown` le dice a TypeScript que *sí* te importa el tipo del valor, pero en realidad no sabes cuál es. Generalmente se prefiere `unknown` sobre `any`.
  - **`void`**: Este es un tipo especial que típicamente solo usarás al definir funciones. Las funciones que no tienen un valor de retorno utilizan un tipo de retorno `void`.
  - **`nunca`**: Representa un tipo que nunca existirá.

- **`tipo` Palabra Clave **: Esta palabra clave es como `const`, pero en lugar de declarar una variable, puedes declarar un tipo.

Es útil para declarar tipos personalizados como tipos de unión o tipos que incluyen solo valores específicos:

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interfaz`**: Las interfaces son como clases para tipos. Pueden implementar o extender otras interfaces, son tipos específicamente de objeto, y generalmente se prefieren a menos que necesites una característica específica ofrecida por una declaración `tipo`.

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **Definiendo Tipo de Retorno**: También puedes definir el *tipo de retorno* de la función.

El ejemplo a continuación define el valor de retorno como una cadena. Si intentas devolver algo más, TypeScript te dará un error de compilador.

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## Genéricos

- **Definiendo Tipo Genérico**: Puedes definir un tipo genérico y referirlo en tu función. Se puede considerar como un parámetro especial que proporcionas a una función para controlar el comportamiento de la definición del tipo de la función.

Aquí tienes un ejemplo de cómo definir un tipo genérico para una función:

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

La sintaxis `<T>` le indica a TypeScript que estás definiendo un tipo genérico `T` para la función. `T` es un nombre común para tipos genéricos, pero puedes usar cualquier nombre.

Luego, le dices a TypeScript que el parámetro `array` es un arreglo de valores que coinciden con el tipo genérico, y que el valor devuelto es un solo elemento de ese mismo tipo.

- **Especificar el Argumento de Tipo en la Llamada a la Función**: Puedes pasar un argumento de tipo a una llamada a la función utilizando corchetes angulares entre el nombre de la función y sus parámetros.

Aquí tienes un ejemplo de cómo pasar un argumento de tipo a una llamada a la función:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Esto le dice a TypeScript que el elemento que esperas encontrar será un elemento de entrada.

## Reducción de Tipo

- **Reducción por Veracidad**: En el ejemplo a continuación, obtienes un error de compilador al intentar acceder a la propiedad `value` de `email` porque `email` *podría* ser `null`.

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Puedes usar una declaración condicional para confirmar que `email` es *veraz* antes de acceder a la propiedad:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

Los chequéos de veracidad también pueden funcionar en la dirección opuesta:

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

Lanzar un error termina la ejecución lógica de este código, lo que significa que cuando llegas a la llamada `console.log()`, TypeScript sabe que `email` *no puede* ser `null`.

- **Encadenamiento Opcional**: El encadenamiento opcional `?.` también es una forma de reducción de tipo, bajo la premisa de que el acceso a la propiedad no puede ocurrir si el valor `email` es `null`.

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **Operador `typeof`**: Puedes usar un condicional para verificar el tipo de la variable utilizando el operador `typeof`.

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **Palabra clave `instanceof`**: Si el objeto proviene de una clase, puedes usar la palabra clave `instanceof` para reducir el tipo.

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **Casting**: Cuando TypeScript no puede determinar automáticamente el tipo de un valor, como el resultado del método `request.json()` en el ejemplo a continuación, obtendrás un error de compilador. Una forma de resolver esto es haciendo casting del tipo, pero al hacerlo se debilita la capacidad de TypeScript para detectar errores potenciales.

```typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **Guardia de Tipo**: En lugar de hacer casting del tipo, puedes escribir un guardia de tipo:

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

La sintaxis `user is User` indica que tu función retorna un valor booleano, que cuando es verdadero, significa que el valor `user` satisface la interface `User`.

## Archivo `tsconfig`

- **`tsconfig.json`**: Las configuraciones del compilador de TypeScript residen en un archivo `tsconfig.json` en el directorio raíz de tu proyecto.

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

Aquí tienes las descripciones de las opciones del compilador usadas en el ejemplo anterior:

- **`opcionesDelCompilador`**: La propiedad `opcionesDelCompilador` es donde controlas cómo se comporta el compilador de TypeScript.
- **`directorioRaíz` y `directorioDeSalida`**: Los `directorioRaíz` y `directorioDeSalida` le dicen a TypeScript qué directorio contiene tus archivos fuente y qué directorio debería contener el código JavaScript transpilation.
- **`biblioteca`**: La propiedad `biblioteca` determina qué definiciones de tipo utiliza el compilador y te permite incluir soporte para lanzamientos específicos de ES, el DOM y más.
- **`módulo` y `resoluciónDelMódulo`**: El `módulo` y `resoluciónDelMódulo` trabajan en conjunto para gestionar cómo tu paquete utiliza módulos - ya sea CommonJS o ECMAScript.
- **`interoperabilidadConESMódulos`**: La `interoperabilidadConESMódulos` permite una interoperabilidad más fluida entre CommonJS y ES módulos al crear automáticamente objetos de espacio de nombres para las importaciones.
- **`omitirVerificaciónDeBiblioteca`**: La opción `omitirVerificaciónDeBiblioteca` omite la validación de archivos `.d.ts` que no están referenciados por importaciones en tu código.
- **`estricto`**: La bandera `estricto` habilita varios chequeos, como asegurar el manejo adecuado de tipos anulables y advertir cuando TypeScript recurre a `cualquier`.
- **`excluir`**: La propiedad `excluir` de nivel superior indica al compilador que ignore estos archivos TypeScript durante la compilación.

# --assignment--

Revise los temas y conceptos de TypeScript.
