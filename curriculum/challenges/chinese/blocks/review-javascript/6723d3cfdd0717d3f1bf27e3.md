---
id: 6723d3cfdd0717d3f1bf27e3
title: JavaScript 复习
challengeType: 31
dashedName: review-javascript
---

# --description--

复习以下概念，为即将到来的预备考试做好准备。


## 使用 HTML、CSS 和 JavaScript

HTML 和 CSS 提供了网站结构，而 JavaScript 则通过实现复杂的功能（如处理用户输入、动画元素，甚至构建完整的网络应用程序）为网站带来了交互性。

## JavaScript 中的数据类型

数据类型可以帮助程序理解所处理的数据的类型，无论是数值、文本还是其他数据。

- **数值**：数值代表整数和浮点数。 整数的例子包括 7、19 和 90。
- **浮点数**：浮点数是带有小数点的数值。 例子包括 3.14、0.5 和 0.0001。
- **字串**：字串是由字符或文本组成的序列，包含在引用中。`"I like coding"` 和 `'JavaScript is fun'` 是字串的例子。
- **布尔**：布尔代表两种可能值之一：`true` 或 `false`。 你可以使用布尔来表示条件，例如 `isLoggedIn = true`。
- **未定义和空值**：未定义值是已声明但未赋值的变量。空值是空值或已被故意赋值为 `null` 的变量。
- **对象**：对象是键值对的集合。 键是属性名称，值是属性值。

这里， `pet` 对象有三个属性或键：`name`、`age` 和 `type`。 值分别是 `Fluffy`、`3` 和 `dog`。

```js
let pet = {
  name: 'Fluffy',
  age: 3,
  type: 'dog'
};
```

- **符号**：符号数据类型是唯一且不可变的值，可用作对象属性的标识符。

在下面的示例中，创建了两个具有相同描述的符号，但它们不相等。

```js
const crypticKey1= Symbol('saltNpepper');
const crypticKey2= Symbol('saltNpepper');
console.log(crypticKey1 === crypticKey2); // false
```

- **大整数**：当数字对于 `Number` 数据类型来说太大时，你可以使用大整数数据类型来表示任意长度的整数。

通过在数字末尾添加 `n` 可以创建大整数。

```js
const veryBigNumber = 1234567890123456789012345678901234567890n;
```

## JavaScript 中的变量

- 变量可使用 `let` 关键字声明。

```js
let cityName;
```

- 要给变量赋值，可使用赋值运算符 `=` 。

```js
cityName = 'New York';
```

- 使用 `let` 声明的变量可以重新赋值。

```js
cityName = 'Los Angeles';
console.log(cityName); // Los Angeles
```

- 除了 `let`，你也可以使用 `const` 来声明变量。 但是，`const` 变量不能重新赋值。

```js
const cityName = 'New York';
cityName = 'Los Angeles'; // TypeError: Assignment to constant variable.
```

- 使用 `const` 声明变量在声明常量时使用，常量在整个代码中不得更改，如 `PI` 或 `MAX_SIZE`。

## 变量命名准则

- 变量名应具有描述性和意义。
- 变量名应为小驼峰，如 `cityName`、`isLoggedIn` 和 `veryBigNumber`。
- 变量名不应以数字开头。 必须以字母、`_` 或 `$` 开头。
- 变量名不得包含空格或特殊字符，`_` 和 `$` 除外。
- 变量名不应是保留关键字。
- 变量名区分分支。`age` 和 `Age` 是不同的变量。

## JavaScript 中的字符串和字符串不可变性

- 字符串是用引号括起来的一串字符。 它们可以使用单引号和双引号创建。

```js
let correctWay = 'This is a string';
let alsoCorrect = "This is also a string";
```

- 在 JavaScript 中，字符串是不可变的。 这意味着一旦创建了字符串，就不能更改字符串中的字符。 不过，你仍可以将字符串重新赋值。

```js
let firstName = 'John';
firstName = 'Jane'; // Reassigning the string to a new value
```

## JavaScript 中的字符串连接

- 连接是将多个字符串连接起来或将字符串与包含文本的变量结合起来的过程。 `+` 操作符是最简单、最常用的字符串连接方法之一。

```js
let studentName = 'Asad';
let studentAge = 25;
let studentInfo = studentName + ' is ' + studentAge + ' years old.';
console.log(studentInfo); // Asad is 25 years old.
```

- 如果需要添加或追加到现有字符串，则可使用 `+=` 操作符。 当你想在一个字符串的基础上逐渐添加更多文字时，这很有帮助。

```js
let message = 'Welcome to programming, ';
message += 'Asad!';
console.log(message); // Welcome to programming, Asad!
```

- 另一种连接字符串的方式是使用 `concat()` 方法。 这种方法是将两个或多个字符串连接在一起。

```js
let firstName = 'John';
let lastName = 'Doe';
let fullName = firstName.concat(' ', lastName);
console.log(fullName); // John Doe
```

## 使用 `console.log()` 记录信息

- `console.log()` 方法用于将消息记录到控制台。 它是调试和测试代码的有用工具。

```js
console.log('Hello, World!');
// Output: Hello, World!
```

## JavaScript 中的分号

- 分号主要用于标记语句的结束。 这有助于 JavaScript 引擎理解单个指令之间的分离，这对正确执行至关重要。

```js
let message = 'Hello, World!'; // first statement ends here
let number = 42; // second statement starts here
```

- 分号有助于防止代码执行中的歧义，并确保语句正确终止。

## JavaScript 中的注释

- 任何注释掉的代码行都会被 JavaScript 引擎忽略。 注释用于解释代码、做备注或暂时禁用代码。
- 单行注释使用 `//` 创建。

```js
// This is a single-line comment and will be ignored by the JavaScript engine
```

- 多行注释使用 `/*` 开始 `*/` 结束来创建。

```js
/*
This is a multi-line comment.
It can span multiple lines.
*/
```

## 作为动态类型语言的 JavaScript

- JavaScript 是一种动态类型语言，这意味着在声明变量时不必指定其数据类型。 JavaScript 引擎会根据分配给变量的值自动确定数据类型。

```js
let error = 404; // JavaScript treats error as a number
error = "Not Found"; // JavaScript now treats error as a string
```

- 其他语言，如 C#，由于不是动态类型，会导致误差：

```csharp
int error = 404; // value must always be an integer
error = "Not Found"; // This would cause an error in C#
```

## 使用 `typeof` 操作符

- `typeof` 操作符用于检查变量的数据类型。 它返回一个字符串，表示变量的类型。

```js
let age = 25;
console.log(typeof age); // number

let isLoggedIn = true;
console.log(typeof isLoggedIn); // boolean
```

- 但是，JavaScript 在处理 null 时有一个众所周知的怪癖。`typeof` 操作符对 null 值返回 `object`。

```js
let user = null;
console.log(typeof user); // object
```

## 字符串基础

- **定义**： 字符串是用单引号、双引号或反引号封装的字符序列。 字符串是原始数据类型，且不可变。  Immutability means that once a string is created, it cannot be changed.
- **访问字符串中的字符**：要访问字符串中的字符，可以使用方括号符号并输入索引值。 索引表示字符在字符串中的位置，从零开始的计数。

```js
const developer = "Jessica";
developer[0] // J
```

- **`\n`（换行符）**：你可以使用 `\n` 换行符在字符串中创建换行。

```js
const poem = "Roses are red,\nViolets are blue,\nJavaScript is fun,\nAnd so are you.";
console.log(poem);
```

- **转义字符串**：你可以通过在引号前添加反斜线（`\`）来转义字符串中的字符。

```js
const statement = "She said, \"Hello!\"";
console.log(statement); // She said, "Hello!"
```
  
## 模板字面量（模板字符串）和字符串插值

- **定义**：模板字面用反引号（`）定义。 它们可以让字符串操作变得更简单，包括直接在字符串中嵌入变量，这种特性被称为字符串插值。

```js
const name = "Jessica";
const greeting = `Hello, ${name}!`; // "Hello, Jessica!"
```

## ASCII、`charCodeAt()` 方法和 `fromCharCode()` 方法

- **ASCII**：ASCII 是 American Standard Code for Information Interchange 的缩写，是一种计算机用于表示文本的字符编码标准。 它为每个字符分配一个数值，机器可以普遍识别。
- **`charCodeAt()` 方法**：该方法作用于字符串，返回指定索引处字符的 ASCII 码。

```js
const letter = "A";
console.log(letter.charCodeAt(0));  // 65
```

- **`fromCharCode()` 方法**：该方法将 ASCII 码转换为相应的字符。

```js
const char = String.fromCharCode(65);
console.log(char);  // A
```

## 其他常用字符串方法

- **`indexOf` 方法**：该方法用于查找字符串中的子字符串。 如果找到子字符串，`indexOf` 将返回该子字符串首次出现的索引（或位置）。 如果未找到子字符串，`indexOf` 将返回 -1，表示查找失败。

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.indexOf("fox")); // 16
console.log(text.indexOf("cat")); // -1
```
  
- **`includes()` 方法**：该方法用于检查字符串是否包含特定子字符串。 如果在字符串中找到子字符串，该方法返回 true。 否则，返回 false。

```js
const text = "The quick brown fox jumps over the lazy dog.";
console.log(text.includes("fox")); // true
console.log(text.includes("cat")); // false
```

- **`slice()` 方法**：此方法返回一个包含原始数组部分浅拷贝的新建数组，该部分由起始和结束索引指定。新建数组包含对与原始数组相同元素的引用（而非副本）。这意味着如果元素是原语（如数字或字串），则值会被拷贝；但如果元素是对象或数组，则拷贝的是引用，而非对象本身。

```js
const text = "freeCodeCamp";
console.log(text.slice(0, 4));  // "free"
console.log(text.slice(4, 8));  // "Code"
console.log(text.slice(8, 12)); // "Camp"
```

- **`toUpperCase()` 方法**：该方法将所有字符转换为大写字母，并返回一个包含所有大写字母的新字符串。

```js
const text = "Hello, world!";
console.log(text.toUpperCase()); // "HELLO, WORLD!"
```

- **`toLowerCase()` 方法**：该方法将所有字符转换为小写字母。

```js
const text = "HELLO, WORLD!"
console.log(text.toLowerCase()); // "hello, world!"
```

- **`replace()` 方法**：此方法允许你在字串中查找指定的值（如单词或字符）并将其替换为另一个值。该方法返回一个包含替换内容的新字串，且不会改变原始字串，因为 JavaScript 字串是不可变的。

```js
const text = "I like cats";
console.log(text.replace("cats", "dogs")); // "I like dogs"
```
 
- **`repeat()` 方法**：该方法用于将字符串重复特定次数。

```js
const text = "Hello";
console.log(text.repeat(3)); // "HelloHelloHello"
```

- **`trim()` 方法**：该方法用于删除字符串首尾的空白。

```js
const text = "  Hello, world!  ";
console.log(text.trim()); // "Hello, world!"
```

- **`trimStart()` 方法**：该方法删除字符串开头（或“起始”）的空白。

```js
const text = "  Hello, world!  ";
console.log(text.trimStart()); // "Hello, world!  "
```

- **`trimEnd()` 方法**：该方法删除字符串末尾的空白。

```js
const text = " Hello, world! ";
console.log(text.trimEnd()); // "  Hello, world!"
```

- **`prompt()` 方法**：`window` 的这种方法用于通过对话框的形式从用户处获取信息。 该方法接受两个参数。 第一个是将出现在对话框中的信息，通常是提示用户输入信息。 第二个是默认值，是可选的，将作为填充输入字段的初始值。

```js
const answer = window.prompt("What's your favorite animal?"); // This will change depending on what the user answers
```

## 使用数字数据类型

- **定义**：JavaScript 的 `Number` 类型包括整数、浮点数、`Infinity` 和 `NaN`。 浮点数是带有小数点的数字。  Positive `Infinity` is a number greater than any other number while `-Infinity` is a number smaller than any other number. `NaN` (`Not a Number`) represents an invalid numeric value like the string `"Jessica"`.

## 常见算术运算

- **加法运算符**：此运算符（`+`）用于计算两个或两个以上数的和。
- **减法运算符**：此运算符（`-`）用于计算两个数的差值。
- **乘法运算符**：此运算符（`*`）用于计算两个或两个以上数的乘积。
- **除法运算符**：此运算符（`/`）用于计算两个数的商。
- **除以零**：如果你尝试除以零，JavaScript 将返回 `Infinity` 。
- **取余运算符**：此运算符（`%`）返回除法的余数。
- **指数运算符**：此运算符（`**`）将一个数字提升为另一个数字的幂。

## 数字和字符串混合计算

- **解释**：当你使用 `+` 操作符对数字和字串进行操作时，JavaScript 会将数字强制转换为字串并连接这两个值。当你使用 `-`、`*` 或 `/` 操作符对字串和数字进行操作时，JavaScript 会将字串强制转换为数字，结果将是数字。对于 `null` 和 `undefined`，JavaScript 在数学操作中将 `null` 视为 0，将 `undefined` 视为 `NaN`。

```js
const result = 5 + '10';

console.log(result); // 510
console.log(typeof result); // string

const subtractionResult = '10' - 5;
console.log(subtractionResult); // 5
console.log(typeof subtractionResult); // number

const multiplicationResult = '10' * 2;
console.log(multiplicationResult); // 20
console.log(typeof multiplicationResult); // number

const divisionResult = '20' / 2;
console.log(divisionResult); // 10
console.log(typeof divisionResult); // number

const result1 = null + 5;
console.log(result1); // 5
console.log(typeof result1); // number

const result2 = undefined + 5;
console.log(result2); // NaN
console.log(typeof result2); // number
```

## 运算符优先级

- **定义**：运算符优先级决定了表达式中运算的求值顺序。 优先级较高的运算符先于优先级较低的运算符进行运算。 括号内的值将优先计算，乘法/除法的优先级高于加法/减法。 如果运算符具有相同的优先级，那么 JavaScript 将使用结合性。 结合性告诉 JavaScript 是从左到右还是从右到左对运算符进行运算。 例如，指数运算符也是从右向左结合的：

```js
const result = (2 + 3) * 4;

console.log(result); // 20

const result2 = 10 - 2 + 3;

console.log(result2); // 11

const result3 = 2 ** 3 ** 2;

console.log(result3); // 512
```

## 自增和自减运算符

- **自增运算符**：该运算符用于将数值加一。 前缀符号 `++num` 先增加变量的值，然后返回一个新值。 后缀符号 `num++` 首先返回变量的当前值，然后增加它。

```js
let x = 5;

console.log(++x); // 6
console.log(x); // 6


let y = 5;

console.log(y++); // 5
console.log(y); // 6
```

- **递减操作符**：该操作符用于将值减少一。前缀和后序表示法的工作方式与之前的递增操作符相同。

```js
let num = 5;

console.log(--num); // 4
console.log(num--); // 4
console.log(num); // 3
```

## 复合赋值运算符

- **加法赋值（`+=`）运算符**：该运算符对数值执行加法运算，并将结果赋值给变量。
- **减法赋值（`-=`）运算符**：该运算符对数值执行减法运算，并将结果赋值给变量。
- **乘法赋值（`*=`）运算符**：该运算符对数值执行乘法运算，并将结果赋值给变量。
- **除法赋值（`/=`）运算符**：该运算符对数值执行除法运算，并将结果赋值给变量。
- **取余赋值（`%=`）运算符**：该运算符将变量除以指定的数字，并将余数赋值给变量。
- **指数赋值（`**=`）运算符**：此运算符将变量提升为指定数字的幂，并将结果赋值给变量。

## 布尔和相等性

- **布尔定义**：布尔是一种只能有两个值的数据类型：`true` 或 `false`。
- **相等（`==`）运算符**：该操作符在检查值是否相等之前使用类型强制。

```js
console.log(5 == '5'); // true
```

- **严格相等（`===`）运算符**：该操作符不执行类型强制，并检查类型和值是否相等。

```js
console.log(5 === '5'); // false
```

- **不等（`!=`）运算符**：该操作符在检查值是否不相等之前使用类型强制。
- **严格不相等 (`!==`) 操作符**：该操作符不执行类型强制转换，并检查类型和值是否都不相等。

## 比较运算符

- **大于 (`>`) 操作符**：此操作符检查左侧的值是否大于右侧的值。
- **大于（`>=`）或相等操作符**：此操作符检查左侧的值是否大于或相等于右侧的值。
- **小于 (`<`) 操作符**：此操作符检查左侧的值是否小于右侧的值。
- **小于（`<=`）或相等操作符**：此操作符检查左侧的值是否小于或等于右侧的值。

## 一元运算符

- **一元正运算符**：该运算符将操作数转换为数字。 如果操作数已经是数字，则保持不变。

```js
const str = '42';
const num = +str;

console.log(num); // 42
console.log(typeof num); // number
```

- **一元负（`-`）运算符**：该运算符将操作数变为负值。

```js
const num = 4;
console.log(-num); // -4
```

- **逻辑非（`!`）运算符**：该运算符翻转操作数的布尔值。 因此，如果操作数是 `true`，会变成 `false`，如果是 `false`，会变成 `true`。

## 位运算符

- **按位与 (`&`) 操作符**：该操作符在两个操作对象的对应位均为 1 时，在该位位置返回 1。
- **按位与赋值（`&=`）操作符**：此操作符对指定数字执行 `bitwise AND` 操作，并将结果重新赋值给变量。
- **按位或（`|`）运算符**：该运算符在两个操作数对应位只要有一个是 1，就返回 1。
- **按位或赋值（`|=`）运算符**：该运算符对指定的数字执行 `bitwise OR` 运算，并将结果重新赋值给变量。
- **按位异或（`^`）运算符**：该运算符在两个操作数对应位中有且仅有一个是 1 时，返回 1。
- **按位非（`~`）运算符**：该运算符反转数字的二进制表示。
- **左移 (`<<`) 操作符**：此操作符将所有位向左移动指定的位数。
- **右移 (`>>`) 操作符**：此操作符将所有位向右移动。

## 条件语句、真值、假值和三元运算符

- **`if/else if/else`**：`if` 语句接收一个条件，并在该条件为 `truthy` 时运行一个代码块。 如果条件为 `false`，则转到 `else if` 代码块。  If none of those conditions are `true`, then it will execute the `else` clause. `Truthy` values are any values that result in `true` when evaluated in a Boolean context like an `if` statement. `Falsy` values are values that evaluate to `false` in a Boolean context.

```js
const score = 87;

if (score >= 90) {
 console.log('You got an A'); 
} else if (score >= 80) {
 console.log('You got a B'); // You got an B
} else if (score >= 70) {
 console.log('You got a C');
} else {
 console.log('You failed! You need to study more!');
}
```

- **三元运算符**：该运算符经常作为编写 `if else` 语句的一种简写方式。

```js
const temperature = 30;
const weather = temperature > 25 ? 'sunny' : 'cool';

console.log(`It's a ${weather} day!`); // It's a sunny day!
```

## 二元逻辑运算符

- **逻辑与（`&&`）操作符**：该操作符检查两个操作对象是否都为真值。如果第一个值为真值，则它将返回第二个值。如果第一个值为假值，则它将返回第一个值。

```js
const result = true && 'hello';

console.log(result); // hello
```

- **逻辑或 (`||`) 操作符**：该操作符检查至少有一个操作对象为真值。如果第一个值为真值，则返回该值。如果第一个值为假值，则返回第二个值。
- **空值合并（`??`）运算符**：只有当第一个值为 `null` 或 `undefined` 时，该运算符才会返回一个值。

```js
const userSettings = {
 theme: null,
 volume: 0,
 notifications: false,
};

let theme = userSettings.theme ?? 'light';
console.log(theme); // light
```

## The `Math` 对象

- **`Math.random()`方法**：该方法生成一个介于 0（包含）和 1（不包含）之间的随机浮点数。 这意味着输出可以是 0，但它永远不会达到 1 。
- **`Math.max()` 方法**：该方法接收一组数字并返回最大值。
- **`Math.min()` 方法**：该方法接收一组数字并返回最小值。
- **`Math.ceil()` 方法**：该方法将数值向上取整为最接近的整数。
- **`Math.floor()` 方法**：该方法将数值向下取整为最接近的整数。
- **`Math.round()` 方法**：该方法将数值四舍五入为最接近的整数。

```js
console.log(Math.round(2.3)); // 2
console.log(Math.round(4.5)); // 5
console.log(Math.round(4.8)); // 5
```

- **`Math.trunc()` 方法**：该方法删除数字的小数部分，只返回整数部分，不进行四舍五入。
- **`Math.sqrt()` 方法**：该方法返回一个数字的平方根。
- **`Math.cbrt()` 方法**：该方法返回一个数字的立方根。
- **`Math.abs()` 方法**：该方法返回一个数字的绝对值。
- **`Math.pow()` 方法**：该方法接收两个数字，第二个数字是第一个数字的指数。

## 常用数字方法

- **`isNaN()`**：`NaN` 代表非数字 "Not-a-Number"。 它是一个特殊值，表示无法表示或未定义的数值结果。  The `isNaN()` function property is used to determine whether a value is `NaN` or not.  `Number.isNaN()` provides a more reliable way to check for `NaN` values, especially in cases where type coercion might lead to unexpected results with the global `isNaN()` function.

```js
console.log(isNaN(NaN));       // true
console.log(isNaN(undefined)); // true
console.log(isNaN({}));        // true

console.log(isNaN(true));      // false
console.log(isNaN(null));      // false
console.log(isNaN(37));        // false


console.log(Number.isNaN(NaN));        // true
console.log(Number.isNaN(Number.NaN)); // true
console.log(Number.isNaN(0 / 0));      // true

console.log(Number.isNaN("NaN"));      // false
console.log(Number.isNaN(undefined));  // false
```

- **`parseFloat()` 方法**：该方法解析字符串参数并返回浮点数。 它的设计目的是从字符串开头提取数字，即使字符串后面包含非数字字符。
- **The `parseInt()` Method**: This method parses a string argument and returns an integer. `parseInt()` stops parsing at the first non-digit it encounters. 对于浮点数，它只返回整数部分。 如果在字符串开头找不到有效整数，则返回 `NaN` 。
- **`toFixed()` 方法**：该方法在数字上调用，它包含一个可选参数，即小数点后的位数。 它返回数字的字符串形式，并带有指定的小数位数。

## 比较运算与 `null` 和 `undefined` 数据类型

- **比较和 `undefined`**：当变量已声明但未赋值时，该变量为 `undefined`。这是未初始化变量和未提供参数的函数参数的默认值。`undefined` 在数值上下文中转换为 `NaN`，这使得所有与 `undefined` 的数值比较都返回 `false`。

```js
console.log(undefined < 0); // false (NaN < 0 is false)
console.log(undefined >= 0); // false (NaN >= 0 is false)
```

- **比较和 `null`**：`null` 类型表现为有意缺失的值。`null` 在数值上下文中转换为 `0`，这可能导致数值比较中出现意外行为：

```js
console.log(null < 0); // false (0 < 0 is false)
console.log(null >= 0); // true (0 >= 0 is true)
```

- 使用相等操作符（`==`）时，`null` 和 `undefined` 只与彼此及自身相等：

```js
console.log(null == undefined); // true
console.log(null == 0); // false
console.log(undefined == NaN); // false
```

- 但是，在使用严格相等运算符（`===`）时，该运算符同时检查值和类型而不执行类型强制，`null` 和 `undefined` 是不相等的：

```js
console.log(null === undefined); // false
```

## `switch` 语句

- **定义**：`switch` 语句对表达式进行计算，并将其值与一系列 `case` 子句匹配。 找到匹配后，将执行与该 case 相关的代码块。

```js
const dayOfWeek = 3; 

switch (dayOfWeek) {
  case 1:
    console.log("It's Monday! Time to start the week strong.");
    break;
  case 2:
    console.log("It's Tuesday! Keep the momentum going.");
    break;
  case 3:
    console.log("It's Wednesday! We're halfway there.");
    break;
  case 4:
    console.log("It's Thursday! Almost the weekend.");
    break;
  case 5:
    console.log("It's Friday! The weekend is near.");
    break;
  case 6:
    console.log("It's Saturday! Enjoy your weekend.");
    break;
  case 7:
    console.log("It's Sunday! Rest and recharge.");
    break;
  default:
    console.log("Invalid day! Please enter a number between 1 and 7.");
}
```

## JavaScript 函数

- 函数是可重复使用的代码片段，可执行特定任务。
- 可以使用 `function` 关键字定义函数，该关键字后跟一个名称、一个参数列表和一个执行任务的代码块。
- 实参是调用函数时传递给函数的值。
- 函数执行完毕后，总会返回一个值。
- 默认情况下，函数的返回值为 `undefined` 。
- `return` 关键字用于指定从函数返回的值，并结束函数的执行。

## 箭头函数

- 箭头函数是 JavaScript 中编写函数的一种更简洁的方法。
- 箭头函数使用参数和函数体之间的 `=>` 语法定义。
- 定义箭头函数时，不需要使用 `function` 关键字。
- 如果只使用一个参数，可以省略参数列表中的括号。
- 如果函数体只有一个表达式，则可以省略大括号和 `return` 关键字。

## 编程中的作用域

- **全局作用域**：这是 JavaScript 中最外层的作用域。 在全局作用域中声明的变量可以从代码中的任何地方访问，这些变量被称为全局变量。
- **局部作用域**：指在函数中声明的变量。 这些变量只能在声明它们的函数中访问，称为局部变量。
- **块级作用域**：块是由 `{}` 括起来的一组语句，比如 `if` 语句或循环中的代码块。
- 使用 `let` 和 `const` 的块级作用域可对变量的可访问性进行更精细的控制，有助于防止错误并使代码更具可预测性。

## JavaScript 数组基础

- **定义**：JavaScript 数组是一个有序的值集合，每个值由一个数字索引标识。JavaScript 数组中的值可以是不同的数据类型，包括数字、字串、布尔、对象，甚至其他数组。数组在内存中是连续的，这意味着所有元素都保存在单个连续的内存块中，从而允许高效的索引和通过索引快速访问元素。

```js
const developers = ["Jessica", "Naomi", "Tom"];
```

- **访问数组中的元素**：要访问数组中的元素，你需要先访问数组，然后在方括弧内写入其索引号。JavaScript 数组是从 0 开始索引的，这意味着第一个元素的索引是 0，第二个元素的索引是 1，依此类推。如果你尝试访问数组中不存在的索引，JavaScript 将返回 `undefined`。

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers[0] // "Jessica"
developers[1] // "Naomi"

developers[10] // undefined
```

- **`length` 属性**：此属性用于返回数组中的项数。

```js
const developers = ["Jessica", "Naomi", "Tom"];
developers.length // 3
```

- **更新数组中的元素**：要更新数组中的元素，你使用赋值操作符（`=`）为特定索引处的元素赋值新值。

```js
const fruits = ['apple', 'banana', 'cherry'];
fruits[1] = 'blueberry';

console.log(fruits); // ['apple', 'blueberry', 'cherry']
```

## 二维数组

- **Definition**: A two-dimensional array is essentially an array of arrays. 它用于表示具有自然网格结构的数据，如棋盘、电子表格或图像中的像素。 要访问二维数组中的元素，需要两个索引：一个是行索引，一个是列索引。

```js
const chessboard = [
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']
];

console.log(chessboard[0][3]); // "Q"
```

## 数组解构

- **定义**：数组解构是 JavaScript 中的一个特色，允许你从数组中提取值并赋值给变量，以更简洁且易读的方式。它提供了一种方便的语法，将数组元素打包到不同的变量中。

```js
const fruits = ["apple", "banana", "orange"];

const [first, second, third] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(third); // "orange"
```

- **Rest 语法**：这允许你捕捉尚未被解构的数组剩余元素到一个新建数组中。

```js
const fruits = ["apple", "banana", "orange", "mango", "kiwi"];
const [first, second, ...rest] = fruits;

console.log(first); // "apple"
console.log(second); // "banana"
console.log(rest); // ["orange", "mango", "kiwi"]
```

## 常用数组方法

- **`push()` 方法**：此方法用于将元素添加到数组末尾，并将返回新长度。

```js
const desserts = ["cake", "cookies", "pie"];
desserts.push("ice cream");

console.log(desserts); // ["cake", "cookies", "pie", "ice cream"];
```

- **`pop()` 方法**：此方法用于从数组中移除最后一个元素，并将该被移除的元素返回。如果数组为空，则返回值将是 `undefined`。

```js
const desserts = ["cake", "cookies", "pie"];
desserts.pop();

console.log(desserts); // ["cake", "cookies"];
```

- **`shift()` 方法**：此方法用于从数组中移除第一个元素并返回该被移除的元素。如果数组为空，则返回值将是 `undefined`。

```js
const desserts = ["cake", "cookies", "pie"];
desserts.shift();

console.log(desserts); // ["cookies", "pie"];
```

- **`unshift()` 方法**：此方法用于将元素添加到数组开头，并将返回新长度。

```js
const desserts = ["cake", "cookies", "pie"];
desserts.unshift("ice cream");

console.log(desserts); // ["ice cream", "cake", "cookies", "pie"];
```

- **`indexOf()` 方法**：此方法用于查找数组中特定元素的第一个索引。如果找不到该元素，则返回 `-1`。

```js
const fruits = ["apple", "banana", "orange", "banana"];
const index = fruits.indexOf("banana");

console.log(index); // 1
console.log(fruits.indexOf("not found")); // -1
```

- **`splice()` 方法**：此方法用于从数组中的任意位置添加或删除元素。`splice()` 方法的返回值将是一个包含从数组中删除的项的数组。如果没有删除任何项，则返回一个空数组。此方法会修改原始数组，在原地更改它，而不是创建一个新数组。第一个参数指定开始修改数组的索引。第二个参数是你希望删除的元素数量。后续参数是你希望添加的元素。

```js
const colors = ["red", "green", "blue"];
colors.splice(1, 0, "yellow", "purple");

console.log(colors); // ["red", "yellow", "purple", "green", "blue"]
```

- **`includes()` 方法**：此方法用于查看数组是否包含特定值。如果数组包含指定的元素，此方法返回 `true`，否则返回 `false`。

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];

console.log(programmingLanguages.includes("Python")); // true
console.log(programmingLanguages.includes("Perl")); // false
```

- **`concat()` 方法**：此方法通过合并两个或多个数组来创建一个新数组。

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.concat("Perl");

console.log(newList); // ["JavaScript", "Python", "C++", "Perl"]
```

- **`slice()` 方法**：此方法返回数组部分的浅拷贝，从指定索引开始或整个数组。浅拷贝将拷贝对数组的引用，而不是复制数组本身。

```js
const programmingLanguages = ["JavaScript", "Python", "C++"];
const newList = programmingLanguages.slice(1);

console.log(newList); // ["Python", "C++"]
```

- **展开语法**：展开语法用于创建数组的浅拷贝。

```js
const originalArray = [1, 2, 3];
const shallowCopiedArray = [...originalArray];

shallowCopiedArray.push(4);

console.log(originalArray); // [1, 2, 3]
console.log(shallowCopiedArray); // [1, 2, 3, 4]
```

- **`split()` 方法**：此方法将字串分割成子字串的数组，并根据给定的分隔符指定每个分割的位置。如果未提供分隔符，该方法将返回一个包含原始字串作为单个元素的数组。

```js
const str = "hello";
const charArray = str.split("");

console.log(charArray); // ["h", "e", "l", "l", "o"]
```

- **`reverse()` 方法**：此方法会原地反转一个数组。

```js
const desserts = ["cake", "cookies", "pie"];
console.log(desserts.reverse()); // ["pie", "cookies", "cake"]
```

- **`join()` 方法**：此方法将数组的所有元素连接成一个单一的字串，每个元素之间用指定的分隔符分隔。如果未提供分隔符，或使用空字串（`""`），则元素将无分隔符地连接。

```js
const reversedArray = ["o", "l", "l", "e", "h"];
const reversedString = reversedArray.join("");

console.log(reversedString); // "olleh"
```

## 对象基础

- **定义**：对象是一种由属性组成的数据结构。属性由密钥和值组成。要从对象中访问数据，你可以使用点符号或方括弧符号。

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};

console.log(person.name);  // Alice
console.log(person["name"]); // Alice
```

要设置现有对象的属性，你可以使用点符号或方括弧符号配合赋值操作符。

```js
const person = {
  name: "Alice",
  age: 30
};

person.job = "Engineer"
person["hobby"] = "Knitting"
console.log(person);  // {name: 'Alice', age: 30, job: 'Engineer', hobby: 'Knitting'}
```

## 从对象中移除属性

- **`delete` 操作符**：此操作符用于从对象中移除一个属性。

```js
const person = {
  name: "Alice",
  age: 30,
  job: "Engineer"
};

delete person.job;

console.log(person.job); // undefined
```

## 查看对象是否具有属性

- **`hasOwnProperty()` 方法**：此方法返回一个布尔值，指示对象是否拥有指定的属性作为其自身属性。

```js
const person = {
  name: "Alice",
  age: 30
};

console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("job")); // false
```

- **`in` 操作符**：如果属性存在于对象中，该操作符将返回 `true`。

```js
const person = {
  name: "Bob",
  age: 25
};

console.log("name" in person);  // true
```

## 从嵌套对象访问属性

- **访问数据**：从嵌套对象访问属性涉及使用点符号或方括弧符号，就像访问简单对象的属性一样。然而，你需要链式调用这些访问器以深入嵌套结构。

```js
const person = {
  name: "Alice",
  age: 30,
  contact: {
    email: "alice@example.com",
    phone: {
      home: "123-456-7890",
      work: "098-765-4321"
    }
  }
};

console.log(person.contact.phone.work); // "098-765-4321"
```

## 原语和非原语数据类型

- **原语数据类型**：这些数据类型包括数字、字串、布尔、`null`、`undefined` 和符号。这些类型被称为“原语”，因为它们表现单个值且不是对象。原语值是不可变的，这意味着一旦创建，它们的值就不能被更改。
- **非原生类型数据**：在 JavaScript 中，这些是对象，包括普通对象、数组和函数。与原语不同，非原生类型可以作为属性或元素保存多值。

## 对象方法

- **定义**：对象方法是关联到对象的函数。它们被定义为对象的属性，并且可以访问和操作对象的数据。方法内部的 `this` 关键字引用对象本身，从而能够访问其属性。

```js
const person = {
  name: "Bob",
  age: 30,
  sayHello: function() {
    return "Hello, my name is " + this.name;
  }
};

console.log(person.sayHello()); // "Hello, my name is Bob"
```

## 对象构造函数

- **定义**：在 JavaScript 中，构造函数是一种用于创建和初始化对象的特殊类型函数。它通过 `new` 关键字调用，并且可以初始化新创建对象上的属性和方法。`Object()` 构造函数创建一个新的空对象。

```js
new Object()
```

## 使用可选链操作符（`?.`）

- **定义**：此操作符让你可以安全地访问对象属性或调用方法，而无需担心它们是否存在。

```js
const user = {
  name: "John",
  profile: {
    email: "john@example.com",
    address: {
      street: "123 Main St",
      city: "Somewhere"
    }
  }
};

console.log(user.profile?.address?.street); // "123 Main St"
console.log(user.profile?.phone?.number);   // undefined
```

## 对象解构

- **定义**：对象解构允许你从对象中提取值，并以更简洁且易读的方式将它们赋值给变量。

```js
const person = { name: "Alice", age: 30, city: "New York" };

const { name, age } = person;

console.log(name); // Alice
console.log(age);  // 30
```

## 处理 JSON

- **定义**：JSON 代表 JavaScript 对象表示法。它是一种轻量级、基于文本的数据格式，通常用于在服务器和网页应用之间交换数据。

```js
{
  "name": "Alice",
  "age": 30,
  "isStudent": false,
  "list of courses": ["Mathematics", "Physics", "Computer Science"]
}
```

- **`JSON.stringify()`**：此方法用于将 JavaScript 对象转换为 JSON 字串。当你想以一种可以轻松共享或在系统之间传输的数据形式保存或传输数据时，这非常有用。

```js
const user = {
  name: "John",
  age: 30,
  isAdmin: true
};

const jsonString = JSON.stringify(user);
console.log(jsonString); // '{"name":"John","age":30,"isAdmin":true}'
```

- **`JSON.parse()`**：此方法将 JSON 字串转换回 JavaScript 对象。当你从网络服务器或 localStorage 获取 JSON 数据并且需要在你的应用中操作这些数据时，这非常有用。

```js
const jsonString = '{"name":"John","age":30,"isAdmin":true}';
const userObject = JSON.parse(jsonString);

// result: { name: 'John', age: 30, isAdmin: true }
console.log(userObject);
```


## 使用循环

- **`for` 循环**：这种类型的循环用于重复执行一个代码块若干次。该循环分为三部分：初始化语句、条件和递增/递减语句。初始化语句在循环开始前执行，通常用于初始化计数变量。条件在每次循环迭代前进行评估。一次迭代是循环的一次单独执行。如果条件为 `true`，则执行循环内的代码块。如果条件为 `false`，循环停止，继续执行下一个代码块。递增/递减语句在每次循环迭代后执行，通常用于递增或递减计数变量。

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

- **`for...of` 循环**：当你需要遍历可迭代对象中的值时使用这种类型的循环。可迭代对象的示例有数组和字串。

```js
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num);
}
```

- **`for...in` 循环**：当你需要循环遍历一个对象的属性时，这种类型的循环是最合适的。此循环将迭代对象的所有可枚举属性，包括继承的属性和非数字属性。

```js
const fruit = {
  name: 'apple',
  color: 'red',
  price: 0.99
};

for (const prop in fruit) {
  console.log(fruit[prop]);
}
```

- **`while` 循环**：只要条件为 `true`，这种类型的循环就会运行一块代码。

```js
let i = 5;

while (i > 0) {
  console.log(i);
  i--;
}
```

- **`do...while` 循环**：这种类型的循环会在检查条件之前至少执行一次代码块。

```js
let userInput;

do {
  userInput = prompt("Please enter a number between 1 and 10");
} while (Number(userInput) < 1 || Number(userInput) > 10);

alert("You entered a valid number!");
```

## `break` 和 `continue` 语句

- **定义**：`break` 语句用于提前退出循环，而 `continue` 语句用于跳过当前循环的迭代并进入下一次迭代。

```js
// Example of break statement
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, and 4

// Example of continue statement 
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    continue;
  }
  console.log(i);
}

// Output: 0, 1, 2, 3, 4, 6, 7, 8, and 9
```

## 字串构造函数和 `toString()` 方法

- **定义**：字串对象用于表现字符序列。字串对象是使用 `String` 构造函数创建的，它将原语值包装在一个对象中。

```js
const greetingObject = new String("Hello, world!");

console.log(typeof greetingObject); // "object"
```

- **`toString()` 方法**：此方法将一个值转换为其字串表现。你可以对数字、布尔、数组和对象使用此方法。

```js
const num = 10;
console.log(num.toString()); // "10"

const arr = [1, 2, 3];
console.log(arr.toString()); // "1,2,3"
```

此方法接受一个可选的 `radix`，它是一个介于 2 到 36 之间的数字。此 `radix` 表现为基数，例如二进制的基数 2 或八进制的基数 8。如果未指定 `radix`，则默认为基数 10，即十进制。


```js
const num = 10;
console.log(num.toString(2)); // "1010"(binary)
```

## 数字构造函数

- **定义**：`Number` 构造函数用于创建数字对象。数字对象包含一些有用的属性和方法，比如 `isNaN` 和 `toFixed` 方法。大多数情况下，你会使用 `Number` 构造函数将其他数据类型转换为数字数据类型。

```js
const myNum = new Number("34");
console.log(typeof myNum); // "object"

const num = Number('100');
console.log(num); // 100

console.log(typeof num); // number
```

## 命名变量和函数的最佳实践

- **camelCasing**：按照惯例，JavaScript 开发者会使用驼峰命名法来命名变量和函数。驼峰命名法是指第一个单词全部小写，后续单词首字母大写。例如 `isLoading`。

- **布尔命名**：对于布尔变量，通常的做法是使用诸如 "is"、"has" 或 "can" 之类的前缀。

```js
let isLoading = true;
let hasPermission = false;
let canEdit = true;
```

- **命名函数**：对于函数，名称应清楚地表明函数的作用。对于返回布尔值的函数（通常称为判断式），你可以使用相同的 "is"、"has" 或 "can" 前缀。当你有获取数据的函数时，通常以 "get" 开头。当你有设置数据的函数时，通常以 "set" 开头。对于事件处理函数，你可以使用 "handle" 作为前缀或使用 "Handler" 作为后缀。

```js
function getUserData() { /* ... */ }

function isValidEmail(email) { /* ... */ }

function getProductDetails(productId) { /* ... */ }

function setUserPreferences(preferences) { /* ... */ }

function handleClick() { /* ... */ }
```

- **在循环中命名变量**：在循环中为迭代器变量命名时，通常使用单个字母如 `i`、`j` 或 `k`。

```js
for (let i = 0; i < array.length; i++) { /* ... */ }
```

## 处理稀疏数组

- **定义**：数组中可以有空槽。空槽被定义为其中没有任何内容的槽。这不同于值为 `undefined` 的数组槽。这类数组被称为稀疏数组。

```js
const sparseArray = [1, , , 4];
console.log(sparseArray.length); // 4
```
  
## 代码检查工具和格式化工具

- **Linters**：Linter 是一种静态代码分析工具，用于标记编程错误、错误、风格错误和可疑构造。一个常见的 linter 示例是 ESLint。
- **格式化工具**：格式化工具是自动格式化你的代码以遵循特定样式指南的工具。一个常见的格式化工具示例是 Prettier。

## 内存管理

- **定义**：内存管理是控制内存的过程，在需要时进行内存分配，在不再需要时释放内存。JavaScript 使用自动内存管理。这意味着 JavaScript（更具体地说，是你网页浏览器中的 JavaScript 引擎）会为你处理内存分配和释放。你不必在代码中显式释放内存。这个自动过程通常称为“垃圾回收”。

## 闭包

- **定义**：闭包是一个函数，即使在外部函数已经返回之后，仍然可以访问其外部（包含的）词法作用域中的变量。

```js
function outerFunction(x) {
  let y = 10;
  function innerFunction() {
    console.log(x + y);
  }
  return innerFunction;
}

let closure = outerFunction(5);
closure(); // 15
```

## `var` 关键字和提升

- **定义**：`var` 是 2015 年之前声明变量的原始方式。但 `var` 在作用域、重新声明等方面存在一些问题。这就是为什么现代 JavaScript 编程使用 `let` 和 `const` 的原因。
- **使用 `var` 重新声明变量**：如果你尝试使用 `let` 重新声明一个变量，那么你会得到一个 `SyntaxError`。但使用 `var`，你可以重新声明一个变量。

```js
// Uncaught SyntaxError: Identifier 'num' has already been declared 
let num = 19;
let num = 18;

var myNum = 5;
var myNum = 10; // This is allowed and doesn't throw an error

console.log(myNum) // 10
```

- **`var` 和作用域**：在块（如 `if` 语句或 `for` 循环）内用 `var` 声明的变量仍然可以在该块外访问。

```js
if (true) {
  var num = 5;
}
console.log(num); // 5
```

- **提升**：这是 JavaScript 在代码执行前的编译阶段，将声明移动到各自作用域顶部的默认行为。当你使用 `var` 关键字声明变量时，JavaScript 会将声明提升到其作用域的顶部。

```js
console.log(num); // undefined
var num = 5;
console.log(num); // 5
```

当你使用函数声明语法声明一个函数时，函数名和函数体都会被提升。这意味着你可以在代码中声明函数之前调用该函数。

```js
sayHello(); // "Hello, World!"

function sayHello() {
  console.log("Hello, World!");
}
```

使用 `let` 或 `const` 进行的变量声明会被提升，但它们不会被初始化，并且你不能在代码中的实际声明之前访问它们。这种行为通常被称为“暂时性死区”。

```js
console.log(num); // Throws a ReferenceError
let num = 10;
```

## 使用导入、导出和模块

- **模块**：这是一个自包含的代码单元，封装了相关的函数、类或变量。要创建一个模块，你需要在一个单独的文件中编写你的 JavaScript 代码。
- **导出**：你想要提供给应用其他部分使用的任何变量、函数或类，都需要使用 `export` 关键字显式导出。导出有两种类型：命名导出和默认导出。
- **导入**：要在应用的其他部分使用导出的项，你需要使用 `import` 关键字导入它们。类型可以是命名导入、默认导入和命名空间导入。

```js
// Within a file called math.js, we export the following functions:

// Named export
export function add(num1, num2) {
  return num1 + num2;
}

// Default export
export default function subtract(num1, num2) {
  return num1 - num2;
}

// Within another file, we can import the functions from math.js.

// Named import - This line imports the add function.
// The name of the function must exactly match the one exported from math.js.
import { add } from './math.js';

// Default import - This line imports the subtract function.
// The name of the function can be anything.
import subtractFunc from './math.js';

// Namespace import - This line imports everything from the file.
import * as Math from './math.js';

console.log(add(5, 3)); // 8
console.log(subtractFunc(5, 3)); // 2
console.log(Math.add(5, 3)); // 8
console.log(Math.subtract(5, 3)); // 2
```

## 回调函数和 `forEach` 方法

- **定义**：在 JavaScript 中，回调函数是作为参数传递给另一个函数的函数，以便在第一个函数中的某个时刻被调用。
- **`forEach()` 方法**：此方法用于迭代数组中的每个元素并对每个元素执行操作。`forEach` 中的回调函数最多可以接受三个参数：当前元素、当前元素的索引以及调用 `forEach` 的数组。

```js
const numbers = [1, 2, 3, 4, 5];

// Result: 2 4 6 8 10
numbers.forEach((number) => {
  console.log(number * 2);
});
```

## 高阶函数

- **定义**：高阶函数将一个或多个函数作为参数，并返回一个函数或值作为结果。

```js
function operateOnArray(arr, operation) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(operation(arr[i]));
  }
  return result;
}

function double(x) {
  return x * 2;
}

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = operateOnArray(numbers, double);
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
```

- **`map()` 方法**：此方法用于通过将给定函数应用到原数组的每个元素来创建一个新数组。回调函数最多可以接受三个参数：当前元素、当前元素的索引以及调用 `map` 的数组。

```js
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);

console.log(numbers); // [1, 2, 3, 4, 5]
console.log(doubled); // [2, 4, 6, 8, 10]
```

- **`filter()` 方法**：此方法用于创建一个包含通过指定测试的元素的新数组，使其在根据条件选择性提取项时非常有用。就像 `map` 方法一样，`filter` 方法的回调函数接受相同的三个参数：当前正在处理的元素、索引和数组。

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter((num) => num % 2 === 0);

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

- **`reduce()` 方法**：此方法用于处理数组并将其压缩为单个值。该单个值可以是数字、字串、对象，甚至是另一个数组。`reduce()` 方法通过依次对数组中的每个元素应用函数来工作，将每次计算的结果传递给下一个。此函数通常称为累加器函数。累加器函数接受两个主要参数：累加器和当前值。累加器是你保存操作运行结果的地方，当前值是正在处理的数组元素。

```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0
);

console.log(sum); // 15
```

## 方法链式调用

- **定义**：方法链是一种编程技术，允许你在同一行 `code` 中对同一个对象调用多个方法。该技术可以使你的 `code` 更加可读和简洁，尤其是在对同一个对象执行一系列操作时。

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

## 使用 `sort` 方法

- **定义**：`sort` 方法用于对数组的元素进行排序并返回排序后数组的引用。此情况下不会进行拷贝，因为元素是在原地排序的。

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();

console.log(fruits); // ["Apple", "Banana", "Mango", "Orange"]
```

如果你需要排序数字，那么你需要传入一个比较函数。`sort` 方法将元素转换为字串，然后比较它们的 UTF-16 码元序列。UTF-16 码元是表现字串中字符的数值。UTF-16 码元的例子是数字 65、66 和 67，分别表现字符 `"A"`、`"B"` 和 `"C"`。因此数字 200 出现在数字 3 之前，因为在比较它们的 UTF-16 码元时，字串 `"200"` 出现在字串 `"3"` 之前。

```js
const numbers = [414, 200, 5, 10, 3];

numbers.sort((a, b) => a - b);

console.log(numbers); // [3, 5, 10, 200, 414]
```

参数 `a` 和 `b` 是被比较的两个元素。如果 `a` 应该排在 `b` 之前，比较函数应返回负值；如果 `a` 应该排在 `b` 之后，比较函数应返回正值；如果 `a` 和 `b` 相等，比较函数应返回零。

## 使用 `every` 和 `some` 方法

- **`every()` 方法**：此方法测试数组中的所有元素是否通过由提供的函数实现的测试。如果提供的函数对数组中的所有元素都返回 `true`，则 `every()` 方法返回 `true`。如果有任何元素未通过测试，该方法会立即返回 `false` 并停止检查剩余元素。

```js
const numbers = [2, 4, 6, 8, 10];
const hasAllEvenNumbers = numbers.every((num) => num % 2 === 0);

console.log(hasAllEvenNumbers); // true
```

- **`some()` 方法**：此方法查看是否至少有一个元素通过测试。`some()` 方法一旦找到通过测试的元素就返回 `true`。如果没有元素通过测试，则返回 `false`。

```js
const numbers = [1, 3, 5, 7, 8, 9];
const hasSomeEvenNumbers = numbers.some((num) => num % 2 === 0);

console.log(hasSomeEvenNumbers); // true
```

## 操作 DOM 和 Web API

- **API**：API（应用编程接口）是一组规则和协议，允许软件应用程序彼此通信并高效交换数据。
- **Web API**：Web API 专为网页应用设计。这些类型的 API 通常分为两大类：浏览器 API 和第三方 API。
- **浏览器 API**：这些 API 公开浏览器中的数据。作为网页开发者，你可以使用 JavaScript 访问和操作这些数据。
- **第三方 API**：这些不是浏览器默认内置的。你必须以某种方式获取它们的代码。通常，它们会有详细的文档说明如何使用它们的服务。一个例子是 Google Maps API，你可以用它在你的网站上显示交互式地图。
- **DOM**：DOM 代表文档对象模型。它是一个编程接口，允许你与超文本标记语言文档交互。通过 DOM，你可以添加、修改或删除网页上的元素。DOM 树的根是 `html` 元素。它是 HTML 文档所有内容的顶层容器。所有其他节点都是该根节点的后代。然后，在根节点下，我们在层次结构中找到其他节点。父节点是包含其他元素的元素。子节点是包含在另一个元素内的元素。
- **`navigator` 接口**：这提供有关浏览器环境的信息，例如用户代理字串、平台和浏览器版本。用户代理字串是一个文本字串，用于识别所使用的浏览器和操作系统。
- **`window`接口**：它表现包含 DOM 文档的浏览器窗口。它提供与浏览器窗口交互的方法和属性，例如调整窗口大小、新建窗口以及导航到不同的 URL。

## 使用 `querySelector()`、`querySelectorAll()` 和 `getElementById()` 方法

- **`getElementById()` 方法**：此方法用于获取表现具有指定 `id` 的超文本标记语言元素的对象。请记住，ID 在每个超文本标记语言文档中必须唯一，因此此方法只会返回一个元素对象。

```html
<div id="container"></div>
```

```js
const container = document.getElementById("container");
```

- **`querySelector()` 方法**：此方法用于获取超文本标记语言文档中第一个匹配作为参数传入的 CSS 选择器的元素。

```html
<section class="section"></section>
```

```js
const section = document.querySelector(".section");
```

- **`querySelectorAll()` 方法**：你可以使用此方法获取匹配特定 CSS 选择器的所有 DOM 元素的列表。

```html
<ul class="ingredients">
  <li>Sugar</li>
  <li>Milk</li>
  <li>Eggs</li>
</ul>
```

```js
const ingredients = document.querySelectorAll('ul.ingredients li');
```

## 使用 `innerText()`、`innerHTML()`、`createElement()` 和 `textContent()` 方法

- **`innerHTML` 属性**：这是 `Element` 的一个属性，用于设置或更新超文本标记语言标记的部分内容。

```html
<div id="container">
  <!-- Add new elements here -->
</div>
```

```js
const container = document.getElementById("container");
container.innerHTML = '<ul><li>Cheese</li><li>Tomato</li></ul>';
```

- **`createElement` 方法**：用于创建一个超文本标记语言元素。

```js
const img = document.createElement("img");
```

- **`innerText`**：这表现了 HTML 元素及其子元素的可见文本内容。

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.innerText);
```

- **`textContent`**：这会返回一个元素的纯文本内容，包括其所有子元素内的文本。

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

```js
const container = document.getElementById("container");
console.log(container.textContent);
```

## 使用 `appendChild()` 和 `removeChild()` 方法

- **`appendChild()` 方法**：此方法用于将节点添加到指定父节点的子节点列表末尾。

```html
<ul id="desserts">
  <li>Cake</li>
  <li>Pie</li>
</ul>
```

```js
const dessertsList = document.getElementById("desserts");
const listItem = document.createElement("li");

listItem.textContent = "Cookies";
dessertsList.appendChild(listItem);
```

- **`removeChild()` 方法**：此方法用于从 DOM 中移除节点。

```html
<section id="example-section">
  <h2>Example sub heading</h2>
  <p>first paragraph</p>
  <p>second paragraph</p>
</section>
```

```js
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");

sectionEl.removeChild(lastParagraph);
```

## 使用 `setAttribute` 方法

- **定义**：此方法用于为给定的元素设置属性。如果属性已存在，则更新其值。否则，将添加一个带有值的新属性。

```html
<p id="para">I am a paragraph</p>
```

```js
const para = document.getElementById("para");
para.setAttribute("class", "my-class");
```

## 事件对象

- **定义**：`Event` 对象是当用户以某种方式与你的网页交互时触发的负载。这些交互可以是点击按钮、聚焦输入框或摇动他们的移动设备。所有 `Event` 对象都会有 `type` 属性。该属性显示触发负载的事件类型，例如 keydown 或 click。这些值将对应于你可能传递给 `addEventListener()` 的相同值，在那里你可以捕捉并利用 `Event` 对象。

## `addEventListener()` 和 `removeEventListener()` 方法

- **`addEventListener` 方法**：此方法用于监听事件。它接受两个参数：你想监听的事件和事件发生时将被调用的函数。一些常见的事件示例包括点击事件、输入事件和更改事件。

```js
const btn = document.getElementById("btn");

btn.addEventListener("click", () => alert("You clicked the button"));
```

- **`removeEventListener` 方法**：此方法用于移除之前通过 `addEventListener` 方法为元素添加的事件监听器。当你想停止监听元素上的特定事件时，这非常有用。

```js
const bodyEl = document.querySelector("body");
const para = document.getElementById("para");
const btn = document.getElementById("btn");

let isBgColorGrey = true;

function toggleBgColor() {
  bodyEl.style.backgroundColor = isBgColorGrey ? "blue" : "grey";
  isBgColorGrey = !isBgColorGrey;
}

btn.addEventListener("click", toggleBgColor);

para.addEventListener("mouseover", () => {
  btn.removeEventListener("click", toggleBgColor);
});
```

- **内联事件处理器**：内联事件处理器是 HTML 元素上的特殊属性，用于在事件发生时执行 JavaScript 代码。在现代 JavaScript 中，内联事件处理器不被视为最佳实践。更推荐使用 `addEventListener` 方法。

```html
<button onclick="alert('Hello World!')">Show alert</button>
```

## DOMContentLoaded

- **定义**：当超文本标记语言文档中的所有内容都已装载并解析时，会触发 `DOMContentLoaded` 事件。如果你有外部样式表或图像，`DOMContentLoaded` 事件不会等待它们装载。它只会等待超文本标记语言装载完成。

## 使用 `style` 和 `classList`

- **`Element.style` 属性**：此属性是一个只读属性，表现元素的内联样式。你可以使用此属性来获取或设置元素的样式。

```js
const paraEl = document.getElementById("para");
paraEl.style.color = "red";
```

- **`Element.classList` 属性**：此属性是一个只读属性，可用于为元素添加、移除或切换类。

```js
// Example adding a class
const paraEl = document.getElementById("para");
paraEl.classList.add("highlight");

// Example removing a class
paraEl.classList.remove("blue-background");

// Example toggling a class
const menu = document.getElementById("menu");
const toggleBtn = document.getElementById("toggle-btn");

toggleBtn.addEventListener("click", () => menu.classList.toggle("show"));
```


## 使用 `setTimeout` 和 `setInterval` 方法

- **`setTimeout()` 方法**：此方法允许你延迟指定时间后执行一个操作。

```js
setTimeout(() => {
 console.log('This runs after 3 seconds'); 
}, 3000);
```

- **`setInterval()` 方法**：此方法会以设定的间隔重复运行一段代码。由于 `setInterval()` 会在指定的间隔持续执行提供的函数，你可能想要停止它。为此，你必须使用 `clearInterval()` 方法。

```js
setInterval(() => {
 console.log('This runs every 2 seconds');
}, 2000);

// Example using clearInterval
const intervalID = setInterval(() => {
 console.log('This will stop after 5 seconds');
}, 1000);

setTimeout(() => {
 clearInterval(intervalID);
}, 5000);
```

## `requestAnimationFrame()` 方法

- **定义**：此方法允许你在下一次屏幕重绘之前调度动画的下一步，从而实现流畅且视觉上吸引人的体验。下一次屏幕重绘指的是浏览器刷新网页视觉显示的时刻。这通常每秒发生多次，在大多数显示器上约为 60 次（或每秒 60 帧）。

```js
function animate() {
 // Update the animation...
 // for example, move an element, change a style, and more.
 update();
 // Request the next frame
 requestAnimationFrame(animate);
}
```

## Web 动画 API

- **定义**：Web Animations API 让你可以直接在 JavaScript 中创建和控制动画。

```js
const square = document.querySelector('#square');

const animation = square.animate(
 [{ transform: 'translateX(0px)' }, { transform: 'translateX(100px)' }],
 {
   duration: 2000, // makes animation lasts 2 seconds
   iterations: Infinity, // loops indefinitely
   direction: 'alternate', // moves back and forth
   easing: 'ease-in-out', // smooth easing
 }
);
```

## Canvas API

- **定义**：Canvas API 是一个强大的工具，允许你直接在你的 JavaScript `file` 中操作图形。要使用 Canvas API，你首先需要在 `HTML` 中提供一个 `canvas` 元素。该元素充当一个绘图表面，你可以通过 Canvas API 中接口的实例方法和属性来操作它。该 API 包含诸如 `HTMLCanvasElement`、`CanvasRenderingContext2D`、`CanvasGradient`、`CanvasPattern` 和 `TextMetrics` 等接口，这些接口包含你可以用来在你的 JavaScript `file` 中创建图形的方法和属性。

```html
<canvas id="my-canvas" width="400" height="400"></canvas>
```

```js
const canvas = document.getElementById('my-canvas');

// Access the drawing context of the canvas. 
// "2d" allows you to draw in two dimensions 
const ctx = canvas.getContext('2d');

// Set the background color
ctx.fillStyle = 'crimson';

// Draw a rectangle
ctx.fillRect(1, 1, 150, 100);
```

## 使用 JavaScript 打开和关闭对话框及模态窗口

- **模态和对话框定义**：对话框让你向用户显示重要的信息或操作。使用超文本标记语言内置的对话框元素，你可以轻松地在你的网页应用中创建这些对话框（包括模态和非模态对话框）。模态对话框是一种迫使用户在访问应用或网页的其他部分之前与其交互的对话框。相比之下，非模态对话框允许用户在对话框打开时继续与页面或应用的其他部分交互。它不会阻止访问其余内容。
- **`showModal()` 方法**：此方法用于打开模态框。

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');

openButton.addEventListener('click', () => {
  dialog.showModal();
});
```

- **`close()` 方法**：此方法用于关闭模态框。

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
   <button id="close-modal">Close Modal</button>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

```js
const dialog = document.getElementById('my-modal');
const openButton = document.getElementById('open-modal');
const closeButton = document.getElementById('close-modal');

openButton.addEventListener('click', () => {
  dialog.show();
});

closeButton.addEventListener('click', () => {
  dialog.close();
});
```

## 更改事件

- **定义**：`change` 事件是一种特殊的事件，当用户修改某些输入元素的值时触发。示例包括选中复选框或单选按钮，或者用户从日期选择器或下拉菜单中进行选择时。

```html
<label>
  Choose a programming language:
  <select class="language" name="language">
    <option value="">---Select One---</option>
    <option value="JavaScript">JavaScript</option>
    <option value="Python">Python</option>
    <option value="C++">C++</option>
  </select>
</label>

<p class="result"></p>
```

```js 
const selectEl = document.querySelector(".language");
const result = document.querySelector(".result");

selectEl.addEventListener("change", (e) => {
  result.textContent = `You enjoy programming in ${e.target.value}.`;
});
```

## 事件冒泡

- **定义**：事件冒泡，或传播，指的是事件在被触发时如何“冒泡”到父对象。

## 事件委托

- **定义**：事件委托是监听已经冒泡到父元素的事件的进程，而不是直接在触发事件的元素上处理它们。

## JavaScript 和无障碍

### 常见的 ARIA 无障碍 属性

- **`aria-expanded` 属性**：用于向屏幕阅读器用户传达切换（或展开）特色的状态。
- **`aria-haspopup` 属性**：此状态用于指示交互式元素在激活时将触发弹出元素。只有当弹出元素具有以下角色之一时，你才能使用 `aria-haspopup` 属性：`menu`、`listbox`、`tree`、`grid` 或 `dialog`。`aria-haspopup` 的值必须是这些角色之一或 `true`，其含义与 `menu` 相同。
- **`aria-checked` 属性**：此属性用于指示元素是否处于选中状态。它最常用于创建自定义复选框、单选按钮、开关和列表框时。
- **`aria-disabled` 属性**：此状态用于仅向使用辅助技术（例如屏幕阅读器）的人指示某个元素已被禁用。
- **`aria-selected` 属性**：此状态用于指示某个元素被选中。你可以在自定义控件中使用此状态，例如标签（页）接口、列表框或网格。
- **`aria-controls` 属性**：用于将一个元素与它控制的另一个元素关联起来。这有助于使用辅助技术的人理解这些元素之间的关系。
- **`hidden` 属性**：隐藏非活动窗格，既对视觉用户也对辅助技术用户不可见。

### 使用实时区域和动态内容

- **`aria-live` 属性**：使网页的一部分成为实时区域，意味着该区域内的任何更新都会被屏幕阅读器宣布，以便用户不会错过重要更改。
- **`polite` 值**：大多数实时区域使用此值。此值表示更新不是紧急的，因此屏幕阅读器可以等待完成当前的任何播报或用户完成当前操作后再播报更新。

下面是一个由 JavaScript 动态更新的实时区域示例：

```html
<div aria-live="polite" id="status"></div>
```

```js
const statusEl = document.getElementById("status");
statusEl.textContent = "Your file has been successfully uploaded.";
```

- **`contenteditable` 属性**：将元素变成一个实时编辑器，允许用户像操作文本字段一样更新其内容。当 `contenteditable` 区域没有可见的标签或标题时，使用 `aria-label` 属性添加一个可访问名称，以帮助屏幕阅读器用户理解可编辑区域的用途。

```html
<div contenteditable="true" aria-label="Note editor">
  Editable content goes here
</div>
```

## `focus` 和 `blur` 事件

- **`blur` 事件**：当元素失去焦点时触发。

```js
element.addEventListener("blur", () => {
  // Handle when user leaves the element
});
```

- **`focus` 事件**：当元素获得焦点时触发。

```js
element.addEventListener("focus", () => {
  // Handle when user enters the element
});
```

## 常见的错误信息类型

- **SyntaxError**：当你在代码中写错内容时会发生这些错误，比如缺少括号或方括弧。把它想象成句子中的语法错误。

```js
const arr = ["Beau", "Quincy" "Tom"]
```

- **ReferenceError**：有几种类型的引用误差，会以不同的方式触发。第一种引用误差是未定义的变量。另一个 ReferenceError 的例子是尝试在用 `let` 或 `const` 声明的变量被定义之前访问该变量。

```js
console.log(num);
const num = 50;
```

- **TypeError**：当你尝试对错误的类型执行操作时，会发生这些错误。

```js
const developerObj = {
  name: "Jessica",
  country: "USA",
  isEmployed: true
};

developerObj.map()
```

- **RangeError**：当你的代码尝试使用超出 JavaScript 可处理范围的值时，会发生这些误差。

```js
const arr = [];
arr.length = -1; 
```

## `throw` 语句

- **定义**：JavaScript 中的 `throw` 语句用于抛出用户定义的异常。编程中的异常是指当发生意外事件并中断程序的正常流程时。

```js
function validateNumber(input) {
  if (typeof input !== "number") {
    throw new TypeError("Expected a number, but received " + typeof input);
  }
  return input * 2;
}
```

## `try...catch...finally`

- **定义**：`try` 块用于包裹可能抛出误差的代码。它作为一个安全空间来尝试可能失败的操作。`catch` 块捕捉并处理在 try 块中发生的误差。你可以在 catch 中使用误差对象来检查出了什么问题。无论是否发生误差，`finally` 块都会在 try 和 catch 块之后运行。它通常用于清理任务，例如关闭文件或释放资源。

```js
function processInput(input) {
  if (typeof input !== "string") {
    throw new TypeError("Input must be a string.");
  }

  return input.toUpperCase();
}

try {
  console.log("Starting to process input...");
  const result = processInput(9);
  console.log("Processed result:", result);
} catch (error) {
  console.error("Error occurred:", error.message);
} 
```

## 调试技术

- **`debugger` 语句**：此语句允许你在特定行暂停你的代码，以便调查程序中发生的情况。

```js
let firstNumber = 5;
let secondNumber = 10;

debugger; // Code execution pauses here
let sum = firstNumber + secondNumber;

console.log(sum);
```

- **断点**：断点允许你在你选择的特定代码行暂停代码执行。暂停后，你可以检查变量、计算表达式并查看调用栈。
- **观察者**：观察表达式让你在代码运行时监视变量或表达式的值，即使它们不在当前作用域内。
- **性能分析**：性能分析通过让你捕捉屏幕截图和记录 CPU 使用率、函数调用及执行时间，帮助你识别性能瓶颈。
- **`console.dir()`**：此方法用于显示指定 JavaScript 对象属性的交互式列表。它输出一个可展开以查看所有嵌套属性的分层列表。

```js
console.dir(document);
```

- **`console.table()`**：此方法在控制台中以表格形式显示表格数据。它接受一个必须是数组或对象的必需参数，以及一个选择性参数，用于指定要显示的属性（列）。

## 正则表达式和常用方法

- **定义**：正则表达式，或称 Regex，用于创建一个“模式”，你可以用它来查看字串、提取文本等。

```js
const regex = /freeCodeCamp/;
```

- **`test()` 方法**：此方法接受一个字串，该字串用于测试是否与正则表达式匹配。如果字串匹配正则表达式，此方法将返回一个布尔值。

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test); // false
```

- **`match()` 方法**：此方法接受一个正则表达式，尽管你也可以传入一个字串，该字串将被构造为正则表达式。`match` 方法返回该字串的匹配数组。

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match); // ["freeCodeCamp"]
```

- **`replace()` 方法**：此方法接受两个参数：用于匹配的正则表达式（或字串），以及用于替换匹配项的字串（或对每个匹配项运行的函数）。

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced); // "freeCodeCamp is rly kewl"
```

- **`replaceAll` 方法**：此方法用于将指定模式的所有出现替换为新字串。如果你传入没有全局修饰符的正则表达式，此方法将抛出误差。

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

- **`matchAll` 方法**：此方法用于检索字串中给定正则表达式的所有匹配项，包括捕获组，并将它们作为迭代器返回。迭代器是一个允许你遍历（或“迭代”）集合中项的对象。

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

## 正则表达式修饰符

- **定义**：修饰符，通常称为“标记”，修改正则表达式的行为。
- **`i` 标记**：此标记使正则表达式忽略分支。

```js
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
```

- **`g` 标记**：此标记，或全局修饰符，允许你的正则表达式多次匹配一个模式。

```js
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
```

- **锚点定义**：位于正则表达式开头的 `^` 锚点表示“匹配字串的开始”。位于正则表达式结尾的 `$` 锚点表示“匹配字串的结束”。

```js
const start = /^freeCodeCamp/i;
const end = /freeCodeCamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
```

- **`m` 标记**：锚点查找整个字串的开始和结束。但你可以使用 `m` 标记，或多行修饰符，使正则表达式处理器支持多行。

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const str = `I love 
freecodecamp
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true

```

- **`d` 标记**：此标记扩展你在匹配对象中获得的信息。

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

- **`u` 标记**：这扩展了正则表达式的功能性，使其能够匹配特殊的 unicode 字符。`u` 标记使你能够访问像 `Extended_Pictographic` 这样的特殊类，以匹配大多数表情符号。还有一个 `v` 标记，它进一步扩展了 unicode 匹配的功能性。
- **`y` 标记**：粘性修饰符的行为与全局修饰符非常相似，但有一些例外。最大区别是，全局正则表达式会从 lastIndex 开始并查找字串剩余部分的另一个匹配项，但如果粘性正则表达式在上一个 lastIndex 处没有立即匹配，则会返回 null 并将 lastIndex 重置为 0。
- **`s` 标记**：单行修饰符允许通配符字符，在正则表达式中由 `.` 表现，匹配换行符——有效地将字串视为单行文本。

## 字符类

- **通配符 `.`**：字符类是一种特殊的语法，你可以用来匹配字符的集合或子集。你应该学习的第一个字符类是通配符类。通配符由句点表示，匹配除换行符以外的任意单个字符。要允许通配符类匹配换行符，请记住你需要使用 `s` 标记。

```js
const regex = /a./;
```

- **`\d`**：这将匹配字串中所有的数字（`0-9`）。

```js
const regex = /\d/;
```

- **`\w`**：用于匹配字串中的任何单词字符（`a-z0-9_`）。单词字符定义为任何字母（从 a 到 z）、数字（从 0 到 9）或下划线字符。

```js
const regex = /\w/;
```

- **`\s`**：空白字符类 `\s`，由一个反斜线后跟一个 `s` 表现。该字符类将匹配任何空白，包括换行符、空格、制表符和特殊的 unicode 空白字符。
- **取反特殊字符类**：要取反这些字符类之一，不要在斜线后使用小写字母，而是使用对应的大写字母。以下示例不匹配数字字符。相反，它匹配任何不是数字字符的单个字符。

```js
const regex = /\D/;
```

- **自定义字符类**：你可以通过将你希望匹配的字符放在一组方括弧内来创建自定义字符类。

```js
const regex = /[abcdf]/;
```

## 前瞻断言和后顾断言

- **定义**：前瞻和后顾断言允许你根据周围模式的存在或缺失来匹配特定的模式。
- **正向前瞻断言**：当一个模式后面跟着另一个模式时，该断言将匹配该模式。要构造正向前瞻，你需要从你想匹配的模式开始。然后，使用括号包裹你想用作条件的模式。在开括号后，使用 `?=` 来定义该模式为正向前瞻。

```js
const regex = /free(?=code)/i;
```

- **负向前瞻断言**：这是一种用于正则表达式中的条件，用来查看某个模式在字串前方未出现。

```js
const regex = /free(?!code)/i;
```

- **正向后行断言**：此断言仅在前述的另一个特定模式存在时匹配一个模式，但不将前述的模式包含在匹配中。

```js
const regex = /(?<=free)code/i;
```

- **负向后行断言**：该断言确保某个模式前面不跟随另一个特定的模式。只有在指定的模式前面没有紧跟给定的序列时才匹配，且匹配结果不包含前述的序列。

```js
const regex = /(?<!free)code/i;
```

## 正则表达式量词

- **定义**：正则表达式中的量词指定模式（或模式的一部分）应出现的次数。它们帮助控制匹配中字符或组的出现次数。以下示例用于匹配前一个字符恰好出现 4 次。

```js
const regex = /^\d{4}$/;
```

- **`*`** ：匹配前述元素的 0 次或多次出现。
- **`+`**：匹配前述的元素 1 次或多次出现。
- **`?`**：匹配前述元素的 0 次或 1 次出现。
- **`{n}`**：精确匹配前述元素的 n 次出现。
- **`{n,}`**：匹配前述元素出现 n 次或更多次。
- **`{n,m}`**：匹配前述元素出现的 n 到 m 次。

## 捕获组和反向引用

- **捕捉组**：捕捉组允许你“捕捉”匹配字串的一部分，以便你根据需要使用。捕捉组由包含要捕捉的模式的括号定义，且前面没有像前瞻这样的字符。

```js
const regex = /free(code)camp/i;
```

- **引用**：正则表达式中的引用指的是一种重用同一表达式中先前匹配的模式部分的方法。它允许你通过编号引用一个被捕捉的分组（括号中的模式部分）。例如，`$1` 指的是第一个被捕捉的分组。

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

## 使用 JavaScript 验证形式

- **约束验证 API**：某些超文本标记语言元素，如 `textarea` 和 `input` 元素，暴露了约束验证 API。该 API 允许你断言用户为该元素提供的值通过你编写的任何超文本标记语言级别的验证，例如最小长度或模式匹配。
- **`checkValidity()` 方法**：如果元素匹配所有基于其属性的超文本标记语言验证，则此方法返回 `true`，如果验证失败，则返回 `false`。

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.setCustomValidity("You must use a .com email.")
  }
})
```

- **`reportValidity()` 方法**：此方法告诉浏览器 `input` 无效。

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.reportValidity();
  }
})
```

- **`validity` 属性**：此属性用于获取或设置形式控件（如 `<input>`、`<select>` 等）的有效性状态，并提供有关用户输入是否符合为该元素定义的约束（例如，`required` 字段、模式约束、最大长度等）的信息。

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.validity);
})
```

- **`patternMismatch` 属性**：如果值不匹配指定的正则表达式模式，则该属性为 `true`。

## `preventDefault()` 方法

- **定义**：DOM 中每个触发的事件都有某种默认行为。复选框上的点击事件默认会切换该复选框的状态。按下聚焦按钮上的空格键会激活该按钮。对这些 `Event` 对象调用的 `preventDefault()` 方法会阻止该行为发生。

```js
button.addEventListener('click', (event) => {
  // Prevent the default button click behavior  
  event.preventDefault(); 
  alert('Button click prevented!');
});
```

## 提交表单

- **定义**：表单可以通过三种方式提交。第一种是用户点击表单中 `type` 属性设置为 `submit` 的按钮。第二种是用户在表单中任何可编辑的 `input` 字段上按下 `Enter` 键。第三种是通过 JavaScript 调用 `form` 元素的 `requestSubmit()` 或 `submit()` 方法。
- **`action` 属性**：`action` 属性应包含一个 URL 或当前域的相对路径。该值决定了表单尝试发送数据的位置——如果你未设置 `action` 属性，表单将把数据发送到当前页面的 URL。

```html
<form action="https://freecodecamp.org">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`method` 属性**：此属性接受标准的 `HTTP` 方法，例如 `GET` 或 `POST`，并在向操作 URL 发起请求时使用该方法。当未设置方法时，表单将默认使用 `GET` 请求。表单中的数据将作为 `name=value` 点对进行 URL 编码，并作为查询参数追加到操作 URL。

```html
<form action="/data" method="POST">
  <input
    type="number"
    id="input"
    placeholder="Enter a number"
    name="number"
  />
  <button type="submit">Submit</button>
</form>
```

- **`enctype` 属性**：`form` 元素接受一个 `enctype` 属性，该属性表现用于数据的编码类型。此属性仅接受三个值：`application/x-www-form-urlencoded`（这是默认值，将数据作为 URL 编码的形式体发送）、`text/plain`（以纯文本形式发送数据，使用换行符分隔的 `name=value` 点对），或 `multipart/form-data`，专门用于处理带有文件上传的形式。

## `date()` 对象和常用方法

- **定义**：`date()` 对象用于在 JavaScript 中创建、操作和格式化日期和时间。在以下示例中，使用 `new` 关键字创建 `Date` 对象的新实例，然后将该 `Date` 对象赋值给变量 `now`。如果你将 `now` 的值记录到控制台，你将看到基于运行代码的计算机系统时钟的当前日期和时间。

```js
const now = new Date();
```

- **`Date.now()` 方法**：此方法用于获取当前日期和时间。`Date.now()` 返回自 1970 年 1 月 1 日 00:00:00 UTC 以来的毫秒数。这被称为 Unix 纪元时间。Unix 纪元时间是在计算机系统中表现日期和时间的常用方式，因为它是一个可以轻松保存和操作的整数。UTC 代表协调世界时，是全球调节时钟和时间的主要时间标准。
- **`getDate()` 方法**：此方法用于根据当前日期获取一个月份中的某一天。`getDate()` 将返回一个介于 1 和 31 之间的整数值，具体取决于当月的日期。如果日期无效，它将返回 `NaN`（非数字）。

```js
const now = new Date();
const date = now.getDate();
console.log(date); // 15
```

- **`getMonth()` 方法**：此方法用于获取月份。月份是从零开始的，因此一月是 0，二月是 1，依此类推。在此示例中，输出是 2，对应三月。如果月份无效，它将返回 `NaN`。

```js
const now = new Date();
const month = now.getMonth();
console.log(month); // 2
```

- **`getFullYear()` 方法**：此方法用于获取完整年份。如果年份无效，它将返回 `NaN`。

```js
const now = new Date();
const year = now.getFullYear();
console.log(year); // 2024
```

## 格式化日期的不同方式

- **`toISOString()` 方法**：此方法用于将日期格式化为扩展的 `ISO`（ISO 8601）形式。ISO 8601 是一种表现日期和时间的国际标准。格式为 `YYYY-MM-DDTHH:mm:ss.sssZ`。

```js
const date = new Date();
console.log(date.toISOString());
```

- **`toLocaleDateString()` 方法**：此方法用于根据用户的区域设置格式化日期。

```js
const date = new Date();
console.log(date.toLocaleDateString());  // 11/23/2024
```

`toLocaleDateString()` 方法接受两个可选的参数：locales 和 options。

`locales` 参数是一个字串，表现要使用的区域设置。例如，你可以传入 `"en-US"` 表示英语（美国）或 `"fr-FR"` 表示法语（法国）。如果你不传入 `locales` 参数，则使用默认区域设置。第二个可选参数是 `options` 参数。该参数是一个对象，允许你指定日期字串的形式。

```js
const date = new Date();
const options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(date.toLocaleDateString("en-GB", options)); // Saturday, November 23, 2024
```

## `Audio` 构造函数和常用方法

- **定义**：`Audio` 构造函数，像其他构造函数一样，是一个使用 `new` 关键字调用的特殊函数。它返回一个 `HTMLAudioElement`，你可以用它为用户播放音频，或者追加到 DOM 中让用户自行控制。当你调用构造函数时，可以可选地传入一个 URL 作为（唯一）参数。该 URL 应指向你想播放的音频文件的源。或者，如果你需要动态更改源，可以将 URL 赋值给返回的音频元素的 `src` 属性。
- **`play()` 方法**：此方法用于 `audio` 或 `video` 元素以开始媒体播放。

```js
const audio = document.getElementById('audio');

// Starts playing the audio
audio.play();  
```

- **`pause()` 方法**：此方法用于 `audio` 或 `video` 元素以暂停媒体播放。

```js
function pauseAudio() {
  const audio = document.getElementById('myAudio');
  audio.pause();  // Pauses the audio playback
}
```

- **`addTextTrack()` 方法**：此方法允许你为媒体元素指定一个文本轨道——这对于为视频添加字幕特别有帮助。
- **`fastSeek()` 方法**：此方法允许你将播放位置移动到媒体中的特定时间。

## 不同的音频和视频格式

- **MIME 类型**：MIME 类型，全称为多用途互联网邮件扩展，是一种以编程方式标准化指示文件类型的方法。MIME 类型可以告诉应用程序，例如你的浏览器，如何处理特定文件。在音频和视频的情况下，MIME 类型表示它是一种可以嵌入网页的多媒体格式。
- **`source` 元素**：用于指定文件类型和来源——可以通过使用多个 `source` 元素包含多种不同类型。这样做时，浏览器将根据用户当前的环境确定最佳格式。
- **MP3**：这是一种用于保存音乐、音频或声音的数字文件形式。它是声音记录的压缩版本，使文件大小更小，因此更容易保存和共享。MP3 文件的 MIME 类型是 `audio/mpeg`。
- **MP4**：MP4 是一种用于保存视频和音频的数字文件格式。它作为一个容器，将视频（图像）和声音（音乐或语音）保存在同一个文件中。MP4 的 MIME 类型可以是 `audio/mp4` 或 `video/mp4`，具体取决于它是视频文件还是仅音频文件。

## 编解码器

- **定义**：codec 是“编码器/解码器”的缩写，是一种可以在模拟和数字的音频与视频之间转换的算法或软件。codec 可以作为 MIME 类型的一部分来指定。定义 codec 的基本语法是在媒体类型后添加分号，然后是 `codecs=` 和 codec。

## HTMLMediaElement API

- **定义**：`HTMLMediaElement` API 用于控件你页面上的音频和视频元素的行为。它扩展了基础的 `HTMLElement` 接口，因此你可以访问基础属性以及这些有用的方法。这些方法的示例包括 `play()`、`fastSeek()` 和 `pause()`。

## 媒体捕捉和流 API

- **定义**：Media Capture and Streams API，或称 MediaStream API，用于从你的设备捕捉音频和视频。为了使用该 API，你需要创建 `MediaStream` 对象。你可以使用构造函数来创建，但它不会绑定到用户的硬件。相反，`global` 导航器对象的 `mediaDevices` 属性有一个 `getUserMedia()` 方法供你使用。

```js
window.navigator.mediaDevices.getUserMedia({
  audio: true,
  video: {
    width: {
      min: 1280,
      ideal: 1920,
      max: 3840
    },
    height: {
      min: 720,
      ideal: 1080,
      max: 2160
    }
  }
});
```

## 屏幕捕捉 API

- **定义**：屏幕捕捉 API 用于记录用户的屏幕。该 API 通过调用 `mediaDevices` 对象的 `getDisplayMedia()` 方法并使用返回的媒体流来暴露。

## MediaStream 记录 API

- **定义**：MediaStream Recording API 与 MediaStreams API 协同工作，允许你录制一个 MediaStream（甚至直接录制一个 `HTMLMediaElement`）。

## 媒体源扩展名 API

- **主题**：Media Source Extensions API 允许你通过 `srcObject` 属性将用户的摄像头视频直接传递给视频元素。

## Web 音频 API

- **定义**：Web Audio API 是驱动网页上所有可听内容的核心。该 API 包含重要对象，如 `AudioBuffer`（专门表现包含音频数据的缓冲区）或 `AudioContext`。

## JavaScript 中的集合

- `Set` 是管理数据集合的内置选项。
- 集合确保其中的每个值只出现一次，使其在从数组中消除副本或处理不同值的集合时非常有用。
- 你可以使用 `Set()` 构造函数创建一个 `Set`：

```js
const set = new Set([1, 2, 3, 4, 5]);
console.log(set); // Set { 1, 2, 3, 4, 5 }
```

- 集合可以使用这些方法进行操作：
  
  - `add()`：为 `Set` 添加一个新建元素。
  - `delete()`：从 `Set` 中移除一个元素。
  - `has()`：查看 `Set` 中是否存在某个元素。
  - `clear()`：从 `Set` 中移除所有元素。

## JavaScript 中的 Weaksets

- `WeakSet` 是一个对象集合，允许你保存弱引用的对象。

## 集合与弱集合

- 与 Set 不同，`WeakSet` 不支持数字或字串等原语。
- `WeakSet` 只保存对象，并且对这些对象的引用是“弱引用”，这意味着如果对象在你的代码中没有被其他地方使用，它会被自动移除以释放内存。

## JavaScript 中的 Maps

- `Map` 是一个内置对象，保存着与对象类似的键值对。
- Map 与标准 JavaScript 对象不同，它允许任何类型的密钥，包括对象和函数。
- 当频繁添加和移除键值点对时，`Map` 相较于标准对象提供了更好的性能。
- 你可以使用 `Map()` 构造函数创建一个 `Map`：

```js
const map = new Map([
  ['flower', 'rose'],
  ['fruit', 'apple'],
  ['vegetable', 'carrot']
]);
console.log(map); // Map(3) { 'flower' => 'rose', 'fruit' => 'apple', 'vegetable' => 'carrot' }
```

- 地图可以使用这些方法进行操作：

  - `set()`：为 `Map` 添加一个新建的密钥-值点对。
  - `get()`：从 `Map` 中检索密钥的值。
  - `delete()`：从 `Map` 中移除一个密钥-值点对。
  - `has()`: 查看 `Map` 中是否存在某个密钥。
  - `clear()`：从 `Map` 中移除所有密钥-值点对。

## JavaScript 中的 WeakMaps

- `WeakMap` 是一个键值点对的集合，就像 `Map` 一样，但对键使用弱引用。键必须是对象，值可以是你喜欢的任何内容。

## Maps 与 WeakMaps

- WeakMap 类似于 WeakSet，因为它们只保存对象，并且对这些对象的引用是“弱引用”。

## 持久存储

- **定义**：持久存储指的是一种保存数据的方式，即使断电或设备重启后数据仍然可用。

## 创建、读取、更新、删除（CRUD）

- **创建**：这指的是创建新数据的过程。例如，在一个网页应用中，这可能是用户为博客添加新帖子的时候。
- **读取**：这是从数据库中检索数据的操作。例如，当你访问博客文章或查看你的网站评测时，你正在执行读取操作以获取并显示保存在数据库中的数据。
- **更新**：这涉及修改数据库中现有的数据。一个例子是编辑博客文章或更新你的评测信息。
- **删除**：这是从数据库中移除数据的操作。例如，当你删除一篇博客文章或账户时，你正在执行删除操作。

## 超文本传输协议 方法

- **定义**：HTTP 代表超文本传输协议，它是网络上数据通信的基础。存在 HTTP 方法，用于定义可以在网络资源上执行的操作。常见的方法有 GET、POST、PUT、PATCH、DELETE。
- **`GET` 方法**：这用于从服务器获取数据。
- **`POST` 方法**：这用于向服务器提交数据，从而创建一个新资源。
- **`PUT` 方法**：用于通过完全替换来更新资源。
- **`PATCH` 方法**：用于部分更新资源。
- **`DELETE` 方法**：用于从数据库中删除记录。

## `localStorage` 和 `sessionStorage` 属性

- **Web Storage API**：该 API 为浏览器提供了一种机制，可以在浏览器内直接保存键值对，允许开发者存储可跨不同页面重载和会话使用的信息。Web Storage API 的两个主要组件是 `localStorage` 和 `sessionStorage` 属性。
- **`localStorage` 属性**：`localStorage` 是 Web Storage API 的一部分，允许数据即使在浏览器窗口关闭或页面刷新后仍然保持持久。该数据将一直可用，直到被应用或用户显式移除。
- **`localStorage.setItem()` 方法**：此方法用于在 `localStorage` 中保存一个密钥-值对。

```js
localStorage.setItem('username', 'Jessica');
```

- **`localStorage.getItem()` 方法**：此方法用于从 `localStorage` 中检索给定密钥的值。

```js
localStorage.setItem('username', 'codingRules');

let username = localStorage.getItem('username');
console.log(username); // codingRules
```

- **`localStorage.removeItem()` 方法**：此方法用于通过其密钥从 `localStorage` 中移除特定项。

```js
localStorage.removeItem('username');
```

- **`localStorage.clear()` 方法**：此方法用于清除 `localStorage` 中保存的所有数据。

```js
localStorage.clear();
```

- **`sessionStorage` 属性**：存储仅在当前会话中存在的数据，浏览器标签（页）或窗口关闭时会被清除。
- **`sessionStorage.setItem()` 方法**：此方法用于在 `sessionStorage` 中保存一个密钥-值点对。

```js
sessionStorage.setItem('cart', '3 items');
```

- **`sessionStorage.getItem()` 方法**：此方法用于从 `sessionStorage` 中检索给定密钥的值。

```js
sessionStorage.setItem('cart', '3 items');

let cart = sessionStorage.getItem('cart');
console.log(cart); // '3 items'
```

- **`sessionStorage.removeItem()` 方法**：此方法用于通过其密钥从 `sessionStorage` 中移除特定项。

```js
sessionStorage.removeItem('cart');
```

- **`sessionStorage.clear()` 方法**：此方法用于清除存储在 `sessionStorage` 中的所有数据。

```js
sessionStorage.clear();
```

## 使用 Cookie

- **定义**：Cookie，也称为网页 Cookie 或浏览器 Cookie，是服务器发送到用户网页浏览器的小块数据。这些 Cookie 存储在用户设备上，并在后续请求中发送回服务器。Cookie 对于帮助网页应用维护状态和记住用户信息至关重要，这一点尤其重要，因为 `HTTP` 是无状态协议。
- **会话 Cookies**：这些 Cookies 仅在用户在网站上的会话期间有效。一旦用户关闭浏览器或标签（页），会话 Cookie 就会被删除。这些 Cookies 通常用于保持用户在访问期间的登录状态等任务。
- **安全 Cookie**：这些 Cookie 仅通过 `HTTPS` 发送，确保它们在传输过程中不会被攻击者截获。
- **HttpOnly Cookies**：这些 Cookie 无法被浏览器中运行的 JavaScript 访问或修改，从而使它们在防范跨站脚本（XSS）攻击方面更安全。
- **Set-Cookie 头部**：当你访问一个网站时，服务器可以在 HTTP 响应中发送一个 Set-Cookie 头部。该头部告诉你的浏览器储存一个包含特定信息的 cookie。例如，它可能保存一个唯一 ID，帮助网站在你下次访问时识别你。  
你可以使用 `document.cookie` 在 JavaScript 中手动设置 cookie：

```js
document.cookie = "organization=freeCodeCamp; expires=Fri, 31 Dec 2021 23:59:59 GMT; path=/";
```

要删除 cookie，你可以将其过期时间设置为过去的某个时间。

```js
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
```

## 缓存 API

- **定义**：缓存是将文件副本存储在临时存储位置的过程，以便可以更快速地访问它们。Cache API 用于保存网络请求和响应，使网页应用更高效，甚至可以离线运行。它是更广泛的 Service Worker API 的一部分，对于创建能够在不可靠或缓慢网络条件下工作的渐进式网页应用（PWA）至关重要。  
Cache API 是一种存储机制，用于存储 `Request` 和 `Response` 对象。当向服务器发出请求时，应用可以保存响应，并在以后从缓存中检索，而不是发出新的网络请求。这减少了装载时间，节省了带宽，并提升了整体用户体验。
- **缓存存储**：用于保存超文本传输协议请求及其对应响应的键值点对。这使得能够高效地检索先前请求的资源，减少后续访问时从网络获取的需求，从而提升性能。
- **Cache-Control**：开发者可以定义缓存资源应保留多长时间，以及是否应重新验证或直接从缓存中提供。
- **离线支持**：通过使用 Cache API，你可以创建离线优先的网页应用。例如，当用户断开网络时，PWA 可以提供缓存的资源。

## 负面模式和客户端存储

- **过度跟踪**：指在没有明确、知情同意或合法需求的情况下，在客户端存储（例如 cookie、local storage 或 session storage）中收集和存储过多的用户数据的做法。这通常涉及跨多个站点或会话跟踪用户行为、偏好和交互，可能侵犯用户隐私。
- **浏览器指纹识别**：一种基于设备和浏览器的独特特征来跟踪和识别单个用户的技术，而不是依赖于 cookie 或其他传统的跟踪方法。与存储在用户设备上的 cookie 不同，指纹识别涉及收集一系列信息，这些信息可用于创建用户浏览器会话的独特“指纹”。
- **在 LocalStorage 中设置密码**：这看起来可能是一个更明显的负面模式，但在局部存储中设置任何敏感数据如密码都会带来安全性风险。局部存储未加密且可以轻松访问。因此，你绝不应该将任何类型的敏感数据保存到那里。

## 索引数据库

- **定义**：IndexedDB 用于在浏览器中保存结构化数据。它内置于现代网页浏览器中，允许网页应用高效地保存和获取 JavaScript 对象。

## 缓存/服务工作者

- **定义**：Service Worker 是一个在后台运行的脚本，独立于你的网页。它可以拦截网络请求，访问缓存，并使网页应用离线工作。这是渐进式网页应用的关键组件。

## 使用类的基础知识

- **定义**：JavaScript 中的类用于定义创建对象的蓝图，并封装数据。类包含一个构造函数，这是一个特殊的方法，当从类中新建对象时会自动调用。它用于初始化对象的属性。这里使用 `this` 关键字来引用类的当前实例。在构造函数下面，你可以定义所谓的方法。方法是在类内部定义的函数，用于对类的数据或状态执行操作。它们用于定义类的实例可以执行的行为。

```js
class Dog {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
}
```

要创建该类的一个新实例，你将使用 `new` 关键字，后跟类名：

```js
const dog = new Dog("Gino");
```

你也可以将类作为类表达式创建。这是指类是匿名的并赋值给一个变量。 

```js
const Dog = class {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
};
```

## 类继承

- **定义**：在编程中，继承允许你定义从父类继承属性和方法的类。这促进了代码重用并建立了类之间的层次关系。父类是作为其他类蓝图的类。它定义了被其他类继承的属性和方法。子类是继承另一个类的属性和方法的类。子类还可以通过添加新属性和方法来扩展其父类的功能性。在 JavaScript 中，我们使用 `extends` 关键字来实现继承。该关键字表示一个类是另一个类的子类。

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

`super` 关键字用于访问父类的方法、构造函数和字段。


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

## 使用静态方法和静态属性

- **静态方法**：这些方法通常用于不需要访问对象特定状态的实用函数。它们在类中定义以封装相关功能性。静态方法对于实现“工厂”方法也很有帮助。工厂方法是你在构造函数之外定义的一个方法，用于根据特定条件创建对象。

```js
class Movie {
  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }
}

let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);

Movie.compareMovies(movieA, movieB);
```

- **静态属性**：这些属性用于定义与类本身关联的值或属性，而不是与类的实例关联。静态属性在类的所有实例之间共享，并且可以在不创建类实例的情况下访问。

```js
class Car {
  // Static property
  static numberOfWheels = 4;

  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  // Instance method
  getCarInfo() {
    return `${this.make} ${this.model}`;
  }

  // Static method
  static getNumberOfWheels() {
    return Car.numberOfWheels;
  }
}

// Accessing static property directly from the class
console.log(Car.numberOfWheels); 
```

## 递归

- 递归是一种编程概念，允许你反复调用一个函数，直到达到基本分支。

下面是一个计算数字阶乘的递归函数示例：

```js
function findFactorial(n) {
  if (n === 0) {
    return 1;
  }
  return n * findFactorial(n - 1);
}
```

在上述示例中，`findFactorial` 函数被递归调用，直到 `n` 达到 `0`。当 `n` 为 `0` 时，达到基本情形，函数返回 `1`。然后函数返回 `n` 与递归调用 `findFactorial(n - 1)` 结果的乘积。

- 递归允许你处理具有未知深度的内容，例如深度嵌套的对象/数组，或文件树。
- 调用栈用于跟踪递归函数中的函数调用。每次调用函数时，都会将其添加到调用栈中。当达到基本情形时，函数调用会从栈中移除。
- 你应该仔细定义基本情形，因为无限调用它会导致你的代码崩溃。这是因为递归不断堆积越来越多的函数调用，直到系统内存耗尽。
- 递归在解决阶乘和斐波那契等数学问题、遍历树和图、生成排列组合等方面有广泛应用。

## 纯函数与非纯函数

- 纯函数是指对于相同的 `input` 总是产生相同的输出且没有任何副作用的函数。它的输出仅依赖于其 `input`，并且不会修改任何外部状态。
- 不纯函数具有副作用，即对函数外部可观察到的程序状态的更改。

## 函数式编程

- 函数式编程是一种软件开发方法，强调使用函数来解决问题，关注需要做什么而不是如何做。
- 函数式编程鼓励使用有助于避免副作用的技术，例如使用不可变的数据结构和高阶函数。
- 当正确使用时，函数式编程原则会导致更简洁且更易维护的代码

## 柯里化

- 柯里化是一种函数式编程技术，它将具有多个参数的函数转换为一系列每次只接受一个参数的函数。

这是一个普通函数与柯里函数的示例：

```js
// Regular function

function average(a, b, c) {
  return (a + b + c) / 3;
}

// Curried function

function curriedAverage(a) {
  return function(b) {
    return function(c) {
      return (a + b + c) / 3;
    };
  };
}

// Usage of curried function

const avg = curriedAverage(2)(3)(4);
```

- 当处理接受多个参数的函数时，柯里化尤其强大。
- 柯里化使你的代码更灵活且更易于重用。
- 你可以使用箭头函数更简洁地创建柯里的函数：

```js
const curriedAverage = a => b => c => (a + b + c) / 3;
```

- 虽然柯里化可以使代码更灵活且可重用，但如果过度使用，也会使代码更难读取。

## 异步的 JavaScript

- **同步的 JavaScript** 是循序执行的，并且在继续下一个操作之前会等待前一个操作完成。
- **异步的 JavaScript** 允许多个操作在后台执行而不会阻塞主线程。
- **线程** 是一条可以独立于主程序流程执行的指令序列。
- **回调函数** 是作为参数传递给其他函数的函数，并在操作完成后或作为事件的结果执行。

## JavaScript 引擎和 JavaScript 运行期

- **JavaScript 引擎** 是一个在网页浏览器中执行 JavaScript 代码的程序。它就像一个转换器，将你的代码转换成计算机能够理解并据此工作的指令。
- V8 是 Google 开发的一个 JavaScript 引擎示例。
- **JavaScript 运行期** 是执行 JavaScript 代码的环境。它包括处理和执行代码的 JavaScript 引擎，以及像网页浏览器或 Node.js 这样的附加特色。

## Fetch API

- Fetch API 允许网页应用发起网络请求，通常用于从服务器检索或发送数据。它提供了一个 `fetch()` 方法，你可以用来发起这些请求。
- 你可以使用 Fetch API 获取文本、图像、音频、JSON 和其他类型的数据。

## Fetch API 的超文本传输协议方法

Fetch API 支持多种与服务器交互的超文本传输协议方法。最常用的方法有：

- **GET**：用于从服务器检索数据。默认情况下，Fetch API 使用 `GET` 方法来检索数据。

```js
fetch('https://api.example.com/data')
```

要使用获取的 `data`，必须使用 `.json()` `method` 将其转换为 JSON 形式：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

在这段代码中，来自 Fetch API 的响应是一个 promise，`.then` 处理器将响应转换为 JSON 形式。

- **POST**：用于向服务器发送数据。`POST` 方法用于在服务器上创建新资源。

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

在这个示例中，我们正在发送一个 `POST` 请求以创建一个新用户。我们已将方法指定为 `POST`，设置了适当的头部，并包含了我们想要发送的数据体。体需要是一个字串，因此我们使用 `JSON.stringify()` 将我们的对象转换为 JSON 字串。

- **PUT**：用于更新服务器上的数据。`PUT` 方法用于更新服务器上的现有资源。

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

在此示例中，我们正在更新 URL 末尾指定的 ID `45`。我们在代码中使用了 `PUT` 方法，并且将数据指定为体，用于更新所识别的数据。 

- **DELETE**：用于删除服务器上的数据。`DELETE` 方法用于删除服务器上的资源。

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

在此示例中，我们发送一个 `DELETE` 请求以删除 ID 为 `45` 的用户。

## Promise 和 promise 链式调用

- **Promises** 是表现异步操作最终完成或失败及其结果值的对象。只有当 `async` 操作完成时，promise 的值才被知晓。
- 这是一个创建简单 `promise` 的示例：

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- `.then()` 方法用于 Promise 中指定当 Promise 完成时应发生的操作，而 `.catch()` 用于处理任何发生的错误。
- 下面是使用 `.then()` 和 `.catch()` 处理 Promise 的示例：

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

在上述示例中，使用 `.then()` 方法记录从 Promise 接收到的数据，而使用 `.catch()` 方法记录发生的任何误差。

- **Promise 链式调用**：Promise 的强大特色之一是我们可以将多个异步的操作串联在一起。每个 `.then()` 都可以返回一个新的 Promise，使你能够依次执行一系列异步的操作。
- 这是一个 Promise 链式调用的示例：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

在上述示例中，我们首先从一个 URL 获取数据，然后根据第一个响应从另一个 URL 获取数据，最后记录收到的第二个数据。 

`catch` 方法会处理进程中发生的任何误差。这意味着你不需要为每个单独步骤添加误差处理器，从而大大简化你的代码。

## 使用 `async/await` 来处理 promises

Async/await 使编写和读取异步的代码更容易，它是建立在 Promise 之上的。

- **async**：`async` 关键字用于定义一个异步的函数。`async` 函数返回一个 Promise，该 Promise 会解析为 `async` 函数返回的值。
- **await**：`await` 关键字用于 `async` 函数内部，暂停函数执行直到 Promise 被解析。它只能在 `async` 函数内部使用。
- 这是使用 `async/await` 的示例：

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

在上述示例中，`delayedGreeting` 函数是一个 `async` 函数，它会暂停 2 秒钟，然后打印问候消息。`await` 关键字用于暂停函数执行，直到 `Promise` 被解析。

- `async/await` 最大的优势之一是通过 `try/catch` 块进行误差处理。以下是一个示例：

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

在上述示例中，`try` 块包含可能抛出误差的代码，而 `catch` 块在发生误差时处理该误差。这使得误差处理更加直接且易读。

## `async` 属性

- `async` 属性告诉浏览器在继续解析超文本标记语言文档的同时异步地下载脚本文件。
- 脚本下载完成后，超文本标记语言解析暂停，脚本执行，然后超文本标记语言解析恢复。
- 你应该为执行顺序无关紧要的独立脚本使用 `async`

## `defer` 属性

- `defer` 属性也会异步地下载脚本，但它会推迟脚本的执行，直到超文本标记语言文档完全解析之后。
- `defer` 脚本维护它们在超文本标记语言文档中出现的执行顺序。

- 重要的是要注意，`async` 和 `defer` 两个属性都会被内联脚本忽略，仅对外部脚本文件有效。

- 当同时存在 `async` 和 `defer` 属性时，`async` 属性具有优先级。

## 地理位置 API

- Geolocation API 提供了一种让网站请求用户位置的方法。

- 下面的示例演示了用于获取用户当前位置的 API `getCurrentPosition()` 方法。

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

在这段代码中，我们调用 `getCurrentPosition` 并传入一个函数，该函数将在成功获取位置时被调用。 

`position` 对象包含各种信息，但这里我们只选择了 `latitude` 和 `longitude`。

如果获取 `position` 出现问题，则误差将被记录到控制台。尊重用户隐私非常重要，只有在必要时才请求他们的位置。


# --assignment--

复习 JavaScript 主题和概念。
