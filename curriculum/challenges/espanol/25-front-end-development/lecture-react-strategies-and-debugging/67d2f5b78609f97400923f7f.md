---
id: 67d2f5b78609f97400923f7f
title: '¿Qué son las bibliotecas de gestión de estado y cuándo deberías usarlas?'
challengeType: 11
videoId: 9GBjI8LDauU
dashedName: what-are-state-management-libraries-and-when-should-you-use-them
---

# --description--

Mira el video o lee el transcripto y responde a las preguntas abajo.

# --transcript--

¿Qué son las bibliotecas de gestión de estado y cuándo deberías usarlas?

A medida que crece tu app, gestionar cómo fluye la información entre componentes puede volverse complejo.

Al comenzar, el hook `useState` de React podría ser suficiente, pero a medida que agregas funciones, podrías encontrarte con problemas de:

- Pasar props a través de componentes que no las necesitan, también conocido como perforación de props
- Mantener la información sincronizada en diferentes partes de tu aplicación
- Manejar actualizaciones complejas que afectan a varios componentes simultáneamente

Estos y otros desafíos pueden surgir, lo que puede llevar a una base de código más difícil de mantener, depurar y probar. Ahí es donde entran las bibliotecas de gestión de estado: proporcionan un lugar centralizado donde los componentes pueden obtener o actualizar la información que necesitan.

Veamos algunas opciones diferentes de gestión de estado que tienes y cuándo usarlas.

La API de Contexto es un gestor de estado integrado en React que te permite compartir estado entre componentes sin utilizar una biblioteca de terceros. Es una mejora bien establecida sobre el hook `useState`, por lo que es perfecto para casos como el cambio de tema o el estado de autenticación del usuario.

Sin embargo, la API de Contexto no maneja bien las actualizaciones frecuentes y puede causar re-renderizados innecesarios, haciéndola menos adecuada para necesidades de estado complejas en aplicaciones como en plataformas de comercio electrónico y redes sociales. 

Aquí tienes un componente contador que demuestra el uso básico de la API de Contexto:

```jsx
import { useState, createContext } from 'react';

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

Este código crea un contexto y un proveedor para compartir un estado `count` a lo largo de la aplicación.

`CounterProvider` usa el hook `useState` para inicializar y gestionar el estado `count` y su setter. Ambos se pasan a los componentes hijos a través del `Provider`.

Así que, cuando envuelves toda tu aplicación con el `CounterProvider`, el estado `count` está disponible en todas partes dentro de tu aplicación.

Así es como puedes envolver `CounterProvider` alrededor de tu aplicación:

```jsx
import { CounterProvider } from './context/CounterContext';

function App() {
  return (
    <CounterProvider>
        {/* App components */}
    </CounterProvider>
  );
}

export default App;
```

Y aquí está cómo puedes usar el estado `count`:

```jsx
import React, { useContext } from 'react';
import { CounterContext } from '../context/CounterContext';

const Counter = () => {
  const { count, setCount } = useContext(CounterContext);

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Context API Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => setCount(count - 1)}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => setCount(count + 1)}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

Como puedes ver, el estado `count` y su función setter, `setCount`, están inicializados a través de la función `useContext`.

El estado `count` actual se muestra, y `setCount` se utiliza para aumentar y disminuir el estado `count` cuando el usuario hace clic en los botones de decremento e incremento, respectivamente.

Otra popular biblioteca de gestión de estado es Redux, que es una de las bibliotecas de gestión de estado más populares para usar con React. Ha existido durante mucho tiempo y es ideal para aplicaciones más grandes, como plataformas de comercio electrónico, redes sociales, foros, etc.

Redux gestiona el estado proporcionando una tienda central y un control estricto sobre las actualizaciones de estado. Utiliza un patrón predecible con acciones, reductores y middleware.

Las acciones son cargas de información que envían datos desde tu aplicación a la tienda de Redux, a menudo desencadenadas por interacciones de usuario.

Los reductores son funciones que especifican cómo debería cambiar el estado en respuesta a esas acciones, asegurando que el estado se actualice de manera inmutable.

El middleware, en cambio, actúa como puente entre el despacho de acción y el reductor, permitiendo extender la funcionalidad de Redux (por ejemplo, registro, manejo de operaciones asincrónicas) sin modificar el flujo central.

La queja más común sobre Redux es todo el código repetitivo que necesitas para comenzar. En respuesta, el equipo de Redux introdujo "Redux Toolkit" y "RTK Query", que simplifican bastante el proceso de configuración.

Por lo general, defines tanto las acciones como los reductores en un único archivo utilizando la función `createSlice()`. Es común nombrar el archivo de manera que termine con la palabra `Slice`, por ejemplo, `productSlice`, `userSlice`, `counterSlice`, etc.

Aquí tienes un archivo `counterSlice` para mostrarte lo básico:

```jsx
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',

  initialState: { count: 0 },

  reducers: {
    increment: (state) => {
      state.count += 1;
    },
    decrement: (state) => {
      state.count -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;

export default counterSlice.reducer;
```

Desde aquí, luego necesitas envolver toda la aplicación con el `Provider`, seleccionar una parte del estado del slice con `useSelector()`, luego usar `useDispatch()` para activar el estado.

Otra opción a considerar es Zustand.

Zustand es una biblioteca de gestión de estado liviana con una API simple. Se basa en hooks, por lo que tiene menos código repetitivo comparado con Redux, lo que lo hace más fácil y rápido de configurar.

Zustand es ideal para aplicaciones de pequeña a mediana escala. Funciona utilizando un hook `useStore` para acceder directamente al estado en componentes y páginas. Esto te permite modificar y acceder a la información sin necesitar acciones, reductores o un proveedor.

Aquí tienes un `useCounterStore` que implementa otra funcionalidad de contador:

```jsx
import { create } from 'zustand';

const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

export default useCounterStore;
```

Y aquí está cómo inicializar y usar los estados en tu aplicación:

```jsx
// Import the useCounterStore (it's just a hook)
import useCounterStore from '../useCounterStore';

const Counter = () => {
  // Initialize the states with the useCounterStore hook
  const { count, increment, decrement } = useCounterStore();

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Zustand Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => decrement()}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => increment()}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

Aunque el ecosistema frontend está en constante evolución y regularmente surgen nuevas bibliotecas de gestión de estado, las que hemos discutido son ampliamente usadas en la industria.

# --questions--

## --text--

¿Cuál de estas es una razón para usar una biblioteca de gestión de estado?

## --answers--

Para evitar escribir cualquier lógica de estado en tu aplicación.

### --feedback--

Piensa en los beneficios de gestionar un estado complejo a través de múltiples componentes y páginas.

---

Para actualizar automáticamente la UI sin volver a renderizar.

### --feedback--

Piensa en los beneficios de gestionar un estado complejo a través de múltiples componentes y páginas.

---

Para crear un flujo de datos consistente y predecible.

---

Para eliminar por completo la necesidad de props.

### --feedback--

Piensa en los beneficios de gestionar un estado complejo a través de múltiples componentes y páginas.

## --video-solution--

3

## --text--

¿Cuál de estas NO es una biblioteca de gestión de estado?

## --answers--

Context API

### --feedback--

Piensa en cuál se utiliza específicamente para realizar solicitudes a una API.

---

Redux

### --feedback--

Piensa en cuál se utiliza específicamente para realizar solicitudes a una API.

---

Zustand

### --feedback--

Piensa en cuál se utiliza específicamente para realizar solicitudes a una API.

---

Axios

## --video-solution--

4

## --text--

¿Cuál fue una queja común sobre Redux y cómo fue abordada?

## --answers--

Tenía un soporte limitado para navegadores, que fue abordado creando polyfills.

### --feedback--

Piensa en las mejoras que se hicieron para reducir la complejidad de la configuración.

---

Tenía problemas de rendimiento, que fueron abordados optimizando su middleware.

### --feedback--

Piensa en las mejoras que se hicieron para reducir la complejidad de la configuración.

---

Requería mucho código repetitivo y complejo, que fue abordado mediante Redux Toolkit y RTK Query.

---

Había una falta de documentación, que fue abordada agregando más ejemplos.

### --feedback--

Piensa en las mejoras que se hicieron para reducir la complejidad de la configuración.

## --video-solution--

3
