---
id: 673b567e3ba535dda140d278
title: 建置一個投票系統
challengeType: 26
dashedName: build-a-voting-system
saveSubmissionToDB: true
---

# --description--

在本實驗中，你將建置一個投票系統，該系統使用 `Map` 來創建一個輪詢，並使用 `Set` 來防止重複投票。

**目標：** 完成以下使用者故事並通過所有測試以完成實驗。

**使用者故事：**

1. 你應該將 `poll` 變數初始化為新的 `Map` 物件。

2. 你應該有一個函式 `addOption`，它接受一個參數 `option`。

3. 在 `addOption` 函式（程式）中：

   - 如果 `option` 尚未存在於輪詢中，應將其添加到輪詢中，並以空的 `Set` 作為其值來追蹤投票者。你也應該傳回訊息 `Option "<option>" added to the poll.`。

   - 如果 `option` 已經存在，應該傳回訊息 `Option "<option>" already exists.`

   - 如果你嘗試添加空的選項，可選方案，該函式應該傳回訊息 `Option cannot be empty.`

4. 你應該有一個函式（程式）`vote`，它接受兩個參數，`option`（要投票的選項，可選方案）和 `voterId`（投票者的唯一 ID）。

5. 在 `vote` 函式（程式）中：

   - 如果 `option` 不存在於輪詢中，該函式應該傳回訊息 `Option "<option>" does not exist.`

   - 如果存在 `option`，函式（程式）應該檢查 `voterId` 是否已經對此 `option` 投票。

   - 如果投票者已經投票，該函式應該傳回訊息 `Voter <voterId> has already voted for "<option>"。`

   - 如果投票者尚未投票，則應將 `voterId` 添加到此選項的 `voters` 的 `Set` 中。該函式應傳回訊息 `Voter <voterId> voted for "<option>"`。

6. 你的 `poll` 中應該至少有三個選項。

7. 你的 `poll` 應該至少有三票。

8. 你應該有一個函式（程式）`displayResults`，該函式（程式）以以下格式傳回輪詢結果：

```js
Poll Results:
OptionA: N votes
OptionB: N votes
.
.

/*
sample output

Poll Results:
Turkey: 2 votes
Morocco: 1 votes
*/
```

# --hints--

你應該有一個 `poll` 變數初始化為一個新的 `Map` 物件。

```js
assert.exists(poll);
assert.instanceOf(poll, Map);
```

你應該定義一個函式 `addOption`，該函式接受一個參數 `option`。

```js
assert.isFunction(addOption);
assert.match(
  addOption.toString(),
  /^function\s+addOption\s*\(\s*option\s*\)\s*\{|\(?\s*option\s*\)?\s*=>/
);
```

你應該定義一個接受兩個參數 `option` 和 `voterId` 的函式 `vote`。

```js
assert.isFunction(vote);
assert.match(vote.toString(), /\(\s*option\s*,\s*voterId\s*\)/);
```

你應該定義一個函式 `displayResults` 來顯示輪詢結果。

```js
assert.isFunction(displayResults);
```

你的 `poll` 中應該至少有三個選項。

```js
assert.isAtLeast(poll.size, 3);
```

你的 `poll` 應該至少有三票。

```js
let totalVotes = 0;
for (let voters of poll.values()) {
  totalVotes += voters.size;
}
assert.isAtLeast(totalVotes, 3);
```

你應該確保每個投票選項對應到一個 `Set` 物件。

```js
const pollCopy = new Map(poll);
try {
  poll.clear();

  addOption('Turkey');
  assert.instanceOf(poll.get('Turkey'), Set);
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

`addOption("Egypt")` 應該傳回 `Option "Egypt" added to the poll.`

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  assert.equal(addOption('Egypt'), 'Option "Egypt" added to the poll.');
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

新增空白選項應該傳回 `"Option cannot be empty."`

```js
assert.equal(addOption(''), 'Option cannot be empty.');
```

當已經添加了 `Turkey`，`addOption("Turkey")` 應該傳回 `Option "Turkey" already exists.`

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Turkey');
  addOption('Turkey');
  assert.equal(addOption('Turkey'), 'Option "Turkey" already exists.');
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

當 `Malaysia` 存在於投票選項中，`vote("Malaysia", "traveler1")` 應該傳回 `Voter traveler1 voted for "Malaysia".`

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Malaysia');
  assert.equal(
    vote('Malaysia', 'traveler1'),
    'Voter traveler1 voted for "Malaysia".'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

`vote` 應該更新該選項的投票者 `Set`。

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Alaska');
  vote('Alaska', 'seal');
  assert.isTrue(poll.get('Alaska').has('seal'));
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

當 `traveler1` 嘗試再次為 `Algeria` 投票時，`vote("Algeria", "traveler1")` 應該傳回 `Voter traveler1 has already voted for "Algeria".`

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Algeria');
  vote('Algeria', 'traveler1');
  assert.equal(
    vote('Algeria', 'traveler1'),
    'Voter traveler1 has already voted for "Algeria".'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

重複投票不應該增加 `Set` 的大小。

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Turkey');
  vote('Turkey', 'traveler1');
  const voterSet = poll.get('Turkey');
  const initialSize = voterSet.size;

  vote('Turkey', 'traveler1');
  assert.equal(voterSet.size, initialSize);
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

當 `Nigeria` 不在投票選項中時，`vote("Nigeria", "traveler2")` 應該傳回 `Option "Nigeria" does not exist.`。

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  assert.equal(
    vote('Nigeria', 'traveler2'),
    'Option "Nigeria" does not exist.'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

一個獨特的選項應該能夠接收多個投票。

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Bali');
  assert.equal(vote('Bali', 'traveler1'), 'Voter traveler1 voted for "Bali".');
  assert.equal(vote('Bali', 'traveler2'), 'Voter traveler2 voted for "Bali".');
  assert.equal(poll.get('Bali').size, 2);
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

當選項 `Turkey` 得到 2 票，選項 `Morocco` 得到 1 票，而選項 `Spain` 沒有得到任何票時，`displayResults()` 應該傳回 `"Poll Results:\nTurkey: 2 votes\nMorocco: 1 votes\nSpain: 0 votes"`。

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Turkey');
  addOption('Morocco');
  addOption('Spain');

  vote('Turkey', 'traveler1');
  vote('Turkey', 'traveler2');
  vote('Morocco', 'traveler3');

  assert.equal(
    displayResults(),
    'Poll Results:\nTurkey: 2 votes\nMorocco: 1 votes\nSpain: 0 votes'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

`displayResults()` 應該以正確的格式傳回結果。

```js
const pollCopy = new Map(poll);
try {
  poll.clear();
  addOption('Turkey');
  addOption('Morocco');

  vote('Turkey', 'traveler1');
  vote('Turkey', 'traveler2');
  vote('Morocco', 'traveler3');

  assert.equal(
    displayResults(),
    'Poll Results:\nTurkey: 2 votes\nMorocco: 1 votes'
  );
} finally {
  poll.clear();
  pollCopy.forEach((val, key) => {
    poll.set(key, val);
  });
}
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
const poll = new Map();

function addOption(option) {
  if (!option || option.trim() === '') {
    return 'Option cannot be empty.';
  }
  if (!poll.has(option)) {
    poll.set(option, new Set());
    return `Option "${option}" added to the poll.`;
  } else {
    return `Option "${option}" already exists.`;
  }
}

function vote(option, voterId) {
  if (!poll.has(option)) {
    return `Option "${option}" does not exist.`;
  }
  const voters = poll.get(option);
  if (voters.has(voterId)) {
    return `Voter ${voterId} has already voted for "${option}".`;
  } else {
    voters.add(voterId);
    return `Voter ${voterId} voted for "${option}".`;
  }
}

function displayResults() {
  let results = 'Poll Results:\n';
  for (let [option, voters] of poll.entries()) {
    results += `${option}: ${voters.size} votes\n`;
  }
  return results.trim();
}

addOption('Turkey');
addOption('Morocco');
addOption('Spain');

vote('Turkey', 'traveler1');
vote('Turkey', 'traveler2');
vote('Morocco', 'traveler3');
```
