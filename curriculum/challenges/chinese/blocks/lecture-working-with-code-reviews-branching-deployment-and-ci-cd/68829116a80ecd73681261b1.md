---
id: 68829116a80ecd73681261b1
title: 与远程同事保持同步的良好做法是什么？
challengeType: 19
dashedName: what-are-good-practices-for-remaining-in-sync-with-your-remote-counterparts
---

# --description--

我们已经稍微谈过使用分支来处理独立更改，以避免污染你的 `main` 分支。但这是什么意思，为什么它很重要？

如果你直接将更改提交到你的 `main` 分支，而上游仓库接受了其他不是你的更改，你最终会得到一个称为“发散历史”的情况。这意味着你 `main` 分支上的提交不再与上游 `main` 分支上的提交保持一致。这会使同步上游更改变得非常困难。

那么，假设你一直遵循良好的分支实践，这就不是问题。如果你跟着我们之前的课程操作，你应该有一个你已在本地克隆的仓库的分叉，并且你应该有一个指向原始仓库的上游远程。

如果你没有这样做，这里有一个快速提醒。你需要将仓库分叉，克隆你的分叉到本地，并运行这个命令：

```sh
git remote add upstream <url>
```

将 `<url>` 替换为原始仓库的 SSH URL，而不是你的分叉。

配置好上游后，你可以运行以下串行命令来拉取最新的上游更改：

```sh
git checkout main
git fetch upstream
git merge upstream/main
```

这些命令有什么作用？你已经了解了 `git checkout`，所以第一个命令确保你在本地的 `main` 分支上。

第二个命令，`git fetch upstream`，告诉 Git 去获取你上游远程（即原始仓库）上的最新更改。然而，与 pull 不同，Git 不会自动更新你的分支。这一点很重要，因为你本地的 `main` 分支连接的是你 fork 的 `main` 分支——而不是原始仓库的 `main` 分支！执行 git pull 可能会导致意外行为。

最后的命令 `git merge upstream/main` 告诉 Git 将上游远程仓库中 `main` 分支的最新更改合并到你当前的分支——也就是你的局部 `main` 分支，因为这就是我们检出的分支。

但是如果合并失败怎么办？如果你不小心提交到了 `main`，而 Git 无法合并发散的历史怎么办？好吧……假设你没有从你的 `main` 分支发起任何拉取请求，你可以执行硬重置来迫使 Git 更新你的分支。

```sh
git reset --hard upstream/main
```

`git reset` 命令允许你重置分支的当前状态。传递 `--hard` 标记告诉 Git 迫使局部的文件匹配该分支的状态。这确保你有一个干净的起点进行工作。传递 `upstream/main` 告诉 Git 你希望当前分支（即 `main`）匹配上游远程的 `main` 分支。使用此命令时要小心——每当你强制更新 Git 历史时，可能会发生奇怪且不幸的情况。

一旦你正确更新了你的局部 `main` 分支，重要的是将该状态推送到你的远程分支（如果你遵循了我们的课程，应该是 `origin`）。为此，你可以运行：

```sh
git push
```

这将把当前状态推送到你的远程分叉。但如果你不得不进行硬重置以清理历史，远程分叉也可能有发散的历史，推送将失败。

你可以通过强制推送来纠正这个问题：

```sh
git push --force
```

**小心使用此命令**。执行 `force push` 实际上会重写你的远程历史记录，如果你操作错误，强制推送将变成一个难以理清的噩梦。

将同步的更改推送到你的远程分支很重要，因为这可以帮助你确保如果丢失了现有的局部仓库，可以安全地克隆带有最新更改的分支。

一旦你同步了你的 `main` 分支，你就可以从该状态创建一个新分支，开始在最新版本的原始代码库上进行另一个贡献的工作！

# --questions--

## --text--

在使用分叉仓库时，为什么你应该避免直接向你的 `main` 分支提交更改的主要原因是什么？

## --answers--

它创建提交的副本。

### --feedback--

考虑当你的分支和原始仓库分别发展时会发生什么。

---

它会导致“发散的历史”，使得与上游同步变得困难。

---

Git 不允许向主分支提交。

### --feedback--

考虑当你的分支和原始仓库分别发展时会发生什么。

---

它会自动删除你的局部的更改。

### --feedback--

考虑当你的分支和原始仓库分别发展时会发生什么。

## --video-solution--

2

## --text--

哪一串命令将正确地使用原始仓库的更改更新你的局部的 `main` 分支？

## --answers--

`git checkout main`；`git pull upstream`

### --feedback--

考虑获取上游更改而不干扰你的分叉所需的逐步进程。

---

`git pull upstream main`

### --feedback--

考虑获取上游更改而不干扰你的分叉所需的逐步进程。

---

`git checkout main`；`git fetch upstream`；`git merge upstream/main`

---

`git fetch upstream/main`；`git merge`

### --feedback--

考虑获取上游更改而不干扰你的分叉所需的逐步进程。

## --video-solution--

3

## --text--

如果你不小心提交到了你的 `main` 分支并且无法合并上游更改，假设你没有创建任何拉取请求，你可以使用什么命令强制重置你的 `main` 分支以匹配上游？

## --answers--

`git checkout upstream/main`

### --feedback--

哪个命令会完全重置你的 `branch` 以匹配另一个 `branch` 的状态？

---

`git reset --hard upstream/main`

---

`git rebase upstream/main`

### --feedback--

哪个命令会完全重置你的 `branch` 以匹配另一个 `branch` 的状态？

---

`git clean upstream/main`

### --feedback--

哪个命令会完全重置你的 `branch` 以匹配另一个 `branch` 的状态？

## --video-solution--

2
