---
id: 6881705cd9860639e98d639d
title: ¿Qué es el problema N+1?
challengeType: 19
dashedName: what-is-the-n-plus-1-problem
---

# --description--

El problema N+1 es un cuello de botella común de rendimiento en aplicaciones basadas en bases de datos. Si alguna vez has experimentado un tiempo de carga muy largo mientras usas una aplicación, es muy probable que esté relacionado con el problema N+1. Este problema ocurre cuando se realizan muchas consultas pequeñas en secuencia para obtener los datos que solicitaste.

¿Pero por qué harías muchas consultas en secuencia? Podrías hacer esto para consultar una lista de registros y obtener información adicional sobre esos registros. Realizarías una consulta inicial para obtener la lista de registros y luego harías una consulta adicional para cada uno de esos registros, para obtener información adicional sobre ellos.

Aunque intuitivamente pienses que realizar muchas consultas pequeñas y simples será más eficiente que hacer una sola consulta grande y compleja, generalmente no es así. Cuantas más consultas realices, más tiempo tomará todo el proceso porque necesitas enviar cada consulta al servidor, buscar los datos en la base de datos y luego recibir los datos enviados por el servidor para esa consulta. Esto puede tener un impacto muy significativo en el rendimiento de tu aplicación.

Para mostrarte un ejemplo práctico, supongamos que estás desarrollando una aplicación para un servicio de entrega de comida y ejecutas una consulta para obtener las primeras 50 órdenes en la base de datos. Primero, obtendrás una lista con estas órdenes de una tabla `orders`, como esta:

```sql
order_id | product   | quantity | customer_id
1        | pizza     | 2        | 3422
2        | salad     | 1        | 1255
3        | ice cream | 4        | 2344
4        | donuts    | 10       | 3455
.        | .         | .        | .
.        | .         | .        | .
.        | .         | .        | .
```

¿Pero qué pasa si también necesitas obtener los datos de los clientes que enviaron estos pedidos? Esta información estaría almacenada en una tabla diferente llamada `customers`.

Una forma de abordar esto sería obtener primero la lista de órdenes y luego ejecutar una consulta por cada orden para obtener la información de los clientes. Para obtener la lista de órdenes, podrías ejecutar una consulta como esta, para obtener los primeros 50 registros de la tabla `orders`:

```sql
SELECT * FROM orders LIMIT 50;
```

Aquí es de donde viene el 1 en N+1. Es la consulta inicial que te da la lista de registros. Luego, necesitarás realizar otra consulta para cada uno de estos registros para obtener la información del cliente que envió el pedido. Para esto, podrías escribir un ciclo en una función asíncrona para procesar tanto los pedidos como los clientes. La función `getCustomerData()` realizará una consulta SQL para obtener los datos del cliente que hizo un pedido específico. Esto se hará en secuencia para cada pedido que se haya realizado:

```js
for (const order of orders) {
  const customerId = order.customer_id;
  const customerData = await getCustomerData(customerId);
  // Process the customer's data.
}
```

Ahí es de donde viene la N en N+1. N representa el número de consultas que se realizarán para obtener datos adicionales para cada uno de los registros.

Este enfoque puede parecer simple e intuitivo, pero te sorprenderá saber que esto es exactamente lo que no debes hacer. Debes evitar hacer consultas en un ciclo porque realizar múltiples consultas pequeñas tomará mucho más tiempo que ejecutar una sola consulta más grande para obtener todos los datos.

Deberías intentar usar las herramientas que SQL te ofrece para reducir la cantidad de consultas tanto como sea posible. En este caso, podríamos usar una operación `JOIN` para unir las tablas `orders` y `customers`.

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name AS customer_name,
  customers.email AS customer_email,
  customers.address AS customer_address
FROM orders
JOIN customers ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50)
```

Con la operación `JOIN`, podemos obtener los datos de las primeras 50 órdenes en la base de datos, incluyendo los datos de los clientes, sus nombres, correo electrónico y direcciones, con solo una consulta. Puede parecer más complejo, pero en realidad es más eficiente de esta manera.

Ahora sabes en qué consiste el problema N+1, así que puedes identificarlo y prevenirlo para interactuar con tu base de datos de manera eficiente.

# --questions--

## --text--

¿Cuál es la característica principal del problema N+1 en el contexto de SQL?

## --answers--

Demasiados datos devueltos en una sola consulta.

### --feedback--

Piensa en la cantidad de consultas que normalmente se involucran y qué desencadena las consultas adicionales después de la primera.

---

Ejecutar una consulta inicial seguida de N consultas adicionales para datos relacionados.

---

Uso ineficiente de índices de base de datos.

### --feedback--

Piensa en la cantidad de consultas que normalmente se involucran y qué desencadena las consultas adicionales después de la primera.

---

Conflictos que surgen de transacciones concurrentes en la base de datos.

### --feedback--

Piensa en la cantidad de consultas que normalmente se involucran y qué desencadena las consultas adicionales después de la primera.

## --video-solution--

2

## --text--

¿Cuál es la principal implicación de rendimiento del problema N+1?

## --answers--

Aumento en el uso de CPU en el servidor de base de datos debido a joins complejos.

### --feedback--

Piensa en la sobrecarga asociada con la comunicación entre la aplicación y la base de datos.

---

Integridad de datos reducida debido a inconsistencias en datos relacionados.

### --feedback--

Piensa en la sobrecarga asociada con la comunicación entre la aplicación y la base de datos.

---

Mayor consumo de memoria en el servidor de la aplicación debido a grandes conjuntos de resultados.

### --feedback--

Piensa en la sobrecarga asociada con la comunicación entre la aplicación y la base de datos.

---

Número aumentado de viajes de ida y vuelta a la base de datos, lo que provoca un tiempo de carga mayor.

## --video-solution--

4

## --text--

Una estrategia para reducir el número de consultas a la base de datos al recuperar datos relacionados y evitar el problema N+1 implica:

## --answers--

Aumentando el tamaño del pool de conexiones de la base de datos.

### --feedback--

Piensa en cómo puedes combinar la recuperación de los datos principales y su información relacionada en una sola interacción con la base de datos.

---

Optimizando consultas SQL individuales para velocidad.

### --feedback--

Piensa en cómo puedes combinar la recuperación de los datos principales y su información relacionada en una sola interacción con la base de datos.

---

Obteniendo datos relacionados dentro de la consulta inicial usando cláusulas JOIN.

---

Implementando filtrado y ordenamiento de datos del lado del cliente.

### --feedback--

Piensa en cómo puedes combinar la recuperación de los datos principales y su información relacionada en una sola interacción con la base de datos.

## --video-solution--

3
