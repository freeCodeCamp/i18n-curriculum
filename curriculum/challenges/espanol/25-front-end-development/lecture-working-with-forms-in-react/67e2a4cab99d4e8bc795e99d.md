---
id: 67e2a4cab99d4e8bc795e99d
title: '¿Cuál es el uso del hook <code>useActionState</code> y cómo funciona?'
challengeType: 19
dashedName: what-is-the-useactionstate-hook-and-how-does-it-work
---

# --description--

React 19 vino con dos nuevas características notables llamadas componentes de servidor y acciones de servidor. 

Desde esa versión en adelante, los componentes de servidor se convirtieron en el estándar en marcos como Next.js que los admiten fácilmente.

Las acciones de servidor, por otro lado, son funciones que se ejecutan en el servidor para permitir el manejo de formularios directamente en el servidor sin necesidad de puntos finales de API.

Una acción de servidor se ve así:

```js
"use server";

async function submitForm(formData) {
  const name = formData.get("name");
  return { message: `Hello, ${name}!` };
}
```

Esta acción de servidor extrae un campo `name` de un formulario y devuelve una cadena saludando ese nombre.

Para simplificar la gestión de estado para acciones de servidor y eliminar la necesidad de JavaScript del lado del cliente para formularios simples, el equipo de React introdujo el hook `useActionState` en la versión 19.

Echemos un vistazo más de cerca a este hook y veamos cómo funciona.

La documentación de React describe el hook `useActionState` como un hook que "te permite actualizar el estado basado en el resultado de una acción de formulario".

Pero esto no significa que solo puedas usar el hook `useActionState` con formularios. También puedes usarlo para gestionar clics en botones y otros eventos, siempre que tengas una acción en su lugar.

Y ten en cuenta que, dado que `useActionState` es un hook, no puedes usarlo dentro de un componente de servidor.

Aquí está la sintaxis básica del hook `useActionState`:

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` es el estado actual que la acción devuelve.

- `action` es la función que desencadena la acción del servidor.

- `isPending` es un booleano que indica si la acción se está ejecutando actualmente o no.

- El parámetro `actionFunction` es la acción del servidor en sí.

- `initialState` es el parámetro que representa el punto de partida para el estado antes de que la acción se ejecute.

- `permalink` es una cadena opcional que contiene la URL única de la página que el formulario modifica.

Para usar el hook `useActionState`, asegúrate de tener una acción en su lugar primero. Usemos la acción del ejemplo anterior para esto, con un pequeño giro:

```js
"use server";

export async function submitForm(_, formData) {
  const name = formData.get("name");

  const hour = new Date().getHours();
  let greeting;

  if (hour < 12) {
    greeting = "Good morning";
  } else if (hour < 18) {
    greeting = "Good afternoon";
  } else {
    greeting = "Good evening";
  }

  return { message: `${greeting}, ${name}` };
}
```

En tu componente, luego necesitas importar el hook `useActionState` y llamarlo en el nivel superior del cuerpo del componente (antes de la sentencia return) al igual que otros hooks. También debes importar la acción:

```jsx
"use client";

// Import the useActionState hook
import { useActionState } from "react";

// Import the submitForm action
import { submitForm } from "./actions/submitForm";

const Greeter = () => {

 // Initialize the hook
 const [state, submit, isPending] = useActionState(submitForm, {
   message: "",
 });

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6">
      {/* Rest of component */}
    </div>
  );
};

export default Greeter;
```

Aquí está el código completo con un poco de estilo:

```jsx
"use client";

import { useActionState } from "react";
import { submitForm } from "./actions/submitForm";

const Greeter = () => {
  const [state, submit, isPending] = useActionState(submitForm, {
    message: "",
  });

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6">
      <form
        action={submit}
        className="bg-white p-6 rounded-2xl shadow-md w-full max-w-md"
      >
        <h2 className="text-2xl text-center font-semibold text-gray-700 mb-4">
          Greet Someone
        </h2>

        <input
          type="text"
          name="name"
          placeholder="Enter your name"
          required
          className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-400"
        />

        <button
          type="submit"
          disabled={isPending}
          className="w-full mt-4 p-3 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 disabled:bg-gray-400 transition-all"
        >
          {isPending ? "Greeting..." : "Greet"}
        </button>

        {state.message && (
          <p className="mt-4 text-green-600 text-center font-medium">
            {state.message}
          </p>
        )}
      </form>
    </div>
  );
};

export default Greeter;
```

En el navegador, verías tu botón de formulario cambiar de `Greet` a `Greeting...` mientras la acción está `isPending` - y el saludo mostraría `Buenos días, {name}`, `Buenas tardes, {name}`, o `Buenas noches, {name}`, dependiendo de la hora del día en que el formulario fue enviado.

¿Recuerdas cómo mencionamos que también puedes usar el hook `useActionState` fuera de un formulario?

En este ejemplo, obtendremos cinco usuarios de JSONPlaceholder con un clic de botón:

```js
"use server";

export async function getUsers() {
  const res = await fetch(
    "https://jsonplaceholder.typicode.com/users?_start=0&_limit=5/"
  );
  return await res.json();
}
```

Aquí está el UI con estilo:

```jsx
"use client";

import { useActionState } from "react";
import { getUsers } from "./actions/getUsers";

export default function FetchUsers() {
  const [users, fetchAction, isPending] = useActionState(getUsers, []);

  return (
    <div className="p-6 max-w-lg mx-auto">
      <button
        onClick={fetchAction}
        disabled={isPending}
        className="px-4 py-2 cursor-pointer bg-green-500 text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400 font-bold"
      >
        {isPending ? "Fetching Users..." : "Fetch Users"}
      </button>

      <ul className="mt-4 space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-3 bg-gray-100 rounded-lg">
            <p className="font-semibold">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

En el navegador, verías que el texto del botón nunca se actualiza a `Fetching Users...` después de que se hace clic.

Esto sucede porque React trata la obtención de datos y el renderizado como de mayor prioridad que el estado `isPending`, lo que bloquea `isPending` en el proceso y lanza un error.

Para solucionar este problema, necesitas envolver la acción en `startTransition`:

```jsx
"use client";

import { useActionState } from "react";
import { getUsers } from "./actions/getUsers";

// import startTransition from React
import { startTransition } from "react";

export default function FetchUsers() {
  const [users, fetchAction, isPending] = useActionState(getUsers, []);

  return (
    <div className="p-6 max-w-lg mx-auto">
      <button
        {/* wrap fetchAction in startTransition */}
        onClick={() => startTransition(() => fetchAction())}
        disabled={isPending}
        className="px-4 py-2 bg-green-500 font-bold cursor-pointer text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400"
      >
        {isPending ? 'Fetching Users...' : 'Fetch Users'}
      </button>

      <ul className="mt-4 space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-3 bg-gray-100 rounded-lg">
            <p className="font-semibold">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

Si te estás preguntando qué es `startTransition`, es una función que indica a React que una actualización de estado es de baja prioridad y puede ser interrumpida. Esto mantiene la UI receptiva mientras maneja actualizaciones asíncronas como acciones de servidor.

Así es cómo usar el hook `useActionState` dentro y fuera de un formulario.

# --questions--

## --text--

¿Cuál es el propósito del hook `useActionState` en React?

## --answers--

Administra el estado basado en el resultado de una acción, incluyendo envíos de formularios, clics en botones y otras actualizaciones impulsadas por eventos.

---

Solo actualiza el estado cuando se envía un formulario y no admite otros tipos de acciones como clics en botones o controladores de eventos personalizados.

### --feedback--

Funciona con acciones, no solo con formularios.

---

Maneja la gestión del estado global entre múltiples componentes, haciéndolo un reemplazo para bibliotecas de gestión de estado como Redux o Zustand.

### --feedback--

Funciona con acciones, no solo con formularios.

---

Reemplaza el hook `useState` por completo al proporcionar una manera integrada de gestionar tanto el estado local como el global sin dependencias adicionales.

### --feedback--

Funciona con acciones, no solo con formularios.

## --video-solution--

1

## --text--

¿Por qué no puedes usar el hook `useActionState` dentro de un componente de servidor?

## --answers--

Porque los componentes del servidor no admiten la gestión de estado, haciendo que `useActionState` sea incompatible.

### --feedback--

Los hooks solo funcionan en un tipo específico de componente.

---

Porque `useActionState` requiere una conexión a la base de datos, que solo está disponible en componentes del cliente.

### --feedback--

Los hooks solo funcionan en un tipo específico de componente.

---

Porque `useActionState` es un hook de React, y los hooks solo pueden ser usados dentro de componentes del cliente.

---

Porque `useActionState` depende de APIs de navegador que no están disponibles en el servidor.

### --feedback--

Hooks only work in a specific type of component.

## --video-solution--

3

## --text--

¿Qué versión de React introdujo los componentes y acciones de servidor?

## --answers--

React 17

### --feedback--

Esta versión se centró en mejorar el renderizado del lado del servidor.

---

React 18

### --feedback--

Esta versión se centró en mejorar el renderizado del lado del servidor.

---

React 19

---

React 16

### --feedback--

This version focused on improving server-side rendering.

## --video-solution--

3
