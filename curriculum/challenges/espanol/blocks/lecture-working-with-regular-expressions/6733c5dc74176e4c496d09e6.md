---
id: 6733c5dc74176e4c496d09e6
title: ¿Qué son las aserciones de anticipación y retroceso, y cómo funcionan?
challengeType: 19
dashedName: what-are-lookaheads-and-lookbehind-assertions-and-how-do-they-work
---

# --interactive--

Las aserciones de anticipación y retroceso te permiten coincidir con patrones específicos según la presencia o falta de patrones circundantes. Hay cuatro variaciones de estas aserciones.

La primera es la aserción de anticipación positiva. Esta aserción coincidirá con un patrón cuando el patrón sea seguido por otro patrón.

Para construir una anticipación positiva, debe comenzar con el patrón que desea coincidir. Luego, use paréntesis para envolver el patrón que desea usar como su condición. Después del paréntesis de apertura, use `?=` para definir ese patrón como una anticipación positiva.

Este patrón solo coincidirá con la palabra `free` si está seguida por `code`:

```js
const regex = /free(?=code)/i;
```

Probemos el comportamiento de nuestro patrón:

:::interactive_editor

```js
const regex = /free(?=code)/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

:::

Observe cómo solo la cadena donde `free` es seguida inmediatamente por `code` pasa la prueba.

Pero, ¿qué pasa si quieres coincidir con la presencia de `free` cuando NO va seguida de `code`? Puedes convertir tu anticipación positiva en una anticipación negativa para invertir el comportamiento. Para hacer esto, cambia tu `?=` por `?!`:

```js
const regex = /free(?!code)/i;
```

Probemos esto contra nuestras mismas cadenas:

:::interactive_editor

```js
const regex = /free(?!code)/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

:::

Como era de esperar, los resultados están invertidos. La única cadena que falla es la primera cadena, donde `free` es seguida inmediatamente por `code`.

Las aserciones de retroceso funcionan de manera similar a las de anticipación, excepto que, en lugar de coincidir condicionalmente con un patrón siguiente, coinciden condicionalmente con un patrón anterior. Echemos un vistazo a un retroceso positivo.

Un lookbehind positivo se denota con `?<=` en lugar de `?=`. Hagamos que nuestra expresión regular coincida con `code` cuando esté precedido por `free`:

```js
const regex = /(?<=free)code/i;
```

Al igual que con nuestra anticipación positiva, nuestro retroceso positivo coincide con la primera cadena porque `code` está precedido inmediatamente por `free`:

:::interactive_editor

```js
const regex = /(?<=free)code/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

:::

Para coincidir con `code` cuando NO está precedido por `free`, podemos usar un lookbehind negativo. Un lookbehind negativo se define reemplazando `?<=` por `?<!`:

```js
const regex = /(?<!free)code/i;
```

Esto coincidiría con cualquier aparición de `code` que NO esté precedida inmediatamente por `free`:

:::interactive_editor

```js
const regex = /(?<!free)code/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

:::

Recuerda que `Regex.prototype.test` solo confirma si una cadena coincide con la expresión regular. Vamos a usar nuestro retroceso negativo con `String.prototype.match` para ver cómo las aserciones afectan eso:

```js
const regex = /(?<!free)code/i;
console.log("freeCodeCamp".match(regex)); // null
console.log("free code camp".match(regex)); // ['code', index: 5, input: 'free code camp', groups: undefined]
console.log(
  "I need someone for free to write code for me".match(regex)
); // ['code', index: 33, input: 'I need someone for free to write code for me', groups: undefined]
```

Observe cómo, aunque nuestra expresión regular usa un retroceso para verificar la presencia de `free`, no coincide con `free`. El único texto incluido en la coincidencia es `code`.

Las anticipaciones y retrocesos son increíblemente útiles para coincidir con texto condicionalmente sin afectar el valor devuelto de tu coincidencia.

# --questions--

## --text--

¿Cuál es la sintaxis para una aserción de anticipación positiva en una expresión regular?

## --answers--

`(?=pattern)`

---

`(?<=pattern)`

### --feedback--

La lección describe cómo estructurar un lookahead positivo usando una sintaxis específica.

---

`(?!pattern)`

### --feedback--

La lección describe cómo estructurar un lookahead positivo usando una sintaxis específica.

---

`(?<!pattern)`

### --feedback--

La lección describe cómo estructurar un lookahead positivo usando una sintaxis específica.

## --video-solution--

1

## --text--

¿Qué aserción usarías para coincidir una palabra solo si NO va seguida de un patrón específico?

## --answers--

Anticipación positiva.

### --feedback--

Piensa en qué aserción "invierte" el comportamiento de una anticipación positiva.

---

Anticipación negativa.

---

Retroceso positivo.

### --feedback--

Piensa en qué aserción "invierte" el comportamiento de una anticipación positiva.

---

Retroceso negativo.

### --feedback--

Piensa en qué aserción "invierte" el comportamiento de una anticipación positiva.

## --video-solution--

2

## --text--

Cuando se usa una aserción de retroceso con `String.prototype.match`, ¿qué parte de la cadena está realmente incluida en el resultado de la coincidencia?

## --answers--

La cadena completa.

### --feedback--

La lección demuestra esto con un ejemplo usando un negative lookbehind.

---

El patrón en la aserción de retroceso.

### --feedback--

La lección demuestra esto con un ejemplo usando un negative lookbehind.

---

El patrón después de la aserción de retroceso.

---

Tanto el patrón de retroceso como el patrón que le sigue.

### --feedback--

La lección demuestra esto con un ejemplo usando un negative lookbehind.

## --video-solution--

3
