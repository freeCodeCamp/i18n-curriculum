---
id: 680b3ef395479b0e449ecb6e
title: Implementar el algoritmo de ordenación por selección
challengeType: 27
dashedName: implement-selection-sort-algorithm
---

# --description--

La ordenación por selección es otro algoritmo de ordenación popular que se enseña en la mayoría de los cursos de ciencias de la computación.

Este algoritmo funciona buscando repetidamente el elemento más pequeño de la porción no ordenada de la lista y cambiándolo con el primer elemento no ordenado. Comienza seleccionando el valor mínimo en toda la lista y cambiándolo con el primer elemento. Luego se mueve a la segunda posición, encuentra el valor más pequeño en los elementos no ordenados restantes, y lo cambia con el segundo elemento. Este proceso continúa, moviéndose por la lista un elemento a la vez, hasta que toda la lista esté ordenada.

El ordenamiento por selección resulta en una complejidad de tiempo cuadrática en los casos mejores, promedio y peores escenarios. La complejidad espacial será constante `O(1)` porque el ordenamiento se realiza en el lugar y se utiliza una cantidad constante de memoria independientemente del tamaño de la lista.

**Objetivo:** Cumplir con las historias de usuario a continuación y pasar todas las pruebas para completar el laboratorio.

**Historias de usuario:**

1. Debes definir una función llamada `selection_sort`.
1. Tu función `selection_sort` debe tener un parámetro que represente la lista de elementos.
1. Tu función `selection_sort` debe tomar una lista y ordenar los elementos en su lugar, de menor a mayor.
1. Tu función `selection_sort` debe modificar la lista de entrada en el lugar y devolverla una vez que esté ordenada.
1. Tu función `selection_sort` debe seguir el algoritmo de ordenamiento por selección, intercambiando el elemento más pequeño de la porción no ordenada de la lista con el primer elemento no ordenado.
1. Tu función `selection_sort` no debe realizar intercambios innecesarios cuando el elemento más pequeño ya está en la posición correcta.
1. Tu función `selection_sort` no debe usar ni el método incorporado `sort()` ni la función `sorted()`.

# --hints--

Deberías tener una función llamada `selection_sort`.

```js
({test: () => {
    runPython(`
assert _Node(_code).has_function('selection_sort')
    `)
}})
```

Tu función `selection_sort` debe tener un parámetro.

```js
(
    {test: () => {
        runPython(`
            import inspect
            sig = inspect.signature(selection_sort)
            assert len(sig.parameters) == 1
        `)
    }}
)
```

No debes importar ningún módulo ni usar métodos de ordenación integrados en tu código.

```js
(
    {
        test: () => runPython(`
            assert len(_Node(_code).find_imports()) == 0
            assert not _Node(_code).block_has_call("sort")
            assert not _Node(_code).block_has_call("sorted")
        `)
    }
)
```

Tu `selection_sort` debería devolver la misma lista que la lista de entrada.

```js
(
    {
        test: () => runPython(`
            input_list = [32, 0, 88, 1, 203]
            assert selection_sort(input_list) is input_list
        `)
    }
)
```

Tu `selection_sort` debe modificar la lista de entrada en el lugar. No debes usar ningún método que agregue o elimine elementos de la lista.

```js
(
    {
        test: () => runPython(`
            from collections import UserList

            class CustomList(UserList):
                def __init__(self, *args, **kwargs):
                    self._record = []
                    super().__init__(*args, **kwargs)

                def __setitem__(self, key, value):
                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')
                    super().__setitem__(key, value)

                def append(self, *args, **kwargs):
                    self._record.append(f'Appending to list: {args}, {kwargs}')
                    super().append(*args, **kwargs)

                def insert(self, *args, **kwargs):
                    self._record.append(f'Inserting to list: {args}, {kwargs}')
                    super().insert(*args, **kwargs)

                def pop(self, *args, **kwargs):
                    self._record.append(f'Popping from list: {args}, {kwargs}')
                    super().pop(*args, **kwargs)

                def remove(self, *args, **kwargs):
                    self._record.append(f'Removing from list: {args}, {kwargs}')
                    super().remove(*args, **kwargs)


            list_to_sort = CustomList([32, 0, 88, 1, 203])

            selection_sort(list_to_sort)
            assert all(
                'Setting item' in record
                for record in list_to_sort._record
            )
        `)
    }
)
```

Tu función `selection_sort` debe seguir el algoritmo de ordenamiento por selección, intercambiando el valor mínimo en la parte no ordenada de la lista con el primer elemento no ordenado. Evita intercambios innecesarios cuando el valor mínimo ya está en la posición correcta.

```js
(
    {
        test: () => runPython(`
            from collections import UserList

            class CustomList(UserList):
                def __init__(self, *args, **kwargs):
                    self._record = []
                    super().__init__(*args, **kwargs)

                def __setitem__(self, key, value):
                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')
                    super().__setitem__(key, value)


            list_to_sort = CustomList([33, 1, 89, 2, 67, 245])

            swap_pairs = [
                ((0, 1, 33), (1, 33, 1)),
                ((1, 2, 33), (3, 33, 2)),
                ((2, 33, 89), (3, 89, 33)),
                ((3, 67, 89), (4, 89, 67)),
            ]

            selection_sort(list_to_sort)
            record = list_to_sort._record

            actual_pairs = [
                (record[offset * 2], record[offset * 2 + 1])
                for offset, _ in enumerate(record[::2])
            ]
            assert len(swap_pairs) == len(actual_pairs)

            for expected_pair, actual_pair in zip(swap_pairs, actual_pairs):
                assert (
                    set(f'Setting item {key} to {value}. Previous value: {old}' for key, value, old in expected_pair)
                    == set(actual_pair)
                )
        `)
    }
)
```

`selection_sort([33, 1, 89, 2, 67, 245])` debería devolver `[1, 2, 33, 67, 89, 245]`.

```js
(
    {
        test: () => runPython(`
            assert selection_sort([33, 1, 89, 2, 67, 245]) == [1, 2, 33, 67, 89, 245]
            
        `)
    }
)
```

`selection_sort([5, 16, 99, 12, 567, 23, 15, 72, 3])` debería devolver `[3, 5, 12, 15, 16, 23, 72, 99, 567]`.

```js
(
    {
        test: () => runPython(`
            assert selection_sort([5, 16, 99, 12, 567, 23, 15, 72, 3]) == [3, 5, 12, 15, 16, 23, 72, 99, 567]
            
        `)
    }
)
```

`selection_sort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92])` debería devolver `[1, 1, 2, 2, 4, 8, 32, 43, 43, 55, 63, 92, 123, 123, 234, 345, 5643]`.

```js
(
    {
        test: () => runPython(`
            assert selection_sort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]) == [1, 1, 2, 2, 4, 8, 32, 43, 43, 55, 63, 92, 123, 123, 234, 345, 5643]
            
        `)
    }
)
```

Tu función `selection_sort` debe ordenar correctamente cualquier lista de números.

```js
(
    {
        test: () => runPython(`
            assert selection_sort([42, 17, 93, 8, 61, 29]) == [8, 17, 29, 42, 61, 93]
            assert selection_sort([11, 4, 78, 23, 55, 198, 65, 90, 2]) == [2, 4, 11, 23, 55, 65, 78, 90, 198]
            assert selection_sort([9, 27, 3, 7, 101, 66, 34, 52, 87, 42, 12, 29]) == [3, 7, 9, 12, 27, 29, 34, 42, 52, 66, 87, 101]
            assert selection_sort([5, 14, 33, 77, 2, 18, 92, 1, 100, 45, 73, 64, 28, 56]) == [1, 2, 5, 14, 18, 28, 33, 45, 56, 64, 73, 77, 92, 100]
            
        `)
    }
)     
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def selection_sort(nums):
    for i, _ in enumerate(nums):
        min_index = i

        for j in range(i + 1, len(nums)):
            if nums[j] < nums[min_index]:
                min_index = j

        if min_index != i:
            nums[i], nums[min_index] = nums[min_index], nums[i]

    return nums

```
