---
id: 6733c5f20cc9584cada942a4
title: ¿Qué son los grupos de captura y las referencias inversas, y cómo funcionan?
challengeType: 19
dashedName: what-are-capturing-groups-and-backreferences-and-how-do-they-work
---

# --interactive--

Un grupo de captura te permite "capturar" una porción de la cadena coincidente para usarla como necesites. Los grupos de captura se definen por paréntesis que contienen el patrón a capturar, sin caracteres iniciales como una búsqueda anticipada.

Capturemos el `code` de nuestra expresión regular `freeCodeCamp`. Para hacer eso, incluiremos `code` entre paréntesis y lo definiremos como un grupo de captura:

```js
const regex = /free(code)camp/i;
```

Para confirmar el comportamiento, podemos probarlo contra una cadena `freecodecamp`:

:::interactive_editor

```js
const regex = /free(code)camp/i;
console.log(regex.test("freecodecamp")); // true
```

:::

Pero esto en realidad no hace uso de nuestro grupo capturado. En cambio, echemos un vistazo al resultado de usar `match`:

```js
const regex = /free(code)camp/i;
console.log("freecodecamp".match(regex));
// [
//   'freecodecamp',
//   'code', <--
//   index: 0,
//   input: 'freecodecamp',
//   groups: undefined
// ]
```

Aquí podemos ver que nuestro array `match` tiene un segundo elemento, que es la porción de la cadena capturada por nuestro grupo de captura.

Observa cómo el grupo de captura coincide con el patrón exacto `code`, donde una clase de caracteres coincidiría con un solo carácter de la lista `c`, `o`, `d` y `e`.

Pero, ¿cómo podemos realmente usar esto? Bueno, los grupos de captura se utilizan a menudo al reemplazar contenidos de una cadena. Configuremos algo de código para hacer eso. Vamos a convertir `freecodecamp` en `paidcodeworld`:

:::interactive_editor

```js
const regex = /free(code)camp/i;
console.log("freecodecamp".replace(regex, "paidcodeworld"));
```

:::

Esto funciona por sí solo, pero ¿qué pasa si no sabíamos cuántos `o`'s había en `code`? Si necesitamos un cuantificador para uno o más `o`s:

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paidcodeworld"));
```

:::

Estamos obteniendo `paidcodeworld` como nuestro resultado. Queremos preservar el número de `o`'s, por lo que necesitamos reutilizar lo que fue capturado por la expresión regular.

Aquí es donde entra en juego una referencia inversa. En lugar de codificar la parte `code` de nuestra cadena de reemplazo, podemos hacer referencia al grupo capturado directamente.

En una llamada `replace`, logras una referencia inversa usando un signo de dólar (`$`) seguido del número del grupo de captura a usar. En nuestro caso, sería `$1`, ya que `code` se captura en el primer grupo de captura:

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world")); // paidcoooooooodeworld
```

:::

Ahora hemos logrado preservar un número desconocido de caracteres `o` al convertir `freecodecamp` en `paidcodeworld`. Pero las referencias inversas no se limitan solo a la llamada de reemplazo. De hecho, puedes usarlas directamente en una expresión regular.

Esto te permitiría coincidir con un patrón capturado previamente más adelante en la expresión regular.

Supongamos que queremos que coincida `freecodecamp` dos veces, con el mismo número de `o`'s, pero en cualquier parte de la cadena.

Primero, necesitamos separarlos con nuestro carácter comodín, y permitir cualquier número de caracteres para que coincida con ese comodín:

```js
const regex = /free(co+de)camp.*free(co+de)camp/i;
```

Sin embargo, esta expresión actual no asegurará que el número de caracteres `o` sea el mismo. Para lograr eso, necesitamos reemplazar el segundo grupo de captura con una referencia al primero.

Dentro de una expresión regular, una referencia inversa se denota con una barra invertida seguida del número del grupo de captura:

:::interactive_editor

```js
const regex = /free(co+de)camp.*free\1camp/i;
console.log(regex.test("freecooooodecamp is great i love freecooooodecamp")); // true
console.log(regex.test("freecooooodecamp is great i love freecodecamp")); // false
```

:::

Y con eso, podemos ver que una cadena con el número correcto de `o`s coincide, mientras que una cadena con dos números diferentes de `o`s no lo hace.

Esta sintaxis es excelente, pero puede volverse confusa rápidamente cuando refieres a múltiples grupos de captura. Afortunadamente, en lugar de usar números, puedes darle nombres a tus grupos.

Para definir un grupo de captura nombrado, agregas un signo de interrogación (`?`) seguido del nombre encerrado en signos menores y mayores, al comienzo del grupo. Nombramos nuestro grupo de captura `code`:

```js
const regex = /free(?<code>co+de)camp.*free\1camp/i;
```

Ahora podemos actualizar nuestra referencia inversa en la expresión regular para refernos a este grupo. Una referencia inversa nombrada comienza con una barra invertida seguida de la letra `k` en JavaScript.  Then you add the name, again enclosed in less than (`<`) and greater than (`>`) signs. Echemos un vistazo a eso:

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
```

Ahora si verificamos nuestra llamada `test()`, podemos ver que aún pasamos:

:::interactive_editor

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
console.log(regex.test("freecooooodecamp is freecooooodecamp")); // true
```

:::

Para utilizar nuestro grupo de captura nombrado en una llamada `replace()`, insertaremos un signo de dólar en la cadena, seguido del nombre encerrado en signos menores y mayores:

:::interactive_editor

```js
const regex = /free(?<code>co+de)camp/i;
console.log("freecooooodecamp".replace(regex, "paid$<code>camp")); // paidcooooodecamp
```

:::

Finalmente, a veces deseas crear un grupo de caracteres, pero no necesitas el resultado capturado.

Supongamos que queremos que coincida `freecodecamp` o `freecandycamp`. Podrías crear dos patrones separados por una aserción OR:

```js
const regex = /freecodecamp|freecandycamp/i;
```

Pero esto puede volverse bastante extenso para expresiones regulares a mayor escala. En su lugar, puedes crear un grupo de no captura alrededor de los caracteres que necesitas OR:

```js
const regex = /free(?:code|candy)camp/i;
```

Un grupo de no captura no almacena la coincidencia `code|candy` por separado en memoria. Pero puede ser útil para crear patrones alternativos sin sacrificar legibilidad o rendimiento.

# --questions--

## --text--

¿Cómo creas un grupo de captura nombrado en una expresión regular?

## --answers--

`(name:pattern)`

### --feedback--

La lección describe una sintaxis específica para nombrar un grupo de captura, que involucra corchetes angulares.

---

`(?<name>pattern)`

---

`(?name:pattern)`

### --feedback--

La lección describe una sintaxis específica para nombrar un grupo de captura, que involucra corchetes angulares.

---

`(name=>pattern)`

### --feedback--

La lección describe una sintaxis específica para nombrar un grupo de captura, que involucra corchetes angulares.

## --video-solution--

2

## --text--

En un método `replace()`, ¿cómo harías referencia al primer grupo de captura en la cadena de reemplazo?

## --answers--

`\1`

### --feedback--

La lección menciona usar un símbolo específico seguido de un número para referenciar grupos de captura en una llamada a replace.

---

`$1`

---

`{1}`

### --feedback--

La lección menciona usar un símbolo específico seguido de un número para referenciar grupos de captura en una llamada a replace.

---

`[1]`

### --feedback--

La lección menciona usar un símbolo específico seguido de un número para referenciar grupos de captura en una llamada a replace.

## --video-solution--

2

## --text--

¿Cuál es el propósito de un grupo de no captura en una expresión regular?

## --answers--

Capturar un grupo sin almacenarlo en memoria

### --feedback--

La lección describe un caso de uso específico para grupos que no capturan relacionado con la creación de patrones alternativos.

---

Crear patrones alternativos sin sacrificar legibilidad o rendimiento

---

Nombrar un grupo de captura

### --feedback--

La lección describe un caso de uso específico para grupos que no capturan relacionado con la creación de patrones alternativos.

---

Hacer referencia a un grupo capturado previamente

### --feedback--

La lección describe un caso de uso específico para grupos que no capturan relacionado con la creación de patrones alternativos.

## --video-solution--

2
