---
id: 672d26917a8ab3220c038a42
title: '¿Cómo funcionan las comparaciones con los tipos de datos nulos y no definidos?'
challengeType: 19
dashedName: how-do-comparisons-work-with-null-and-undefined-data-types
---

# --description--

En JavaScript, `null` y `undefined` son dos tipos de datos distintos que representan la ausencia de un valor, pero se comportan de manera diferente en las comparaciones. Entender cómo interactúan estos tipos en varios escenarios de comparación es crucial para escribir código robusto y sin errores.

Comencemos con el tipo `undefined`. Una variable es `undefined` cuando ha sido declarada pero no ha sido asignada un valor. Es el valor por defecto de variables no inicializadas y parámetros de función a los que no se les proporcionó un argumento.

El tipo `null`, por otro lado, es un valor de asignación que representa una no-valía deliberada. A menudo se usa para indicar que una variable intencionalmente no tiene valor.

Al comparar `null` y `undefined` usando el operador de igualdad (`==`), JavaScript realiza una coerción de tipos. Esto significa que intenta convertir los operandos al mismo tipo antes de realizar la comparación. En este caso, `null` y `undefined` se consideran iguales:

```js
console.log(null == undefined); // true
```

Sin embargo, al usar el operador de igualdad estricta (`===`), que verifica tanto el valor como el tipo sin realizar coerción de tipos, `null` y `undefined` no son iguales:

```js
console.log(null === undefined); // false
```

Esta diferencia es importante tenerla en cuenta al escribir declaraciones condicionales o realizar verificaciones de igualdad en el código. Al comparar `null` o `undefined` con otros valores usando el operador de igualdad (`==`), el comportamiento puede ser inesperado. Por ejemplo:

```js
console.log(null == 0);  // false
console.log(null == ''); // false
console.log(undefined == 0); // false
console.log(undefined == ''); // false
```

Estas comparaciones devuelven `false` porque `null` y `undefined` solo son iguales entre sí (y consigo mismos) al usar el operador de igualdad. El comportamiento de `null` en otras comparaciones es particularmente complicado:

```js
console.log(null > 0);  // false
console.log(null == 0); // false
console.log(null >= 0); // true
```

`undefined`, por otro lado, siempre se convierte en `NaN` en contextos numéricos, lo que hace que todas las comparaciones numéricas con `undefined` devuelvan `false`:

```js
console.log(undefined > 0);  // false
console.log(undefined < 0);  // false
console.log(undefined == 0); // false
```

Dadas estas diferencias, generalmente se recomienda usar el operador de igualdad estricta al comparar valores, especialmente al tratar con `null` y `undefined`. Este enfoque ayuda a evitar coerciones de tipo inesperadas y hace que el comportamiento de su código sea más predecible.

En resumen, aunque `null` y `undefined` se utilizan para representar la ausencia de un valor, se comportan de manera diferente en las comparaciones. Entender estas diferencias es clave para escribir código JavaScript claro y sin errores.

# --questions--

## --text--

¿Cuál es el resultado de la expresión: `null === undefined`?

## --answers--

`true`

### --feedback--

Piense en lo que el operador de igualdad estricta (`===`) comprueba.

---

`false`

---

`undefined`

### --feedback--

Think about what the strict equality operator (`===`) checks for.

---

`null`

### --feedback--

Piense en lo que el operador de igualdad estricta (`===`) comprueba.

## --video-solution--

2

## --text--

En JavaScript, ¿cuál es el resultado de la comparación: `null >= 0`?

## --answers--

`true`

---

`false`

### --feedback--

Considere cómo se comporta `null` en comparaciones numéricas.

---

`undefined`

### --feedback--

Considere cómo se comporta `null` en comparaciones numéricas.

---

`Error`

### --feedback--

Considere cómo se comporta `null` en comparaciones numéricas.

## --video-solution--

1

## --text--

¿Cuál de las siguientes afirmaciones sobre `undefined` es correcta?

## --answers--

`undefined == null` evalúa a `false`.

### --feedback--

Piense en cómo se comporta `undefined` en diferentes tipos de comparaciones.

---

`undefined === null` evalúa a `true`.

### --feedback--

Piense en cómo se comporta `undefined` en diferentes tipos de comparaciones.

---

`undefined < 0` evalúa a `true.`

### --feedback--

Piense en cómo se comporta `undefined` en diferentes tipos de comparaciones.

---

`undefined == 0` evalúa a `false`.

## --video-solution--

4
