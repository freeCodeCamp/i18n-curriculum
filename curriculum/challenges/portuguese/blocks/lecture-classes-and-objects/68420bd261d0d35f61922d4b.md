---
id: 68420bd261d0d35f61922d4b
title: Como as Classes Funcionam e Como Elas Diferem dos Objetos?
challengeType: 19
dashedName: how-do-classes-work-and-how-do-they-differ-from-objects
---

# --description--

Em Python, classes e objetos trabalham juntos para organizar e gerenciar dados. Você cria uma classe para definir comportamentos compartilhados e depois cria objetos que usam esses comportamentos.

Em outras palavras, uma classe é como um modelo ou template que você usa para criar objetos.

Vamos ver o que são classes e como usá-las para criar objetos.

Para criar uma classe, você usa a palavra-chave `class` seguida do nome da classe e dois pontos. Então, dentro da classe, você pode adicionar um inicializador, junto com quaisquer atributos e métodos.

Atributos são como variáveis dentro de uma classe e são usados para armazenar dados. Métodos são funções definidas dentro de uma classe e são as ações que objetos criados com uma classe podem executar.

Aqui está a sintaxe básica de uma classe:

```python
class ClassName:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sample_method(self):               
        print(self.name.upper())
```

* `class ClassName` é composto pela palavra-chave `class` para criar uma classe, seguida pelo nome da classe, aqui chamado de `ClassName`. É comum em Python usar a convenção **PascalCase** ao nomear classes.
    
* `def __init__(self, name, age)` é o método especial chamado automaticamente quando um novo objeto é criado. Ele inicializa os atributos dos objetos que serão criados com a classe. Além disso, o primeiro parâmetro de `__init__` é sempre uma referência ao objeto específico que está sendo criado ou usado. Por convenção, esse parâmetro é chamado de `self`, mas tecnicamente, você pode usar qualquer nome. `self` permite que você acesse os próprios atributos e métodos do objeto.
    
* `self.name = name` e `self.age = age` são os atributos que os objetos terão.
    
* `def sample_method(self):` é o método que cada objeto criado pode chamar.
    
* `print(self.name.upper())` é o que o método `sample_method` fará, neste caso, ele imprime o nome em maiúsculas.
    

Se isso tudo parecer demais, não se preocupe. Vamos dar uma olhada em um exemplo semelhante da classe `Dog` e como você pode criar objetos a partir dela:

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f"{self.name.upper()} says woof woof!")
```

Com esta classe `Dog`, você pode criar um objeto. Aqui está a sintaxe básica para criar objetos a partir de uma classe:

```python
object_1 = ClassName(attribute_1, attribute_2)
object_2 = ClassName(attribute_1, attribute_2)
```

Você também pode chamar qualquer um dos métodos definidos na classe a partir de cada objeto:

```python
object_1.method_name()
object_2.method_name()
```

Agora vamos criar dois cachorros usando a classe `Dog` como modelo:

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f"{self.name.upper()} says woof woof! I'm {self.age} years old!")

dog_1 = Dog("Jack", 3)
dog_2 = Dog("Thatcher", 5)

# Call the bark method
dog_1.bark()  # JACK says woof woof! I'm 3 years old!
dog_2.bark()  # THATCHER says woof woof! I'm 5 years old!
```

Como você pode ver, criamos dois objetos dog usando a classe `Dog`. Ao inicializar `dog_1`, a string `Jack` e o número `3` são passados, o que define os atributos `name` e `age` para essa instância. E `dog_2` é inicializado com a string `Thatcher` e o número `5` como seu `name` e `age`, respectivamente.

Então, quando você chamar o método `.bark()` em `dog_1` e `dog_2`, poderá ver como ambas as saídas diferem e usar os atributos únicos `name` e `age` que você passou ao criar cada objeto.

Em resumo, a diferença entre uma classe e um objeto é que uma classe é o modelo ou o projeto e um objeto é o que é criado usando esse modelo.

Além disso, uma classe define quais dados e comportamentos o objeto deve ter e um objeto contém os dados reais e usa esse comportamento. Você escreve uma classe uma vez e pode criar muitos objetos a partir dela, cada um com dados diferentes.


# --questions--

## --text--

Qual é a saída deste código?

```python
class Dog:  
    def __init__(self, name):  
        self.name = name

    def bark(self):  
        print(f"{self.name} says Woof!")  

my_dog = Dog("Rex")
print(my_dog.name)
```

## --answers--

`Rex says Woof!`

### --feedback--

Veja o que está sendo impresso: está chamando um método ou acessando um atributo?

---

`name`

### --feedback--

Veja o que está sendo impresso: está chamando um método ou acessando um atributo?

---

`Rex`

---

Erro

### --feedback--

Veja o que está sendo impresso: está chamando um método ou acessando um atributo?

## --video-solution--

3

## --text--

Qual é o método especial que é chamado automaticamente quando um novo objeto é criado?

## --answers--

`__create_object__`

### --feedback--

Pense no que inicializa os atributos que um objeto terá.

---

`__init__`

---

`__new__`

### --feedback--

Pense no que inicializa os atributos que um objeto terá.

---

`__setup__`

### --feedback--

Pense no que inicializa os atributos que um objeto terá.

## --video-solution--

2

## --text--

O que é o blueprint ou modelo para criar objetos?

## --answers--

Uma variável

### --feedback--

Pense no que define a estrutura e o comportamento dos objetos criados a partir dele.

---

Uma função

### --feedback--

Pense no que define a estrutura e o comportamento dos objetos criados a partir dele.

---

Uma classe

---

Um loop

### --feedback--

Pense no que define a estrutura e o comportamento dos objetos criados a partir dele.

## --video-solution--

3

