---
id: 594810f028c0303b75339ad4
title: 自动换行
challengeType: 1
forumTopicId: 302344
dashedName: word-wrap
---

# --description--

即使在今天，使用比例字体和复杂布局，仍然存在需要在指定列处包装文本的情况。 基本任务是以简单的方式包装一段文本。

# --instructions--

编写一个函数，可以将此文本换行到任意数量的字符。请注意，输入文本已经包含换行符，你的函数应适当处理这些换行符。作为示例，换行到 80 个字符的文本应如下所示：

<pre>
Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX
algorithm. If your language provides this, you get easy extra credit, but you
must reference documentation indicating that the algorithm is something better
than a simple minimum length algorithm.
</pre>

# --hints--

`wrap` 应该是一个函数。

```js
assert.equal(typeof wrap, 'function');
```

`wrap` 应该返回一个字串。

```js
assert.equal(typeof wrap('abc', 10), 'string');
```

`wrap(text,80)` 应该返回 4 行。

```js
assert(wrapped80.split('\n').length === 4);
```

你的 `wrap` 函数应返回预期的文本。

```js
assert.equal(wrapped80.split('\n')[0], firstRow80);
```

`wrap(text,42)` 应返回 7 行。

```js
assert(wrapped42.split('\n').length === 7);
```

你的 `wrap` 函数应返回预期的文本。

```js
assert.equal(wrapped42.split('\n')[0], firstRow42);
```

# --seed--

## --after-user-code--

```js
const text =
`Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.
If your language provides this, you get easy extra credit,
but you ''must reference documentation'' indicating that the algorithm
is something better than a simple minimum length algorithm.`;

const wrapped80 = wrap(text, 80);
const wrapped42 = wrap(text, 42);

const firstRow80 =
    'Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX';

const firstRow42 = 'Wrap text using a more sophisticated';
```

## --seed-contents--

```js
function wrap(text, limit) {
  return text;
}
```

# --solutions--

```js
function wrap(text, limit) {
  const noNewlines = text.replace('\n', '');
  if (noNewlines.length > limit) {
    // find the last space within limit
    const edge = noNewlines.slice(0, limit).lastIndexOf(' ');
    if (edge > 0) {
      const line = noNewlines.slice(0, edge);
      const remainder = noNewlines.slice(edge + 1);
      return line + '\n' + wrap(remainder, limit);
    }
  }
  return text;
}
```
