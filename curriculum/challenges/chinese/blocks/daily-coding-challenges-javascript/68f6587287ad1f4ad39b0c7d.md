---
id: 68f6587287ad1f4ad39b0c7d
title: "挑战 91：单词查找"
challengeType: 28
dashedName: challenge-91
---

# --description--

给定一个由单个字母组成的矩阵（数组的数组）和一个要查找的单词，返回该单词在矩阵中的起始和结束索引。

- 给定的矩阵将填充所有小写字母（`a-z`）。
- 要查找的单词将在矩阵中且仅出现一次。
- 要查找的单词将始终沿以下某个方向的直线上排列：
  - 从左到右
  - 从右到左
  - 从上到下
  - 从底部到顶部

例如，给定矩阵：

```md
[
  ["a", "c", "t"],
  ["t", "a", "t"],
  ["c", "t", "c"]
]
```

而单词 `"cat"`，返回：

```md
[[0, 1], [2, 1]]
```

其中 `[0, 1]` 是 `"c"`（单词开头）的索引，`[2, 1]` 是 `"t"`（单词结尾）的索引。

# --hints--

`findWord([["a", "c", "t"], ["t", "a", "t"], ["c", "t", "c"]], "cat")` 应该返回 `[[0, 1], [2, 1]]`。

```js
assert.deepEqual(findWord([["a", "c", "t"], ["t", "a", "t"], ["c", "t", "c"]], "cat"), [[0, 1], [2, 1]]);
```

`findWord([["d", "o", "g"], ["o", "g", "d"], ["d", "g", "o"]], "dog")` 应该返回 `[[0, 0], [0, 2]]`。

```js
assert.deepEqual(findWord([["d", "o", "g"], ["o", "g", "d"], ["d", "g", "o"]], "dog"), [[0, 0], [0, 2]]);
```

`findWord([["h", "i", "s", "h"], ["i", "s", "f", "s"], ["f", "s", "i", "i"], ["s", "h", "i", "f"]], "fish")` 应该返回 `[[3, 3], [0, 3]]`。

```js
assert.deepEqual(findWord([["h", "i", "s", "h"], ["i", "s", "f", "s"], ["f", "s", "i", "i"], ["s", "h", "i", "f"]], "fish"), [[3, 3], [0, 3]]);
```

`findWord([["f", "x", "o", "x"], ["o", "x", "o", "f"], ["f", "o", "f", "x"], ["f", "x", "x", "o"]], "fox")` 应该返回 `[[1, 3], [1, 1]]`。

```js
assert.deepEqual(findWord([["f", "x", "o", "x"], ["o", "x", "o", "f"], ["f", "o", "f", "x"], ["f", "x", "x", "o"]], "fox"), [[1, 3], [1, 1]]);
```

# --seed--

## --seed-contents--

```js
function findWord(matrix, word) {

  return matrix;
}
```

# --solutions--

```js
function findWord(matrix, word) {
  const rows = matrix.length;
  const cols = matrix[0].length;
  const len = word.length;

  const directions = [
    [0, 1],
    [0, -1],
    [1, 0],
    [-1, 0]
  ];

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      for (let [dr, dc] of directions) {
        let match = true;
        for (let i = 0; i < len; i++) {
          const nr = r + dr * i;
          const nc = c + dc * i;
          if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || matrix[nr][nc] !== word[i]) {
            match = false;
            break;
          }
        }
        if (match) {
          return [
            [r, c],
            [r + dr * (len - 1), c + dc * (len - 1)]
          ];
        }
      }
    }
  }
}
```
