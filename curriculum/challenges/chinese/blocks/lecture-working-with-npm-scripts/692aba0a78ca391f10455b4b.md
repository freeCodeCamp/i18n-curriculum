---
id: 692aba0a78ca391f10455b4b
title: CommonJS 模块中的导入和导出如何工作？
challengeType: 19
dashedName: how-do-imports-and-exports-work-with-commonjs-modules
---

# --description--

在现代网页开发中，你可以将你的代码拆分成多个称为 "modules" 的文件。

你可以将一个模块视为一个自包含且可重用的代码块。

通过将模块导入到其他模块中，你可以重用它们的功能性，同时仍然将代码保存在不同的文件中，这样更易于维护，尤其适用于大型和复杂的网页应用。

在 Node.js 中，每个文件都被视为一个模块。

Node 有两种不同的系统用于处理模块：CommonJS 和 ES。

CommonJS 是 Node.js 中使用包的原始且默认方式。它同步地装载模块，这意味着它必须等待一个模块完全装载后，才能开始装载下一个模块或继续运行代码。

它仍然被广泛使用，但正逐渐被更新的 ES 语法取代。

CommonJS 使用 `require()` 函数导入模块，传入其相对路径作为参数。

例如，假设我们有一个名为 `math.js` 的模块，在其中定义基本的数学操作。

这里我们只使用一个乘法函数，以保持此示例简单且专注：

```js
function multiply(a, b) {
  return a * b;
}
```

我们如何在当前模块之外重用这个函数？默认情况下，在 Node.js 模块中定义的函数和变量是**私有的**——其他模块无法访问它们，除非我们显式地导出它们。有几种方法可以做到这一点。

一种常见的方法是为 `module.exports` 赋值。该对象表现模块在被其他地方导入时将返回的内容，从而使其他模块能够访问你选择公开的函数、变量或对象。

在此示例中，我们将一个带有 `multiply` 属性的对象赋值给 `module.exports`。该属性的值是对我们之前定义的 `multiply` 函数的引用。这将导出该函数，因此如果需要，我们可以从其他模块调用它。

```javascript
function multiply(a, b) {
  return a * b;
}

module.exports = {
  multiply: multiply
};
```

假设我们尝试将 `math.js` 模块导入到另一个模块中。我们调用 `require()` 函数，并将相对路径作为参数传入。然后，我们将 `require()` 返回的对象赋值给 `math` 变量。

```javascript
const math = require('./math');
```

让我们通过使用 `console.log()` 打印它，在控制台查看 `math` 的值：

```javascript
console.log(math);
```

这是输出。它是一个具有 `multiply` 属性且值为函数的对象：

```javascript
{ multiply: [Function: multiply] }
```

如果我们用 `math.multiply()` 调用这个函数，传入数字 `6` 和 `7` 作为参数，输出是 `42`。函数成功运行，且它在另一个文件中！所以我们的导入语句工作正常。

```javascript
const math = require('./math');

console.log(math.multiply(6, 7)); // 42
```

但还有其他方式可以导出函数、变量或对象。

例如，如果你只需要导出单个函数、变量或对象，你可以将它直接赋值为 `module.exports` 的值：

```javascript
function multiply(a, b) {
  return a * b;
}

module.exports = multiply;
```

如果你需要导出多个函数，只需将它们添加到 `module.exports` 对象中，用逗号分隔。

在这里，你可以看到导出的对象有两个属性：`subtract` 和 `multiply`。它们的值是对相应函数的引用，因此你将在导入 `math.js` 的任何模块中访问它们。

```javascript
function subtract(a, b) {
  return a - b;
}

function multiply(a, b) {
  return a * b;
}

module.exports = {
  subtract: subtract,
  multiply: multiply
};
```

当 `module.exports` 对象有多个属性时，你将有选项选择是导入全部还是单独导入属性。

在此示例中，我们导入了由 `math.js` 导出的整个对象，因此我们将可以访问 `subtract` 和 `multiply`。

```javascript
const math = require('./math');

console.log(math.subtract(6, 7));  // -1
console.log(math.multiply(6, 7));  // 42
```

如果我们只想导入 `multiply` ，只需在 `const` 关键字后用花括弧写出它的名字。基本上，你是在使用解构赋值语法从导出的对象中获取它的值。然后，我们可以在代码中直接通过它的名字来调用它：

```javascript
const { multiply } = require('./math');

console.log(multiply(6, 7));
```

这也适用于多个元素。你只需在括弧状的花括弧内用逗号分隔它们。这里，我们正在导入 `subtract` 和 `multiply` 两个函数：

```javascript
const { subtract, multiply } = require('./math');
```

默认情况下，Node.js 会将以下内容视为 CommonJS 模块：

* 带有 `.cjs` 扩展名的文件。
    
* 当最近的父级 `package.json` 文件包含顶层字段 `"type"` 且其值为 `"commonjs"` 时，具有 `.js` 扩展名的文件。
    
* 当最近的父级 `package.json` 文件不包含顶层字段 `"type"`，或者任何父级文件夹中都没有 `package.json` 时，具有 `.js` 扩展名或无扩展名的文件。
    
* 扩展名不是 `.mjs`、`.cjs`、`.json`、`.node` 或 `.js` 的文件。
    

虽然 ES Modules 正在逐步取代 CommonJS 模块，但理解它们对于处理现有 Node.js 代码库和许多 npm 包的开发者来说仍然至关重要。

# --questions--

## --text--

在 CommonJS 中使用哪个函数来导入模块？

## --answers--

`import()`

### --feedback--

考虑在 Node.js 环境中使用哪个关键字来引入外部代码。

---

`require()`

---

`export()`

### --feedback--

考虑在 Node.js 环境中使用哪个关键字来引入外部代码。

---

`include()`

### --feedback--

考虑在 Node.js 环境中使用哪个关键字来引入外部代码。

## --video-solution--

2

## --text--

以下哪项是 CommonJS 中导出模块的主要方式？

## --answers--

`export default`

### --feedback--

考虑哪个对象用于定义模块向其他文件提供的内容。

---

`module.exports`

---

`export const`

### --feedback--

考虑哪个对象用于定义模块向其他文件提供的内容。

---

`import from`

### --feedback--

考虑哪个对象用于定义模块向其他文件提供的内容。

## --video-solution--

2

## --text--

CommonJS 使用什么类型的装载？

## --answers--

异步的装载

### --feedback--

代码是否等待模块完全装载后再继续执行？

---

惰性装载

### --feedback--

代码是否等待模块完全装载后再继续执行？

---

同步的装载

---

条件式装载

### --feedback--

代码是否等待模块完全装载后再继续执行？

## --video-solution--

3
