---
id: 69247cd74caa633ccd7e3351
title: Node.js 核心模块回顾
challengeType: 31
dashedName: review-node-js-core-modules
---

# --description--

## Node.js 核心模块简介

- **Node.js 核心模块**：随 Node.js 预装的内置模块，提供文件操作、加密、操作系统交互等基本功能性。
- **标准模块**：无需单独安装；只要安装了 Node.js 即可使用。
- **导入语法**：使用 `require()` 将核心模块导入到你的应用中。

```javascript
const fs = require("fs");
const crypto = require("crypto");
const os = require("os");
```

## 文件系统（fs）模块

- **目的**：提供用于处理文件和文件夹的方法，包括打开、关闭、读取、写入和删除操作。
- **导入**：`const fs = require("fs");`
- **灵活性**：方法有三种形式：回调、promise 和同步的。

### 方法使用模式

- **异步的带回调**：默认行为，非阻塞。

```javascript
fs.writeFile("filePath", "content", "utf8", (err) => {
  if (err) throw err;
  console.log("File written to!");
});
```

- **基于 Promise**：现代应用的首选，使用 `async/await`。

```javascript
const fs = require("fs/promises");

async function writeToFile() {
  try {
    await fs.writeFile("article.md", "## Node fs Module");
    console.log("File written to!");
  } catch (err) {
    console.error(err);
  }
}
```

- **同步的**：阻塞操作，适用于简单脚本。

```javascript
try {
  fs.writeFileSync("article.md", "## Node fs Module", "utf8");
  console.log("File written to!");
} catch (err) {
  console.error(err);
}
```

### 核心文件操作

- **`writeFile()` 方法**：创建或覆盖具有指定内容的文件。

```javascript
await fs.writeFile("article.md", "## Node fs Module: The Complete Guide");
```

- **`appendFile()` 方法**：将内容添加到现有文件的末尾。

```javascript
await fs.appendFile("article.md", "\n\nIn this article, you will learn...");
```

- **`readFile()` 方法**：读取文件的内容。

```javascript
const content = await fs.readFile("article.md", "utf8");
console.log("File content:", content);
```

- **`unlink()` 方法**：从文件系统中删除一个文件。

```javascript
await fs.unlink("article.md");
console.log("File deleted successfully");
```

### 字符编码

- **UTF-8 编码**：指定 `"utf8"` 以将文件读取为文本字串。
- **缓冲区格式**：如果没有编码规格说明，文件将作为二进制缓冲区对象被读取。

```javascript
// Returns string
const textContent = await fs.readFile("file.txt", "utf8");

// Returns Buffer
const bufferContent = await fs.readFile("file.txt");
```

## 缓冲区模块

- **目的**：直接在内存中处理文件、图像和网络流的二进制数据。
- **导入**：`const { Buffer } = require("buffer");`
- **使用分支**：文件 I/O、TCP 流、图像处理和二进制数据操作。

### 缓冲区创建

- **`Buffer.from()` 方法**：从字串、数组或其他数据创建缓冲区。

```javascript
// From string
const myStrBuffer = Buffer.from("freeCodeCamp");
console.log(myStrBuffer); // <Buffer 66 72 65 65 43 6f 64 65 43 61 6d 70>

// From array of numbers
const myNumBuffer = Buffer.from([70, 82, 69, 69, 67, 79, 68, 69, 67, 65, 77, 80]);
```

- **`Buffer.alloc()` 方法**：创建指定大小且填充为零的缓冲区。

```javascript
const someBuffer = Buffer.alloc(10);
console.log(someBuffer); // <Buffer 00 00 00 00 00 00 00 00 00 00>
```

### 缓冲区操作

- **类数组访问**：使用索引表示法访问单个缓冲区元素。

```javascript
console.log(myStrBuffer[0]); // 102 (byte value for 'f')
```

- **`toString()` 方法**：将缓冲区转换为可读字串。

```javascript
console.log(myStrBuffer.toString()); // "freeCodeCamp"
```

- **`Buffer.write()` 方法**：将数据写入已分配的缓冲区。

```javascript
someBuffer.write("Hello fCC");
console.log(someBuffer.toString()); // "Hello fCC"
```

- **`Buffer.byteLength()` 方法**：返回保存字串所需的字节数。

```javascript
console.log(Buffer.byteLength("Hello freeCodeCamp")); // 18
```

### 附加缓冲区方法

- **`Buffer.isBuffer()`**：查看一个对象是否是缓冲区。
- **`Buffer.compare()`**：比较两个缓冲区并返回排序顺序。
- **`Buffer.concat()`**：将多个缓冲区合并为一个。

## 加密模块

- **目的**：提供加密功能性，包括哈希、加密、解密和数字签名。
- **导入**：`const crypto = require("crypto");`
- **安全性注意**：在生产认证中使用经过充分测试的库，如 `bcrypt` 或 `jsonwebtoken`。

### 哈希方法

- **`createHash()` 方法**：使用 SHA256、SHA512 或 MD5 等算法创建单向哈希。

```javascript
const hashedPassword = crypto
  .createHash("sha256")
  .update("myPassword123")
  .digest("hex");

console.log("createHash result:", hashedPassword);
```

- **`createHmac()` 方法**：使用密钥创建用于认证和数据完整性的哈希。

```javascript
const hashedMessage = crypto
  .createHmac("sha256", "secret-key")
  .update("Hello World")
  .digest("hex");
```

### 加密和解密

- **`createCipheriv()` 和 `createDecipheriv()` 方法**：使用算法、密钥和初始化向量加密和解密数据。

```javascript
const key = Buffer.from("12345678901234567890123456789012"); // 32 bytes for AES-256
const iv = Buffer.from("1234567890123456"); // 16 bytes for AES

// Encryption
const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
let encrypted = cipher.update("Hello campers!", "utf8", "hex");
encrypted += cipher.final("hex");

// Decryption
const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
let decrypted = decipher.update(encrypted, "hex", "utf8");
decrypted += decipher.final("utf8");
```

### 随机值生成

- **`randomBytes()` 方法**：生成加密安全的随机字节。

```javascript
console.log("Random Bytes:", crypto.randomBytes(16).toString("hex"));
// Output: a6154ef5a296fa176ad0f332bd94d712
```

- **`randomInt()` 方法**：在指定范围内生成安全的随机整数。

```javascript
console.log("Random Int:", crypto.randomInt(0, 100)); // Random number 0-99
```

### 密钥管理

- **`createSecretKey()` 方法**：从未经处理的字节创建加密密钥对象。

```javascript
const secret = crypto.createSecretKey(crypto.randomBytes(32));
console.log(secret.export().toString('hex'));
```

### 数字签名

- **`sign()` 和 `verify()` 方法**：使用私钥/公钥点对创建和验证数字签名。
- **使用分支**：证明数据的真实性和完整性。

### 附加加密方法

- **`createPublicKey()` 和 `createPrivateKey()`**：处理外部生成的密钥。
- **`createDiffieHellman()`**：启用安全的共享密钥生成。
- **`Certificate()`**：处理 HTTPS 证书操作。

## 操作系统模块

- **目的**：提供与操作系统相关的实用函数，用于系统信息和跨平台兼容性。
- **导入**：`const os = require("os");`
- **使用分支**：系统监控、跨平台脚本、硬件信息。

### 系统信息方法

- **`platform()` 方法**：返回操作系统平台。

```javascript
console.log(os.platform()); // 'darwin', 'win32', 'linux', etc.

// Cross-platform usage
if (os.platform() === 'win32') {
  // Windows-specific code
} else {
  // Unix-like systems
}
```

- **`arch()` 方法**：返回 CPU 架构。

```javascript
console.log(os.arch()); // 'arm64', 'x64', 'arm', 'ia32', etc.
```

- **`type()` 方法**：返回官方操作系统名称。

```javascript
console.log(os.type()); // 'Darwin', 'Linux', 'Windows_NT'
```

### 版本简介

- **`release()` 方法**：显示操作系统核心版本。

```javascript
console.log(os.release()); // '25.0.0'
```

- **`version()` 方法**：返回详细的操作系统版本信息。

```javascript
console.log(os.version());
// Darwin Kernel Version 25.0.0: Wed Sep 17 21:41:39 PDT 2025
```

### 硬件简介

- **`cpus()` 方法**：返回一个 CPU 核心信息的数组。

```javascript
console.log(os.cpus()); // Array of CPU core objects with model, speed, times
```

- **`uptime()` 方法**：返回系统运行时间（秒）。

```javascript
console.log(os.uptime()); // 23047 (seconds since system boot)
```

### 内存简介

- **`totalmem()` 方法**：返回系统总内存的字节数。
- **`freemem()` 方法**：返回可用系统内存的字节数。

## 最佳实践

### 性能考虑

- **避免同步的方法**：在生产应用中使用异步的方法以防止阻塞。
- **优先使用 Promise**：使用基于 Promise 的 API 的 `async/await` 以获得更简洁、可维护的代码。
- **误差处理**：始终使用 try-catch 块或误差回调实现适当的误差处理。

### 安全性指南

- **Crypto 模块**：使用已建立的库进行认证，而不是创建自定义的加密方案。
- **输入验证**：验证 `file` 路径和 `user` 输入以防止安全性漏洞。
- **密钥管理**：安全地保存加密密钥，绝不将它们硬编码在源代码中。

### 跨平台开发

- **OS 模块使用**：使用 OS 模块方法以实现跨平台兼容性。
- **路径处理**：使用 `path` 模块进行跨平台文件路径操作。
- **环境变量**：查看特定平台的环境变量和配置。

## 常见使用分支

### 文件操作

- 配置文件管理
- 日志文件的创建和维护
- 数据导出/导入功能性
- 模板处理

### 数据安全性

- 用于用户认证的密码哈希处理
- 敏感信息的数据加密
- 会话的随机令牌生成
- 数字签名验证

### 系统集成

- 跨平台应用部署
- 系统资源监控
- 硬件兼容性查看
- 基于系统能力的性能优化

# --assignment--

查看 Node.js 核心模块的主题和概念。
