---
id: 5cd9a70215d3c4e65518328f
title: Construye una Cuenta Regresiva
challengeType: 26
dashedName: build-a-countdown
---

# --description--

En este laboratorio, construirás una función `countdown` que toma un número inicial y genera una lista de cuenta regresiva.

Cuando llamas a `countdown(n)`, debe devolver un arreglo que comience en `n` y cuente hacia atrás de `1` en `1` hasta llegar a `1`.

Por ejemplo:

- `countdown(5)` deberia retornar `[5, 4, 3, 2, 1]`
- `countdown(1)` debería devolver `[1]`

Si el número inicial es menor que `1`, no hay nada que contar hacia atrás, así que devuelve un arreglo vacío:

- `countdown(0)` debería devolver `[]`
- `countdown(-3)` debería devolver `[]`

Para completar el laboratorio, debes construir el resultado usando recursión y no debes usar bucles (`for`, `while`) ni métodos de iteración de arreglos (`forEach`, `map`, `filter`, `reduce`). Cada llamada debe producir su propio arreglo de resultados (no uses variables globales para almacenar la cuenta regresiva).

**Objetivo:** Cumplir con las historias de usuario a continuación y pasar todas las pruebas para completar el laboratorio.

**Historias de usuario:**

1. Debes crear una función llamada `countdown`.
2. La función `countdown` debe tomar un solo argumento `n` (un número).
3. Si `n` es menor que `1`, `countdown` debe devolver un arreglo vacío.
4. De lo contrario, `countdown` debería devolver un arreglo que contenga los enteros desde `n` hasta `1` en orden descendente.
5. Debes usar recursión (la función debe llamarse a sí misma) y no debes usar bucles de ningún tipo (`for`, `while` o métodos de orden superior como `forEach`, `map`, `filter`, `reduce`).
6. Cada llamada recursiva debe usar un valor más pequeño que la llamada anterior (por ejemplo, `n - 1`) para que la función alcance su caso base.
7. La solución no debe usar variables globales para almacenar o guardar en caché el arreglo de resultados.
8. Llamar a `countdown` varias veces con diferentes entradas siempre debería devolver el resultado correcto e independiente.

# --hints--

Debes tener una función llamada `countdown`.

```js
assert.isFunction(countdown);
```

`countdown(-1)` debería retornar un arreglo vacío.

```js
assert.isEmpty(countdown(-1));
```

`countdown(10)` debería retornar `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(10), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
```

`countdown(5)` deberia retornar `[5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

Tu código no debe depender de ningún tipo de ciclos (`for`, `while`) o funciones de orden alto tales como `forEach`, `map`, `filter`, y `reduce`).

```js
assert(
  !__helpers.removeJSComments(code).match(/for|while|forEach|map|filter|reduce/g)
);
```

Debes usar recursión para resolver este problema.

```js
assert(
  countdown.toString().match(/countdown\s*\(.+\)/)
);
```

No debes emplear variables globales para almacenar el array en caché.

```js
countdown(1)
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

# --seed--

## --seed-contents--

```js

```

# --solutions--

```js
function countdown(n) {
  if (n < 1) {
    return [];
  }

  return [n, ...countdown(n - 1)];
}
```
