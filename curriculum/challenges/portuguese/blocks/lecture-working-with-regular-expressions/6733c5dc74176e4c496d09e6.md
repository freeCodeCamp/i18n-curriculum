---
id: 6733c5dc74176e4c496d09e6
title: O que são asserções Lookahead e Lookbehind e como elas funcionam?
challengeType: 19
dashedName: what-are-lookaheads-and-lookbehind-assertions-and-how-do-they-work
---

# --description--

Vamos aprender sobre asserções lookahead e lookbehind em expressões regulares.

Asserções lookahead e lookbehind permitem que você combine padrões específicos com base na presença ou ausência de padrões ao redor. Existem quatro variações dessas asserções.

Primeiro é a asserção de lookahead positivo. Esta asserção corresponderá a um padrão quando o padrão for seguido por outro padrão.

Para construir um lookahead positivo, você precisa começar com o padrão que deseja corresponder. Então, use parênteses para envolver o padrão que você quer usar como sua condição. Após o parêntese de abertura, use `?=` para definir esse padrão como um lookahead positivo.

Este padrão só corresponderá à palavra `free` se ela for seguida por `code`:

```js
const regex = /free(?=code)/i;
```

Vamos testar o comportamento do nosso padrão:

```js
const regex = /free(?=code)/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

Note como apenas a string onde `free` é imediatamente seguida por `code` passa no teste.

Mas e se você quiser corresponder à presença de `free` quando ele NÃO for seguido por `code`? Você pode transformar seu positive lookahead em um negative lookahead para inverter o comportamento. Para fazer isso, altere seu `?=` para `?!`:

```js
const regex = /free(?!code)/i;
```

Vamos testar isso com nossas mesmas strings:

```js
const regex = /free(?!code)/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

Como esperado, os resultados estão invertidos. A única string que falha é a primeira string, onde `free` é imediatamente seguida por `code`.

Asserções lookbehind funcionam de forma semelhante às asserções lookahead, exceto que, em vez de corresponder condicionalmente com base em um padrão seguinte, elas correspondem condicionalmente com base em um padrão precedente. Vamos dar uma olhada em um positive lookbehind.

Um lookbehind positivo é denotado com `?<=` em vez de `?=`. Vamos fazer nossa expressão regular corresponder a `code` quando for precedida por `free`:

```js
const regex = /(?<=free)code/i;
```

Assim como com nosso lookahead positivo, nosso lookbehind positivo corresponde à primeira string porque `code` é imediatamente precedido por `free`:

```js
const regex = /(?<=free)code/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

Para corresponder a `code` quando ele NÃO é precedido por `free`, podemos usar um lookbehind negativo. Um lookbehind negativo é definido substituindo `?<=` por `?<!`:

```js
const regex = /(?<!free)code/i;
```

Isto corresponderia a qualquer ocorrência de `code` que NÃO seja imediatamente precedida por `free`.

```js
const regex = /(?<!free)code/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

Lembre-se de que `Regex.prototype.test` apenas confirma se uma string corresponde à expressão regular. Vamos usar nosso lookbehind negativo com `String.prototype.match` para ver como as assertions afetam isso:

```js
const regex = /(?<!free)code/i;
console.log("freeCodeCamp".match(regex)); // null
console.log("free code camp".match(regex)); // ['code', index: 5, input: 'free code camp', groups: undefined]
console.log(
  "I need someone for free to write code for me".match(regex)
); // ['code', index: 33, input: 'I need someone for free to write code for me', groups: undefined]
```

Note como, mesmo que nossa expressão regular use um lookbehind para verificar a presença de `free`, ela não corresponde a `free`. O único texto incluído na correspondência é `code`.

Lookaheads e lookbehinds são incrivelmente úteis para corresponder condicionalmente ao texto sem impactar o valor retornado da sua correspondência.

# --questions--

## --text--

Qual é a sintaxe para uma asserção de lookahead positivo em uma expressão regular?

## --answers--

`(?=pattern)`

---

`(?<=pattern)`

### --feedback--

A lição descreve como construir um lookahead positivo usando uma sintaxe específica.

---

`(?!pattern)`

### --feedback--

A lição descreve como construir um lookahead positivo usando uma sintaxe específica.

---

`(?<!pattern)`

### --feedback--

A lição descreve como construir um lookahead positivo usando uma sintaxe específica.

## --video-solution--

1

## --text--

Qual asserção você usaria para corresponder a uma palavra somente se ela NÃO for seguida por um padrão específico?

## --answers--

Lookahead positivo.

### --feedback--

Pense em qual asserção "inverte" o comportamento de um lookahead positivo.

---

Lookahead negativo.

---

Lookbehind positivo.

### --feedback--

Pense em qual asserção "inverte" o comportamento de um lookahead positivo.

---

Lookbehind negativo.

### --feedback--

Pense em qual asserção "inverte" o comportamento de um lookahead positivo.

## --video-solution--

2

## --text--

Ao usar uma asserção lookbehind com `String.prototype.match`, qual parte da string é realmente incluída no resultado da correspondência?

## --answers--

A string inteira.

### --feedback--

A lição demonstra isso com um exemplo usando um negative lookbehind.

---

O padrão na asserção lookbehind.

### --feedback--

A lição demonstra isso com um exemplo usando um negative lookbehind.

---

O padrão após a asserção lookbehind.

---

Tanto o padrão lookbehind quanto o padrão após ele.

### --feedback--

A lição demonstra isso com um exemplo usando um negative lookbehind.

## --video-solution--

3
