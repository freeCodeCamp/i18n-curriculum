---
id: 6895d06b5968736797c408e5
title: 堆疊和佇列如何運作？
challengeType: 19
dashedName: how-do-stacks-and-queues-work
---

# --description--

堆疊和佇列是電腦科學中常用的資料結構。

它們是線性資料結構，遵循特定規則來添加和移除元素。

## 堆疊

讓我們從 **堆疊** 開始。

**堆疊** 是一種後進先出（LIFO）的資料結構。

這表示最後一個被添加到堆疊的元素是第一個被移除的。

堆疊有兩個端點，我們稱之為頂端和底端。

元素會從堆疊頂端被添加和移除。

你可以將堆疊想像成一堆盤子，你只能將盤子放在堆疊的頂端，並從堆疊的頂端取出盤子。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-1.png" alt="stack data structure visualization">

在這個背景關係中，這些添加和移除元素的操作有特殊名稱。

將元素添加到堆疊稱為「push」操作行為。當我們將元素添加到堆疊頂端時，我們說我們「push」該元素到堆疊上。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-2.png" alt="stack push operation visualization">

從堆疊中移除元素稱為「pop」操作。當我們從堆疊頂端移除元素時，我們說我們從堆疊中「pop」該元素。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-3.png" alt="stack pop operation visualization">

你可以看到我們並沒有在堆疊底部真正執行任何操作，但我們將它保留在那裡作為引用。

`push` 和 `pop` 操作的時間複雜度通常是 `O(1)`，屬於常數時間複雜度。

當你將元素推入 `stack` 時，該元素會被簡單地添加到頂部。

當你從堆疊中彈出一個元素時，頂端的元素會被移除。

因此，執行這些操作所需的時間無論堆疊的大小如何都保持不變。

`push` 和 `pop` 操作的空間複雜度通常是常數 `O(1)`。這表示執行這些操作所需的記憶體量不會隨著堆疊大小而改變。

## 佇列

現在你對堆疊有更多了解了，讓我們來學習 **佇列**。

佇列是一種先進先出（FIFO）的線性資料結構。這表示最先加入佇列的元素會是最先被移除的元素。

佇列有兩個端點：前端和後端。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-4.webp" alt="queue data structure visualization">

元素會被添加到佇列的尾端，並且從佇列的前端移除。

你可以將佇列想像成一排人在超市排隊結帳。排在最前面的人是第一個去收銀台結帳的，而新的人會加入排隊的最後面。

在佇列的背景關係中，添加和移除元素的操作有特殊名稱。

將元素添加到佇列的尾端稱為「enqueue」操作。

在一次入佇列操作中，新的元素會被添加到佇列的末端，成為隊伍的最後一個。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-5.png" alt="queue enqueue operation visualization">

從佇列前端移除元素的操作行為稱為「dequeue」操作。  
  
在 `dequeue` 操作中，佇列前端的元素會被移除，下一個排隊的元素會成為新的前端。

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-6.png" alt="queue dequeue operation visualization">

`enqueue` 和 `dequeue` 操作的時間複雜度是 `O(1)`，常數時間。執行這些操作所需的時間保持不變，無論佇列的大小為何。

`enqueue` 和 `dequeue` 操作的空間複雜度通常是常數 `O(1)`。這表示執行這些操作所需的記憶體量不會隨著佇列大小而改變。

堆疊和佇列是用於計算機科學中組織和管理元素的資料結構。理解它們對於在各種程式設計應用中建造高效演算法至關重要。

# --questions--

## --text--

堆疊和佇列之間的主要差異是什麼？

## --answers--

堆疊是 LIFO，而佇列是 FIFO。

---

堆疊是 FIFO，而佇列是 LIFO。

### --feedback--

思考元素被添加和移除自每個資料結構的順序。

---

堆疊用於儲存資料，而佇列用於處理資料。

### --feedback--

思考元素被添加和移除自每個資料結構的順序。

---

堆疊和佇列之間沒有差別。

### --feedback--

思考元素被添加和移除自每個資料結構的順序。

## --video-solution--

1

## --text--

哪一個操作用於將元素添加到堆疊？

## --answers--

`push`

---

`pop`

### --feedback--

想像一個盤子堆疊的類比。

---

`enqueue`

### --feedback--

想像一個盤子堆疊的類比。

---

`dequeue`

### --feedback--

想像一個盤子堆疊的類比。

## --video-solution--

1

## --text--

哪一個操作用於從佇列中移除元素？

## --answers--

`push`

### --feedback--

想像一排人在排隊的類比。

---

`pop`

### --feedback--

想像一排人在排隊的類比。

---

`enqueue`

### --feedback--

想像一排人在排隊的類比。

---

`dequeue`

## --video-solution--

4

