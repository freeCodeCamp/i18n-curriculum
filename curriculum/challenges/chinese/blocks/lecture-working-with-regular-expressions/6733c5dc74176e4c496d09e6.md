---
id: 6733c5dc74176e4c496d09e6
title: 什么是 Lookahead 和 Lookbehind 断言，它们如何工作？
challengeType: 19
dashedName: what-are-lookaheads-and-lookbehind-assertions-and-how-do-they-work
---

# --interactive--

前瞻和后顾断言允许你根据周围模式的存在或缺失来匹配特定的模式。这些断言有四种变体。

首先是正向前瞻断言。当一个模式后面跟着另一个模式时，该断言将匹配该模式。

要构造一个正向前瞻，你需要从你想要匹配的 `pattern` 开始。然后，使用括号将你想用作条件的 `pattern` 包裹起来。在开括号后，使用 `?=` 来定义该 `pattern` 为正向前瞻。

此模式仅当 `free` 后面跟着 `code` 时才会匹配该单词：

```js
const regex = /free(?=code)/i;
```

让我们测试我们的模式的行为：

:::interactive_editor

```js
const regex = /free(?=code)/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

:::

注意只有 `free` 紧跟 `code` 的字串通过测试。

但是如果你想匹配 `free` 出现时后面**不**跟着 `code` 呢？你可以将你的正向前瞻转换为负向前瞻以反转行为。为此，将你的 `?=` 改为 `?!`：

```js
const regex = /free(?!code)/i;
```

让我们用相同的字串来测试这个。

:::interactive_editor

```js
const regex = /free(?!code)/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

:::

如预期，结果是反转的。唯一失败的字串是第一个字串，其中 `free` 紧跟着 `code`。

回顾断言的功能类似于前瞻断言，不同之处在于它们不是基于后续的模式进行条件式匹配，而是基于前述的模式进行条件式匹配。让我们来看一个正向回顾。

正向后行断言用 `?<=` 表示，而不是 `?=`。让我们的正则表达式匹配前面带有 `free` 的 `code`：

```js
const regex = /(?<=free)code/i;
```

就像我们的正向先行断言一样，我们的正向后行断言匹配第一个字串，因为 `code` 紧跟在 `free` 之前：

:::interactive_editor

```js
const regex = /(?<=free)code/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

:::

要匹配未被 `free` 之前的 `code`，我们可以使用负向回顾。负向回顾是通过将 `?<=` 替换为 `?<!` 来定义的：

```js
const regex = /(?<!free)code/i;
```

这将匹配任何未紧跟 `free` 的 `code` 出现：

:::interactive_editor

```js
const regex = /(?<!free)code/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

:::

请记住，`Regex.prototype.test` 仅确认字串是否匹配正则表达式。让我们使用带有 `String.prototype.match` 的负向后行断言来看看断言如何影响匹配：

```js
const regex = /(?<!free)code/i;
console.log("freeCodeCamp".match(regex)); // null
console.log("free code camp".match(regex)); // ['code', index: 5, input: 'free code camp', groups: undefined]
console.log(
  "I need someone for free to write code for me".match(regex)
); // ['code', index: 33, input: 'I need someone for free to write code for me', groups: undefined]
```

注意，即使我们的正则表达式使用了后行断言来查看 `free` 的存在，它也不会匹配 `free`。匹配中唯一包含的文本是 `code`。

前瞻和后顾对于在不影响匹配返回值的情况下条件式匹配文本非常有用。

# --questions--

## --text--

正则表达式中正向先行断言的语法是什么？

## --answers--

`(?=pattern)`

---

`(?<=pattern)`

### --feedback--

本课描述了如何使用特定的语法构造正向先行断言。

---

`(?!pattern)`

### --feedback--

本课描述了如何使用特定的语法构造正向先行断言。

---

`(?<!pattern)`

### --feedback--

本课描述了如何使用特定的语法构造正向先行断言。

## --video-solution--

1

## --text--

你会使用哪个断言来匹配仅当其后不跟特定模式的单词？

## --answers--

正向先行断言。

### --feedback--

考虑哪个断言“反转”正向先行断言的行为。

---

负向前瞻。

---

正向后行断言。

### --feedback--

考虑哪个断言“反转”正向先行断言的行为。

---

负向后行断言。

### --feedback--

考虑哪个断言“反转”正向先行断言的行为。

## --video-solution--

2

## --text--

当使用带有 `String.prototype.match` 的回顾断言时，字串的哪一部分实际上包含在匹配结果中？

## --answers--

整个字串。

### --feedback--

本课通过一个使用负向后行断言的示例来演示这一点。

---

后行断言中的模式。

### --feedback--

本课通过一个使用负向后行断言的示例来演示这一点。

---

断言后面的模式。

---

前瞻模式和其后的模式。

### --feedback--

本课通过一个使用负向后行断言的示例来演示这一点。

## --video-solution--

3
