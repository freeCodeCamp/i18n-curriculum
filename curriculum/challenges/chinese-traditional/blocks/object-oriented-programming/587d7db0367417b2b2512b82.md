---
id: 587d7db0367417b2b2512b82
title: 了解原型串鏈
challengeType: 1
forumTopicId: 301329
dashedName: understand-the-prototype-chain
---

# --description--

JavaScript 中所有物件（有少數例外）都有一個 `prototype`。此外，物件的 `prototype` 本身也是一個物件。

```js
function Bird(name) {
  this.name = name;
}

typeof Bird.prototype;
```

因為 `prototype` 是一個物件，`prototype` 可以有它自己的 `prototype`！在這種情況下，`Bird.prototype` 的 `prototype` 是 `Object.prototype`：

```js
Object.prototype.isPrototypeOf(Bird.prototype);
```

這有什麼用處？你可能還記得之前挑戰中提到的 `hasOwnProperty` 方法：

```js
let duck = new Bird("Donald");
duck.hasOwnProperty("name");
```

`hasOwnProperty` 方法定義在 `Object.prototype` 中，`Bird.prototype` 可以存取它，而 `duck` 又可以存取 `Bird.prototype`。這是 `prototype` 串鏈的範例。在這個 `prototype` 串鏈中，`Bird` 是 `duck` 的超型別，而 `duck` 是子型別。`Object` 是 `Bird` 和 `duck` 的超型別。`Object` 是 JavaScript 中所有物件的超型別。因此，任何物件都可以使用 `hasOwnProperty` 方法。

# --instructions--

修改程式碼以顯示正確的 prototype 串鏈。

# --hints--

你的程式碼應該顯示 `Object.prototype` 是 `Dog.prototype` 的原型。

```js
assert(/Object\.prototype\.isPrototypeOf/.test(__helpers.removeJSComments(code)));
```

# --seed--

## --seed-contents--

```js
function Dog(name) {
  this.name = name;
}

let beagle = new Dog("Snoopy");

Dog.prototype.isPrototypeOf(beagle);  // yields true

// Fix the code below so that it evaluates to true
???.isPrototypeOf(Dog.prototype);
```

# --solutions--

```js
function Dog(name) {
  this.name = name;
}
let beagle = new Dog("Snoopy");
Dog.prototype.isPrototypeOf(beagle);
Object.prototype.isPrototypeOf(Dog.prototype);
```
