---
id: 67d1ebb595f4f619c0e35d1a
title: '¿Cómo actualizas objetos en el estado?'
challengeType: 11
videoId: BwHJrBW-m0M
dashedName: how-do-you-update-objects-in-state
---

# --description--

Mira el video o lee la transcripción y responde las preguntas a continuación.

# --transcript--

¿Cómo actualizas objetos en el estado?

Actualizar objetos en el estado en React puede ser complicado si estás acostumbrado a cambiar directamente los valores de propiedad del objeto.

React trata el estado como inmutable, lo que significa que no deberías modificarlo directamente.

Veamos qué sucede si intentas cambiar objetos en el estado de React directamente y luego profundicemos en la manera correcta de hacerlo.

Digamos que tienes un objeto en el estado de tu componente que representa el perfil de un usuario, y deseas que el usuario actualice su edad:

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({
    name: "John Doe",
    age: 31,
    city: "LA",
  });

  // Change user age directly
  const handleAgeChange = (e) => {
    user.age = e.target.value;
    console.log(user);
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" value={user.age} onChange={handleAgeChange} />
    </div>
  );
}

export default Profile;
```

Este código no funcionará porque estás modificando directamente la propiedad `user.age`.

Aunque `console.log(user)` mostrará la nueva edad en la consola, React no volverá a renderizar el componente para mostrarlo en la interfaz de usuario porque no usaste la función set, `setUser`.

Para actualizar un objeto directamente en el estado, debes usar la función set para crear un nuevo objeto con el valor actualizado. Por ejemplo:

```js
const handleAgeChange = (e) => {
  setUser({
    age: e.target.value,
  });
};
```

Eso funciona. Pero si miras la página ahora, la edad del usuario se actualiza, pero los valores de nombre y ciudad se pierden.

Esto es porque el nuevo objeto que pasaste a la función set solo contenía una clave/valor para `edad`.

Para evitar que esto ocurra, puedes copiar primero el objeto existente y luego actualizar solo la propiedad que deseas actualizar, en este caso, `edad`.

Para hacer esto, puedes pasar una función especial llamada función actualizadora a tu función set, `setUser`. La función actualizadora toma el estado pendiente como argumento, aquí llamado `prevUser`, y debe devolver el próximo estado:

```js
const handleAgeChange = (e) => {
  setUser((prevUser) => {
    const updatedUser = { ...prevUser, age: e.target.value };
    console.log('Previous State:', prevUser);
    console.log('Updated State:', updatedUser);
    return updatedUser;
  });
};
```

Como puedes ver, creamos un nuevo objeto usuario llamado `updatedUser` usando la sintaxis de propagación para copiar el objeto de usuario pendiente, `...prevUser`. Luego actualizamos la edad basándonos en la entrada del formulario y devolvemos `updatedUser` al final de la función como el próximo estado.

Ahora tu proyecto funciona como se esperaba, y las actualizaciones en la entrada de edad no afectan el nombre o ciudad del usuario. También puedes ver los estados anteriores y actualizados en la consola.

Esta es la forma ideal de actualizar un objeto en el estado, especialmente cuando no estás actualizando todas las propiedades.

Para actualizar las propiedades restantes `nombre` y `ciudad`, puedes escribirlas como funciones de configuración separadas y conectarlas a sus respectivas entradas:

```js
const handleNameChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    name: e.target.value,
  }));
};

const handleCityChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    city: e.target.value,
  }));
};
```

O puedes combinarlas en una sola función set como esta:

```js
const handleChange = (e) => {
  const { name, value } = e.target;
  setUser((prevUser) => ({
    ...prevUser,
    [name]: value,
  }));
};
```

Para que esto funcione, cada campo de entrada debe tener un atributo `nombre`.

Aquí está el código completo ahora:

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

# --questions--

## --text--

¿Cómo trata React el estado en un componente?

## --answers--

Como mutable, permitiendo la modificación directa.

### --feedback--

Piensa en el enfoque de React para garantizar cambios de estado predecibles.

---

Como inmutable, lo que significa que no debe ser modificado directamente.

---

Como una variable global accesible en todos los componentes.

### --feedback--

Piensa en el enfoque de React para garantizar cambios de estado predecibles.

---

Como una variable temporal que se restablece en cada renderizado.

### --feedback--

Piensa en el enfoque de React para garantizar cambios de estado predecibles.

## --video-solution--

2

## --text--

¿Cómo deberías actualizar un objeto almacenado en el estado de React?

## --answers--

Usa la función set para crear un nuevo objeto.

---

Modifica el objeto directamente en el estado.

### --feedback--

React trata el estado como inmutable, así que evita la modificación directa.

---

Usa `Object.assign()` sin llamar al set.

### --feedback--

React trata el estado como inmutable, así que evita la modificación directa.

---

Usa el método `push()` para añadir propiedades al objeto.

### --feedback--

React trata el estado como inmutable, así que evita la modificación directa.

## --video-solution--

1

## --text--

¿Qué es la función set en este código?

```js
const [user, setUser] = useState({
   name: 'John Doe',
   age: 31,
   city: 'LA',
 });
```

## --answers--

`user`

### --feedback--

La función set actualiza la variable `estado`.

---

`useState`

### --feedback--

La función set actualiza la variable `estado`.

---

`age`

### --feedback--

La función set actualiza la variable `estado`.

---

`setUser`

## --video-solution--

4
