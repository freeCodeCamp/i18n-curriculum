---
id: 672a54f29d783890d1f94740
title: ¿Cuáles son algunos estados comunes de ARIA utilizados en elementos de control personalizables?
challengeType: 19
dashedName: what-are-some-common-aria-states-used-on-custom-control-elements
---

# --interactive--

Los elementos de control de formularios semánticos como `input`, `select`, `textarea`, `button` y `fieldset` tienen estados integrados que se transmiten a tecnologías de asistencia.

Por ejemplo, puedes utilizar el atributo `disabled` para desactivar un botón o el atributo `checked` para indicar que una casilla está marcada.

Pero si estás creando un elemento de control personalizado, necesitas usar atributos ARIA para comunicar el estado del control a las tecnologías de asistencia.

En esta lección, hablaremos de algunos estados ARIA comunes que puedes usar en elementos de control personalizados.

El primer estado ARIA que discutiremos es `aria-selected`. Este estado se usa para indicar que un elemento está seleccionado. Puedes usar este estado en controles personalizados como una interfaz con pestañas, un cuadro de lista o una cuadrícula.

Aquí tienes un ejemplo de cómo puedes usar `aria-selected` en un control de pestaña personalizado:

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<div role="tablist">
  <button role="tab" aria-selected="true">Tab 1</button>
  <button role="tab" aria-selected="false">Tab 2</button>
  <button role="tab" aria-selected="false">Tab 3</button>
</div>
<script src="index.js"></script>
```

```css
[role="tablist"] {
  display: flex;
  border-bottom: 2px solid #ddd;
  gap: 0.25rem;
  font-family: system-ui, sans-serif;
}

[role="tab"] {
  appearance: none;
  border: none;
  background: none;
  padding: 0.5rem 1rem;
  cursor: pointer;
  font-size: 1rem;
  color: #444;
  border-radius: 4px 4px 0 0;
  transition: background-color 0.2s, color 0.2s;
}

[role="tab"]:hover {
  background-color: #f3f3f3;
}

[role="tab"][aria-selected="true"] {
  background-color: #fff;
  color: #0078d4;
  border: 2px solid #0078d4;
  border-bottom: 2px solid #fff; 
  font-weight: 600;
  position: relative;
  z-index: 1;
}

[role="tab"]:focus {
  outline: 2px solid #0078d4;
  outline-offset: 2px;
}

```

```js
document.addEventListener("click", (event) => {
  const clickedTab = event.target.closest('[role="tab"]');
  if (!clickedTab) return;

  const tablist = clickedTab.closest('[role="tablist"]');
  const tabs = tablist.querySelectorAll('[role="tab"]');

  tabs.forEach((tab) => {
    const isSelected = tab === clickedTab;
    tab.setAttribute("aria-selected", isSelected);
    tab.tabIndex = isSelected ? 0 : -1;
  });
});

document.addEventListener("keydown", (event) => {
  const activeTab = document.activeElement;
  if (activeTab.getAttribute("role") !== "tab") return;

  const tablist = activeTab.closest('[role="tablist"]');
  const tabs = Array.from(tablist.querySelectorAll('[role="tab"]'));
  const index = tabs.indexOf(activeTab);

  let newIndex = index;
  if (event.key === "ArrowRight") newIndex = (index + 1) % tabs.length;
  if (event.key === "ArrowLeft") newIndex = (index - 1 + tabs.length) % tabs.length;

  if (newIndex !== index) {
    tabs[newIndex].focus();
    tabs[newIndex].click();
  }
});

```

:::

Las pestañas se utilizan para mostrar múltiples paneles de contenido en un espacio limitado. El estado `aria-selected` se usa para indicar qué pestaña está actualmente seleccionada.

Cuando el usuario selecciona una pestaña, el estado `aria-selected` de la pestaña seleccionada se establece en `true`, y el estado `aria-selected` de las otras pestañas se establece en `false`.

Otro estado común de ARIA es `aria-disabled`. Este estado se usa para indicar que un elemento está desactivado solo para personas que usan tecnologías de asistencia, como lectores de pantalla. Es importante notar que `aria-disabled` no desactiva realmente el elemento. Depende de ti, el desarrollador, hacer que se vea y actúe como un elemento desactivado. Este atributo también se utiliza comúnmente en elementos HTML nativos en lugar del atributo `disabled`. Cuál elijas dependerá del contexto en el que se utilice el botón.

Aquí tienes un ejemplo de cómo puedes usar `aria-disabled` en un botón de edición personalizado:

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<div role="button" tabindex="-1" aria-disabled="true">Edit</div>
```

```css
[role="button"] {
  display: inline-block;
  background-color: #0078d4;
  color: #fff;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-family: system-ui, sans-serif;
  font-size: 1rem;
  text-align: center;
  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s, transform 0.1s, opacity 0.2s;
}

[role="button"]:not([aria-disabled="true"]):hover {
  background-color: #005fa3;
}

[role="button"]:not([aria-disabled="true"]):focus {
  outline: 2px solid #005fa3;
  outline-offset: 2px;
}

[role="button"]:not([aria-disabled="true"]):active {
  transform: scale(0.97);
}

[role="button"][aria-disabled="true"] {
  opacity: 0.5;
  pointer-events: none;
  cursor: not-allowed;
  background-color: #b0b0b0;
  color: #f2f2f2;
}
```

:::

El atributo `aria-disabled` se utiliza para informar a los usuarios de lectores de pantalla que el botón de edición está desactivado y no se puede interactuar con él. Nuevamente, no desactiva realmente el botón. Al usar `aria-disabled`, necesitarás aplicar estilos y JavaScript para hacer que el control luzca y se comporte como un botón desactivado.

En la mayoría de los casos, probablemente usarás el elemento de botón nativo, pero hay casos en los que podrías necesitar usar un control personalizado. Por lo tanto, es esencial saber cómo comunicar el estado del control a las tecnologías de asistencia.

El siguiente estado de ARIA que discutiremos es `aria-haspopup`. Este estado se usa para indicar que un elemento interactivo activará un elemento emergente al ser activado. Solo puedes usar el atributo `aria-haspopup` cuando el elemento emergente tiene uno de los siguientes roles: `menu`, `listbox`, `tree`, `grid` o `dialog`. El valor de `aria-haspopup` debe ser uno de estos roles o `true`, que por defecto es el rol de `menu`. 

Aquí tienes un ejemplo de un menú de editor de archivos que usa `aria-haspopup`:

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<button id="menubutton" aria-haspopup="menu" aria-controls="filemenu" aria-expanded="false">File</button>
<ul id="filemenu" role="menu" aria-labelledby="menubutton" hidden>
  <li role="menuitem" tabindex="-1">Open</li>
  <li role="menuitem" tabindex="-1">New</li>
  <li role="menuitem" tabindex="-1">Save</li>
  <li role="menuitem" tabindex="-1">Delete</li>
</ul>
```

```css
#menubutton {
  background-color: #0078d4;
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  position: relative;
}

#menubutton:hover,
#menubutton:focus {
  background-color: #005ea2;
  outline: none;
}

#filemenu {
  list-style: none;
  padding: 4px 0;
  margin: 4px 0 0;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: #fff;
  width: 160px;
  position: absolute;
  z-index: 1000;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#filemenu[hidden] {
  display: none;
}

#filemenu [role="menuitem"] {
  display: block;
  padding: 8px 12px;
  font-size: 14px;
  color: #333;
  cursor: pointer;
}

#filemenu [role="menuitem"]:hover,
#filemenu [role="menuitem"]:focus {
  background-color: #e5f1fb;
  outline: none;
}

#filemenu [role="menuitem"]:focus-visible {
  box-shadow: inset 0 0 0 2px #0078d4;
}

```

:::

El estado `aria-haspopup` se usa para indicar que el botón de menú `Archivo` abrirá un menú emergente al ser activado. Los usuarios de lectores de pantalla pueden escuchar esta información adicional cuando navegan al botón.

Necesitarás usar JavaScript para mostrar y ocultar el menú emergente y para implementar el soporte adecuado de teclado para interactuar con el menú. Además, ten en cuenta que el rol `menu` de ARIA se refiere a un tipo muy específico de menú. Generalmente se refiere a una lista de acciones que el usuario puede invocar, similar a un menú en una aplicación de escritorio. No incluye usos más comunes de lo que típicamente llamamos "menús", como menús de navegación. Realísticamente, la mayoría de los "menús" que creas en la web no serán menús ARIA y no usarás `aria-haspopup` con ellos.

El siguiente estado de ARIA que discutiremos es `aria-required`. El atributo `aria-required` se utiliza para indicar que un campo debe completarse antes de enviar el formulario.

Aquí tienes un ejemplo de trabajo con el atributo `aria-required` para un control de formulario personalizado.

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<div id="name-label">Full Name*</div>
<div role="textbox" contenteditable aria-labelledby="name-label" aria-required="true" id="name"></div>
```

```css
#name-label {
  font-family: system-ui, sans-serif;
  font-size: 0.95rem;
  font-weight: 600;
  margin-bottom: 0.25rem;
  color: #333;
}

[role="textbox"] {
  display: block;
  width: 100%;
  min-height: 2rem;
  padding: 0.5rem 0.75rem;
  border: 1.5px solid #ccc;
  border-radius: 4px;
  font-family: system-ui, sans-serif;
  font-size: 1rem;
  color: #222;
  background-color: #fff;
  line-height: 1.4;
  transition: border-color 0.2s, box-shadow 0.2s;
}

[role="textbox"]:hover {
  border-color: #999;
}

[role="textbox"]:focus {
  outline: none;
  border-color: #0078d4;
  box-shadow: 0 0 0 3px rgba(0, 120, 212, 0.25);
}

[role="textbox"]:empty::before {
  content: attr(data-placeholder);
  color: #aaa;
  pointer-events: none;
}

[role="textbox"][aria-required="true"] {
  border-left: 3px solid #e81123;
  padding-left: calc(0.75rem - 3px);
}
```

:::

Necesitamos usar el atributo `contenteditable` para que los usuarios puedan escribir su entrada. También estamos utilizando el atributo `aria-required` establecido en `true` para indicar que este control de formulario personalizado es obligatorio.

Para que el control del formulario se vea como un control de formulario normal, necesitarías agregar CSS. También necesitarías agregar JavaScript para evitar que el formulario se envíe sin contenido.

Si la etiqueta ya tiene la palabra `required`, entonces debes omitir el atributo `aria-required`. Esto asegura que los lectores de pantalla solo anuncien la palabra requerida una vez.

En la mayoría de los casos, probablemente usarás los elementos nativos `label` y `form` con el atributo `required`. Pero si necesitas crear un control de formulario personalizado, entonces es importante agregar el atributo `aria-required` cuando sea necesario.

Además, el atributo `aria-required` también se puede usar en entradas de formularios nativas, como los elementos `input`, `textarea` y `select`. Esto a menudo es preferido sobre el atributo requerido nativo, ya que el atributo requerido puede tener posibles preocupaciones de usabilidad y accesibilidad, especialmente con el manejo de errores predeterminado proporcionado por el navegador. Finalmente, necesitarás hacer pruebas para determinar qué atributo es mejor para tu situación.

El último estado ARIA que discutiremos es `aria-checked`. Este atributo se utiliza para indicar si un elemento está en el estado marcado. Se utiliza más comúnmente al crear casillas de verificación personalizadas, botones de opción, interruptores y cuadros de lista.

Aquí tienes un ejemplo de cómo puedes usar `aria-checked` en un control de casilla de verificación personalizado:

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">
<div role="checkbox" aria-checked="true" tabindex="0">Checkbox</div>
```

```css
[role="checkbox"] {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-family: system-ui, sans-serif;
  font-size: 1rem;
  cursor: pointer;
  user-select: none;
  color: #222;
}

[role="checkbox"]::before {
  content: "";
  display: inline-block;
  width: 1rem;
  height: 1rem;
  border: 2px solid #666;
  border-radius: 4px;
  background-color: #fff;
  transition: all 0.2s ease;
  box-sizing: border-box;
}

[role="checkbox"]:hover::before {
  border-color: #0078d4;
}

[role="checkbox"]:focus::before {
  outline: 2px solid #0078d4;
  outline-offset: 2px;
}

[role="checkbox"][aria-checked="true"]::before {
  background-color: #0078d4;
  border-color: #0078d4;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'><path fill='white' d='M5.2 10.4L2 7.2l1.1-1.1 2.1 2.1L10.9 2.5 12 3.6z'/></svg>");
  background-repeat: no-repeat;
  background-position: center;
}

[role="checkbox"][aria-disabled="true"] {
  opacity: 0.5;
  pointer-events: none;
  cursor: not-allowed;
}

```

:::

Los elementos de casilla de verificación nativos tienen un estado `checked` integrado que se transmite a tecnologías de asistencia. Pero si estás creando un control de casilla de verificación personalizado, necesitarás usar el atributo `aria-checked` para indicar su estado.

Cuando el usuario interactúa con el control de casilla de verificación personalizado, necesitarás usar el estado `aria-checked` para reflejar el nuevo estado de la casilla de verificación. Cuando la casilla está marcada, el atributo `aria-checked` se establece en `true`. Cuando está desmarcada, se establece en `false`.

Los elementos nativos generalmente tienen mejor soporte y características de accesibilidad integradas.

Sin embargo, si debes crear controles personalizados, usar atributos ARIA es esencial para comunicar el estado de estos controles a las tecnologías de asistencia de manera efectiva.

Como siempre, prueba tu trabajo para asegurarte de que los atributos ARIA se apliquen correctamente y que el control personalizado funcione de una manera que sea tanto accesible como fácil de usar.

# --questions--

## --text--

¿Qué estado ARIA utilizarías para indicar que una pestaña está actualmente seleccionada?

## --answers--

`aria-disabled`

### --feedback--

Este estado muestra qué pestaña está activa.

---

`aria-selected`

---

`aria-haspopup`

### --feedback--

Este estado muestra qué pestaña está activa.

---

`aria-checked`

### --feedback--

Este estado muestra qué pestaña está activa.

## --video-solution--

2

## --text--

En el contexto de controles personalizados, ¿qué estado ARIA se utiliza para indicar que un elemento está actualmente desactivado?

## --answers--

`aria-checked`

### --feedback--

Este estado muestra que un elemento no se puede interactuar con él.

---

`aria-disabled`

---

`aria-selected`

### --feedback--

Este estado muestra que un elemento no se puede interactuar con él.

---

`aria-haspopup`

### --feedback--

Este estado muestra que un elemento no se puede interactuar con él.

## --video-solution--

2

## --text--

Cuando quieres indicar que un elemento del menú tiene un submenú, ¿qué estado ARIA debería usarse?

## --answers--

`aria-checked`

### --feedback--

Uno de los estados sugiere mucho que hay un elemento emergente presente.

---

`aria-disabled`

### --feedback--

Uno de los estados sugiere mucho que hay un elemento emergente presente.

---

`aria-haspopup`

---

`aria-selected`

### --feedback--

Uno de los estados sugiere mucho que hay un elemento emergente presente.

## --video-solution--

3
