---
id: 67f39e391c9b373069def02c
title: Python 复习
challengeType: 31
dashedName: review-python
---

# --description--

## 什么是 Python？

- **介绍**：Python 是一种通用的编程语言，以其简洁和易用性著称。Python 被广泛应用于数据科学和机器学习、网页开发、脚本和自动化、嵌入式系统和物联网等众多领域。
- **常见使用分支**：Python 用于数据科学、机器学习、网页开发、安全性、自动化以及像 Raspberry Pi 和兼容 MicroPython 的微型计算机。

## 在你的局部环境中使用 Python

- **安装**：在 Windows、Mac 和 Linux 上安装 Python 的最佳方式是从官方 Python 网站（`https://www.python.org/`）下载安装程序。

## 变量

- **声明变量**：声明变量时，先写变量名，后跟赋值操作符（`=`），然后是值。这个值可以是数字、字串、布尔等。以下是一些示例：

```py
name = 'John Doe'
age = 25
```

- **变量的命名规范**：以下是你应该为变量使用的命名规范：

  - 变量名只能以字母或下划线（_）开头，不能以数字开头。
  - 变量名只能包含字母数字字符（a-z、A-Z、0-9）和下划线（_）。
  - 变量名区分分支——`age`、`Age` 和 `AGE` 都被视为唯一。
  - 变量名不能是 Python 的保留关键字之一，例如 `if`、`class` 或 `def`。
  - 多个单词组成的变量名用下划线分隔。例如 `snake_case`。


## 评论

- **单行评论**：这些类型的评论应用于你希望在代码中留下的简短备注。

```py
# This is a single line comment
```

- **多行字串**：这些类型的字串可用于留下更大篇幅的备注或注释掉代码的部分。

```py
"""
This is a multi-line string.
Here is some code commented out.

name = 'John Doe'
age = 25
"""
```

- **`print()` 函数**：要将数据打印到控制台，你可以像这样使用 `print()` 函数：

```py
print('Hello world!') # Hello world!
```

## Python 中的常见数据类型

- **介绍**：Python 是一种动态类型语言，类似于 JavaScript，这意味着你不需要为变量显式声明类型。语言会根据你赋值给变量的内容来判断变量的类型。
- **整数**：没有小数的整数：

```py
my_integer_var = 10
print('Integer:', my_integer_var) # Integer: 10
```

- **Float**：带小数的数字：

```py
my_float_var = 4.50
print('Float:', my_float_var) # Float: 4.5
```

- **字串**：用引用包裹的一串字符：

```py
my_string_var = 'hello'
print('String:', my_string_var) # String: hello
```

- **布尔**：一个表现为 `True` 或 `False` 的值：

```py
my_boolean_var = True
print('Boolean:', my_boolean_var) # Boolean: True
```

- **集合**：一个无序的唯一元素集合：

```py
my_set_var = {7, 5, 8}
print('Set:', my_set_var) # Set: {7, 5, 8}
```

- **字典**：一个由密钥-值点对组成的集合，包含在括弧状的花括弧中：

```py
my_dictionary_var = {"name": "Alice", "age": 25}
print('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}
```

- **元组**：一个不可变的有序集合，包含在括号内：

```py
my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)
```

- **范围**：一组数字，通常用于循环：

```py
my_range_var = range(5)
print(my_range_var) # range(0, 5)
```

- **列表**：一个有序的支持不同数据类型的元素集合：

```py
my_list = [22, 'Hello world', 3.14, True]
print(my_list) # [22, 'Hello world', 3.14, True]
```

- **None**：一个表现值缺失的特殊值：

```py
my_none_var = None
print('None:', my_none_var) # None: None
```

## 不可变的和可变的类型

- **不可变的类型**：这些类型一旦声明就不能更改，尽管你可以将它们的变量指向新的内容，这称为重新赋值。它们包括整数、浮点数、复杂数、布尔、字串、元组、范围和 `None`。
- **可变的类型**：这些类型在声明后可以更改。你可以添加、删除或更新它们的项。它们包括列表、集合和字典等集合类型。
- **`type()` 函数**：要查看变量的类型，你可以像这样使用 `type()` 函数：

```py
greeting = 'Hello there!'
age = 21

print(type(greeting)) # <class 'str'>
print(type(age)) # <class 'int'>
```

- **`isinstance()` 函数**：用于查看变量是否匹配特定的数据类型：

```py
print(isinstance('Hello world', str)) # True
print(isinstance('John Doe', int)) # False
```

## 处理字串

- **定义**：正如你从 JavaScript 中查全率到的，字串是不可变的，这意味着你在创建它们之后无法更改它们。在 Python 中，你可以使用单引号或双引号。建议选择一个规则并坚持使用：

```py
developer = 'Jessica'
city = 'Los Angeles'
```

- **访问字串中的字符**：你可以使用方括弧表示法来访问字串中的字符，如下所示：

```py
my_str = "Hello world"

print(my_str[0])  # H
print(my_str[6])  # w

print(my_str[-1])  # d
print(my_str[-2]) # l
```

- **转义字串**：如果你的字串包含像这样的引用，你可以使用反斜线（`\`）：

```py
msg = 'It\'s a sunny day'
quote = "She said, \"Hello!\""
```

- **字串串接**：要串接字串，你可以像这样使用 `+` 操作符：

```py
developer = 'Jessica'
print('My name is ' + developer + '.') # My name is Jessica.
```

另一种串接字串的方法是使用 `+=` 操作符。它用于在同一步骤中执行串接和赋值，如下所示：

```py
greeting = 'My name is '
developer = 'Jessica.'

greeting += developer
print(greeting) # My name is Jessica.
```

- **`f-strings`**：这是格式化字面值的缩写。它允许你处理插值，并且通过简洁且可读的语法进行一些串接：

```py
developer = 'Jessica'
greeting = f'My name is {developer}.'
print(greeting) # My name is Jessica.
```

- **字串切片**：这是指你可以提取字串的部分内容。基本语法如下：

```py
str[start:stop:step]
```

起始位置表现提取应开始的索引。停止位置是切片应结束的位置。该位置不包含在内。步长位置表现切片递增的间隔。以下是一些示例：

```py
message = 'Python is fun!'

print(message[0:6])  # Python
print(message[7:])  # is fun!
print(message[::2])  # Pto sfn
```

- **获取字串长度**：`len()` 函数用于返回字串中的字符数：

```py
developer = 'Jessica'

print(len(developer)) # 7
```

## 使用 `in` 操作符

- **`in` 操作符**：这将返回一个布尔值，指定字符或字符是否存在于字串中：

```py
my_str = 'Hello world'

print('Hello' in my_str)  # True
print('hey' in my_str)    # False
print('hi' in my_str)    # False
print('e' in my_str)  # True
print('f' in my_str)  # False
```

## 常用字串方法

- **`str.upper()`**：这将返回一个所有字符都转换为大写的新建字串：

```py
developer = 'Jessica'

print(developer.upper()) # JESSICA
```

- **`str.lower()`**：这将返回一个所有字符都转换为小写的新建字串：

```py
developer = 'Jessica'

print(developer.lower()) # jessica
```

- **`str.strip()`**：这将返回一个字串的拷贝，移除指定的前导和尾随字符（如果没有传递参数给该方法，则移除前导和尾随的空白字符）。

```py
greeting = '  hello world  '

trimmed_my_str = greeting.strip()
print(trimmed_my_str)  # 'hello world'
```

- **`replace()`**：这会返回一个新字串，其中所有旧字串的出现都被替换为新字串。

```py
greeting = 'hello world'

replaced_my_str = greeting.replace('hello', 'hi')
print(replaced_my_str)  # 'hi world'
```

- **`split()`**：用于使用指定的分隔符将字串拆分成列表。分隔符是指定拆分位置的字串。

```py
dashed_name = 'example-dashed-name'

split_words = dashed_name.split('-')
print(split_words)  # ['example', 'dashed', 'name']
```

- **`join()`**：用于将可迭代对象的元素用分隔符连接成一个字串。可迭代对象是可以像列表、字串或元组一样循环的元素集合。

```py
example_list = ['example', 'dashed', 'name']

joined_str = ' '.join(example_list)
print(joined_str)  # example dashed name
```

- **`str.startswith(prefix)`**：这将返回一个布尔值，指示字串是否以指定的前缀开始：

```py
developer = 'Naomi'

result = developer.startswith('N')
print(result)  # True
```

- **`str.endswith(suffix)`**：这将返回一个布尔值，指示字串是否以指定的后缀结尾：

```py
developer = 'Naomi'

result = developer.endswith('N')
print(result)  # False
```

- **`str.find()`**：这会返回子串首次出现的索引。如果未找到，则返回 `-1`：

```py
developer = 'Naomi'

result = developer.find('N')
print(result)  # 0

city = 'Los Angeles'
print(city.find('New')) # -1
```

- **`str.count(substring)`**：这会计算一个字串在字串中出现的次数：

```py
city = 'Los Angeles'
print(city.count('e')) # 2
```

- **`str.capitalize()`**：这将返回一个新建的字串，其中第一个字符大写，其他字符小写：

```py
dessert = 'chocolate cake'
print(dessert.capitalize()) # Chocolate cake
```

- **`str.isupper()`**：如果字串中所有字母都是大写，则返回 `True`，否则返回 `False`：

```py
dessert = 'chocolate cake'
print(dessert.isupper()) # False
```

- **`str.islower()`**：如果字串中的所有字母都是小写，则返回 `True`，否则返回 `False`：

```py
dessert = 'chocolate cake'
print(dessert.islower()) # True
```

- **`str.title()`**：这将返回一个新字串，其中每个单词的首字母均大写：

```py
city = 'los angeles'
print(city.title()) # Los Angeles
```

- **`str.maketrans()`**：此方法用于创建一个 1 对 1 字符映射的表格。它通常与 `translate()` 方法一起使用，后者将该表格应用于字串并返回翻译结果。

```py
trans_table = str.maketrans('abc', '123')
print(trans_table) # {97: 49, 98: 50, 99: 51}

result = 'abcabc'.translate(trans_table)
print(result)  # 123123
```

## 与整数和浮点数一起使用的常见操作

- **基本数学操作**：在 Python 中，你可以对整数和浮点数进行基本数学操作，包括加法、减法、乘法和除法：

```py
int_1 = 56
int_2 = 12
float_1 = 5.4
float_2 = 12.0

# Addition

print('Integer Addition:', int_1 + int_2) # Integer Addition: 68
print('Float Addition:', float_1 + float_2) # Float Addition: 17.4

# Subtraction

print('Int Subtraction:', int_1 - int_2) # Int Subtraction: 44
print('Float Subtraction:',  float_2 - float_1) # Float Subtraction: 6.6

# Multiplication

print('Int Multiplication:', int_1 * int_2) # Int Multiplication: 672
print('Float Multiplication:', float_2 * float_1) # Float Multiplication: 64.80000000000001

# Division

print('Int Division:', int_1 / int_2) # Int Division: 4.666666666666667
print('Float Division:', float_2 / float_1) # Float Division: 2.222222222222222
```

当你添加一个浮点数和一个整数时，结果将被转换为浮点数，如下所示：

```py
int_1 = 56
float_1 = 5.4

print(int_1 + float_1) # 61.4
```

- **取模操作符 (`%`)**：当一个数字被另一个数字除时，这会返回余数：

```py
int_1 = 56
int_2 = 12

print(int_1 % int_2) # 8
```

- **向下取整除法 (`//`)**：此操作符用于除以两个数字并将结果向下取整到最接近的整数：

```py
int_1 = 56
int_2 = 12

print(int_1 // int_2) # 4
```

- **指数操作符 (`**`)**：此操作符用于将一个数字引起另一个数字的幂：

```py
int_1 = 4
int_2 = 2

print(int_1 ** int_2) # 16
```

- **`float()` 函数**：你可以使用此函数将整数转换为浮点数。

```py
num = 4

print(float(num)) # 4.0
```

- **`int()` 函数**：你可以使用此函数将浮点数转换为整数。

```py
num = 4.0

print(int(num)) # 4
```

- **`round()` 函数**：用于将数字四舍五入到最接近的整数：

```py
num_1 = 3.4
num_2 = 7.7

print(round(num_1)) # 3
print(round(num_2)) # 8
```

- **`abs()` 函数**：用于返回数字的绝对值：

```py
num = -13

print(abs(num)) # 13
```

- **`bin()` 函数**：用于将整数转换为其二进制表现形式的字串：

```py
num = 56

print(bin(num))  # 0b111000
```

- **`oct()` 函数**：用于将整数转换为其八进制表现形式的字串：

```py
num = 56

print(oct(num))  # 0o70
```

- **`hex()` 函数**：用于将整数转换为其十六进制表现形式的字串：

```py
num = 56

print(hex(num))  # 0x38
```

- **`pow()` 函数**：用于将一个数字提升到另一个数字的幂：

```py
result = pow(2, 3) 
print(result)  # 8
```

## 扩充赋值

- **定义**：扩充赋值将二元操作与赋值合并为一步。它取一个变量，对其与另一个值执行操作，并将结果保存回同一个变量。

```py
# Addition assignment 
my_var = 10
my_var += 5

print(my_var) # 15

# Subtraction assignment
count = 14
count -= 3

print(count) # 11

# Multiplication assignment 
product = 65
product *= 7

print(product) # 455

# Division assignment 
price = 100
price /= 4

print(price) # 25.0

# Floor Division assignment 
total_pages = 23
total_pages //= 5

print(total_pages) # 4

# Modulus assignment 
bits = 35
bits %= 2

print(bits) # 1

# Exponentiation assignment 
power = 2
power **= 3

print(power) # 8
```

还有其他扩充赋值操作符，比如用于按位操作符的。它们包括 `&=`、`^=`、`>>=` 和 `<<=`。

## 使用函数

- **定义**：函数是可重用的代码片段，接受输入（参数）并返回输出。要调用函数，你需要引用函数名，后跟一对括号：

```py
# Defining a function

def get_sum(num_1, num_2):
    return num_1 + num_2

result = get_sum(3, 4) # function call
print(result) # 7
```

如果一个函数没有显式返回值，那么默认返回值是 `None`：

```py
def greet():
    print('hello') 

result = greet() # hello
print(result) # None
```

你也可以这样为参数提供默认值：

```py
def get_sum(num_1, num_2=2):
    return num_1 + num_2

result = get_sum(3) 
print(result) # 5
```

如果你调用函数时参数数量不正确，你将得到一个 `TypeError`：

```py
def calculate_sum(a, b):
    print(a + b)

calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'
```

## 常用内置函数

- **`input()` 函数**：用于提示用户输入一些内容：

```py
name = input('What is your name?') # User types 'Kolade' and presses Enter  
print('Hello', name) # Hello Kolade
```

- **`int()` 函数**：用于将数字、布尔值或数字字串转换为整数：

```py
print(int(3.14)) # 3
print(int('42')) # 42
print(int(True)) # 1
print(int(False)) # 0 
```

## Python 中的作用域

- **局部作用域**：这是指在函数或类内部声明的变量只能在该函数或类内部访问。

```py
def my_func():
    num = 10
    print(num)
```

- **封闭作用域**：这是指嵌套在另一个函数内部的函数可以访问其所嵌套函数的变量。

```py
def outer_func():
    msg = 'Hello there!'
    
    def inner_func():
        print(msg)
    inner_func()

print(outer_func()) # Hello there!
```

- **全局作用域**：指的是声明在任何函数或类之外的变量，这些变量可以在程序的任何地方访问。

```py
tax = 0.70 

def get_total(subtotal):
    total = subtotal + (subtotal * tax)
    return total

print(get_total(100))  # 170.0
```

- **内置作用域**：Python 中为预定义函数、模块、关键字和对象保留的名称。

```py
print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False
```

## 比较运算符

- **相等 (`==`)**：查看两个值是否相等：

```py
print(3 == 4) # False
```

- **不相等 (`!=`)**：查看两个值是否不相等：

```py
print(3 != 4) # True
```

- **严格大于 (`>`)**：查看一个值是否大于另一个值：

```py
print(3 > 4) # False
```

- **严格小于 (`<`)**：查看一个值是否小于另一个值：

```py
print(3 < 4) # True
```

- **大于或等于(`>=`)**：查看一个值是否大于或等于另一个值：

```py
print(3 >= 4) # False
```

- **小于或等于(`<=`)**：查看一个值是否小于或等于另一个值：

```py
print(3 <= 4) # True
```

## 使用 `if`、`elif` 和 `else` 语句

- **`if` 语句**：这些是用于判断某事是否为真的条件。如果条件计算结果为 `True`，那么该代码块将被运行。

```py
age = 18

if age >= 18:
    print('You are an adult') # You are an adult
```

- **`elif` 语句**：这些是跟在 `if` 语句之后的条件。如果 `elif` 条件计算结果为 `True`，那么该代码块将被运行。

```py
age = 16

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')  # You are a teenager
```

- **`else` 子句**：如果没有其他条件计算为 `True`，则会运行此代码。

```py
age = 12

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')
else:
    print('You are a child')  # You are a child
```

你也可以像这样使用嵌套的 `if` 语句：

```py
is_citizen = True
age = 25

if is_citizen:
    if age >= 18:
        print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

## 真值和假值

- **定义**：在 Python 中，每个值都有固有的布尔值，或者说在逻辑上下文中应被视为 `True` 或 `False` 的内置含义。许多值被认为是真值，即它们在逻辑上下文中计算为 `True`。其他值是假值，意味着它们计算为 `False`。以下是假值的一些示例：

```md
None
False
Integer 0
Float 0.0
Empty strings ''
```

其他值如非零数字和非空字串都是真值。

## 使用 `bool()` 函数

- **定义**：如果你想查看一个值是真值还是假值，你可以使用内置的 `bool()` 函数。它显式地将一个值转换为其布尔等价物，并为真值返回 `True`，为假值返回 `False`。以下是一些示例：

```py
print(bool(False)) # False
print(bool(0))  # False
print(bool('')) # False

print(bool(True)) # True
print(bool(1)) # True
print(bool('Hello')) # True
```

## 布尔操作符和短路

- **定义**：这些是特殊的操作符，允许你组合多个表达式以创建更复杂的决策逻辑在你的代码中。Python 中有三个布尔操作符：`and`、`or` 和 `not`。
- **`and` 操作符**：该操作符接受两个操作对象，如果第一个操作对象为假值，则返回第一个操作对象，否则返回第二个操作对象。两个操作对象都必须为真值，表达式才会返回真值。

```py
is_citizen = True
age = 25

print(is_citizen and age) # 25
```

你也可以在条件式中像这样使用 `and` 操作符：

```py
is_citizen = True
age = 25

if is_citizen and age >= 18:
    print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

- **`or` 操作符**：该操作符如果第一个操作对象为真值，则返回第一个操作对象，否则返回第二个操作对象。一个 or 表达式如果至少有一个操作对象为真值，则结果为真值。以下是一个示例：

```py
age = 19
is_employed = False

print(age or is_employed) # 19
```

就像使用 `and` 操作符一样，你也可以在条件式中这样使用 `or` 操作符：

```py
age = 19
is_student = True

if age < 18 or is_student:
    print('You are eligible for a student discount') # You are eligible for a student discount
else:
    print('You are not eligible for a student discount')
```

- **短路**：`and` 和 `or` 操作符被称为短路操作符。短路意味着 Python 从左到右检查值，并在确定最终结果后立即停止。
- **`not` 操作符**：该操作符接受单个操作对象并反转其布尔值。它将真值转换为 `False`，将假值转换为 `True`。与我们之前看到的操作符不同，`not` 总是返回 `True` 或 `False`。以下是一些示例：

```py
print(not '') # True, because empty string is falsy
print(not 'Hello') # False, because non-empty string is truthy
print(not 0) # True, because 0 is falsy
print(not 1) # False, because 1 is truthy
print(not False) # True, because False is falsy
print(not True) # False, because True is truthy
```

这是一个在条件式中使用 `not` 操作符的示例： 

```py
is_admin = False

if not is_admin:
    print('Access denied for non-administrators.') # Access denied for non-administrators.
else:
    print('Welcome, Administrator!')
```


## Python 列表

- **介绍**：在 Python 中，列表数据类型是一个有序的元素序列，元素可以由字串、数字甚至其他列表组成。列表是可变的，并且基于零索引。

```python
cities = ['Los Angeles', 'London', 'Tokyo']
```

- **访问列表中的元素**：要访问 `cities` 列表中的元素，你可以引用其在序列中的索引号：

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[0] # Los Angeles
```

- **使用负索引访问元素**：要访问任何列表的最后一个元素，你可以使用 `-1` 作为索引号：

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[-1] # Tokyo
```

- 负索引用于从列表末尾开始访问元素，而不是从索引 `0` 开始。

- **使用 `list()` 构造函数创建列表**：列表也可以使用 `list()` 构造函数创建。`list()` 构造函数用于将可迭代对象转换为列表：

```python
developer = 'Jessica'

print(list(developer)) 
# Result: ['J', 'e', 's', 's', 'i', 'c', 'a']
```

- **查找列表的长度**：你可以使用 `len()` 函数来获取列表的长度：

```python
numbers = [1, 2, 3, 4, 5]
len(numbers) # 5
```

- **列表可变性**：列表是可变的，这意味着只要你传入有效的索引数字，就可以更新列表中的任何元素。要在特定索引处更新列表，你可以为该索引赋值一个新值：

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[0] = 'JavaScript'
print(programming_languages) # ['JavaScript', 'Java', 'C++', 'Rust']
```

- **索引超出范围误差**：如果你传入的索引（正数或负数）超出了列表的边界，那么你将收到一个 `IndexError`：

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[10] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
"""
```

- **从列表中移除元素**：可以使用 `del` 关键字从列表中移除元素：

```python
developer = ['Jane Doe', 23, 'Python Developer']
del developer[1]
print(developer) # ['Jane Doe', 'Python Developer']
```

- **查看元素是否存在于列表中**：可以使用 `in` 关键字来查看元素是否存在于列表中：

```py
programming_languages = ['Python', 'Java', 'C++', 'Rust']

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **嵌套列表**：列表可以嵌套在其他列表中：

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
```

- 要访问嵌套列表，你需要使用索引 `2` 访问它，因为列表是从零开始索引的。

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2] # ['Python', 'Rust', 'C++']
```

- 要进一步访问该嵌套列表中的第二种语言，你需要使用索引 `1` 来访问它：

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2][1] # Rust
```

- **从列表中解包值：** 从列表中解包值是一种将列表中的值赋值给新变量的技术。下面是一个示例，将 `developer` 列表解包到名为 `name`、`age` 和 `job` 的新变量中，如下所示：

```py
developer = ['Alice', 34, 'Rust Developer']
name, age, job = developer
```

- **从列表中收集剩余项**：要收集列表中的任何剩余元素，你可以像这样使用星号（`*`）操作符：

```py
developer = ['Alice', 34, 'Rust Developer']
name, *rest = developer
```

- 如果赋值操作符左侧的变量数量与列表中的项总数不匹配，则你会收到一个 `ValueError`。

- **切片列表**：切片是通过使用切片操作符 `:` 来访问列表部分内容的概念。要切片一个从索引 `1` 开始到索引 `3` 结束的列表，你可以使用以下语法：

```python
desserts = ['Cake', 'Cookies', 'Ice Cream', 'Pie']
desserts[1:3] # ['Cookies', 'Ice Cream']
```

- **步长间隔**：也可以指定步长间隔，用于确定索引之间的增量。如果你想使用切片提取仅包含偶数的列表，下面是一个示例：

```python
numbers = [1, 2, 3, 4, 5, 6]
numbers[1::2] # [2, 4, 6]
```

## 列表方法

- **append()**：用于将一项添加到列表的末尾。下面是使用 `append()` 方法将数字 `6` 添加到此 `numbers` 列表的示例：

```py
numbers = [1, 2, 3, 4, 5]
numbers.append(6)
print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **追加列表**：`append()` 方法也可以用于将一个列表添加到另一个列表的末尾：

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.append(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, [6, 8, 10]]
```

- **extend()**：用于将多项添加到列表的末尾。下面是将数字 `6`、`8` 和 `10` 添加到 `numbers` 列表末尾的示例：

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.extend(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, 6, 8, 10]
```

- **insert()**：用于在列表中的特定索引插入一项。以下是使用 `insert()` 方法的示例：

```py
numbers = [1, 2, 3, 4, 5]
numbers.insert(2, 2.5)

print(numbers) # [1, 2, 2.5, 3, 4, 5]
```

- **remove():** 用于从列表中移除一项。`remove()` 方法只会移除列表中第一次出现的该项：

```py
numbers = [1, 2, 3, 4, 5, 5, 5]
numbers.remove(5)

print(numbers) # [1, 2, 3, 4, 5, 5]

```

- **pop()**：用于从列表中移除特定项并返回它：

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop(1) # The number 2 is returned
```

- 如果你没有为 `pop` 方法指定元素，则会移除最后一个元素。

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop() # The number 5 is returned
```

- **clear()**：用于从列表中移除所有项：

```py
numbers = [1, 2, 3, 4, 5]
numbers.clear()

print(numbers) # []
```

- **sort()**：`sort()` 方法用于就地排序元素。以下是就地排序随机 `numbers` 列表的示例：

```py
numbers = [19, 2, 35, 1, 67, 41]
numbers.sort()

print(numbers) # [1, 2, 19, 35, 41, 67]
```

- **sorted()**：用于对列表中的元素进行排序，并返回一个新建的排序列表，而不是修改原始列表。

- **reverse()**：用于反转列表中元素的顺序：

```py
numbers = [6, 5, 4, 3, 2, 1]
numbers.reverse()

print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **index()**：用于查找元素在列表中首次出现的索引：

```python
programming_languages = ['Rust', 'Java', 'Python', 'C++']
programming_languages.index('Java') # 1
```

- 如果使用 `index()` 方法找不到元素，则结果将是 `ValueError`。

## Python 中的元组

- **定义**：元组是 Python 的一种数据类型，用于创建有序的值序列。元组可以包含混合的数据类型：

```py
developer = ('Alice', 34, 'Rust Developer')
```

- 元组是不可变的，这意味着元组中的元素一旦创建就不能更改。如果你尝试更新元组中的某一项，你将得到一个 `TypeError`：

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')
programming_languages[0] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object does not support item assignment
"""
```

- **从元组访问元素**：要访问元组中的元素，使用方括弧表示法和索引号：

```py
developer = ('Alice', 34, 'Rust Developer')
developer[1] # 34
```

- 可以使用负索引从元组的末尾访问元素：

```py
numbers = (1, 2, 3, 4, 5)
numbers[-2] # 4
```

- 如果你尝试传入一个大于或相等于元组长度的索引号，则会收到一个 `IndexError`：

```py
numbers = (1, 2, 3, 4, 5)
numbers[7]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: tuple index out of range
"""
```

- 元组也可以使用 `tuple()` 构造函数创建。在构造函数中，你可以传入不同的可迭代对象，比如字串、列表甚至其他元组。

```python
developer = 'Jessica'

print(tuple(developer)) 
# Result: ('J', 'e', 's', 's', 'i', 'c', 'a')
```

- **验证元组中的项**：要查看某项是否在元组中，你可以像这样使用 `in` 关键字：

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **解包元组**：项可以像这样从元组中解包：

```py
developer = ('Alice', 34, 'Rust Developer')
name, age, job = developer
```

- 如果你需要收集元组中剩余的元素，可以像这样使用星号（`*`）操作符：

```py
developer = ('Alice', 34, 'Rust Developer')
name, *rest = developer
```

- **切片元组**：切片可用于提取元组的一部分。例如，项 `pie` 和 `cookies` 可以切片成一个单独的元组：

```py
desserts = ('cake', 'pie', 'cookies', 'ice cream')
desserts[1:3] # ('pie', 'cookies')
```

- **从元组中移除项**：从元组中移除一项会引起 `TypeError`，因为元组是不可变的：

```py
developer = ('Jane Doe', 23, 'Python Developer')
del developer[1]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object doesn't support item deletion
"""
```

- **何时使用元组而非列表？**：如果你需要一个动态的元素集合，可以添加、删除和更新元素，那么你应该使用列表。如果你知道你正在处理一个固定且不可变的数据集合，那么你应该使用元组。

## 常用元组方法

- **`count()`**：用于确定一项在元组中出现了多少次。例如，你可以查看语言 `'Rust'` 在元组中出现了多少次：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('Rust') # 2
```

- 如果 `count()` 函数中指定的项在元组中根本不存在，则返回值将是 `0`：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('JavaScript') # 0
```

- 如果没有传递参数给 `count()` 函数，那么 Python 会返回一个 `TypeError`。

- **index()**：用于查找特定项在元组中出现的索引。以下是使用 `index()` 方法查找语言 `'Java'` 的索引的示例：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.index('Java') # 1
```

- 如果找不到指定的项，Python 将返回一个 `ValueError`。

- 你可以向 `index()` 方法传递一个可选的起始索引，以指定从元组中的哪个位置开始查找该项：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
programming_languages.index('Python', 3) # 5
```

- 你也可以传入一个可选的结束索引到 `index()` 方法中，以指定在元组中停止查找该项的位置：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python', 'JavaScript', 'Python')
programming_languages.index('Python', 2, 5) # 2
```

- **`sorted()`**：用于对任何可迭代对象中的元素进行排序并返回一个新排序的列表。以下是使用 `sorted()` 函数创建一个新数字列表的示例：

```py
numbers = (13, 2, 78, 3, 45, 67, 18, 7)
sorted(numbers) # [2, 3, 7, 13, 18, 45, 67, 78]
```

- **修改排序行为**：你可以使用可选的 `reverse` 和 `key` 参数来自定义可迭代对象的排序行为。以下是使用 `key` 参数按长度对元组中的项进行排序的示例：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
sorted(programming_languages, key=len)

# Result
# ['C++', 'Rust', 'Java', 'Rust', 'Python', 'Python']
```

- 你可以使用 `reverse` 参数创建一个逆序的新值列表，方法如下：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')

print(sorted(programming_languages, reverse=True))

# Result
# ['Rust', 'Rust', 'Python', 'Python', 'Java', 'C++']
```

## Python 中的循环

- **定义**：循环用于重复执行一段代码块指定的次数。

- **`for` 循环**：用于迭代序列（如列表、元组或字串）并为序列中的每个项执行一块代码。下面是使用 `for` 循环迭代列表并打印每种语言到控制台的示例：

```py
programming_languages = ['Rust', 'Java', 'Python', 'C++']

for language in programming_languages:
    print(language)

"""
Result 

Rust
Java
Python
C++
"""
```

- 下面是使用 `for` 循环遍历字串 `code` 并打印出每个字符的示例：

```py
for char in 'code':
    print(char)

"""
Result 

c
o
d
e
"""
```

- `for` 循环可以嵌套。以下是使用嵌套 `for` 循环的示例：

```py
categories = ['Fruit', 'Vegetable']
foods = ['Apple', 'Carrot', 'Banana']

for category in categories:
    for food in foods:
        print(category, food)

"""
Result

Fruit Apple
Fruit Carrot
Fruit Banana
Vegetable Apple
Vegetable Carrot
Vegetable Banana
"""

```

- **`while` 循环**：重复执行一段代码块直到条件为 `False`。下面是使用 `while` 循环进行猜数字游戏的示例：

```py
secret_number = 3
guess = 0

while guess != secret_number:
    guess = int(input('Guess the number (1-5): '))
    if guess != secret_number:
        print('Wrong! Try again.')

print('You got it!')

"""
Result

Guess the number (1-5): 2
Wrong! Try again.
Guess the number (1-5): 1
Wrong! Try again.
Guess the number (1-5): 3
You got it!
"""

```

- **`break` 和 `continue` 语句**：用于循环中以修改循环的执行。

- `break` 语句用于在满足某个条件时立即退出循环。以下是使用 `break` 语句处理 `developer_names` 列表的示例：

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        break
    print(developer)
```

- `continue` 语句用于跳过当前迭代并进入循环的下一次迭代。下面是一个使用 `continue` 语句替代 `break` 语句的示例：

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        continue
    print(developer)
```

- `for` 和 `while` 循环都可以与 `else` 子句结合使用，只有当循环未被 `break` 终止时才会执行该子句：

```python
words = ['sky', 'apple', 'rhythm', 'fly', 'orange']

for word in words:
    for letter in word:
        if letter.lower() in 'aeiou':
            print(f"'{word}' contains the vowel '{letter}'")
            break
    else:
        print(f"'{word}' has no vowels")
```

## 范围及其在循环中的使用

- **`range()` 函数**：用于生成一个整数序列。

```py
range(start, stop, step)
```

- 必需的 `stop` 参数是一个整数（不包含），它表现为所生成数字序列的终点。以下是使用 `range()` 函数的示例：

```py
for num in range(3):
    print(num)
```

- 如果未指定 `start` 参数，则默认值为 `0`。默认情况下，整数序列将以 `1` 递增。你可以使用可选的 `step` 参数来更改默认的递增值。以下是生成从 2 到但不包括 11（即包括 10）的偶数序列的示例。

```py
for num in range(2, 11, 2):
    print(num)
```

- 如果你不给 `range()` 函数提供任何参数，那么你将得到一个 `TypeError`。

- `range()` 函数只接受整数作为参数，不接受浮点数。使用浮点数也会导致 `TypeError`：

```py
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
```

- 你可以为 `step` 参数使用负整数来生成递减顺序的整数序列：

```py
for num in range(40, 0, -10):
    print(num)
```

- `range()` 函数也可以通过与 `list` 构造函数一起使用来创建整数列表。`list` 构造函数用于将可迭代对象转换为列表。以下是生成包含 2 到 10（含）之间偶数整数列表的示例：

```py
numbers = list(range(2, 11, 2))
print(numbers) # [2, 4, 6, 8, 10]
```

## Python 中的 `enumerate()` 和 `zip()` 函数

- **`enumerate()`**：用于迭代序列并跟踪该序列中每个项的索引。`enumerate()` 函数将可迭代对象作为参数，并返回一个 `enumerate` 对象，该对象包含可迭代对象中每个项的索引和值。

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

for index, language in enumerate(languages):
    print(f'Index {index} and language {language}')

# Result
# Index 0 and language Spanish
# Index 1 and language English
# Index 2 and language Russian
# Index 3 and language Chinese

```

- `enumerate()` 函数也可以在 `for` 循环之外使用：

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

print(list(enumerate(languages)))
# [(0, 'Spanish'), (1, 'English'), (2, 'Russian'), (3, 'Chinese')]
```

- `enumerate()` 函数还接受一个可选的 `start` 参数，用于指定计数的起始值。如果省略此参数，则计数将从 `0` 开始。

-  **`zip()`** ：用于并行迭代多个可迭代对象。下面是一个使用 `zip()` 函数并行迭代 `developers` 和 `ids` 的示例：

```python
developers = ['Naomi', 'Dario', 'Jessica', 'Tom']
ids = [1, 2, 3, 4]

for name, id in zip(developers, ids):
    print(f'Name: {name}')
    print(f'ID: {id}')


"""
Result

Name: Naomi
ID: 1
Name: Dario
ID: 2
Name: Jessica
ID: 3
Name: Tom
ID: 4
"""

```

## Python 中的列表推导式

- **定义**：列表推导允许你通过将循环和条件直接组合在方括弧内，在一行中创建一个新列表。这使代码更简短且通常更易于阅读。

```py
even_numbers = [num for num in range(21) if num % 2 == 0]
print(even_numbers)
```

## 可迭代方法

- **`filter()`**：用于根据条件过滤可迭代对象中的元素。它返回一个只包含满足条件元素的迭代器。下面是创建一个只包含长度超过四个字符单词的新列表的示例：

```py
words = ['tree', 'sky', 'mountain', 'river', 'cloud', 'sun']

def is_long_word(word):
    return len(word) > 4

long_words = list(filter(is_long_word, words))
print(long_words) # ['mountain', 'river', 'cloud']
```

- **`map()`**：用于将函数应用到可迭代对象中的每一项，并返回一个包含结果的新可迭代对象。下面是使用 `map()` 函数将摄氏温度列表转换为华氏温度的示例：

```py
celsius = [0, 10, 20, 30, 40]

def to_fahrenheit(temp):
    return (temp * 9/5) + 32

fahrenheit = list(map(to_fahrenheit, celsius))
print(fahrenheit) # [32.0, 50.0, 68.0, 86.0, 104.0]
```

- **`sum()`**：用于从可迭代对象（如列表或元组）中获取总和。以下是使用 `sum()` 函数的示例：

```py
numbers = [5, 10, 15, 20]
total = sum(numbers)
print(total) # Result: 50
```

- 你也可以传入一个可选的 `start` 参数，用于设置求和的初始值。下面是一个使用 `start` 参数作为位置参数的更新示例：

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, 10) # positional argument
print(total) # 60
```

- 你也可以选择将 `start` 参数作为关键字参数这样使用：

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, start=10) # keyword argument
print(total) # 60
```

## Lambda 函数

- **定义**：Python 中的 lambda 函数是一种简洁的方式来创建没有名称的函数（匿名函数）。
- Lambda 函数通常用作另一个函数的参数。下面是一个 lambda 函数的示例：

```py
numbers = [1, 2, 3, 4, 5]

even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]
```

- 使用 lambda 函数的最佳实践包括不将它们赋值给变量，保持它们简单且易读，以及将它们用于简短的一次性函数。

## 字典

- **字典**：字典是内置的数据结构，用于保存键值对集合。键需要是不可变的数据类型。这是 Python 字典的通用语法：

```python
dictionary = {
    key1: value1,
    key2: value2
}
```

- **`dict()` 构造函数**：`dict()` 构造函数是构建字典的备选方法。你将一个元组列表作为参数传递给 `dict()` 构造函数。这些元组包含第一个元素作为密钥，第二个元素作为值。

```python
pizza = dict([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250), ('toppings', ['mozzarella', 'basil'])])
```

- **方括弧表示法**：要访问一个点对的值，你可以使用称为方括弧表示法的语法。

```python
dictionary[key]
```

## 常用字典方法

- **`get()` 方法**：`get()` 方法检索与密钥关联的值。它类似于方括弧表示法，但允许你设置默认值，从而防止密钥不存在时出现误差。

```python
dictionary.get(key, default)
```

- **`keys()` 和 `values()` 方法**：`keys()` 和 `values()` 方法分别返回包含字典中所有密钥和值的视图对象。视图对象是一种查看字典内容而不创建数据单独拷贝的方式。

```python
pizza = {
    'name': 'Margherita Pizza',
    'price': 8.9,
    'calories_per_slice': 250
}

pizza.keys()
# dict_keys(['name', 'price', 'calories_per_slice'])

pizza.values()
# dict_values(['Margherita Pizza', 8.9, 250])
```

- **`items()` 方法**：`items()` 方法返回一个包含字典中所有键值点对的视图对象，包括键和值。

```python
pizza.items()
# dict_items([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250)])
```

- **`clear()` 方法**：`clear()` 方法从字典中移除所有的密钥-值点对。

```python
pizza.clear()
```

- **`pop()` 方法**：`pop()` 方法移除第一个参数指定的密钥对应的点对并返回其值。如果密钥不存在，则返回第二个参数指定的默认值。如果密钥不存在且未指定默认值，则引起 `KeyError`。

```python
pizza.pop('price', 10)
pizza.pop('total_price') # KeyError
```

- **`popitem()` 方法**：在 Python 3.7 及以上版本中，`popitem()` 方法会移除最后插入的项。

```python
pizza.popitem()
```

- **`update()` 方法**：`update()` 方法使用另一个字典的键值对更新键值对。如果它们有相同的键，则其值将被覆盖。新键将作为新的键值对添加到字典中。

```python
pizza.update({ 'price': 15, 'total_time': 25 })
```

## 遍历字典的循环

- **迭代值**：如果你需要迭代字典中的值，可以编写一个带有 `values()` 的 `for` 循环来获取字典的所有值。

```python
products = {
    'Laptop': 990,
    'Smartphone': 600,
    'Tablet': 250,
    'Headphones': 70,
}

for price in products.values():
    print(price)
```

输出:

```md
990
600
250
70
```

- **迭代密钥**：如果你需要迭代上面 `products` 字典中的密钥，你可以写 `products.keys()` 或直接写 `products`。

```python
for product in products.keys():
    print(product)
    
# Or

for product in products:
    print(product)
```

输出:

```md
Laptop
Smartphone
Tablet
Headphones
```

- **迭代密钥-值点对**：如果你需要同时迭代密钥及其对应的值，你可以迭代 `products.items()`。你将获得包含密钥及其对应值的单个元组。

```python
for product in products.items():
    print(product)
```

输出:

```md
('Laptop', 990)
('Smartphone', 600)
('Tablet', 250)
('Headphones', 70)
```

要将密钥和值分别保存到不同的循环变量中，你需要用逗号将它们分开。第一个变量保存密钥，第二个保存值。

```python
for product, price in products.items():
    print(product, price)
```

输出:

```md
Laptop 990
Smartphone 600
Tablet 250
Headphones 70
```

- **`enumerate()` 函数**：如果你需要在迭代字典的同时跟踪计数器，可以调用 `enumerate()` 函数。该函数返回一个 `enumerate` 对象，它为每个项赋值一个整数，就像计数器一样。你可以从任意数字开始计数，但默认从 0 开始。

将索引和项赋值给单独的循环变量是使用 `enumerate()` 的常见方式。例如，使用 `products.items()`，你可以除了索引外，还获取整个键值点对：

```python
for index, product in enumerate(products.items()):
    print(index, product)
```

输出:

```md
0 ('Laptop', 990)
1 ('Smartphone', 600)
2 ('Tablet', 250)
3 ('Headphones', 70)
```

要自定义计数的初始值，你可以向 `enumerate()` 传递第二个参数。例如，这里我们从 1 开始计数。

```python
for index, product in enumerate(products.items(), 1):
    print(index, product)
```

输出:

```md
1 ('Laptop', 990)
2 ('Smartphone', 600)
3 ('Tablet', 250)
4 ('Headphones', 70)
```

## 集合

- **集合**：集合是 Python 中的内置数据结构，不允许有副本值。集合是可变的且无序的，这意味着它们的元素不会以任何特定顺序保存，因此你不能使用索引或密钥来访问它们。此外，集合只能包含不可变数据类型的值，比如数字、字串和元组。

- **定义一个集合**：要定义一个集合，你需要将它的元素写在括弧状的括号内，并用逗号分隔。

```python
my_set = {1, 2, 3, 4, 5}
```

- **定义空集**：如果你需要定义一个空集，必须使用 `set()` 函数。仅写空的括弧状的花括弧会自动创建一个字典。

```python
set() # Set
{}    # Dictionary
```

## 常用集合方法

- **`add()` 方法**：你可以使用 `add()` 方法为集合添加一个元素，将新元素作为参数传入。

```python
my_set.add(6)
```

- **`remove()` 和 `discard()` 方法**：要从集合中移除一个元素，你可以使用 `remove()` 方法或 `discard()` 方法，将你想移除的元素作为参数传入。若未找到该元素，`remove()` 方法会引起 `KeyError`，而 `discard()` 方法则不会。

```python
my_set.remove(4)
my_set.discard(4)
```

- **`clear()` 方法**：`clear()` 方法从集合中移除所有元素。

```python
my_set.clear()
```

## 数学集合操作

- **`issubset()` 和 `issuperset()` 方法**：`issubset()` 和 `issuperset()` 方法分别检查一个集合是否是另一个集合的子集或超集。

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 5}

print(your_set.issubset(my_set)) # True
print(my_set.issuperset(your_set)) # True
```

- **`isdisjoint()` 方法**：`isdisjoint()` 方法检查两个集合是否不相交，即它们没有共同的元素。

```python
my_set = {1, 2, 3}
your_set = {4, 5, 6}

print(my_set.isdisjoint(your_set)) # True
```

- **并集操作符 (`|`)**：并集操作符 `|` 返回一个包含两个集合中所有元素的新建集合。

```python
my_set = {1, 2, 3}
your_set = {4, 5, 6}

my_set | your_set # {1, 2, 3, 4, 5, 6}
```

- **交集操作符 (`&`)**：交集操作符 `&` 返回一个只包含集合共有元素的新建集合。

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

my_set & your_set # {2, 3, 4}
```

- **差集操作符 (`-`)**：差集操作符 `-` 返回一个新建集合，其中包含第一个集合中不在其他集合内的元素。

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

my_set - your_set # {1, 5}
```

- **对称差操作符 (`^`)**：对称差操作符 `^` 返回一个新建集合，该集合包含仅存在于第一个集合或第二个集合中的元素，但不包含两者共有的元素。

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

my_set ^ your_set # {1, 5, 6}
```

- **`in` 操作符**：你可以使用 `in` 操作符查看一个元素是否在集合中。

```python
print(5 in my_set)
```

## Python 标准函数库

- **Python 标准函数库**：库为你提供预先编写且可重用的代码，如函数、类和数据结构，你可以在你的项目中重复使用。Python 拥有一个庞大的标准函数库，内置模块实现了许多问题和任务的标准化方案。一些流行的内置模块示例包括 `math`、`random`、`re`（“正则表达式”的缩写）和 `datetime`。

## 导入语句

- **导入语句**：要访问内置模块中定义的元素，你使用导入语句。导入语句通常写在文件顶部。导入语句对模块中定义的函数、类、常量、变量以及任何其他元素的作用相同。

- **基本导入语句**：你可以使用 `import` 关键字，后跟模块名称：

```python
import module_name
```

然后，如果你需要调用该模块中的方法，你应使用点符号，模块名称后跟方法名称。

```python
module_name.method_name()
```

例如，你可以在你的代码中写如下内容来导入 `math` 模块并获取 36 的平方根：

```python
import math

math.sqrt(36)
```

- **使用不同名称导入模块**：如果你需要使用不同名称（也称为“别名”）导入模块，可以在导入语句末尾使用 `as` 后跟别名。这通常用于模块名称较长或避免命名冲突。

```python
import module_name as module_alias
```

例如，要在你的代码中将 `math` 模块别名为 `m`，你可以这样赋值别名：

```python
import math as m
```

然后，你可以使用别名访问模块的元素：

```python
m.sqrt(36)
```

- **导入特定元素**：如果你不需要模块中的所有内容，可以使用 `from` 导入特定元素。在这种情况下，导入语句以 `from` 开头，后跟模块名称，然后是 `import` 关键字，最后是你想导入的元素名称。

```python
from module_name import name1, name2
```

然后，你可以在你的 Python 脚本中使用这些名称而无需模块前缀。 例如：

```python
from math import radians, sin, cos

angle_degrees = 40
angle_radians = radians(angle_degrees)

sine_value = sin(angle_radians)
cos_value = cos(angle_radians)

print(sine_value) # 0.6427876096865393
print(cos_value)  # 0.766044443118978
```
 
这很有帮助，但如果你已经有同名的函数或变量，可能会导致命名冲突。选择你想使用的导入语句类型时请记住这一点。

如果你需要为这些名称赋值别名，也可以使用 `as` 关键字，后跟别名。

```python
from module_name import name1 as alias1, name2 as alias2
```

- **带星号（`*`）的导入语句**：星号告诉 Python 你想导入该模块中的所有内容，但你想导入它以便不需要使用模块名作为前缀。

```python
from module_name import *
```

例如，如果你使用这个来导入 `math` 模块，你将能够调用该模块中定义的任何函数，而无需指定模块名称作为前缀。

```python
from math import *
print(sqrt(36))  # 6.0
```

但是，这通常不被推荐，因为它可能导致命名空间冲突，并且使得难以知道名称的来源。

## `if __name__ == '__main__'`

- **`__name__` 变量**：`__name__` 是 Python 中一个特殊的内置变量。当一个 Python 文件被直接执行时，Python 会将该变量的值设置为字串 `"__main__"`。但如果该 Python 文件作为模块被导入到另一个 Python 脚本中，`__name__` 变量的值则被设置为该模块的名称。

这就是为什么你经常会在 Python 脚本中找到这个条件式。它包含你只想在 Python 脚本作为主程序运行时**才**运行的代码。

```python
if __name__ == '__main__': 
    # Code
```

## Python 中的常见误差

- **SyntaxError**：当你的代码不符合其语法规则时，Python 引起的误差。例如，代码 `print("Hello there"` 会导致带有消息 `SyntaxError: '(' was never closed` 的语法误差，因为代码缺少一个闭合的括号。
- **NameError**：当你尝试访问未定义的变量或函数时，Python 会引起 `NameError`。例如，如果你的代码中有一行 `print(username)`，但没有先定义 `username` 变量，你将收到带有消息 `NameError: name 'username' is not defined` 的名称错误。
- **TypeError**：当你对两个或多个不兼容的数据类型执行操作时，Python 会抛出此误差。例如，如果你尝试将字串添加到数字，你将得到误差 `TypeError: can only concatenate str (not "int") to str`。
- **IndexError**：如果你访问列表或其他序列如元组和字串中不存在的索引，就会得到一个 `IndexError`。例如，在一个 `Hello world` 字串中，最后一个字符的索引是 `11`。如果你继续这样访问字符，`greet = "hello world"; print(greet[12])`，你将得到一条消息为 `IndexError: string index out of range` 的错误。
- **AttributeError**：当你尝试在该类型的对象中使用不存在的方法或属性时，Python 会引起此误差。例如，在字串上调用 `.append()`，如 `"hello".append("!")`，将导致带有消息 `AttributeError: 'str' object has no attribute 'append'` 的误差。

## Python 中的良好调试技巧

- **使用 `print` 函数**：在调试时，在代码的各个点插入 `print()` 语句可以帮助你查看变量的值以及代码的执行流程。
- **使用 Python 的内置调试器 (`pdb`)**：Python 提供了一个用于调试的 `pdb` 模块。它是 Python 标准函数库的一部分，因此始终可用。通过 `pdb`，你可以使用 `set_trace()` 方法设置追踪，从而以交互方式开始逐步执行代码并检查变量。
- **利用集成开发环境调试工具**：许多集成开发环境（IDE）和代码编辑器如 Pycharm 和 VS Code 提供带有断点、逐步执行、变量检查及其他调试功能的调试工具。

## 异常处理

- **`try...except`**: This is used to execute a block of code that might raise an exception. The `try` block is  where you anticipate an error might occur, while the `except` block takes a specified exception and runs if that specified error is raised. Here's an example:

  ```py
  try:
    print(22 / 0)
  except ZeroDivisionError:
    print('You can\'t divide by zero!')
    # You can't divide by zero!
  ```

  You can also chain multiple `except` blocks so you can handle more types of exceptions:

  ```py
  try:
    number = int(input('Enter a number: '))
    print(22 / number)
  except ZeroDivisionError:
    print('You cannot divide by zero!')
    # You cannot divide by zero! prints when you enter 0
  except ValueError:
    print('Please enter a valid number!')
    # Please enter a valid number! prints when you enter a string  
  ```

- **`else` 和 `finally`**：这些块扩展了 `try...except`。如果没有发生异常，`else` 块将运行。无论是否有误差，`finally` 块总是运行。

  ```py
  try:
    result = 100 / 4
  except ZeroDivisionError:
    print('You cannot divide by zero!') # This will not run
  else:
    print(f'Result is {result}') # Result is 25.0
  finally:
    print('Execution complete!') # Execution complete!
  ```

- **异常对象**：这让你能够访问异常本身，以便更好地调试和打印直接的错误信息。要访问异常对象，你需要使用 `as` 关键字。以下是一个示例：

  ```py
  try:
      value = int('This will raise an error')
  except ValueError as e:
      print(f'Caught an error: {e}')
      # Caught an error: invalid literal for int() with base 10: 'This will raise an error'
  ```

- **`raise` 语句**：这允许你手动引起一个异常。当满足某个条件时，你可以使用它来抛出异常。下面是一个示例：

  ```py
  def divide(a, b):
      if b == 0:
          raise ZeroDivisionError('You cannot divide by zero')
      return a / b
  ```
  
## 异常信号
  
  `raise` 语句在你创建自己的自定义异常时也很有用，因为你可以使用它来抛出带有自定义消息的异常。下面是一个示例：

  ```py
  class InvalidCredentialsError(Exception):
      def __init__(self, message="Invalid username or password"):
          self.message = message
          super().__init__(self.message)

  def login(username, password):
      stored_username = "admin"
      stored_password = "password123"
      
      if username != stored_username or password != stored_password:
          raise InvalidCredentialsError()
      
      return f"Welcome, {username}!"
  ```  

  以下是如何使用来自 `InvalidCredentialsError` 异常的 `login` 函数：

  ```py
  # failed login attempt
  try:
      message = login("user", "wrongpassword")
      print(message)
  except InvalidCredentialsError as e:
      print(f"Login failed: {e}")

  # successful login attempt
  try:
      message = login("admin", "password123")
      print(message)
  except InvalidCredentialsError as e:
      # This block is not executed because the login was successful
      print(f"Login failed: {e}")
  else:
      # The else block runs if the 'try' block completes without an exception
      print(message)
  ```

  `raise` 语句也可以与 `from` 关键字一起使用，以链接异常，显示不同误差之间的关系：

  ```py
  def parse_config(filename):
    try:
        with open(filename, 'r') as file:
            data = file.read()
            return int(data)
    except FileNotFoundError:
        raise ValueError('Configuration file is missing') from None
    except ValueError as e:
        raise ValueError('Invalid configuration format') from e

  config = parse_config('config.txt')
```

## Python 类和对象

- **类定义**：类是创建对象的蓝图。它通过其属性和方法定义对象将具有的行为。以下是 Python 中类定义的基本示例：

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f'{self.name.upper()} says woof woof!')
```

- **创建对象**：对象是类的实例。它们通过使用必要的参数调用类来创建。

```python
dog1 = Dog('Jack', 3)
dog2 = Dog('Thatcher', 5)

dog1.bark()  # JACK says woof woof!
dog2.bark()  # THATCHER says woof woof!
```

- **使用对象调用方法**：你可以在对象上调用方法以执行操作或检索信息。

```python
objectName1.methodName()
objectName2.methodName()
```

- **类和对象之间的区别**：类是一个可重用的模板，而对象是该类具有实际数据的特定实例。

## 属性

- **实例属性**：在 `__init__()` 中使用 `self` 定义，并且对每个对象都是唯一的。
- **类属性**：直接在类内部定义，并由所有实例共享。

```python
class Dog:
    species = 'French Bulldog'  # Class attribute

    def __init__(self, name):
        self.name = name  # Instance attribute

print(Dog.species) # French Bulldog

jack = Dog('Jack')
print(jack.name)     # Jack
print(jack.species)  # French Bulldog
```

## 方法

- **方法**：定义在类内部、作用于对象属性的函数。

```python
class Car:
    def __init__(self, color, model):
        self.color = color
        self.model = model

    def describe(self):
        return f'This car is a {self.color} {self.model}'

my_car_1 = Car('red', 'Tesla Model S')
print(my_car_1.describe())  # This car is a red Tesla Model S
```

- **访问方法**：使用点符号调用对象上的方法。以下是调用两个不同汽车对象的 `describe` 方法的示例：

```python
class Car:
 def __init__(self, color, model):
   self.color = color  
   self.model = model  

 def describe(self):
   return f'This car is a {self.color} {self.model}'

my_car_1 = Car('red', 'Tesla Model S')
my_car_2 = Car('green', 'Lamborghini Revuelto')

print(my_car_1.describe()) # Calling methods using the dot notation

print(my_car_2.describe()) # Calling methods using the dot notation
```

## 双下划线（魔术）方法

- **定义**：以双下划线开头和结尾的特殊方法（例如，`__init__`、`__len__`、`__str__`、`__eq__`）。Python 在内部使用它们来执行内置操作。

```python
class Book:
    def __init__(self, title, pages):
        self.title = title
        self.pages = pages

    def __len__(self):
        return self.pages

    def __str__(self):
        return f"'{self.title}' has {self.pages} pages"

    def __eq__(self, other):
        return self.pages == other.pages

book1 = Book('Built Wealth Like a Boss', 420)
print(len(book1))        # 420
print(str(book1))        # 'Built Wealth Like a Boss' has 420 pages
```

- **间接调用 dunder 方法**：你不需要直接调用 dunder 方法。相反，当发生某些操作时，Python 会自动调用它们。这些操作包括：

  - **算术操作，如加法、减法、乘法、除法和其他操作**。此外，会调用 `__add__()`，减法调用 `__sub__()`，乘法调用 `__mul__()`，除法调用 `__truediv__()`。
        
  - **像串接、重复、格式化和转换为文本的字串操作**。`__add__()` 用于串接，`__mul__()` 用于重复，`__format__()` 用于格式化，`__str__()` 和 `__repr__()` 用于文本转换，等等。
        
  - **比较操作，如相等、小于、大于和其他**。`__eq__()` 用于相等性查看，`__lt__()` 用于小于，`__gt__()` 用于大于，依此类推。
        
  - **迭代操作，例如使对象可迭代和遍历项**。调用 `__iter__()` 来返回迭代器，调用 `__next__()` 来获取下一项。

## 真实世界示例：购物车

- **带有双下划线方法的 Cart 类**：允许添加、移除、迭代和查看内容，具有内置行为。

```python
class Cart:
    def __init__(self):
        self.items = []

    def add(self, item):
        self.items.append(item)

    def remove(self, item):
        if item in self.items:
            self.items.remove(item)
        else:
            print(f'{item} is not in cart')

    def list_items(self):
        return self.items

    def __len__(self):
        return len(self.items)

    def __getitem__(self, index):
        return self.items[index]

    def __contains__(self, item):
        return item in self.items

    def __iter__(self):
        return iter(self.items)

cart = Cart()
cart.add('Laptop')
print(len(cart))        # 1
print('Laptop' in cart) # True
```

## 什么是面向对象编程？

- **面向对象编程**：一种编程风格，开发者将代码中的所有内容视为现实世界中的对象。它通常被称为 OOP。帮助你有效组织和管理代码的四个关键原则是 **封装**、**继承**、**多态** 和 **抽象**。
- **类**：用于创建对象的蓝图。每个由类创建的对象都有定义数据的属性和决定对象行为的方法。

## 什么是封装？

- **封装**：将对象的属性和方法捆绑成一个单一单元。它允许你通过一组简单的公共方法和属性隐藏对象的内部状态，这些方法和属性就像门一样。在这些门后面是私有属性和方法，它们控制数据如何变化以及谁可以查看数据。
- **封装示例**：如果你想跟踪钱包余额，你会允许存款和取款，但你不会希望任何人篡改钱包余额本身：

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

- **单下划线和双下划线前缀属性的区别**：为属性和方法添加单下划线前缀意味着它们是供内部使用的。这是一种约定，并不强制禁止从外部访问属性。为属性和方法添加双下划线前缀则有效地阻止了它们被类外部访问。

## 什么是 Getter 和 Setter？

- **Getter 和 Setter**：允许你控制如何访问和修改类的属性的方法。你使用 getter 来获取值，使用 setter 来设置值。
- **属性**：它们连接 getter 和 setter，并允许访问数据。当你获取、设置或删除值时，它们会在后台运行额外的逻辑。
- **为什么使用属性而不是方法**：属性用于替代方法，以提高可读性和使代码更简洁。它们允许你像访问普通属性一样使用点符号访问值，而无需使用括号。
- **创建 Getter**：要创建 getter，你使用 `@property` 装饰器。下面是一个获取圆半径的 getter：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

- **创建 Setter**：要创建设置半径的 setter，你必须定义另一个同名的方法，并在其上方使用 `@<property_name>.setter`：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

- **Python 如何处理 getter 和 setter**：一旦你定义了 getter 和 setter，Python 会在你以这种方式使用普通属性语法时自动在后台调用它们：

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

 设置值时，你不应将值赋值给属性名本身，因为那会导致 `RecursionError`。使用一个单独的内部名称，通常带有下划线，来保存该值。

- **删除器**：在使用 setter 和 getter 设置和获取值之后，你可以使用 `deleter` 控制它如何被删除。当你对属性使用 `del` 语句时，删除器会运行自定义逻辑。要创建删除器，你需要使用 `@<property_name>.deleter` 装饰器。

```py
  # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

## 什么是继承以及它如何促进代码重用？

- **继承**：子类使用父类的属性和方法的过程。继承促进代码重用，提供清晰的层次结构，并且无需重写所有内容即可自定义行为。要实现继承，子类需要接受父类的名称：

```py
class Parent:
    # Parent attributes and methods

class Child(Parent):
    # Child inherits, extends, and/or overrides where necessary
```

- **单继承和多继承**：当一个子类从单个父类继承属性和方法时，如上所示，该过程称为**单继承**。当一个子类从多个父类继承属性和方法时，这就是**多继承**。以下是其语法：

```py
class Parent:
    # Attributes and methods for Parent

class Child:
    # Attributes and methods for Child

class GrandChild(Parent, Child):
    # GrandChild inherits from both Parent and Child
    # GrandChild can combine or override behavior from each
```

- **`super()` 函数**：一个允许你在子类中覆写父类方法的函数。

## 什么是多态以及它如何促进代码重用？

- **多态**：面向对象编程的原则，允许不同的类使用相同的方法名，但每个类在被调用时以不同的方式实现它。以下是它的语法：

```py
class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # Works for A, B, or C
```

- **基于继承的多态**：父类设置一个方法，每个子类根据自己的需要进行调整。

## 什么是 Name Mangling 及其工作原理？

- **名称重整**：Python 内部通过添加下划线和类名作为前缀，将以双下划线开头的属性重命名的过程，将 `__attribute` 转换为 `_ClassName__attribute`。
- **名称改编的目的**：名称改编的主要目的是防止在使用继承时意外覆盖属性和方法。下面的代码可以让这一点更易理解：

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

## 什么是抽象以及它如何帮助保持复杂系统的有序？

- **抽象**：一种编程概念，其中隐藏对象或系统的复杂实现细节，仅显示必要的特色。在 Python 和其他编程语言中，抽象通过提高可重用性简化复杂系统。
- **抽象的示例**：生活中抽象的一个好例子是汽车让你只需使用方向盘、踏板和换挡杆，而无需了解发动机或刹车的工作原理。
- **Python 如何实现抽象**：Python 通过 `abc` 模块实现抽象。该模块提供了 `ABC` 类（抽象基类）和 `@abstractmethod` 装饰器。抽象基类（ABC）定义了子类必须实现的公共方法和属性。它不能被实例化。
- **抽象方法如何定义**：抽象方法使用 `@abstractmethod` 定义，且必须在子类中重写，即使它有默认实现。抽象的基本语法如下：

```py
from abc import ABC, abstractmethod

# Define an abstract base class
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# Concrete subclass that implements the abstract method
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# Another concrete subclass
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

## 算法和大 O 表示法

- **算法**：一组解决问题或执行任务的明确指令。算法必须在有限的步骤内完成，每一步都必须精确且明确。

- **大 O 记号**：描述算法在输入规模增加时的最坏分支性能或增长率。它关注资源使用随输入规模的增长情况，忽略常量因子和低阶项。

### 常见时间复杂度

- **O(1) - 常量时间**：算法无论输入大小，所需时间均相同。

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

- **O(log n) - 对数时间**：随着输入增长，时间缓慢增加。常见于通过分数反复缩小问题规模的算法（如二分查找）。

- **O(n) - 线性时间**：运行时间与输入大小成正比增加。

```python
for grade in grades:
    print(grade)
```

- **O(n log n) - 对数线性时间**：高效排序算法如归并排序和快速排序的常见时间复杂度。

- **O(n²) - 二次时间**：运行时间呈二次增长。通常出现在嵌套循环中。

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

### 空间复杂度

- **O(1) - 常量空间**：算法无论输入大小，使用相同数量的内存。
- **O(n) - 线性空间**：内存使用量随着输入大小成比例增长。
- **O(n²) - 二次空间**：内存使用量随输入大小二次增长。

## 问题解决技巧

- **理解问题**：多次阅读问题 `statement`。识别 `input`、预期输出以及如何将 `input` 转换为输出。

- **伪代码**：与语言无关的算法逻辑高级描述。使用通用书面语言混合 `IF`、`ELSE`、`FOR`、`WHILE` 等编程构造。

```md
GET original_string
SET reversed_string = ""
FOR EACH character IN original_string:
  ADD character TO THE BEGINNING OF reversed_string
DISPLAY reversed_string
```

- **边界分支**：算法应处理的边界处出现的特定有效输入。始终考虑并测试边界分支。

## 数组

- **静态数组**：在初始化时确定固定大小。元素保存在相邻的内存位置。大小在程序执行期间不可更改。

- **动态数组**：可以在程序执行期间自动增长或缩小。通过自动拷贝到更大的数组来处理调整大小。

### Python 列表（动态数组）

```python
numbers = [3, 4, 5, 6]

# Access elements
numbers[0]  # 3

# Update elements
numbers[2] = 16

# Add elements
numbers.append(7)
numbers.insert(3, 15)  # Insert at specific index

# Remove elements
numbers.pop(2)  # Remove at specific index
numbers.pop()   # Remove last element
```

### 动态数组的时间复杂度

- **访问**：O(1)
- **插入到末尾**：平均 O(1)，需要调整大小时为 O(n)
- **插入中间**：O(n)
- **删除**：中间为 O(n)，末尾为 O(1)

## 栈

- **栈**：后进先出（LIFO）数据结构。元素仅从顶部添加和移除。

- **入栈操作**：为栈顶添加一个元素。时间复杂度：O(1)。

- **Pop 操作**：从栈顶移除一个元素。时间复杂度：O(1)。

```python
# Using Python list as stack
stack = []

# Push operations
stack.append(1)
stack.append(2)
stack.append(3)

# Pop operations
top_element = stack.pop()  # Returns 3
```

## 队列

- **队列**：先进先出（FIFO）数据结构。元素添加到队列尾部，从队列头部移除。

- **入队操作**：将一个元素添加到队列的末尾。时间复杂度：O(1)。

- **出队操作**：从队列前端移除一个元素。时间复杂度：O(1)。

```python
from collections import deque

# Using deque for efficient queue operations
queue = deque()

# Enqueue operations
queue.append(1)
queue.append(2)
queue.append(3)

# Dequeue operations
first_element = queue.popleft()  # Returns 1
```

## 链表

- **链表**：线性数据结构，其中每个节点包含数据和指向下一个节点的引用。节点像链条一样连接。

### 单向链表

- **结构**：每个节点都有数据和一个指向下一个节点的引用。
- **遍历**：只能从头部向尾部转发。
- **头节点**：列表中的第一个节点，通常是唯一可直接访问的节点。
- **尾节点**：列表中的最后一个节点，指向 `None`。

### 操作和时间复杂度

- **在开头插入**：O(1)
- **插入到末尾**：O(n) - 必须遍历到末尾
- **插入中间**：O(n) - 必须遍历到位置
- **从开头删除**：O(1)
- **从末尾删除**：O(n) - 必须遍历以查找前一个节点
- **从中间删除**：O(n) - 必须遍历以查找节点

### 双向链表

- **结构**：每个节点都有数据和两个引用：下一个节点和上一个节点。
- **遍历**：可以双向移动。
- **内存**：由于额外的引用，所需内存比单链表更多。

## 哈希映射和集合

### 映射和哈希映射

- **Map（抽象的数据类型）**：管理密钥-值点对的集合。每个密钥必须唯一，但值可以重复。

- **哈希映射**：使用哈希技术对映射抽象数据类型的具体实现。使用哈希函数为密钥生成哈希值，哈希值决定底层数组中的存储位置。

### Python 字典（哈希映射）

```python
# Creating dictionaries
my_dictionary = {
    "A": 1,
    "B": 2, 
    "C": 3
}

# Alternative creation
my_dictionary = dict(A=1, B=2, C=3)

# Access and modify
value = my_dictionary["A"]  # 1
my_dictionary["A"] = 4      # Update value
del my_dictionary["A"]      # Remove key-value pair

# Check membership
"C" in my_dictionary

# Get keys, values, items
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

### 哈希映射的时间复杂度

- **平均分支**：插入、获取、删除的时间复杂度为 O(1)
- **最坏分支**：当发生大量哈希冲突时为 O(n)

### 集合

- **集合**：唯一元素的无序集合。不允许有副本，不维护特定顺序。

- **仅限不可变元素**：集合只能包含不可变的数据类型（数字、字串、元组），因为哈希值必须保持常量。

```python
# Creating sets
numbers = {1, 2, 3, 4}
empty_set = set()  # Must use set(), not {}

# Add and remove elements
numbers.add(5)
numbers.remove(4)      # Raises KeyError if not found
numbers.discard(4)     # No error if not found

# Set operations
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

# Union, intersection, difference, symmetric difference
set_a.union(set_b)                    # or set_a | set_b
set_a.intersection(set_b)             # or set_a & set_b
set_a.difference(set_b)               # or set_a - set_b
set_a.symmetric_difference(set_b)     # or set_a ^ set_b

# Subset and superset checks
set_a.issubset(set_b)
set_a.issuperset(set_b)
set_a.isdisjoint(set_b)

# Membership testing
5 in numbers
```

### 集合的时间复杂度

- **平均分支**：`add`、`remove`、`membership testing` 的时间复杂度为 O(1)
- **最坏分支**：由于哈希冲突，时间复杂度为 O(n)

## 哈希冲突

- **哈希碰撞**：当两个不同的密钥产生相同的哈希值时发生。

- **碰撞分辨率策略**：
  - **链式**：每个数组索引指向一个链表，存储所有具有相同哈希值的元素
  - **开放寻址**：使用预定义序列查找下一个可用索引

## 何时使用每种数据结构

- **列表**：当你需要有序、索引访问且事先不知道大小时
- **栈**：用于后进先出操作（撤销功能性、表达式求值、回溯）
- **队列**：用于 FIFO 操作（任务调度、广度优先查找）
- **链表**：当频繁在开头插入/删除、大小未知且不需要随机访问时
- **哈希映射**：用于快速的密钥-值查找、计数出现次数、缓存
- **集合**：用于唯一性检查、数学集合运算、去除副本

## 查找算法

查找算法让你在某个项列表中查找目标。

在计算机科学中，有两种你应该了解的查找算法。它们是**线性查找**和**binary search**算法。理解这两种算法的区别以及何时使用每一种非常重要。

### 线性查找

- 线性查找迭代一个项列表，从头开始查看每一项，直到找到目标项。
- 如果找到目标项，则返回该项在列表中的索引。
- 如果未找到目标，它将返回 `-1`，这在大多数编程语言中表示**无效索引**。
- 因为线性查找会检查每一项直到找到目标，所以对于大量项的列表来说，它并不高效。
- 线性查找的时间复杂度是 `O(n)`，因为查找列表所需的时间随着列表大小线性增长。
- 线性查找的空间复杂度是 `O(1)`，因为它不需要任何额外空间来查找列表。

### 二分查找

- 二分查找通过将列表中的项分成两半，并查看目标值是否在列表中间来工作。
- 二分查找生效的条件是列表中的项必须按升序排列。
- 二分查找是一种更高效的算法，用于在大型项列表中查找，因为它将项列表分成两半，并忽略任何未找到目标的那一半。
- 如果目标项位于列表中间，则返回目标项的索引。
- 如果未找到该项，算法会查看目标项是在列表的左半部分还是右半部分。
- 它继续将列表的剩余部分分成两半，直到找到目标项。
- 如果最终在列表中未找到目标项，则返回 `-1`
- 二分查找的时间复杂度是 `O(log n)`，因为查找列表所需的时间随着列表大小呈对数增长。
- 二分查找的空间复杂度是 `O(1)`，因为它在查找列表时不需要任何额外空间。

### 线性查找与二分查找的区别

- 与线性查找相比，二分查找更适合用于大型项列表。
- 线性查找的时间复杂度是 `O(n)`，因为查找列表所需的时间随着列表大小线性增长。
- 二分查找的时间复杂度是 `O(log n)`，因为查找列表所需的时间随着列表大小呈对数增长。

## 排序算法与分治法

在计算机科学中，分治是一种将问题拆分为更小子问题以便更容易解决的技术。递归是分治中常用的技术，分治是一种强大的策略，用于实现许多高效的排序算法，如归并排序。

### 归并排序

- 归并排序是一种遵循分治法的排序算法。
- 它通过递归地将一个列表划分为更小的子列表，直到每个子列表只包含一个元素。
- 然后它反复将子列表合并回去，按排序顺序。
- 归并排序的时间复杂度是 `O(n log n)`，因为列表不断被对半划分 `(log n)`，然后再合并 `(O(n))`。
- 归并排序的空间复杂度是 `O(n)`，因为它不是原地排序算法。

## 图概览

图是一组由边（连接）连接的节点（顶点）。每个节点可以连接到多个其他节点，形成一个网络。不同类型的图包括：

- 有向：边具有方向（从一个节点到另一个节点），通常用直线和箭头表现。
- 无向：边没有方向，用简单线条表现。
- 顶点：每个节点关联一个标签或标识符。
- 循环的：包含周期（一个起点和终点相同的路径）。
- 无环（DAG）：不包含周期。
- 边缘标签：每条边缘都有一个标签，通常绘制在对应边缘旁边。
- 加权：边具有关联的权值（数值），可用于执行算术操作。
- 不连通：包含两个或更多未被任何边连接的节点。

图被用于各种应用中，例如地图、网络、推荐系统、依赖分辨率。

## 图遍历

这涉及访问图中的所有节点。两个主要的算法是：

- **广度优先查找 (BFS)**
  - 使用队列。
  - 逐级探索。
  - 查找无权图中的最短路径。

- **深度优先搜索（DFS）**
  - 使用 `stack`（或递归）。
  - 在回溯之前完全探索一个分支。
  - 对周期检测和路径查找有用。

## 图表现

图可以用两种主要方式表现：

- **邻接列表**
  - 每个节点都有一个它的邻居的列表。
  - 针对稀疏图的空间高效方案。
  - 易于迭代邻居。

- **邻接矩阵**
  - 一个二维数组，其中行和列表现节点。
  - 对于大型图来说空间密集。
  - 快速查看两个节点之间是否存在边。

## 树

树是一种特殊类型的无环且连通的图。主要属性包括：

- 它们没有循环或周期（起点和终点节点相同的路径）。
- 它们必须是连通的（每个节点都可以从其他任意节点访问）。

### 常见的树类型

最常见的树的类型有：

- 二叉树
  - 每个节点最多有两个子节点，分别是左子节点和右子节点。

- 二叉搜索树（BST）
  - 一个二叉树，其中每个左子节点都小于其父节点，每个右子节点都大于其父节点。


## 尝试

也称为前缀树，它们用于保存字串集合，其中每个节点表现一个字符。

共享前缀只保存一次，使它们在自动完成和拼写检查等任务中高效。

查找和插入操作的时间复杂度为 O(L)，其中 L 是字串的长度。

## 优先级队列

优先级队列是一种抽象的数据类型，其中每个元素都有一个优先级。

队列和栈只考虑插入顺序，而优先级队列考虑元素的优先级。 

标准队列遵循 FIFO（先进先出），栈遵循 LIFO（后进先出）。但是，在优先级队列中，优先级较高的元素会先于优先级较低的元素被处理，无论它们的插入顺序如何。

## 堆

它是一种特化的基于树的数据结构，具有一种非常特定的属性，称为堆属性。 

堆属性决定父节点和子节点之间的关系。堆有两种类型：

- 最大堆
  - 每个父节点的值大于或相等于其子节点的值。
  - 最大的元素位于根节点。

- 最小堆
  - 每个父节点的值小于或相等于其子节点的值。
  - 最小的元素位于根部。

### Python `heap` 模块示例

```py
import heapq

# Create empty heap
my_heap = []

# Insert elements
heapq.heappush(my_heap, 9)
heapq.heappush(my_heap, 3)
heapq.heappush(my_heap, 5)

# Remove smallest element
print(heapq.heappop(my_heap))  # 3

# Push + Pop in one step
print(heapq.heappushpop(my_heap, 2)) # 2

# Transform list into heap
nums = [5, 7, 3, 1]
heapq.heapify(nums)
```

### 使用优先级

```py
my_heap = []
heapq.heappush(my_heap, (3, "A"))
heapq.heappush(my_heap, (2, "B"))
heapq.heappush(my_heap, (1, "C"))

# Removes lowest number = highest priority
print(heapq.heappop(my_heap))  # (1, "C")
```

## 动态规划简介

- **定义**：动态规划是一种算法技术，通过将复杂问题分解为更简单的子问题并存储结果以避免重复计算来解决问题。
- **重叠子问题**：在解决较大问题时，相同的较小问题会多次出现。我们不是反复重新计算这些子问题，而是将它们的 `solution` 保存起来。
- **最优子结构**：问题的最优 `solution` 包含其子问题的最优 `solution`。这意味着我们可以通过组合较小部分的最优 `solution` 来构建最佳 `solution`。

## 动态编程方案

- **记忆化（自顶向下方法）**：记忆化保存昂贵函数调用的结果，当相同的 `input` 再次出现时返回缓存的结果。

```py
def climb_stairs_memo(n, memo={}):
    """Dynamic programming with memoization"""
    # Check if we've already calculated this value
    if n in memo:
        return memo[n]  # Return cached result - O(1) lookup!
    
    # Base cases
    if n <= 2:
        return n
    
    # Calculate once and store in memo for future use
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    return memo[n]
```

- **自底向上法（Tabulation）**：Tabulation 从底层构建方案，通过填充一个表格来解决子问题。

```py
def climb_stairs_tabulation(n):
    """Dynamic programming with tabulation"""
    if n <= 2:
        return n
    
    # Create array to store results for all steps from 0 to n
    dp = [0] * (n + 1)
    dp[1] = 1  # 1 way to reach step 1
    dp[2] = 2  # 2 ways to reach step 2
    
    # Build up the solution iteratively
    for i in range(3, n + 1):
        # Ways to reach step i = ways to reach (i-1) + ways to reach (i-2)
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

## 使用动态编程的现实世界应用

- **路径优化**：GPS 系统使用动态编程算法来查找位置之间的最短路径。
- **文本处理**：拼写检查器和自动完成功能通常依赖动态编程来计算单词之间的编辑距离。
- **金融模型**：投资策略和投资组合优化经常采用动态编程技术。
- **资源分配**：背包问题及其变体出现在调度、预算和资源管理中。

## 何时使用动态规划

你应该考虑在以下场景中使用动态编程：

- 该问题可以分解为重叠子问题。
- 该问题表现出最优子结构。
- 一个简单的递归的方案将涉及重复计算。
- 你需要以空间复杂度为代价优化时间复杂度。

# --assignment--

复习 Python 主题和概念。
