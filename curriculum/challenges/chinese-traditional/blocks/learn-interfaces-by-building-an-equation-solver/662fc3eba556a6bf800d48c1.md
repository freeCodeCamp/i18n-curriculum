---
id: 662fc3eba556a6bf800d48c1
title: 第 14 步
challengeType: 20
dashedName: step-14
---

# --description--

內建函式 `isinstance()` 接受兩個引數，並傳回一個布林值，表示作為第一個引數傳入的物件是否為作為第二個引數傳入的類別的實體。

```py
isinstance(7, int) # True
```

另一件你想檢查的是每個引數是否為數字。在你的第一個 `if` 之後，創建一個 `for` 迴圈，迭代 `args` 並檢查目前迭代的引數是否不是 `int` 或 `float` 的實體。使用 `isinstance()` 函式，並將包含 `int` 和 `float` 的元組作為第二個引數傳入。

如果引數不是數字，則引發 `TypeError`，並顯示 `"Coefficients must be of type 'int' or 'float'"`。

# --hints--

你應該在你的 `if` 述語之後創建一個迭代 `args` 的 `for` 迴圈。

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("__init__").find_for_loops()[0].find_for_iter().is_equivalent("args")`)) })
```

你應該在 `for` 迴圈中創建一個 `if` 述語，檢查目前的係數是否不是 `int` 或 `float` 的實體。

```js
({ test: () => assert(runPython(`
var = str(_Node(_code).find_class("Equation").find_function("__init__").find_for_loops()[0].find_for_vars())
cond1 = f'not isinstance({var}, (int, float))'
cond2 = f'not isinstance({var}, (float, int))'
if_stmt = _Node(_code).find_class("Equation").find_function("__init__").find_for_loops()[0].find_ifs()[0].find_conditions()[0]
if_stmt.is_equivalent(cond1) or if_stmt.is_equivalent(cond2)
`)) })
```

你應該使用提供的字串在 `if` 述語中引發 `TypeError`。

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("__init__").find_for_loops()[0].find_ifs()[0].find_bodies()[0].has_stmt("raise TypeError(\\"Coefficients must be of type 'int' or 'float'\\")")
`)) })
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod
--fcc-editable-region--
class Equation(ABC):
    degree: int
    
    def __init__(self, *args):
        if (self.degree + 1) != len(args):
            raise TypeError(
                f"'{self.__class__.__name__}' object takes {self.degree + 1} positional arguments but {len(args)} were given"
            )
--fcc-editable-region--
    def __init_subclass__(cls):
        if not hasattr(cls, "degree"):
            raise AttributeError(
                f"Cannot create '{cls.__name__}' class: missing required attribute 'degree'"
            )
    
    @abstractmethod
    def solve(self):
        pass
        
    @abstractmethod
    def analyze(self):
        pass
        
class LinearEquation(Equation):
    degree = 1
    
    def solve(self):
        pass
    
    def analyze(self):
        pass
    
lin_eq = LinearEquation(2, 3)
```
