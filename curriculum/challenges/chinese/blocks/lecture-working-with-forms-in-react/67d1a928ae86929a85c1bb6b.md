---
id: 67d1a928ae86929a85c1bb6b
title: React 中的表单如何工作？
challengeType: 19
dashedName: how-do-forms-work-in-react
---

# --description--

表单是每个网页应用的基础，因为它们让你处理用户输入、收集数据并触发操作。

在 React 中，形式通过使用状态或 refs 来管理，使你能够完全控件它们的行为和验证。这两种管理形式的方式称为 `"controlled"` 和 `"uncontrolled"` 输入。

让我们来看一下什么是受控和非受控 `input`。

受控输入是处理形式输入中最“React 风格”的方式。通过受控输入，你将输入字段的值保存在状态中，并通过 `onChange` 事件进行更新。这使你能够完全控制形式数据，并允许即时验证和条件式渲染。

该进程的工作方式如下：React 使用 `useState` 钩子维护形式状态，并且你在每次更改时更新它。当用户在输入字段中输入时，`onChange` 事件触发，更新状态，React 使用新值重新渲染组件。

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form> 
    </>
  );
}

export default App;
```

受控 `input` 的优点包括以下几点：

- 即时访问表单数据。

- 你可以实现即时验证。

- 你可以有条件式地禁用提交按钮。

- 你可以通过程序控制输入值。

另一方面，非受控输入更多地出现在传统的超文本标记语言形式中。因此，非通过 `useState` 钩子处理输入，而是超文本标记语言中的非受控输入借助 DOM 维护它们自己的内部状态。

由于 DOM 控制输入值，你需要做的是通过 ref 获取输入字段的值。这种方法需要更少的代码且执行更高效，因为 refs 不会导致 React 重新渲染。

这是一个非受控输入的示例：

```jsx
import { useRef } from "react";

function App() {
  const nameRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(nameRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="name">Your</label>{" "}
      <input type="text" ref={nameRef} id="name" />
      <button type="submit">Submit</button>
    </form>
  );
}

export default App;
```

非受控输入的一个非常显著的优点是它们需要更少的代码。它们的性能也更好，对于熟悉超文本标记语言的 React 初学者来说感觉更自然。

那么，你应该在 `controlled` 和 `uncontrolled inputs` 之间选择哪个？ 

当你需要动态形式更新、实时验证或想将输入值与状态同步时，使用受控输入。它们提供更好的控制，但需要更多的重新渲染。

当你需要更简单的形式、只想在提交时访问值，或当你使用非 React 代码时，使用非受控输入。

无论你在受控输入和非受控输入之间使用哪种，以下是在 React 中制作形式时你应遵循的一些最佳实践：

- 始终阻止默认的表单提交。

- 确保你在提交前验证输入。

- 始终为用户提供有关装载、验证误差或其他相关状态的清晰反馈。

# --questions--

## --text--

你如何在受控输入中管理输入字段的值？

## --answers--

通过将值存储在状态中并通过 `onChange` 事件更新它。

---

通过直接修改 DOM `input` 值并使用 JavaScript 获取这些值。

### --feedback--

状态保存值，且更改会触发更新。

---

通过使用 refs 跟踪更改并将 ref 属性赋值给每个输入。

### --feedback--

状态保存值，且更改会触发更新。

---

通过将输入值初始设置为 `null` 并编写一个函数稍后获取它们。

### --feedback--

状态保存值，且更改会触发更新。

## --video-solution--

1

## --text--

以下哪项是受控输入的优点？

## --answers--

它们直接更新 DOM，而不进行状态管理。

### --feedback--

受控输入让你对表单数据和行为拥有更多控制。

---

它们允许对表单数据有更多控件。

---

它们阻止表单验证。

### --feedback--

受控输入让你对表单数据和行为拥有更多控制。

---

他们禁用了 `onChange` 事件处理器。

### --feedback--

受控输入让你对表单数据和行为拥有更多控制。

## --video-solution--

2

## --text--

在 React 中，无控 `input` 如何处理表单 `data`？

## --answers--

他们将输入值保存在组件状态中。

### --feedback--

非受控输入依赖于浏览器的默认形式行为，而不是 React 状态。

---

他们使用 `useReducer` 钩子进行状态管理。

### --feedback--

非受控输入依赖于浏览器的默认形式行为，而不是 React 状态。

---

React 通过 `onChange` 事件更新输入值。

### --feedback--

非受控输入依赖于浏览器的默认形式行为，而不是 React 状态。

---

DOM 在内部管理表单数据。

## --video-solution--

4
