---
id: 5900f3971000cf542c50feaa
title: '問題 43：子字串可整除性'
challengeType: 1
forumTopicId: 302100
dashedName: problem-43-sub-string-divisibility
---

# --description--

數字 1406357289 是一個 0 到 9 的全數字字串，因為它由 0 到 9 的每個數字以某種順序組成，但它也具有相當有趣的子字串可被整除的屬性。

令 $d_1$ 為第 1 個數字，$d_2$ 為第 2 個數字，依此類推。以此方式，我們記錄以下內容：

- ${d_2}{d_3}{d_4} = 406$ 可被 2 整除
- ${d_3}{d_4}{d_5} = 063$ 可被 3 整除
- ${d_4}{d_5}{d_6} = 635$ 可被 5 整除
- ${d_5}{d_6}{d_7} = 357$ 可被 7 整除
- ${d_6}{d_7}{d_8} = 572$ 可被 11 整除
- ${d_7}{d_8}{d_9} = 728$ 可被 13 整除
- ${d_8}{d_9}{d_{10}} = 289$ 可被 17 整除

找出所有 0 到 `n` 的泛數字字串中，其子字串符合 `n - 2` 個這些可被整除性質的總和。

**注意：** 以 `0` 開頭的全數字應納入結果中。

# --hints--

`substringDivisibility(5)` 應該傳回一個數字。

```js
assert(typeof substringDivisibility(5) === 'number');
```

`substringDivisibility(5)` 應該傳回 `12444480`。

```js
assert.strictEqual(substringDivisibility(5), 12444480)
```

`substringDivisibility(7)` 應該傳回 `1099210170`。

```js
assert.strictEqual(substringDivisibility(7), 1099210170)
```

`substringDivisibility(8)` 應該傳回 `1113342912`。

```js
assert.strictEqual(substringDivisibility(8), 1113342912)
```

`substringDivisibility(9)` 應該傳回 `16695334890`。

```js
assert.strictEqual(substringDivisibility(9), 16695334890)
```

# --seed--

## --seed-contents--

```js
function substringDivisibility(n) {

  return true;
}

substringDivisibility(5);
```

# --solutions--

```js
function substringDivisibility(n) {
  function isSubDivisible(digits) {
    const factors = [2, 3, 5, 7, 11, 13, 17];

    for (let i = 1; i < digits.length - 2; i++) {
      const subNumber = digits[i] * 100 + digits[i + 1] * 10 + digits[i + 2];
      if (subNumber % factors[i - 1] !== 0) {
        return false;
      }
    }
    return true;
  }

  function heapsPermutations(k, digits, conditionCheck, results) {
    if (k === 1) {
      if (conditionCheck(digits)) {
        const number = parseInt(digits.join(''), 10);
        results.push(number);
      }
      return;
    }

    heapsPermutations(k - 1, digits, conditionCheck, results);

    for (let i = 0; i < k - 1; i++) {
      if (k % 2 === 0) {
        [digits[i], digits[k - 1]] = [digits[k - 1], digits[i]];
      } else {
        [digits[0], digits[k - 1]] = [digits[k - 1], digits[0]];
      }
      heapsPermutations(k - 1, digits, conditionCheck, results);
    }
    return;
  }

  const allowedDigits = [...new Array(n + 1).keys()];
  const divisiblePandigitals = [];
  heapsPermutations(
    allowedDigits.length,
    allowedDigits,
    isSubDivisible,
    divisiblePandigitals
  );

  let sum = 0;
  for (let i = 0; i < divisiblePandigitals.length; i++) {
    sum += divisiblePandigitals[i];
  }

  return sum;
}
```
