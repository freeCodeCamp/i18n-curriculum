---
id: 67d301a5f536d1a9e5df1a8c
title: 什么是类型缩小，它是如何工作的？
challengeType: 19
dashedName: what-is-type-narrowing-and-how-does-it-work
---

# --description--

有时你会有一个广泛类型的值，需要将其缩小到更具体的类型。例如，也许你需要确保一个对象匹配你定义的一个接口。或者一个字串在特定的值列表中。有很多方法可以实现这一点。

第一个是通过真实性进行缩小。考虑我们上一课的示例：

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

我们尝试访问 `email` 的 `value` 属性时会得到编译器误差，因为 `email` 可能是 `null`。但是，我们可以使用条件式来确认 `email` 为真值后再访问该属性：

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

在这个更新的示例中，因为 `null` 不是一个真值，TypeScript 能够推导出 `email` 必须是在条件式块内的一个 `input` 元素。所以它不再抛出编译器误差。

真值检查也可以反向工作：

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

通过这种方法，如果 `email` 是假值，我们就抛出一个误差。`null` 是一个假值。抛出误差会结束这段代码的逻辑执行，这意味着当我们达到 `console.log()` 调用时，TypeScript 知道 `email` 不可能是 `null`。

可选链也是一种类型缩小的形式，前提是如果 `email` 值为 `null`，则不会发生属性访问。

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

但是其他类型呢？你也可以使用 `typeof` 操作符来缩小类型。让我们看一个变量可能是字串或数字的例子：

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
console.log(myVal / 10)
```

在此示例中，我们看到一个编译器误差，因为我们无法对字串值执行算术。但我们可以使用条件式来查看 `myVal` 变量的 `typeof`：

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

因为我们使用了 `typeof` 关键字，TypeScript 现在知道 `myVal` 必须是一个数字，我们可以安全地对它执行算术运算。

但是更复杂的对象类型呢？如果相关对象恰好来自某个类，你实际上可以使用 `instanceof` 关键字来缩小类型。回到我们的 `querySelector()` 示例：

```js
const email = document.querySelector("#email");
```

与其传递一个通用的类型并告诉 TypeScript 元素是什么，我们可以使用 `instanceof` 来缩小类型范围并编写更安全的代码：

```js
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

这种方法看起来可能和我们之前的方法相同，但 `instanceof` 是一种运行期验证——这意味着，如果我们以某种方式错误地使用了 TypeScript 类型，我们的 JavaScript 代码仍然会确认 `email` 是一个 `input` 元素。

接下来，让我们看一个示例，从 API 获取一个 `User` 对象并尝试打印信息：

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json();
printAge(myUser);
```

我们尝试将 `myUser` 传入函数时会得到编译器误差，因为尽管我们知道 API 返回了正确的对象，TypeScript 并不知道。而且 `.json()` 方法不接受通用的类型。

解析此问题的“简单”方法是强制转换类型：

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

但是每当你进行类型断言时，实际上是在削弱 TypeScript 捕捉潜在误差的能力。所以你可以不进行类型断言，而是编写一个类型保护：

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

这里的返回类型是此函数定义的关键组件。`user is User` 语法表示我们的函数返回一个布尔值，当为 `true` 时表示 `user` 值满足 `User` 接口。然后我们进行一些基本查看以确保 `user` 对象的结构匹配——注意使用了真值缩小（`!!user`）和 `typeof` 缩小。我们必须这样做，因为 `typeof null` 返回 `"object"`：

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
if (isValidUser(myUser)) {
    printAge(myUser);
}
```

现在，如果我们将所有逻辑组合在一起，就不会再出现编译器误差，并且可以成功构建我们的代码。

类型缩小是一项强大的特色，帮助你编写更安全、错误更少的代码——但请记住，TypeScript 的类型并非完全刚性，因此应避免在未缩小类型的情况下强制转换值的类型。

# --questions--

## --text--

以下哪项不是课程中讨论的类型缩小的方法？

## --answers--

真实性检查。

### --feedback--

虽然所有这些都可以用来缩小 `type`，但其中有一个没有被提及。

---

可选链。

### --feedback--

虽然所有这些都可以用来缩小 `type`，但其中有一个没有被提及。

---

`typeof` 操作符。

### --feedback--

虽然所有这些都可以用来缩小 `type`，但其中有一个没有被提及。

---

Switch 语句。

## --video-solution--

4

## --text--

`user is User` 语法在类型保护函数中的目的是什么？

## --answers--

它将 `user` 参数转换为 `User` 类型。

### --feedback--

想想单词 `is`，以及短语 `user is User` 是如何工作的。

---

它表示该函数返回一个布尔值。

### --feedback--

考虑单词 `is`，以及短语 `user is` 用户的作用。

---

它表明 `user` 满足 `User` 接口。

---

它创建了 `User` 接口的一个新实例。

### --feedback--

考虑单词 `is`，以及短语 `user is` 用户的作用。

## --video-solution--

3

## --text--

以下关于 TypeScript 中的类型转换，哪项是正确的？

## --answers--

这是解析类型问题的推荐方法。

### --feedback--

类型转换应作为最后手段进行。

---

它增强了 TypeScript 捕捉误差的能力。

### --feedback--

类型转换应作为最后手段进行。

---

这是使用 `as` 关键字完成的。

---

它应始终替代 type guards 使用。

### --feedback--

类型转换应作为最后手段进行。

## --video-solution--

3
